<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>时光小栈 on 时光小栈</title>
        <link>//blog.pytool.com/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Tue, 12 Dec 2017 15:47:11 CST</updated>
        
        <item>
            <title>wepack3 url-loader</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack-url-loader/</link>
            <pubDate>Tue, 12 Dec 2017 15:47:11 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack-url-loader/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module: {
  rules: [
    {
      test: /\.js$/,
      use: &#39;babel-loader?cacheDirectory&#39;, // 开启 babel-loader 缓存
      include: [path.resolve(&#39;src&#39;), path.resolve(&#39;test&#39;)],
      exclude: /node_modules/
    },
    {
      test: /\.(css|scss)$/,
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]
    },
    {
      test: /\.(png|jpe?g|gif|svg)(\?.*)?$/i,
      loader: &#39;url-loader&#39;,
      options: {
        limit: 10 * 1024,
        name: &#39;images/[name].[ext]?[hash]&#39;
      }
    },
    {
      test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
      loader: &#39;url-loader&#39;,
      options: {
        limit: 10 * 1024,
        name: &#39;media/[name].[ext]?[hash]&#39;
      }
    },
    {
      test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
      loader: &#39;url-loader&#39;,
      options: {
        limit: 10 * 1024,
        name: &#39;fonts/[name].[ext]?[hash]&#39;
      }
    }
  ]
},
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module: {
     rules: [
         {
             // 后缀正则
             test: /\.js$/,
             // 加载器组
             use: [
                 {
                     loader: &#39;babel-loader&#39;,
                 },
                 {
                     loader: &#39;eslint-loader&#39;,
                 },
             ],
             exclude: /node_modules/,
         },
         {
             test: /\.less$/,
             use: ExtractTextPlugin.extract({
                 fallback: &#39;style-loader&#39;,
                 use: [
                     &#39;css-loader&#39;,
                     &#39;postcss-loader&#39;,
                     &#39;less-loader&#39;,
                 ],
             }),
             exclude: /node_modules/,
         },

         {
             test: /\.(woff|woff2)(\?v=\d+\.\d+\.\d+)?$/,
             use: [
                 {
                     loader: &#39;url-loader&#39;,
                     options: {
                         name: &#39;[path][name].[ext]&#39;,
                         limit: 10240,
                         mimetype: &#39;application/font-woff&#39;,
                     }
                 },
             ],
             // loaders: [&#39;url-loader?&amp;amp;limit=102400&amp;amp;mimetype=application/font-woff&#39;],
         },
         {
             test: /\.ttf(\?v=\d+\.\d+\.\d+)?$/,
             use: [
                 {
                     loader: &#39;url-loader&#39;,
                     options: {
                         name: &#39;[path][name].[ext]&#39;,
                         limit: 10240,
                         mimetype: &#39;application/octet-stream&#39;,
                     }
                 },
             ],
             // loaders: [&#39;url-loader?name=[path][name].[ext]&amp;amp;limit=1024&amp;amp;mimetype=application/octet-stream&#39;],
         },
         {
             test: /\.eot(\?v=\d+\.\d+\.\d+)?$/,
             use: [
                 {
                     loader: &#39;file-loader&#39;,
                     options: {
                         name: &#39;[path][name].[ext]&#39;,
                     }
                 },
             ],
             // loaders: [&#39;file-loader?name=[path][name].[ext]&#39;],
         },
         {
             test: /\.svg(\?v=\d+\.\d+\.\d+)?$/,
             use: [
                 {
                     loader: &#39;url-loader&#39;,
                 },
             ],
             // loaders: [&#39;url-loader?name=[path][name].[ext]&amp;amp;limit=1024&amp;amp;mimetype=image/svg+xml&#39;],
         },
         {
             test: /\.(png|jpg|gif)$/,
             use: [
                 {
                     loader: &#39;url-loader&#39;,
                 },
             ],
             // loaders: [&#39;url-loader?name=[path][name].[ext]?[hash]&amp;amp;limit=204800000&#39;], // 单位bit
             exclude: /node_modules/,
         },
     ],
 },
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>wepack3 详解</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack/</link>
            <pubDate>Tue, 12 Dec 2017 15:47:11 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://doc.webpack-china.org/&#34;&gt;webpack3中文文档&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000012068849&#34;&gt;Fis3构建迁移Webpack之路&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/fouber/blog/issues/6&#34;&gt;大公司里怎样开发和部署前端代码&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/webpack-china/awesome-webpack-cn&#34;&gt;awesome-webpack-cn&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000005742122&#34;&gt;webpack进阶之插件篇&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000012356915&#34;&gt;webpack飞行手册 &lt;em&gt;推荐&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//blog.pytool.com/images/webpack.svg&#34; alt=&#34;webpack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;entry：入口，定义要打包的文件
output：出口，定义打包输出的文件；包括路径，文件名，还可能有运行时的访问路径（publicPath）参数
module: webpack将所有资源都看做是模块,而模块就需要加载器；
  loaders: Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。
plugins：定义以下额外的插件
resolve：定义能够被打包的文件，文件后缀名
    extensions: [&amp;ldquo;, &amp;lsquo;.js&amp;rsquo;, &amp;lsquo;.es6&amp;rsquo;]&lt;/p&gt;

&lt;h3 id=&#34;wenbpack-安装失败的原因&#34;&gt;wenbpack 安装失败的原因&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、网络问题    cnpm&lt;/li&gt;
&lt;li&gt;2、权限问题&lt;/li&gt;
&lt;li&gt;3、node 版本问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==============================================&lt;/p&gt;

&lt;h3 id=&#34;webpack版本问题修改&#34;&gt;webpack版本问题修改&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新项目
&amp;gt;直接删除node_modules 重新安装 npm install &amp;ndash;save-dev webpack&lt;/li&gt;
&lt;li&gt;旧项目
&amp;gt;修改package.json中的版本号   删除node_modules   重新  npm install&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===============================================&lt;/p&gt;

&lt;h3 id=&#34;学习步骤&#34;&gt;学习步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、配置文件webpack.config.js&lt;/li&gt;
&lt;li&gt;2、entery选项（入口配置）&lt;/li&gt;
&lt;li&gt;3、output选项（出口配置）&lt;/li&gt;
&lt;li&gt;4、多入口、多出口配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==================================================&lt;/p&gt;

&lt;h3 id=&#34;基本结构&#34;&gt;基本结构&lt;/h3&gt;

&lt;p&gt;const path=require(&amp;lsquo;path&amp;rsquo;);
module.export={
    entry:{
        entry:&amp;lsquo;文件路径&amp;rsquo;
    },       入口配置
    output:{
        path：path.resolve(__dirname,&amp;lsquo;dist&amp;rsquo;),  node语法相对路径
        filename:&amp;rsquo;[name].js&amp;rsquo;    //压缩后的文件名
    },      出口配置
    module:{},      解读css  图片转换压缩
    plugins:[]      插件
    devServer:{}    配置服务
}&lt;/p&gt;

&lt;p&gt;======================================================&lt;/p&gt;

&lt;h3 id=&#34;webpack配置服务-热更新技术&#34;&gt;webpack配置服务、热更新技术&lt;/h3&gt;

&lt;p&gt;devServer:{
    contentBase:path.resolve(__dirname,&amp;lsquo;dist&amp;rsquo;),
    host:&amp;lsquo;192.168.199.106&amp;rsquo;,           //服务器地址
    compress:true,                    //服务器是否压缩
    port:1717                        //服务器端口
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;npm install webpack-dev-server &amp;ndash;save-dev&lt;/li&gt;
&lt;li&gt;修改package.json&lt;/li&gt;
&lt;li&gt;&amp;ldquo;script&amp;rdquo;:{
&amp;ldquo;server&amp;rdquo;:&amp;ldquo;webpack-dev-server&amp;rdquo;
}
&amp;gt;起服务  npm run server&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;webpack3.6以上的热更新&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;=========================================================&lt;/p&gt;

&lt;h3 id=&#34;css打包&#34;&gt;css打包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;style-loader      //处理css中URL&lt;/li&gt;
&lt;li&gt;css-loader        //对标签处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;module:{
        rules:[
            {
                test:/.css$/,    //通过正则的方式找到处理的扩展
                //use:[&amp;lsquo;style-loader&amp;rsquo;,&amp;lsquo;css-loader]
                //loader
                //use:[{
                    loader:&amp;lsquo;style-loader&amp;rsquo;
                    },{
                        loader:&amp;lsquo;css-loader&amp;rsquo;
                }]
            }
        ]
    },&lt;/p&gt;

&lt;p&gt;================================================================&lt;/p&gt;

&lt;h3 id=&#34;js打包&#34;&gt;js打包&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;引入插件 uglify&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;const uglify = require(&amp;lsquo;uglifyjs-webpack-plugin&amp;rsquo;);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;plugins:[
new uglify()
]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==================================================================&lt;/p&gt;

&lt;h3 id=&#34;html打包&#34;&gt;html打包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装并引入插件  html-webpack-plugin&lt;/li&gt;
&lt;li&gt;const htmlPlugin = require(&amp;lsquo;html-webpack-plugin&amp;rsquo;);&lt;/li&gt;

&lt;li&gt;&lt;p&gt;plugins:[
new  htmlPlugin({
    minify:{
        removeAttributeQuotes:true
    },
    hash:true,
    template:&amp;lsquo;./src/index.html&amp;rsquo;
})
]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;template：是要打包的html模版路径和文件名称。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=====================================================================&lt;/p&gt;

&lt;h3 id=&#34;css图片路径问题&#34;&gt;css图片路径问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;module:[{
rules{
    test:/.(png|jpg|gif)/,
    use:[{
        loader:&amp;lsquo;url-loader&amp;rsquo;,
        options:{
            limit:50000
        }
    }]
}
}]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test:/.(png|jpg|gif)/是匹配图片文件后缀名称。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;use：是指定使用的loader和loader的配置参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;limit：是把小于500000B的文件打成Base64的格式，写入JS。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===============================================================&lt;/p&gt;

&lt;h3 id=&#34;css分离&#34;&gt;css分离&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装插件  extract-text-webpack-plugin&lt;/li&gt;
&lt;li&gt;引入插件&lt;/li&gt;
&lt;li&gt;在插件中声明&lt;/li&gt;
&lt;li&gt;修改处理css&lt;/li&gt;
&lt;li&gt;rules:[
{
    test:/.css$/,
    use:extractTextPlugin.extract({
        fallback:&amp;lsquo;style-loader&amp;rsquo;,
        use:&amp;lsquo;css-loader&amp;rsquo;
    })
}]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===================================================================&lt;/p&gt;

&lt;h3 id=&#34;处理html中的图片&#34;&gt;处理html中的图片&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装插件  html-withimg-loader&lt;/li&gt;
&lt;li&gt;配置插件&lt;br /&gt;
&amp;gt;{
test:/.(html|htm)$/i,
use:[&amp;lsquo;html-withimg-loader&amp;rsquo;]
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;====================================================================&lt;/p&gt;

&lt;h3 id=&#34;自动补全css前缀&#34;&gt;自动补全css前缀&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装插件  postcss-loader   autoprefixer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建postcss.config.js
&amp;gt;module.exports={
plugins:[
    require(&amp;lsquo;auotprefixer&amp;rsquo;)
]
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写loader
&amp;gt;{
test: /.css$/,
use: extractTextPlugin.extract({
    fallback: &amp;lsquo;style-loader&amp;rsquo;,
    use: [
        { loader: &amp;lsquo;css-loader&amp;rsquo;, options: { importLoaders: 1 } },
        &amp;lsquo;postcss-loader&amp;rsquo;
    ]
})&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;git@github.com:heavenswen/webpack-page.git&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//编译状态
const Env = process.env.NODE_ENV === &#39;production&#39;
const { join, resolve } = require(&#39;path&#39;)
const webpack = require(&#39;webpack&#39;)
const glob = require(&#39;glob&#39;)
// const ImageminPlugin = require(&#39;imagemin-webpack-plugin&#39;).default;
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)
const CommonsChunkPlugin = require(&#39;webpack/lib/optimize/CommonsChunkPlugin&#39;)
const LiveReloadPlugin = require(&#39;webpack-livereload-plugin&#39;)
const ROOT = process.cwd();  // 根目录
// 通过允许您并行转换多个文件， HappyPack使Webpack构建更快。
const HappyPack = require(&#39;happypack&#39;);
const HappyThreadPool = HappyPack.ThreadPool({ size: (Env ? 10 : 4) });
const release = Env ? &#39;/&#39; : &#39;/&#39;//域名文件夹
//页面对应路口
const entries = {}
//入口对象集
const chunks = []
//页面list
const pagesList = []
//logo
const favicon = &amp;quot;./src/assets/img/logo.png&amp;quot;
// 页面模版
const entryHtml = []

//页面模版
glob.sync(&amp;quot;./src/pages/**/*.{ejs,html}&amp;quot;).forEach(path =&amp;gt; {
  //HtmlWebpackPlugin 不支持 .html 编译 ejs 用.ejs
  let filename = path.split(&#39;./src/pages/&#39;)[1]

  //入口js文件名
  let chunk = path.split(&#39;./src/pages/&#39;)[1].split(/\.(ejs|html)/)[0]
  //设置产出路径
  chunk = &#39;js/&#39; + chunk
  // 入口js路径
  let js = path

  //js路径
  js = js.replace(/\/pages/ig, &#39;/entry&#39;);
  js = js.replace(/\.(ejs|html)/gi, &#39;.js&#39;);
  entries[chunk] = js
  //入口js名称名称
  chunks.push(chunk)

  filename = filename.replace(/\.ejs/ig, &#39;.html&#39;)
  //获得所有页面
  pagesList.push(filename)
  let htmlConf = {
    filename: filename,//文件名
    //模版位置
    template: path,
    inject: &#39;body&#39;,
    favicon: favicon,
    hash: Env,
    env: Env,//HtmlWebpackPlugin.options.env 非打包时的处理
    list: pagesList,//页面地址
    chunks: [&#39;vendors&#39;, chunk] //chunk
  }

  //保存配置
  entryHtml.push(htmlConf)

})

const config = {
  entry: entries,
  output: {
    path: resolve(__dirname, &#39;./dist&#39;),
    filename: &#39;[name].js&#39;,
    publicPath: release
  },
  resolve: {
    //路径检索
    extensions: [&#39;.js&#39;, &#39;.vue&#39;],
    alias: {
      //资源
      assets: join(__dirname, &#39;/src/assets&#39;),
      //组件
      components: join(__dirname, &#39;/src/components&#39;),
      //视图
      views: join(__dirname, &#39;/src/views&#39;),
      root: join(__dirname, &#39;node_modules&#39;)

    }
  },
  module: {
    //忽略以下js
    noParse: /node_modules\/(jquey|zepto|moment|chart\.js)/,
    rules: [
      {
        test: /\.vue$/,
        use: &#39;vue-loader&#39;
      },
      {
        test: /\.js$/,
        use: [{
          loader: &#39;babel-loader?id=js&#39;,
          options: {
            //es6
            presets: [&#39;es2015&#39;]
          }
        }],
        exclude: /node_modules/
      },
      {
        //编译sass
        test: /\.(scss|sass)$/,
        use: ExtractTextPlugin.extract({
          fallback: &#39;style-loader?id=style&#39;,
          use: [{
            loader: &#39;css-loader?id=style&#39;,
            options: {
              //压缩css
              minimize: Env
            }
          }, &#39;postcss-loader?id=style&#39;, &#39;sass-loader?id=style&#39;],
        })

      },
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: &#39;style-loader?id=style&#39;,
          use: [{
            loader: &#39;css-loader?id=style&#39;,
            options: {
              //压缩css
              minimize: Env
            }
          }, &#39;postcss-loader?id=style&#39;],
        })
      },

      {
        //修改html img路径
        test: /\.html$/,
        use: [{
          loader: &#39;html-loader&#39;,
          options: {
            root: resolve(__dirname, &#39;src&#39;),
            attrs: [&#39;img:src&#39;, &#39;img:data-src&#39;, &#39;img:data-background&#39;, &#39;link:href&#39;]
          }
        }]
      },
      {
        test: /\.(png|jpg|jpeg|gif|svg|svgz)(\?.+)?$/,
        exclude: /favicon\.(png|ico)$/,//除外
        loaders: [
          &#39;url-loader?limit=1000&amp;amp;outputPath=assets/img/&amp;amp;name=[name].[ext]?[hash]&#39;,
          {
            //图片压缩
            loader: &#39;image-webpack-loader&#39;,
            options: {
              gifsicle: {
                interlaced: false,
              },
              optipng: {
                optimizationLevel: 1,
              },
              pngquant: {
                quality: &#39;65-90&#39;,
                speed: 4
              },
              mozjpeg: {
                progressive: true,
                quality: 65
              }
            }
          }
        ]
      },
      {
        //文字资源
        test: /\.(eot|ttf|woff|woff2)(\?.+)?$/,
        use: [{
          loader: &#39;url-loader&#39;,
          options: {
            limit: 1000,
            name: &amp;quot;[name].[ext]?[hash]&amp;quot;,
            outputPath: &amp;quot;assets/fonts/&amp;quot;,//产出目录
          }
        }]
      },
      {
        //资源
        test: /\.(apk|docx|doc|exe)(\?.+)?$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            name: &amp;quot;[name].[ext]?[hash]&amp;quot;,
            outputPath: &amp;quot;assets/file/&amp;quot;,//产出目录
          }
        }]
      }
    ]
  },
  plugins: [
    //会跟 webpack-dev-server 冲突，导致js修改时找不到修改对象
    // new LiveReloadPlugin({
    // }),
    new HappyPack({
      id: &#39;js&#39;,
      // @see https://github.com/amireh/happypack
      threadPool: HappyThreadPool,
      loaders: [&#39;babel-loader&#39;]
    }),
    new HappyPack({
      id: &#39;styles&#39;,
      threadPool: HappyThreadPool,
      loaders: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]
    }),
    //获取公用模块生成js
    new CommonsChunkPlugin({
      name: &#39;vendors&#39;,
      filename: &#39;assets/js/vendors.js?[hash]&#39;,
      chunks: chunks,
      minChunks: chunks.length
    }),
    //提取公用模块生成css
    new ExtractTextPlugin({
      filename: (getPath) =&amp;gt; {
        //获得地址
        let name = getPath(&#39;[name]&#39;)

        if (!name.match(/vendors/ig)) {
          let arr = name.split(&#39;/&#39;)
          name = arr[arr.length - 1]//获得文件名
        }
        return &#39;assets/css/&#39; + name + &#39;.css&#39;;
      },
      allChunks: true
    }),
    //webpack3.0
    new webpack.optimize.ModuleConcatenationPlugin()
  ],
  devServer: {
    contentBase: [
      join(ROOT, &#39;src/&#39;)
    ],
    port: 8010,
    //启动路由功能
    //historyApiFallback: false,
    // noInfo: true,
    hot: false,
    //真实地址 可以用局域访问
    disableHostCheck: true,
    //允许其他电脑访问
    host: &#39;0.0.0.0&#39;,
  },
  devtool: &#39;#eval-source-map&#39;
}


//页面模版
entryHtml.forEach(function (v) {
  config.plugins.push(new HtmlWebpackPlugin(v));
});

module.exports = config

if (process.env.NODE_ENV === &#39;production&#39;) {
  module.exports.devtool = &#39;#source-map&#39;
  // http://vue-loader.vuejs.org/en/workflow/production.html
  module.exports.plugins = (module.exports.plugins || []).concat([
    new webpack.DefinePlugin({
      &#39;process.env&#39;: {
        NODE_ENV: &#39;&amp;quot;production&amp;quot;&#39;
      }
    }),
    //压缩单元
    new webpack.optimize.UglifyJsPlugin({
      // 最紧凑的输出
      beautify: false,
      // 删除所有的注释
      comments: false,
      compress: {
        // 在UglifyJs删除没有用到的代码时不输出警告  
        warnings: false,
        // 删除所有的 `console` 语句
        // 还可以兼容ie浏览器
        drop_console: true,
        // 内嵌定义了但是只用到一次的变量
        collapse_vars: true,
        // 提取出出现多次但是没有定义成变量去引用的静态值
        reduce_vars: true,
      }
    }),

  ])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var path = require(&#39;path&#39;);
var fs = require(&#39;fs&#39;);
var webpack = require(&#39;webpack&#39;);
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);
var FriendlyErrorsWebpackPlugin = require(&#39;friendly-errors-webpack-plugin&#39;);

console.log(&#39;NODE_ENV&#39;,process.env.NODE_ENV);

const extractCSS = new ExtractTextPlugin(&#39;css/[name]-one.css&#39;);
const extractLESS = new ExtractTextPlugin(&#39;css/[name]-two.css&#39;);
const extractSASS = new ExtractTextPlugin(&#39;css/[name]-three.css&#39;);

var config = {
    entry: {
        main: [
            // &#39;babel-polyfill&#39;,
            &#39;webpack-hot-middleware/client?path=/__webpack_hmr&amp;amp;timeout=20000&amp;amp;reload=true&#39;,
            &#39;webpack/hot/dev-server&#39;,
            path.resolve(__dirname, &#39;src/main.js&#39;),
            path.resolve(__dirname, &#39;src/index.js&#39;)
        ],
        verdor: [
            path.resolve(__dirname, &#39;src/verdor/verdor.js&#39;),
        ]
    },
    // entry: path.resolve(__filename, &#39;../src/main.js&#39;),
    output: {
        path: path.resolve(__filename, &#39;../dist&#39;),
        publicPath: &#39;/&#39;,
        filename: &#39;[name].[hash:8].bundle.js&#39;,
        // webpack 允许你根据文件内容生成哈希值，只要用 [chunkhash] 替换 [hash] 就可以了
        // 不要在开发环境下使用 [chunkhash]，因为这会增加编译时间。将开发和生产模式的配置分开，并在开发模式中使用 [name].js 的文件名， 在生产模式中使用 [name].[chunkhash].js 文件名。
        //    publicPath: &#39;/&#39;,
        //    chunkFilename: &#39;[id].[chunkhash].js&#39;
    },
    // 生成.map文件
    // devtool: &#39;source-map&#39;,
    module: {
        rules: [
            // 加载JSON文件 使用json-loader webpack1
            // wenpack2 + ,json-loader 不再需要手动添加
            // [官方: 是为了消除 webpack、 node.js 和 browserify 之间的环境差异。 https://github.com/webpack/webpack/issues/3363]
            // {
            //     test: /\.json$/,
            //     use: &#39;json-loader&#39;
            // },

            // 处理 .json5结尾的文件
            {
                test: /\.json5$/,
                use: &#39;json5-loader&#39;
            },
            // {
            //     test: /\.css$/,
            //     // 使用①生成的css文件 插入到html中
            //     // use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]
            //     // 使用②ExtractTextPlugin 生成style.css文件
            //     // 在主入口文件中import
            //     use: ExtractCSS.extract([
            //         &#39;css-loader&#39;,
            //         // &#39;px2rem2-loader&#39;,
            //         &#39;postcss-loader&#39;,
            //     ]),
            // }

            // 使用postcss方式， css 插入到DOM形式 ， 支持热更新
            // {
            //     test: /\.css$/,
            //     use: [ &#39;style-loader&#39;, &#39;css-loader&#39;,  &#39;postcss-loader&#39; ]
            // },
            {
                test: /\.less$/,
                use: extractLESS.extract({
                    fallback: [&#39;style-loader&#39;],
                    use: [
                        &#39;css-loader&#39;,
                        &#39;postcss-loader&#39;,
                        &#39;less-loader&#39;
                    ]
                })
            },
            {
                test: /\.scss$/,
                use: extractSASS.extract({
                    fallback: [&#39;style-loader&#39;],
                    use: [
                        &#39;css-loader&#39;,
                        &#39;postcss-loader&#39;,
                        &#39;sass-loader&#39;
                    ]
                })
            },
            // ExtractTextPlugin 提取了样式出来， 官方说No Hot Module Replacement。
            // https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/webpack-1/README.md
            {
                test: /\.css$/,
                use: extractCSS.extract({
                    fallback: [&#39;style-loader&#39;],
                    use: [
                        &#39;css-loader&#39;,
                        &#39;postcss-loader&#39;
                    ]
                })
            },
            {
                test: /\.js(x)*$/,
                exclude: /node_modules/,
                loader: &#39;babel-loader&#39;
            },
            {
                test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
                loader: &#39;url-loader&#39;,
                options: {
                    limit: 8000,
                    name: &#39;image/[name].[hash:7].[ext]&#39;
                }
            },
            {
                test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
                loader: &#39;url-loader&#39;,
                options: {
                    limit: 8000,
                    name: &#39;font/[name].[hash:7].[ext]&#39;
                }
            },
            // 手写一个简单的webpack loader
            // 处理 .huangyb 后缀的文件
            {
                test: /\.huangyb$/,
                loader: &#39;huangyb-loader&#39;
            }
        ]
    },
    plugins: [
        // 生成html文件，里面的JS文件 src 地址自动添加hash
        new HtmlWebpackPlugin({
            title: &#39;huangyb&#39;,
            favicon: &#39;./src/image/logoNew.gif&#39;,
            filename: &#39;index.html&#39;,
            minify:{
                removeComments: true, // 删除注释
                collapseWhitespace: true // 删除空格
            }
        }),
        // CSS生成单独的文件
        // new ExtractTextPlugin({
        //     filename: &#39;css/[name][hash:8].css&#39;,
        //     allChunks: true,
        //     disable: false
        // })

        extractCSS,
        extractLESS,
        extractSASS,

        // 用来跳过编译时出错的代码并记录，使编译后运行时的包不会发生错误
        // * webpack3 NoEmitOnErrorsPlugin 已经 取代webpack 2 的 NoErrorsPlugin
        new webpack.NoEmitOnErrorsPlugin(),
        new FriendlyErrorsWebpackPlugin(), // 终端显示

        new webpack.optimize.CommonsChunkPlugin({ // 提取公用JS代码插件
            names: [&#39;vendor&#39;],
            // ( 公共chunk(commnons chunk) 的名称)
            filename: &#39;commons.js&#39;,
            // ( 公共chunk 的文件名)
            minChunks: 3
            // (模块必须被3个 入口chunk 共享)
            // CommonsChunkPlugin 可以通过传参minChunks来控制你希望重复出现几次的module 被提取出来打包。
            // 也就是说你自己可以控制当一个模块被引入几次可以被打包到共用的chunk中，还可以规定如果这个公共模块小于一个值 minSize，
            // 就不被提取出来这些都可以帮助你控制你想要的粒度。当你改的不是公共模块的代码，理论上webpack 打包的时候本来就不会影响其他代码。
            // chunks: [&#39;pageA&#39;, &#39;pageB&#39;],
            // (只使用这些 入口chunk)
        }),

        // OccurrenceOrderPlugin 现在默认启用，并已重命名（在 webpack 1 中为 OccurenceOrderPlugin）。 因此，请确保从您的配置中删除该插件：
        // OccurrenceOrderPlugin is now on by default
        // new webpack.optimize.OccurrenceOrderPlugin(),
        new webpack.HotModuleReplacementPlugin()
    ]
    // resolve: {
    //     alias: {
    //         huangImg: path.resolve(__dirname, &#39;src/image/&#39;)
    //     }
    // }
}

module.exports = config;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*
 * @Author: ignaciozhu
 * @Date: 2017-05-03 16:32:21
 * @Last Modified by: ignaciozhu
 * @Last Modified time: 2017-06-02 11:50:06
 */
//配置本地反向代理文件夹所在路径
const DIST = &#39;../../../ya/client_html/branch/nginx-1.10.1/&#39;;
const path = require(&#39;path&#39;)
const webpack = require(&#39;webpack&#39;)
const HtmlWebpackPlugin = require(&amp;quot;html-webpack-plugin&amp;quot;) //自动生成一个html 引入打包之后的js
const ExtractTextPlugin = require(&amp;quot;extract-text-webpack-plugin&amp;quot;) //默认打包css 这些全部在js 里面  用这个可以分离出来 单独生成css文件  //生产环节会用到
const OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;) //打包完成自动打开浏览器
const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;) //拷贝文件  当有第三方依赖可以copy到打包文件夹中
const autoprefixer = require(&#39;autoprefixer&#39;) //自动加前缀
const CptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;) //压缩css
const ImageminPlugin = require(&#39;imagemin-webpack-plugin&#39;).default //压缩图片
const { BundleAnalyzerPlugin } = require(&#39;webpack-bundle-analyzer&#39;) //生成打包图
const UglifyJSPlugin = require(&#39;uglifyjs-webpack-plugin&#39;); //webpack3 单独分离出来了这个压缩的

const { host, dev_port } = require(&amp;quot;./config&amp;quot;)
const { delhttp } = require(&#39;./server/utils/method.js&#39;)

module.exports = (env) =&amp;gt; {
  //env 是npm script 运行webpack时传进来的  判断是否是开发环境
  const mode = (env &amp;amp;&amp;amp; env.mode) || &amp;quot;DEV&amp;quot;

  const options = {
      //开发工具
      devtool: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;source-map&amp;quot; : false,

      //开发服务器
      devServer: {
        contentBase: path.resolve(__dirname, &amp;quot;dist&amp;quot;), //静态资源根目录
        compress: true, //压缩
        port: dev_port, //端口
        host: delhttp(host),
        hot: true, //热更新
        inline: true, //iframe 模式
        historyApiFallback: true, //浏览器 history
        stats: { //统计
          color: true, //输出有颜色的信息
          errors: true, //显示错误信息
          version: true, //显示版本号
          warnings: true, //显示警告
          progress: true, //显示进度,
          timings: true, //显示时间
        }
      },

      //入口
      entry: mode === &amp;quot;DEV&amp;quot; ? [
        &amp;quot;react-hot-loader/patch&amp;quot;, //热更新
        `webpack-dev-server/client?${host}:${dev_port}`,
        &amp;quot;webpack/hot/only-dev-server&amp;quot;,
        path.resolve(__dirname, &amp;quot;src/index.js&amp;quot;),
      ] : {
        app: path.resolve(__dirname, &amp;quot;src/index.js&amp;quot;),
        // vendor:[&#39;react&#39;]
      },

      //打包输出
      output: {
        path: path.resolve(__dirname, DIST + &amp;quot;dist&amp;quot;), ///myblog
        filename: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;js/[name].js&amp;quot; : &amp;quot;./js/[name].[chunkhash:8].js&amp;quot;,
        chunkFilename: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;js/[name]Chunk.js&amp;quot; : &amp;quot;./js/[name]Chunk.[chunkhash:8].js&amp;quot;,
        publicPath: mode === &amp;quot;DEV&amp;quot; ? `${host}:${dev_port}/` : &amp;quot;/&amp;quot; //myblog/
      },

      //模块加载器
      module: {
        rules: [{
          test: /\.js[x]?$/,
          use: [{
            loader: &amp;quot;babel-loader&amp;quot;
          }],
          exclude: &amp;quot;/node_modules/&amp;quot;,
          use: [
            // {loader:&#39;react-hot-loader&#39;},
            {
              loader: &amp;quot;babel-loader&amp;quot;,
              options: {
                //按需加载模块，antd...
                plugins: [
                  [&amp;quot;import&amp;quot;, [{
                    &amp;quot;libraryName&amp;quot;: &amp;quot;antd&amp;quot;,
                    &amp;quot;libraryDirectory&amp;quot;: &amp;quot;lib&amp;quot;,
                    &amp;quot;style&amp;quot;: true
                  }, {
                    &amp;quot;libraryName&amp;quot;: &amp;quot;antd-mobile&amp;quot;,
                    &amp;quot;libraryDirectory&amp;quot;: &amp;quot;component&amp;quot;,
                  }, ]],
                  // &amp;quot;transform-decorators-legacy&amp;quot;,
                  // &amp;quot;transform-class-properties&amp;quot;
                ]
              }
            },
          ],
          include: [path.resolve(&amp;quot;src&amp;quot;)] //只遍历src目录下的
        }, {
          test: /\.less$/,
          use: mode === &amp;quot;DEV&amp;quot; //开发环境 css打包到js中
            ? [
              { loader: &amp;quot;style-loader&amp;quot; }, //loader 倒序执行  先执行 less-laoder
              { loader: &amp;quot;css-loader&amp;quot;, options: { minimize: false, sourceMap: true } },
              { loader: &amp;quot;postcss-loader&amp;quot; }, //自动加前缀
              { loader: &amp;quot;less-loader&amp;quot;, options: { sourceMap: true } }
            ] : ExtractTextPlugin.extract({ //生产环境 把css单独分离出来
              fallback: &amp;quot;style-loader&amp;quot;,
              use: [
                &amp;quot;css-loader&amp;quot;,
                &amp;quot;postcss-loader&amp;quot;, {
                  loader: &amp;quot;less-loader&amp;quot;,
                  options: {
                    sourceMap: false,
                  },
                },
              ],
            })
        }, {
          test: /\.css$/,
          use: mode === &amp;quot;DEV&amp;quot; ? [
            { loader: &amp;quot;style-loader&amp;quot; }, //loader 倒序执行  先执行 less-laoder
            { loader: &amp;quot;css-loader&amp;quot;, options: { minimize: false, sourceMap: true } },
            { loader: &amp;quot;postcss-loader&amp;quot; }
          ] : ExtractTextPlugin.extract({
            fallback: &amp;quot;style-loader&amp;quot;,
            use: [
              &amp;quot;css-loader&amp;quot;,
              &amp;quot;postcss-loader&amp;quot;, {
                loader: &amp;quot;less-loader&amp;quot;,
                options: {
                  sourceMap: false
                },
              },
            ],
          })
        }, {
          test: /\.(jpg|jpeg|png|gif|cur|ico)$/,
          use: [{
            loader: &#39;file-loader&#39;,
            options: {
              name: &amp;quot;images/[name][hash:8].[ext]&amp;quot; //遇到图片  生成一个images文件夹  名字.后缀的图片
            }
          }]
        }, {
          test: /\.(eot|ttf|svg|woff|woff2)$/,
          use: [{
            loader: &amp;quot;file-loader&amp;quot;,
            options: {
              name: &amp;quot;fonts/[name][hash:8].[ext]&amp;quot;,
            },
          }, ],
        }, ]
      },

      //自动补全后缀
      resolve: {
        enforceExtension: false, //2.0 后 不能写 extensions :[&amp;quot;&amp;quot;]
        extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.json&#39;], //比如 test.js   可以写成 require(&#39;test&#39;)
        alias: {
          // Support React Native Web
          // https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/
          &#39;react-native&#39;: &#39;react-native-web&#39;,
          components: path.resolve(__dirname) + &#39;/src/common/components&#39;,
          /* container: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/container&#39;,
           images: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/images&#39;,
           pages: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/pages&#39;,
           utils: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/utils&#39;,
           data: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/server/data&#39;,
           actions: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/actions&#39;,
           reducers: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/reducers&#39;,*/
        },
        modules: [
          path.resolve(&amp;quot;src&amp;quot;), //比如 src/app/components/xx  可以写成 app/components/xx
          path.resolve(&amp;quot;.&amp;quot;),
          path.resolve(&amp;quot;src/shared&amp;quot;),
          &amp;quot;node_modules&amp;quot;,
        ],
      },

      //插件
      plugins: []
    }
    //根据开发环境不同  concat 不同的插件
  if (mode === &amp;quot;DEV&amp;quot;) {
    options.plugins = options.plugins.concat([
      new webpack.NamedModulesPlugin(), //打印更具可读性模块名称在浏览器控制台
      new webpack.NoEmitOnErrorsPlugin(), //错误不打断
      new webpack.DefinePlugin({ //调试
        __DEBUG__: true,
      }),
      new webpack.HotModuleReplacementPlugin(), //热加载插件  
      /*      new OpenBrowserPlugin({ //编译完成打开浏览器
              url: `${host}:${dev_port}`
            })*/
    ])
  } else {
    options.plugins = options.plugins.concat([
      // new BundleAnalyzerPlugin(),     //生成打包图
      // //webpackv3.0新增 作用域提升 默认是闭包式打包 浏览器执行速度变慢
      // //开启这个去掉模块的包裹函数,体积更小
      // new webpack.optimize.ModuleConcatenationPlugin(),
      new webpack.DefinePlugin({
        &amp;quot;process.env.NODE_ENV&amp;quot;: JSON.stringify(&amp;quot;production&amp;quot;),
        __DEBUG__: false,
      }),
      new UglifyJSPlugin({ //压缩
        output: {
          comments: false //移除所有注释
        },
        compress: {
          warnings: false
        }
      }),
      new ExtractTextPlugin({ // 将打包文件中的css分离成一个单独的css文件
        filename: &#39;css/app.[contenthash:8].css&#39;,
        allChunks: true
      }),
      //[1]
      //找到所有node_modules的依赖包  分离出来
      // /axios/ 没有用到的模块
      new webpack.optimize.CommonsChunkPlugin({
        name: &amp;quot;app&amp;quot;,
        async: &amp;quot;common-in-lazy&amp;quot;,
        children: true,
        minChunks: ({ resource } = {}) =&amp;gt; (
          resource &amp;amp;&amp;amp;
          resource.includes(&#39;node_modules&#39;) &amp;amp;&amp;amp;
          /axios/.test(resource)
        )
      }),
      // [2]
      //找到模块次数使用两次的  分离出来
      //单独打成used-twice.js 减少包的体积
      /**
       * 升级到 v2.6 貌似async不起作用  article admin detail 都使用了但是moment都打包进了对应的chunk文件
       * 导致文件增大了600kb
       * 经过github上的提问 各路大神的帮助下  解决了上面这个问题 需要设置name!!!!!!!!!!!
       */
      new webpack.optimize.CommonsChunkPlugin({
        name: &amp;quot;app&amp;quot;,
        children: true,
        async: &#39;used-twice&#39;,
        minChunks: (module, count) =&amp;gt; (
          count &amp;gt;= 2
        ),
      }),
      //[3]
      //[1][2][3] 是按需加载 大幅减少打包js体积的关键
      //遍历node_modules目录 以.js结尾 一道vender chunk
      //自动化分离第三方依赖
      new webpack.optimize.CommonsChunkPlugin({
        name: &#39;app&#39;,
        filename: &amp;quot;js/common.[chunkhash:8].js&amp;quot;,
        minChunks: ({ resource }) =&amp;gt; (
          resource &amp;amp;&amp;amp;
          resource.indexOf(&#39;node_modules&#39;) &amp;gt;= 0 &amp;amp;&amp;amp;
          resource.match(/\.js$/)
        )
      }),
      new webpack.LoaderOptionsPlugin({ //laoder最小化
        minimize: true
      }),
      //图片压缩没用。。。什么鬼
      new ImageminPlugin({
        // disable:false,
        test: /\.(jpe?g|png|gif|svg)$/i,
        optipng: {
          optimizationLevel: 7
        }
      }),
      new CptimizeCssAssetsPlugin({ //压缩css  与 ExtractTextPlugin 配合使用
        cssProcessor: require(&#39;cssnano&#39;),
        cssProcessorOptions: { discardComments: { removeAll: true } }, //移除所有注释
        canPrint: true //是否向控制台打印消息
      })
    ])
  }
  options.plugins.push(
    new HtmlWebpackPlugin({
      title: &amp;quot;西溪泊岸共享&amp;quot;,
      filename: &amp;quot;index.html&amp;quot;, //自动把打包的js文件引入进去
      template: path.resolve(__dirname, &amp;quot;src/index.html&amp;quot;), //模板文件
      hash: true, //添加hash码
      inject: true //注射所有资源到 body元素的底部     &amp;quot;head&amp;quot; &amp;quot;body&amp;quot; true false  &amp;quot;body&amp;quot; == true
    })
  )
  return options
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Shell常用招式大全-入门篇</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</guid>
            <description>

&lt;p&gt;采用source 而不是bash 命令 可以将环境变量传递过去&lt;/p&gt;

&lt;p&gt;本教程分为入门篇，命令篇和实战篇，结合平时工作中使用Shell的经验编写。以实例为主，侧重于应用，总结了一些实用的技巧。&lt;/p&gt;

&lt;p&gt;以下为本教程的《入门篇》，适于初学者快速入门以及老手查缺补漏。&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;第一招-helloworld&#34;&gt;第一招 HelloWorld&lt;/h1&gt;

&lt;h2 id=&#34;第一式-echo&#34;&gt;第一式：echo&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;echo -n &amp;quot;Hello World&amp;quot;    # 不带换行
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;echo -e &#39;\e[0;33;1mHello\e[0m World&#39;   # 带颜色的玩法
echo -e &#39;\e[0;33;4mHello\e[0m World&#39;   # 带颜色+下划线
echo -e &#39;\e[0;33;5mHello\e[0m World&#39;   # 带颜色+闪烁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式为 &lt;code&gt;\e[背景色;前景色;高亮格式m&lt;/code&gt;，请阅读&lt;a href=&#34;http://blog.chinaunix.net/uid-15007890-id-3152717.html&#34;&gt;详细文档&lt;/a&gt;后使用正确的姿势进行装逼。&lt;/p&gt;

&lt;h1 id=&#34;第二招-判断&#34;&gt;第二招 判断&lt;/h1&gt;

&lt;h2 id=&#34;第一式-if&#34;&gt;第一式：if&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;if true
then
    echo &amp;quot;Hello World&amp;quot;
else
	echo &amp;quot;Bug&amp;quot;
fi

if false
then
    echo &amp;quot;Hello World&amp;quot;
elif true
then
    echo &amp;quot;Bug&amp;quot;
else
	echo &amp;quot;Bee&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;判断原理&#34;&gt;判断原理&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;elif&lt;/code&gt;会执行它后面跟着的命令，然后看返回值是否为&lt;code&gt;0&lt;/code&gt;，如果为&lt;code&gt;0&lt;/code&gt;则执行&lt;code&gt;then&lt;/code&gt;下面的语句块，否则执行&lt;code&gt;else&lt;/code&gt;下面的语句块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]$ true
[casheywen@ubuntu:~]$ echo $?
0
[casheywen@ubuntu:~]$ false
[casheywen@ubuntu:~]$ echo $?
1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;事实上也为一个命令，&lt;code&gt;true&lt;/code&gt;的返回码必为&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;false&lt;/code&gt;的返回码必为&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt;为&lt;code&gt;shell&lt;/code&gt;内置变量，用于存放上一个命令的返回码&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-test-和&#34;&gt;第二式：test、[ ] 和 [[ ]]&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;test&lt;/code&gt;、&lt;code&gt;[ ]&lt;/code&gt;、&lt;code&gt;[[ ]]&lt;/code&gt;实际上都是&lt;code&gt;shell&lt;/code&gt;中的命令，执行之后会返回&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;，而这几个命令与&lt;code&gt;if&lt;/code&gt;相结合可以达到我们所需要的许多判断功能，例如测试字符串是否为空的三种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s=&amp;quot;&amp;quot;
if [ -z ${s} ]
then
    echo &amp;quot;empty&amp;quot;
fi

if [[ -z ${s} ]]
then
    echo &amp;quot;empty&amp;quot;
fi

if test -z ${s}
then
    echo &amp;quot;empty&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上，&lt;code&gt;if&lt;/code&gt;后的&lt;code&gt;[  ]&lt;/code&gt;、&lt;code&gt;[[  ]]&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;命令都是可以单独执行的，而根据&lt;code&gt;if&lt;/code&gt;的&lt;a href=&#34;#判断原理&#34;&gt;判断原理&lt;/a&gt;，后续执行哪个分支也是由&lt;code&gt;[  ]&lt;/code&gt;、&lt;code&gt;[[  ]]&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;的返回值来决定的，以下是单独执行它们的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]$ s=&amp;quot;&amp;quot;
[casheywen@ubuntu:~]$ [ -z &amp;quot;${s}&amp;quot; ]
[casheywen@ubuntu:~]$ echo $?
0
[casheywen@ubuntu:~]$ s=&amp;quot;abc&amp;quot;
[casheywen@ubuntu:~]$ test -z &amp;quot;${s}&amp;quot;
[casheywen@ubuntu:~]$ echo $?
1
[casheywen@ubuntu:~]$ s=&amp;quot;123&amp;quot;
[casheywen@ubuntu:~]$ [[ 100 -lt ${s} ]]
[casheywen@ubuntu:~]$ echo $?
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在性能方面&lt;code&gt;[ ]&lt;/code&gt;和&lt;code&gt;test&lt;/code&gt;性能基本相同，&lt;code&gt;[[ ]]&lt;/code&gt;性能是最高的，为前两者的&lt;code&gt;5&lt;/code&gt;倍左右（以&lt;code&gt;-d&lt;/code&gt;运算符测试），所以建议尽量使用&lt;code&gt;[[ ]]&lt;/code&gt;提高脚本性能。&lt;/p&gt;

&lt;h2 id=&#34;文件测试&#34;&gt;文件测试&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-e filename&lt;/td&gt;
&lt;td&gt;如果 filename 存在，则为真&lt;/td&gt;
&lt;td&gt;[ -e /var/log/syslog ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d filename&lt;/td&gt;
&lt;td&gt;如果 filename 为目录，则为真&lt;/td&gt;
&lt;td&gt;[ -d /tmp/mydir ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f filename&lt;/td&gt;
&lt;td&gt;如果 filename 为常规文件，则为真&lt;/td&gt;
&lt;td&gt;[ -f /usr/bin/grep ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-L filename&lt;/td&gt;
&lt;td&gt;如果 filename 为符号链接，则为真&lt;/td&gt;
&lt;td&gt;[ -L /usr/bin/grep ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r filename&lt;/td&gt;
&lt;td&gt;如果 filename 可读，则为真&lt;/td&gt;
&lt;td&gt;[ -r /var/log/syslog ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-w filename&lt;/td&gt;
&lt;td&gt;如果 filename 可写，则为真&lt;/td&gt;
&lt;td&gt;[ -w /var/mytmp.txt ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-x filename&lt;/td&gt;
&lt;td&gt;如果 filename 可执行，则为真&lt;/td&gt;
&lt;td&gt;[ -x /usr/bin/grep ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;filename1 -nt filename2&lt;/td&gt;
&lt;td&gt;如果 filename1 比 filename2 新，则为真&lt;/td&gt;
&lt;td&gt;[ /tmp/install/etc/services -nt /etc/services ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;filename1 -ot filename2&lt;/td&gt;
&lt;td&gt;如果 filename1 比 filename2 旧，则为真&lt;/td&gt;
&lt;td&gt;[ /boot/bzImage -ot arch/i386/boot/bzImage ]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-z string&lt;/td&gt;
&lt;td&gt;如果 string 长度为零，则为真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[ -z &amp;quot;${myvar}&amp;quot; ]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n string&lt;/td&gt;
&lt;td&gt;如果 string 长度非零，则为真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[ -n &amp;quot;${myvar}&amp;quot; ]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;string1 = string2&lt;/td&gt;
&lt;td&gt;如果 string1 与 string2 相同，则为真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; = &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;string1 != string2&lt;/td&gt;
&lt;td&gt;如果 string1 与 string2 不同，则为真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; != &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;string1 &amp;lt; string&lt;/td&gt;
&lt;td&gt;如果 string1 小于 string2，则为真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; \&amp;lt; &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[[ &amp;quot;${myvar}&amp;quot; &amp;lt; &amp;quot;abc&amp;quot; ]]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;string1 &amp;gt; string&lt;/td&gt;
&lt;td&gt;如果 string1 大于 string2，则为真&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; \&amp;gt; &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[[ &amp;quot;${myvar}&amp;quot; &amp;gt; &amp;quot;abc&amp;quot; ]]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在字符串两边加上&amp;rdquo;&amp;ldquo;防止出错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;是字符串比较，不要错用成整数比较&lt;/li&gt;
&lt;li&gt;如果是在&lt;code&gt;[ ]&lt;/code&gt;中使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;，需要将它们写成&lt;code&gt;\&amp;lt;&lt;/code&gt;和&lt;code&gt;\&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;整数比较&#34;&gt;整数比较&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;num1 -eq num2&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;td&gt;[ 3 -eq $mynum ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;num1 -ne num2&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;td&gt;[ 3 -ne $mynum ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;num1 -lt num2&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;td&gt;[ 3 -lt $mynum ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;num1 -le num2&lt;/td&gt;
&lt;td&gt;小于或等于&lt;/td&gt;
&lt;td&gt;[ 3 -le $mynum ]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;num1 -ge num2&lt;/td&gt;
&lt;td&gt;大于或等于&lt;/td&gt;
&lt;td&gt;[ 3 -ge $mynum ]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;第三式&#34;&gt;第三式：&amp;amp;&amp;amp;、||&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;可以用来对两个判断语句求与&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if [ -n &amp;quot;abc&amp;quot; ] &amp;amp;&amp;amp; [ -n &amp;quot;aa&amp;quot; ]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; ]] &amp;amp;&amp;amp; [[ -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if test -n &amp;quot;abc&amp;quot; &amp;amp;&amp;amp; test -n &amp;quot;aa&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; &amp;amp;&amp;amp; -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;只有&lt;code&gt;[[ ]]&lt;/code&gt;才允许把&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;写在里面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;\|\|&lt;/code&gt;可以用来对两个判断语句求或&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if [ -n &amp;quot;abc&amp;quot; ] \|\| [ -n &amp;quot;aa&amp;quot; ]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; ]] \|\| [[ -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if test -n &amp;quot;abc&amp;quot; \|\| test -n &amp;quot;aa&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; \|\| -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt; &lt;strong&gt;注：&lt;/strong&gt;只有&lt;code&gt;[[ ]]&lt;/code&gt;才允许把`&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;小技巧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;还可以用来拼接命令，达到按前一个命令成功与否来决定是否执行后一个命令的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /data &amp;amp;&amp;amp; ls         # 当`cd /data`返回0(即成功)时才执行后面的`ls`
cd /data || cd /root   # 当`cd /data`返回非0(即失败)时才执行后面的`cd /root`
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第三招-循环&#34;&gt;第三招：循环&lt;/h1&gt;

&lt;h2 id=&#34;第一式-for&#34;&gt;第一式：for&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;for i in {1..100}
do
    echo ${i}
done
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{1..100}&lt;/code&gt;属于&lt;a href=&#34;#第五招通配&#34;&gt;通配&lt;/a&gt;的一种写法，展开会是&lt;code&gt;1 2 3 ... 100&lt;/code&gt;（1~100以空格隔开）这样的字串。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;code&gt;for i in 1 2 3;&lt;/code&gt;这样的语句，&lt;code&gt;for&lt;/code&gt;会将&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;依次赋值于&lt;code&gt;i&lt;/code&gt;进行循环，而对于&lt;a href=&#34;#第五招通配&#34;&gt;通配&lt;/a&gt;的情况，&lt;code&gt;for&lt;/code&gt;则会将通配展开后将里面的每一项依次赋值于&lt;code&gt;i&lt;/code&gt;进行循环。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;for i in `seq 100`
do
    echo ${i}
done

for i in `seq 1 2 100`
do
    echo ${i}
done
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;seq&lt;/code&gt;本身为一个命令，用于输出数字组成的序列，如&lt;code&gt;seq 100&lt;/code&gt;会生成并输出&lt;code&gt;1 2 3 ... 100&lt;/code&gt;（1~100以换行符隔开）这样的序列，而&lt;code&gt;seq 1 2 100&lt;/code&gt;则会生成并输出&lt;code&gt;1 3 5 ... 99&lt;/code&gt;（以1开始，2为公差的等差数列中小于100的项，以换行符隔开）。&lt;/li&gt;
&lt;li&gt;反引号(`)之间的命令会被执行，其输出结果会转换成一个&lt;a href=&#34;#第五式将命令执行结果存入变量&#34;&gt;变量&lt;/a&gt;，故上面的&lt;code&gt;for in&lt;/code&gt;会依次取出&lt;code&gt;seq&lt;/code&gt;的执行结果赋值于&lt;code&gt;i&lt;/code&gt;进行循环。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;for ((i = 0; i &amp;lt; 100; i++))
do
    echo ${i}
done

for ((i = 0; i &amp;lt; 100; i+= 2))
do
    echo ${i}
done
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上与C语言式的&lt;code&gt;for&lt;/code&gt;循环语法基本相同，区别在于双重括号：&lt;code&gt;(( ))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-while-until&#34;&gt;第二式：while、until&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;i=0
while [[ ${i} -lt 100 ]]
do
    echo ${i}
    ((i++))
done
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;i=0
until [[ ${i} -ge 100 ]]
do
    echo ${i}
    ((i++))
done
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;until&lt;/code&gt;的判断原理与&lt;code&gt;if&lt;/code&gt;是类似的，它会执行并它后面跟着的命令，不同点在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;是后面语句返回值为&lt;code&gt;0&lt;/code&gt;，则执行循环中的语句块，否则跳出循环;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;until&lt;/code&gt;则是后面语句返回值非&lt;code&gt;0&lt;/code&gt;，则执行循环中的语句块，否则跳出循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第四招-变量&#34;&gt;第四招：变量&lt;/h1&gt;

&lt;h2 id=&#34;第一式-整数&#34;&gt;第一式：整数&lt;/h2&gt;

&lt;h2 id=&#34;整数的运算&#34;&gt;整数的运算&lt;/h2&gt;

&lt;p&gt;方法较多，此处只列举最浅显易懂，并且效率最高的办法——直接将符合C语言语法的表达式放到&lt;code&gt;(( ))&lt;/code&gt;中即可达到对整数的计算目的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $(( 1+1 ))        # 最简单的1+1
echo $(( (1+2)*3/4 ))  # 表达式中还可以带括号
echo $(( 1&amp;lt;&amp;lt;32 ))      # 左移右移也支持，但仅限于-4294967296~4294967296之间的数值
echo $(( 1&amp;amp;3 ))        # &amp;amp;、^、|、~ 这样的位操作亦支持
(( i=1+2 ))            # 将1+2计算出结果后赋值给i，后续若`echo ${i}`会得到3
(( i++ ))              # 变量i自增1
(( i+=3 ))             # 变量i自增3
# ...                  # 还有很多，不再详列
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进行整数运算的方法还有：&lt;code&gt;expr&lt;/code&gt;、&lt;code&gt;$[]&lt;/code&gt;、&lt;code&gt;let&lt;/code&gt;等&lt;code&gt;shell&lt;/code&gt;等内置命令，也可调用&lt;code&gt;bc&lt;/code&gt;、&lt;code&gt;python&lt;/code&gt;等外部工具进行更复杂的数学运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-字符串&#34;&gt;第二式：字符串&lt;/h2&gt;

&lt;h2 id=&#34;替换&#34;&gt;替换&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;${string/old/new}&lt;/td&gt;
&lt;td&gt;string中第一个old替换为new&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;${string//old/new}&lt;/td&gt;
&lt;td&gt;string中所有old替换为new&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;i hate hate you&amp;quot;
[casheywen@ubuntu:~]# echo ${s/hate/love}
i love hate you
[casheywen@ubuntu:~]# echo ${s//hate/love}
i love love you
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;截取子串&#34;&gt;截取子串&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;${string:n}&lt;/td&gt;
&lt;td&gt;string从下标n到结尾的子串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;${string:n:m}&lt;/td&gt;
&lt;td&gt;string从下标n开始长度为m的子串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;${string::m}&lt;/td&gt;
&lt;td&gt;string从下标0开始长度为m的子串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;0123456789&amp;quot;
[casheywen@ubuntu:~]# echo ${s:3}
3456789
[casheywen@ubuntu:~]# echo ${s::3}
012
[casheywen@ubuntu:~]# echo ${s:0:3}
012
[casheywen@ubuntu:~]# echo ${s:2:5}
23456
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通配删除&#34;&gt;通配删除&lt;/h2&gt;

&lt;p&gt;通配删除，即按通配符，删除掉字符串中符合条件的一部分&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;${string#pattern}&lt;/td&gt;
&lt;td&gt;string从左到右删除pattern的最小通配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;${string##pattern}&lt;/td&gt;
&lt;td&gt;string从左到右删除pattern的最大通配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;${string%pattern}&lt;/td&gt;
&lt;td&gt;string从右到左删除pattern的最小通配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;${string%%pattern}&lt;/td&gt;
&lt;td&gt;string从右到左删除pattern的最大通配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;此处通配规则参考&lt;a href=&#34;#通配符一览表&#34;&gt;通配符一览表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;最小通配和最大通配的区别：
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最小通配：符合通配的最小子串
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最大通配：符合通配的最大子串
例如string值为&lt;code&gt;/00/01/02/dir&lt;/code&gt;，对于通配&lt;code&gt;/*/&lt;/code&gt;，其最小通配为&lt;code&gt;/00/&lt;/code&gt;，而最大通配&lt;code&gt;/00/01/02/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;/00/01/02/dir&amp;quot;
[casheywen@ubuntu:~]# echo ${s#/*/}
01/02/dir
[casheywen@ubuntu:~]# echo ${s##/*/}
dir
[casheywen@ubuntu:~]#
[casheywen@ubuntu:~]# s=&amp;quot;abc/cde/efg&amp;quot;
[casheywen@ubuntu:~]# echo ${s%/*}
abc/cde
[casheywen@ubuntu:~]# echo ${s%%/*}
abc
[casheywen@ubuntu:~]#
[casheywen@ubuntu:~]# s=&amp;quot;/00/01/02/dir&amp;quot;
[casheywen@ubuntu:~]# echo ${s#/*/}
01/02/dir
[casheywen@ubuntu:~]# echo ${s##/*/}
dir
[casheywen@ubuntu:~]# s=&amp;quot;abc/cde/efg&amp;quot;
[casheywen@ubuntu:~]# echo ${s%/*}
abc/cde
[casheywen@ubuntu:~]# echo ${s%%/*}
abc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;小技巧&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;获取文件名：&lt;code&gt;${path##*/}&lt;/code&gt; (相当于&lt;code&gt;basename&lt;/code&gt;命令的功能)&lt;/li&gt;
&lt;li&gt;获取目录名：&lt;code&gt;${path%/*}&lt;/code&gt; (相当于&lt;code&gt;dirname&lt;/code&gt;命令的功能)&lt;/li&gt;
&lt;li&gt;获取后缀名：&lt;code&gt;${path##*.}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;/root/test/dir/subdir/abc.txt&amp;quot;
[casheywen@ubuntu:~]# echo ${s##*/}
abc.txt
[casheywen@ubuntu:~]# echo ${s%/*}
/root/test/dir/subdir
[casheywen@ubuntu:~]# echo ${s##*.}
txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-数组&#34;&gt;第三式：数组&lt;/h2&gt;

&lt;h2 id=&#34;普通数组&#34;&gt;普通数组&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;a=()         # 空数组
a=(1 2 3)    # 元素为1,2,3的数组
echo ${#a[*]}  # 数组长度
echo ${a[2]}   # 下标为2的元素值（下标从0开始）
a[1]=0         # 给下标为1的元素赋值

# 遍历数组
for i in ${a[*]}
do
    echo ${i}
done

unset a        # 清空数组
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关联数组&#34;&gt;关联数组&lt;/h2&gt;

&lt;p&gt;关联数组可以用于存储&lt;code&gt;key-value&lt;/code&gt;型的数据，其功能相当于&lt;code&gt;C++&lt;/code&gt;中的&lt;code&gt;map&lt;/code&gt;或&lt;code&gt;python&lt;/code&gt;中的&lt;code&gt;dict&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;declare -A a        # 声明关联数组（必须有此句）
a=([&amp;quot;apple&amp;quot;]=&amp;quot;a1&amp;quot; [&amp;quot;banana&amp;quot;]=&amp;quot;b2&amp;quot; [&amp;quot;carrot&amp;quot;]=&amp;quot;c3&amp;quot;)   # 初始化关联数组
echo ${#a[*]}       # 获取元素个数
echo ${a[&amp;quot;carrot&amp;quot;]} # 获取元素值  
a[&amp;quot;durian&amp;quot;]=&amp;quot;d4&amp;quot;    # 插入或修改元素
echo ${!a[*]}       # 获取所有的key
unset a[&amp;quot;banana&amp;quot;]   # 删除元素

# 遍历数组(仅value)
for i in ${a[*]}
do
    echo ${i}
done

# 遍历数组(key和value)
for key in ${!a[*]}
do
	echo &amp;quot;${key} ==&amp;gt; ${a[${key}]}&amp;quot;
done

unset a             # 清空数组
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;关联数组需要bash 4.0以上版本才支持，选用需慎重。查看&lt;code&gt;bash&lt;/code&gt;版本用&lt;code&gt;bash --version&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关联数组必须用&lt;code&gt;declare -A&lt;/code&gt;显示声明类型，否则数值会出错。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第四式-将命令执行结果存入变量&#34;&gt;第四式：将命令执行结果存入变量&lt;/h2&gt;

&lt;h2 id=&#34;与&#34;&gt;` `与$( )&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;LINE_CNT=`wc -l test.txt`
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;LINE_CNT=$(wc -l test.txt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令均可把&lt;code&gt;wc -l test.txt&lt;/code&gt;的结果存入&lt;code&gt;LINE_CNT&lt;/code&gt;变量中&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;` `&lt;/code&gt; 和&lt;code&gt;$( )&lt;/code&gt;都只将命令行标准输出的内容存入变量，如果需要将标准错误内容存入变量，需要用到&lt;a href=&#34;#第五招重定向&#34;&gt;重定向&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;换行符处理&#34;&gt;换行符处理&lt;/h2&gt;

&lt;p&gt;如果命令执行结果有多行内容，存入变量并打印时换行符会丢失：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# cat test.txt
a
b
c
[casheywen@ubuntu:~]# CONTENT=`cat test.txt`
[casheywen@ubuntu:~]# echo ${CONTENT}
a b c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若需要保留换行符，则在打印时必须加上&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# CONTENT=`cat test.txt`
[casheywen@ubuntu:~]# echo &amp;quot;${CONTENT}&amp;quot;      
a
b
c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h1 id=&#34;第五招-重定向&#34;&gt;第五招：重定向&lt;/h1&gt;

&lt;h2 id=&#34;标准输入流-标准输出流-标准错误流&#34;&gt;标准输入流、标准输出流、标准错误流&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;英文缩写&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;默认绑定位置&lt;/th&gt;
&lt;th&gt;文件路径&lt;/th&gt;
&lt;th&gt;Shell中代号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标准输入流&lt;/td&gt;
&lt;td&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;程序读取的用户输入&lt;/td&gt;
&lt;td&gt;键盘输入&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/dev/stdin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;标准输出流&lt;/td&gt;
&lt;td&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;程序的打印的正常信息&lt;/td&gt;
&lt;td&gt;终端(&lt;code&gt;terminal&lt;/code&gt;), 即显示器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/dev/stdin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;标准错误流&lt;/td&gt;
&lt;td&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;程序的错误信息&lt;/td&gt;
&lt;td&gt;终端(&lt;code&gt;terminal&lt;/code&gt;)，, 即显示器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/dev/stderr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;重定向方式一览表&#34;&gt;重定向方式一览表&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;gt; file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 stdout 重定向到 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;gt;&amp;gt; file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 stdout 追加到 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd 2&amp;gt; file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 stderr 重定向到 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd 2&amp;gt;&amp;gt; file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 stderr 追加到 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;amp;&amp;gt; file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 stdout 和 stderr 重定向到 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 stdout 和 stderr 重定向到 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;gt;&amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 stdout 和 stderr 追加到 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;lt;file &amp;gt;file2 cmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cmd 以 file 作为 stdin，以 file2 作为 stdout&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cat &amp;lt;&amp;gt;file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以读写的方式打开 file&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;lt; file cmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cmd 命令以 file 文件作为 stdin&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd &amp;lt;&amp;lt; delimiter Here document&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从 stdin 中读入，直至遇到 delimiter 分界符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;第一式-重定向标准输出流-stdout&#34;&gt;第一式：重定向标准输出流(stdout)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;把程序打印的内容输出到文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 以下两种方式都会将`Hello World`写入到hello.txt(若不存在则创建)
echo &amp;quot;Hello World&amp;quot; &amp;gt; hello.txt   # hello.txt原有的将被覆盖
echo &amp;quot;Hello World&amp;quot; &amp;gt;&amp;gt; hello.txt  # hello.txt原有内容后追加`Hello World`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二式-重定向标准错误流-stderr&#34;&gt;第二式：重定向标准错误流(stderr)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;把程序的错误信息输出到文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如文件路径中不存在&lt;code&gt;+++&lt;/code&gt;这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls +++
ls: cannot access +++: No such file or directory
[casheywen@ubuntu:~]# ls +++ &amp;gt; out.txt
ls: cannot access +++: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的&lt;code&gt;ls +++&lt;/code&gt;后输出的内容为标准错误流中的错误信息，所以即使用&lt;code&gt;&amp;gt; out.txt&lt;/code&gt;重定向标准输入，错误信息仍然被打印到了屏幕。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 以下两种方式都会将`ls +++`输出的错误信息输出到err.txt(若不存在则创建)
ls +++ 2&amp;gt; err.txt    # err.txt原有内容将被覆盖
ls +++ 2&amp;gt;&amp;gt; err.txt   # err.txt原有内容后追加内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-重定向标准输入流-stdin&#34;&gt;第三式：重定向标准输入流(stdin)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 让程序从文件读取输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以默认从标准输入读取表达式，并进行数学计算的命令&lt;code&gt;bc&lt;/code&gt;为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# bc -q
1+1
2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1+1&lt;/code&gt;为键盘输入的内容，&lt;code&gt;2&lt;/code&gt;为&lt;code&gt;bc&lt;/code&gt;命令打印的计算结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bc&lt;/code&gt;后的&lt;code&gt;-q&lt;/code&gt;参数用于禁止输出欢迎信息&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为&lt;code&gt;命令 &amp;lt; 文件路径&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我需要把已经存在文件&lt;code&gt;exp.txt&lt;/code&gt;中的一个表达式输入到&lt;code&gt;bc&lt;/code&gt;中进行计算，可以采用重定向标准输入流的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bc -q &amp;lt; exp.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当&lt;code&gt;exp.txt&lt;/code&gt;中内容为&lt;code&gt;1+1&lt;/code&gt;时，以上语句输出&lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;bc&lt;/code&gt;命令本身支持从文件输入，如不使用重定向，也可用&lt;code&gt;bc exp.txt&lt;/code&gt;达到相同效果&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2. 将&lt;a href=&#34;#第四招变量&#34;&gt;变量&lt;/a&gt;中内容作为程序输入&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXP=&amp;quot;1+1&amp;quot;
bc -q &amp;lt;&amp;lt;&amp;lt; &amp;quot;${EXP}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以上代码等同于执行&lt;code&gt;bc&lt;/code&gt;并输入&lt;code&gt;1+1&lt;/code&gt;，得到的输出为&lt;code&gt;2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为&lt;code&gt;命令 &amp;lt;&amp;lt;&amp;lt; 变量内容&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. 将当前shell脚本中的多行内容作为程序的输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如在shell中内嵌多行python代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python &amp;lt;&amp;lt; EOF
print &#39;hello from python&#39;
print &#39;hello&#39; + &#39;world&#39;
EOF

# 内容中支持shell变量
MSG=&amp;quot;shell variable&amp;quot;

python &amp;lt;&amp;lt; EOF
print &#39;${MSG}&#39;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以上用法可以方便地将某个程序需要的多行输入内容直接包含在当前脚本中&lt;/li&gt;
&lt;li&gt;支持变量，可以动态地改变多行输入的内容&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为：&lt;code&gt;命令 &amp;lt;&amp;lt; EOF (换行)...(换行) EOF&lt;/code&gt;，其中的&lt;code&gt;EOF&lt;/code&gt;换成其它字符串也是有效的，如：&lt;code&gt;命令 &amp;lt;&amp;lt; ABC (换行)...(换行) ABC&lt;/code&gt;的，但通用习惯都使用&lt;code&gt;EOF&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第六招-管道&#34;&gt;第六招：管道&lt;/h1&gt;

&lt;h2 id=&#34;第一式-管道的基本功能&#34;&gt;第一式：管道的基本功能&lt;/h2&gt;

&lt;p&gt;管道的写法为 &lt;code&gt;cmd1 | cmd2&lt;/code&gt;，功能是依次执行&lt;code&gt;cmd1&lt;/code&gt;和&lt;code&gt;cmd2&lt;/code&gt;，并将&lt;code&gt;cmd1&lt;/code&gt;的标准输出作为&lt;code&gt;cmd2&lt;/code&gt;的标准输入，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;1+1&amp;quot; | bc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;echo &amp;quot;1+1&amp;quot;&lt;/code&gt; 会将&lt;code&gt;1+1&lt;/code&gt;输出到标准输出，而管道会将&lt;code&gt;echo&lt;/code&gt;输出的&lt;code&gt;1+1&lt;/code&gt;作为&lt;code&gt;bc&lt;/code&gt;命令的标准输入，这样&lt;code&gt;bc&lt;/code&gt;会读取到&lt;code&gt;1+1&lt;/code&gt;，最终得到计算结果&lt;code&gt;2&lt;/code&gt;打印到屏幕。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;管道可以多级拼接：&lt;code&gt;cmd1 | cmd2 | cmd3 | ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;管道的返回值为最后一级命令的返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-管道与while-read组合&#34;&gt;第二式：管道与while、read组合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;LINE_NO=0
cat test.txt |
while read LINE
do
	(( LINE_NO++ ))
	echo &amp;quot;${LINE_NO} ${LINE}&amp;quot;
done

# echo &amp;quot;${LINE_NO}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将&lt;code&gt;test.txt&lt;/code&gt;中每一行标上行标后输出。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt;命令用于从标准输入读取一行并赋值给一个或多个变量，如&lt;code&gt;read LINE&lt;/code&gt;会从标准输入读取一行并将整行内容赋值给&lt;code&gt;LINE&lt;/code&gt;变量，&lt;code&gt;read A B&lt;/code&gt;则会从标准输入读入一行并将这行的第1、2列分别赋值给A、B两个变量（分割符默认为空格或tab，可给&lt;code&gt;IFS&lt;/code&gt;赋值来更改分割符）
&amp;gt; 2. 末尾注释掉的&lt;code&gt;echo &amp;quot;${LINE_NO}&amp;quot;&lt;/code&gt;若执行会输出&lt;code&gt;0&lt;/code&gt;，原因是管道中的&lt;code&gt;while&lt;/code&gt;语句是执行在子进程中的，不会改变父进程中&lt;code&gt;LINE_NO&lt;/code&gt;变量的值&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第三式-管道与xargs组合&#34;&gt;第三式：管道与xargs组合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;find . -type f -name *.log | xargs rm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将当前目录及子目录所有后缀名为&lt;code&gt;.log&lt;/code&gt;的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -type f -name *.log | xargs -i mv {} /data/log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将当前目录及子目录中所有后缀名为&lt;code&gt;.log&lt;/code&gt;的文件移动到&lt;code&gt;/data/log&lt;/code&gt;中
&amp;gt; &lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;xargs&lt;/code&gt;可以从标准输入读取内容，以之构建并执行另一个命令行
&amp;gt;&lt;br /&gt;
&amp;gt;  - &lt;code&gt;xargs&lt;/code&gt;直接接命令名称，则将从标准输入读取的所有内容合并为一行构建命令行并执行
&amp;gt;  - &lt;code&gt;xargs&lt;/code&gt;加上&lt;code&gt;-i&lt;/code&gt;参数，则会每读取一行就构建并执行一个命令行，构建命令行时会将&lt;code&gt;{}&lt;/code&gt;替换为该行的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# cat test.txt
a
b
c
[casheywen@ubuntu:~]# cat test.txt | xargs echo rm
rm a b c
[casheywen@ubuntu:~]# cat test.txt | xargs -i echo rm {}
rm a
rm b
rm c
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上例展示了&lt;code&gt;xargs&lt;/code&gt;构建命令的原理，如果去掉&lt;code&gt;xargs&lt;/code&gt;后的&lt;code&gt;echo&lt;/code&gt;，则会执行打印出来的命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第七招-通配&#34;&gt;第七招：通配&lt;/h1&gt;

&lt;h2 id=&#34;shell通配的原理&#34;&gt;shell通配的原理&lt;/h2&gt;

&lt;p&gt;如果你的当前目录中有&lt;code&gt;1.txt 2.txt 3.txt&lt;/code&gt;三个文件，那么当你执行&lt;code&gt;ls *.txt&lt;/code&gt;这条命令，&lt;code&gt;shell&lt;/code&gt;究竟为你做了什么？&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;shell&lt;/code&gt;会先读取当前目录，然后按&lt;code&gt;*.txt&lt;/code&gt;的通配条件过滤得到&lt;code&gt;1.txt 2.txt 3.txt&lt;/code&gt;这个文件列表，然后将这个列表作为参数传给&lt;code&gt;ls&lt;/code&gt;，即&lt;code&gt;ls *.txt&lt;/code&gt;相当于&lt;code&gt;ls 1.txt 2.txt 3.txt&lt;/code&gt;，&lt;code&gt;ls&lt;/code&gt;命令本身并不会得到&lt;code&gt;*.txt&lt;/code&gt;这样的参数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：仅当目录中没有符合&lt;code&gt;*.txt&lt;/code&gt;通配的文件，&lt;code&gt;shell&lt;/code&gt;才会将&lt;code&gt;*.txt&lt;/code&gt;这个字符串当作参数直接传给&lt;code&gt;ls&lt;/code&gt;命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以如果需要列出当前目录中所有的&lt;code&gt;txt&lt;/code&gt;文件，我们使用&lt;code&gt;echo *.txt&lt;/code&gt;也同样可以达到目的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls *.txt
1.txt  2.txt  3.txt
[casheywen@ubuntu:~]# echo *.txt
1.txt 2.txt 3.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;对于&lt;code&gt;{ }&lt;/code&gt;通配&lt;code&gt;shell&lt;/code&gt;不会读取目录并过滤获得文件列表。详细请&lt;a href=&#34;#通配符一览表&#34;&gt;参考下文&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;通配符一览表&#34;&gt;通配符一览表&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配 0 或多个字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a*b&lt;/code&gt; a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;匹配任意一个字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a?b&lt;/code&gt; a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[list]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配 list 中的任意单一字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a[xyz]b&lt;/code&gt; a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[!list]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[^list]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配 除list 中的任意单一字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a[!0-9]b&lt;/code&gt; a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[c1-c2]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a[0-9]b&lt;/code&gt; 0与9之间必须也只能有一个字符 如a0b, a1b&amp;hellip; a9b。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{string1,string2,...}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;枚举sring1或string2(或更多)其一字符串&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a{abc,xyz,123}b&lt;/code&gt; 展开成&lt;code&gt;aabcb axyzb a123b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{c1..c2}&lt;/code&gt;&lt;br/&gt;&lt;code&gt;{n1..n2}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;枚举c1-c2中所有字符或n1-n2中所有数字&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{a..f}&lt;/code&gt;展开成&lt;code&gt;a b c d e f&lt;/code&gt;&lt;br/&gt;&lt;code&gt;a{1..5}&lt;/code&gt; 展开成&lt;code&gt;a1 a2 a3 a4 a5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;[ ]&lt;/code&gt;的通配都会按&lt;a href=&#34;#shell%E9%80%9A%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86&#34;&gt;读取目录并过滤&lt;/a&gt;的方式展开通配项目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{ }&lt;/code&gt;则不会有读取目录的过程，它是通过枚举所有符合条件的通配项直接展开的
&lt;code&gt;
[casheywen@ubuntu:~]# ls
1.txt  2.txt  3.txt
[casheywen@ubuntu:~]# echo *.txt
1.txt 2.txt 3.txt
[casheywen@ubuntu:~]# echo {1..5}.txt
1.txt 2.txt 3.txt 4.txt 5.txt
[casheywen@ubuntu:~]# ls {1..5}.txt
ls: cannot access 4.txt: No such file or directory
ls: cannot access 5.txt: No such file or directory
1.txt  2.txt  3.txt
&lt;/code&gt;
由上面的命令可见，&lt;code&gt;*&lt;/code&gt;通配的结果与目录中存在哪些文件有关系，而&lt;code&gt;{ }&lt;/code&gt;的通配结果与目录中存在哪些文件无关。若用&lt;code&gt;{ }&lt;/code&gt;进行通配，则有可能将不存在的文件路径作为命令行参数传给程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第一式&#34;&gt;第一式：*&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;用于通配文件名或目录名中某一部分为任意内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm *.log          # 删除当前目录中所有后缀名为.log的文件
rm */log/*.log    # 删除所有二级log目录中后缀名为.log的文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二式&#34;&gt;第二式：[ ]&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt;用于通配文件名或目录名中某个字符为限定范围内或限定范围外的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
rm Program[1-9]*.log  # 删除当前目录中以Program跟着一个1到9的数字开头，并以.log为后缀名的文件
du -sh /[^udp]*       # 对根目录中所有不以u、d、p开头的文件夹求取总大小
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-1&#34;&gt;第三式：?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;?&lt;/code&gt;用于通配文件名中某处一个任意值的字符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm L????.txt    # 通配一个文件名以L开头，后面跟着4个字符，并以.txt结尾的文件：如LAB01.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第四式&#34;&gt;第四式：{ }&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt;也为通配符，用于通配在它枚举范围内的值，由于它是直接展开的，我们可以将它用于批量创建目录或文件，也可以用于生成序列：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;批量生成目录&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls
[casheywen@ubuntu:~]# mkdir dir{0..2}{0..2}    
[casheywen@ubuntu:~]# ls
dir00  dir01  dir02  dir10  dir11  dir12  dir20  dir21  dir22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生成序列&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt;生成的序列常用于&lt;a href=&#34;#第一式for&#34;&gt;for循环&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for ip in 192.168.234.{1..255}
do
    ping ${ip} -w 1 &amp;amp;&amp;gt; /dev/null &amp;amp;&amp;amp; echo ${ip} is Alive
done
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;以上例子用于查找&lt;code&gt;192.168.234.1~192.168.234.255&lt;/code&gt;整个网段能&lt;code&gt;ping&lt;/code&gt;通的所有&lt;code&gt;ip&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Shell常用招式大全-命令篇</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%91%BD%E4%BB%A4%E7%AF%87/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%91%BD%E4%BB%A4%E7%AF%87/</guid>
            <description>

&lt;p&gt;继上篇《入门篇》之后，本篇《命令篇》为《Shell常用招式大全》的第二篇教程。&lt;/p&gt;

&lt;p&gt;本篇根据本人的工作经验，总结了Linux下一些常用命令的使用技巧。旨在精而不在全，对于百度一下或&lt;code&gt;man&lt;/code&gt;一下即可知道的使用方法不做详细介绍。&lt;/p&gt;

&lt;p&gt;适合在Linux下用过一些命令，小尝甜头，但仍觉得Shell不是那么称手的读者。&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;第一招-文本处理&#34;&gt;第一招 文本处理&lt;/h1&gt;

&lt;p&gt;无名氏说：编程有两件事，一件是处理数值，另一件是处理字符串。&lt;/p&gt;

&lt;h2 id=&#34;第一式-cut-切割分列&#34;&gt;第一式 cut 切割分列&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;casheywen@ubuntu:~$ cat test.txt
1 2 3 4 5 6
a b c d e f g h i
apple banana pear peach
casheywen@ubuntu:~$ cat test.txt | cut -f 2 -d &#39; &#39;   # 取出第2列
2
b
banana
casheywen@ubuntu:~$ cat test.txt | cut -f 2,3 -d &#39; &#39;  # 取出第2,3两列
2 3
b c
banana pear
casheywen@ubuntu:~$ cat test.txt | cut -f 3- -d &#39; &#39;   # 取出第3到最后一列
3 4 5 6
c d e f g h i
pear peach
casheywen@ubuntu:~$ cat test.txt | cut -f 3-5 -d &#39; &#39;  # 取出第3~5列
3 4 5
c d e
pear peach
casheywen@ubuntu:~$ cat test.txt | cut -f 3 --complement -d &#39; &#39;  # 取出除第3列外的所有列
1 2 4 5 6
a b d e f g h i
apple banana peach
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从以上示例大家可以明白，&lt;code&gt;cut&lt;/code&gt;是一个列处理命令，功能上可以代替大多数类似&lt;code&gt;awk &#39;{print $1}&#39;&lt;/code&gt;的效果，写起来很方便。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;cut命令的参数:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 指定选择的列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 指定分割符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--complement&lt;/code&gt; 反选，指定后会打印不在&lt;code&gt;-f&lt;/code&gt;中的所有列&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;技一-读取配置文件&#34;&gt;技一: 读取配置文件&lt;/h3&gt;

&lt;p&gt;例如有一个格式如下的配置文件 &lt;code&gt;test.conf&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP = 192.168.0.1
PORT = 12800
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以用如下命令来读取IP字段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;casheywen@ubuntu:~$ cat test.conf | grep -w IP | cut -f 2 -d = | xargs
192.168.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>shell中的map使用</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/2017-11-07-shell%E4%B8%AD%E7%9A%84map%E4%BD%BF%E7%94%A8/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/2017-11-07-shell%E4%B8%AD%E7%9A%84map%E4%BD%BF%E7%94%A8/</guid>
            <description>

&lt;p&gt;bash 的版本必须 &amp;gt;= 4.1.2，升级bash：&lt;/p&gt;

&lt;p&gt;declare -A abc
declare: usage: declare [-afFirtx] [-p] [name[=value] &amp;hellip;]&lt;/p&gt;

&lt;h1 id=&#34;shell中map的定义与使用&#34;&gt;shell中map的定义与使用&lt;/h1&gt;

&lt;p&gt;declare -A 变量名 #切记使用大写的A，不是小写的a&lt;/p&gt;

&lt;p&gt;[root@www ~]# declare -A map=([&amp;ldquo;sunjun&amp;rdquo;]=&amp;ldquo;a&amp;rdquo; [&amp;ldquo;jason&amp;rdquo;]=&amp;ldquo;b&amp;rdquo; [&amp;ldquo;lee&amp;rdquo;]=&amp;ldquo;c&amp;rdquo;) #定义时初始化一些值
[root@www ~]# echo ${map[@]}        #输出所有values
a c b
[root@www ~]# echo ${!map[@]}       #输出所有keys
sunjun lee jason&lt;/p&gt;

&lt;p&gt;[root@www ~]# map[&amp;ldquo;hello&amp;rdquo;]=123      #向map中添加一个key=value
[root@www ~]# echo ${map[@]}
a c b 123
[root@www ~]# echo ${!map[@]}
sunjun lee jason hello
[root@www ~]#&lt;/p&gt;

&lt;h1 id=&#34;shell中的数组&#34;&gt;shell中的数组&lt;/h1&gt;

&lt;p&gt;[root@www ~]# declare -a array=(&amp;ldquo;aa&amp;rdquo; &amp;ldquo;bb&amp;rdquo; &amp;ldquo;cc&amp;rdquo;)     #定义一个数组
[root@www ~]# echo ${array[@]}      #输出所有元素的值
aa bb cc
[root@www ~]# echo ${!array[@]}     #输出所有元素的索引
0 1 2&lt;/p&gt;

&lt;p&gt;[root@www ~]# array[100]=&amp;ldquo;hello&amp;rdquo;    #指定索引添加一个元素
[root@www ~]# echo ${array[@]}
aa bb cc hello
[root@www ~]# echo ${!array[@]}
0 1 2 100
[root@www ~]#&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>shell条件判断</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/2017-11-07-shell%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/2017-11-07-shell%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</guid>
            <description>

&lt;h2 id=&#34;整数比较&#34;&gt;整数比较&lt;/h2&gt;

&lt;p&gt;-eq 等于      if [ &amp;ldquo;$a&amp;rdquo; -eq &amp;ldquo;$b&amp;rdquo; ]
-ne 不等于    if [ &amp;ldquo;$a&amp;rdquo; -ne &amp;ldquo;$b&amp;rdquo; ]
-gt 大于      if [ &amp;ldquo;$a&amp;rdquo; -gt &amp;ldquo;$b&amp;rdquo; ]
-ge 大于等于  if [ &amp;ldquo;$a&amp;rdquo; -ge &amp;ldquo;$b&amp;rdquo; ]
-lt 小于     if [ &amp;ldquo;$a&amp;rdquo; -lt &amp;ldquo;$b&amp;rdquo; ]
-le 小于等于  if [ &amp;ldquo;$a&amp;rdquo; -le &amp;ldquo;$b&amp;rdquo; ]
&amp;lt; 小于（使用 双圆括号）((&amp;ldquo;$a&amp;rdquo; &amp;lt; &amp;ldquo;$b&amp;rdquo;))
&amp;lt;= 小于等于（使用双圆括号）((&amp;ldquo;$a&amp;rdquo; &amp;lt;= &amp;ldquo;$b&amp;rdquo;))
&amp;gt; 大于（使用双圆括号）((&amp;ldquo;$a&amp;rdquo; &amp;gt; &amp;ldquo;$b&amp;rdquo;))
&amp;gt;= 大于等于（使用双圆括号） ((&amp;ldquo;$a&amp;rdquo; &amp;gt;= &amp;ldquo;$b&amp;rdquo;))&lt;/p&gt;

&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;

&lt;h3 id=&#34;等于-if-a-b-注意-在-前后要加上空格&#34;&gt;= 等于  if [ &amp;ldquo;$a&amp;rdquo; = &amp;ldquo;$b&amp;rdquo; ] 注意: 在=前后要加上空格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;   if [ &amp;quot;$a&amp;quot;=&amp;quot;$b&amp;quot; ] 和上面不等价。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;等于-if-a-b-和-同义&#34;&gt;== 等于 if [ &amp;ldquo;$a&amp;rdquo; == &amp;ldquo;$b&amp;rdquo; ] 和 = 同义&lt;/h3&gt;

&lt;p&gt;note == 操作符在 双方括号 和单方括号里的功能是不同的。&lt;/p&gt;

&lt;p&gt;[[ $a == z* ]]   # $a 以 &amp;ldquo;z&amp;rdquo; 开头时为真（模式匹配）
[[ $a == &amp;ldquo;z&lt;em&gt;&amp;rdquo; ]] # $a 等于 z&lt;/em&gt; 时为真（字符匹配）&lt;/p&gt;

&lt;p&gt;[ $a == z* ]     # 发生文件匹配和字符分割。
[ &amp;ldquo;$a&amp;rdquo; == &amp;ldquo;z&lt;em&gt;&amp;rdquo; ] # $a 等于 z&lt;/em&gt; 时为真（字符匹配）&lt;/p&gt;

&lt;h3 id=&#34;不等于-if-a-b&#34;&gt;!= 不等于 if [ &amp;ldquo;$a&amp;rdquo; != &amp;ldquo;$b&amp;rdquo; ]&lt;/h3&gt;

&lt;p&gt;在 [[ &amp;hellip; ]] 结构中会进行模式匹配。&lt;/p&gt;

&lt;h3 id=&#34;小于-按照-ascii码-排序&#34;&gt;&amp;lt; 小于，按照 ASCII码 排序。&lt;/h3&gt;

&lt;p&gt;if [[ &amp;ldquo;$a&amp;rdquo; &amp;lt; &amp;ldquo;$b&amp;rdquo; ]]
if [ &amp;ldquo;$a&amp;rdquo; &amp;lt; &amp;ldquo;$b&amp;rdquo; ]&lt;/p&gt;

&lt;p&gt;注意在 [] 结构里 &amp;lt; 需要被 转义。&lt;/p&gt;

&lt;h3 id=&#34;大于-按照-ascii-码排序&#34;&gt;&amp;gt; 大于，按照 ASCII 码排序。&lt;/h3&gt;

&lt;p&gt;if [[ &amp;ldquo;$a&amp;rdquo; &amp;gt; &amp;ldquo;$b&amp;rdquo; ]]
if [ &amp;ldquo;$a&amp;rdquo; &amp;gt; &amp;ldquo;$b&amp;rdquo; ]&lt;/p&gt;

&lt;p&gt;注意在 [] 结构里 &amp;gt; 需要被转义。&lt;/p&gt;

&lt;h3 id=&#34;z-字符串为空-即字符串长度为0&#34;&gt;-z 字符串为空，即字符串长度为0。&lt;/h3&gt;

&lt;p&gt;String=&amp;rdquo;   # 长度为0的字符串变量。&lt;/p&gt;

&lt;p&gt;if [ -z &amp;ldquo;$String&amp;rdquo; ]
then
  echo &amp;ldquo;\$String is null.&amp;rdquo;
else
  echo &amp;ldquo;\$String is NOT null.&amp;rdquo;
fi     # $String is null.&lt;/p&gt;

&lt;h3 id=&#34;n-字符串非空-null-使用-n-时字符串必须是在括号中且被引用的&#34;&gt;-n 字符串非空（null）使用 -n 时字符串必须是在括号中且被引用的。&lt;/h3&gt;

&lt;p&gt;使用 ! -z 判断未引用的字符串或者直接判断（样例 7-6）通常可行，但是非常危险。判断字符串时一定要引用1。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>shell特殊字符</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/2017-11-07-shell%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/shell/2017-11-07-shell%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</guid>
            <description>&lt;p&gt;Shell特殊字符&lt;/p&gt;

&lt;p&gt;下面来看看Shell特殊字符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;双引号&amp;quot;：用来使Shell无法认出除字符$、`、\之外的任何字符或字符串，也称之为弱引用。

单引号&#39;：用来使Shell无法认出所有的特殊字符，也称之为强引用。

反引号`：优先执行当前命令。

反斜杠\：有两种作用，一种是用来使Shell无法认出其后的字符，使其后的字符失去特殊的含义，如有特殊含义的字符$，也称为转义符。
另外，如果放在指令前，有取消别名的作用，例如在“\rm/home/yhc/*.log”中，rm指令前加上\，作用是暂时取消别名的功能，将rm指令还原。

分号； ：允许在一行上放多个命令。

&amp;amp;     ：将命令放于后台执行，建议带上nohup。

括号() ：创建成组的命令。  新开shell子进程

大括号{}：创建命令块。

&amp;lt;&amp;gt;&amp;amp;    ：重定向。

*? [] !：表示模式匹配。

$      ：变量名的开头。

#      ：表示注释（第一行除外）。

空格、制表符、换行符：当作空白。
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hugo Shortcode</title>
            <link>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_shortcode/</link>
            <pubDate>Thu, 05 Oct 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_shortcode/</guid>
            <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Markdown 语法十分简洁，如果想要插入更加复杂的内容就需要直接使用 HTML 代码，比如通过 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 来自定义图片尺寸，通过 &lt;code&gt;&amp;lt;iframes&amp;gt;&lt;/code&gt; 来插入视频。显然这样做，虽然扩展了 Markdown 文档的表达能力，但却牺牲了 Markdown 语法的简洁性，而且插入的 HTML 代码不利于后续对文档的维护和更新。&lt;/p&gt;

&lt;p&gt;问题的关键在于，Markdown 的简洁性本身就意味着它难以用来书写复杂的内容，尤其是涉及到展示效果的内容。Hugo 提供了 shortcode 来解决这一问题，既使内容保持了 Markdown 的简洁性，又允许创作者在文档中嵌入一些 Markdown 不支持的形式复杂的内容。&lt;/p&gt;

&lt;p&gt;简单来说，shortcode 是一些可以直接插入内容文档中的助记符，在 Hugo 生成网站时，会将这些助记符替换为相应的 HTML 代码片段（严格来说是模板片段）。这样的好处在于，在创作内容时，只要了解这些助记符的用法而不必关心它们是如何实现和转换的。另一方面来看，更新助记符对应的 HTML 片段时，内容文档不会受到影响。接下来将分别介绍：如何在内容文档中使用 shortcode ，Hugo 内置了哪些 shortcode 以及如何自定义 shortcode ？&lt;/p&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;p&gt;Shortcode 语法有些类似 HTML 标记，一个完整的 shortcode 包含以下几个部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{% shorcodename parameters %}}some content for shortcode template{{% /shortcodename %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;{{% shorcodename parameters %}}&lt;/code&gt; 表示开标记，相应的 &lt;code&gt;{{% /shortcodename %}}&lt;/code&gt; 表示闭标记，闭标记是可选的，同样在开闭标记之间的内容也是可选的。&lt;/p&gt;

&lt;p&gt;开标记中的参数，最终会被传入 shortcode 模板文件中，影响模板的渲染。参数允许以位置参数或命名参数的形式输入（但不能同时传递这两种参数），参数之间用空格间隔，如果参数本身含有空格则需要为其添加双引号。命名参数的格式为 &lt;code&gt;name=&amp;quot;value&amp;quot;&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;除了使用上面的 &lt;code&gt;%&lt;/code&gt; 外，还可以使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 来作为 shortcode 的定界符，比如 &lt;code&gt;{{&amp;lt; gist spf13 7896402 &amp;gt;}}&lt;/code&gt; 。后者跟前者的唯一区别在于，包含在开闭标记之间的内容将不会被 Markdown 引擎处理。&lt;/p&gt;

&lt;p&gt;另外，本文中的许多 shortcode 只是用于显示，并不想要被 Hugo 处理，此时需要在 &lt;code&gt;%&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 定界符内侧添加 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;内置-shortcode&#34;&gt;内置 Shortcode&lt;/h2&gt;

&lt;p&gt;Hugo 预先定义了一些较为常用的 shortcode ，下面介绍如何使用以及在什么情形下使用它们，更详细的用法参见&lt;a href=&#34;https://gohugo.io/content-management/shortcodes/&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;高亮&#34;&gt;高亮&lt;/h3&gt;

&lt;p&gt;用来高亮文档中的代码片段，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; highlight python &amp;gt;}}
def pt(txt):
    print(txt)
{{&amp;lt; /highlight &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;图片&#34;&gt;图片&lt;/h3&gt;

&lt;p&gt;用来扩展 Markdown 中插入图片的语法，该 shortcode 插入的图片支持自定义 CSS 类、添加链接和 caption 等，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; figure src=&amp;quot;/media/spf13.jpg&amp;quot; title=&amp;quot;Steve Francia&amp;quot; link=&amp;quot;&amp;quot; caption=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot; attr=&amp;quot;&amp;quot; attrlink=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档引用&#34;&gt;文档引用&lt;/h3&gt;

&lt;p&gt;根据文档在本地文件系统中的路径，来插入文档的超链接，甚至可以引用文档标题位置，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Neat]({{&amp;lt; ref &amp;quot;blog/neat.md&amp;quot; &amp;gt;}})
[Who]({{&amp;lt; relref &amp;quot;about.md#who&amp;quot; &amp;gt;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数为被引用文档的路径，Hugo 会自动将其替换为被引用文档的永久链接（permalink），&lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;relref&lt;/code&gt; 的不同之处在于，后者给出相对链接，而前者给出完整链接。以上样例的生成结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;/blog/neat&amp;quot;&amp;gt;Neat&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;/about/#who:c28654c202e73453784cfd2c5ab356c0&amp;quot;&amp;gt;Who&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;github-代码片段&#34;&gt;GitHub 代码片段&lt;/h3&gt;

&lt;p&gt;用来在文档中插入 GitHub 上创建的代码片段，假设代码片段链接为：&lt;a href=&#34;https://gist.github.com/username/id&#34;&gt;https://gist.github.com/username/id&lt;/a&gt; ，则插入语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; gist username id &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;twitter-推文&#34;&gt;Twitter 推文&lt;/h3&gt;

&lt;p&gt;用来在内容中插入一条 tweet ，推文的链接是这样的： &lt;a href=&#34;https://twitter.com/spf13/status/666616452582129664&#34;&gt;https://twitter.com/spf13/status/666616452582129664&lt;/a&gt; ，插入这条推文的 shortcode 如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; tweet 666616452582129664 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;youtube-视频&#34;&gt;YouTube 视频&lt;/h3&gt;

&lt;p&gt;用来在内容中插入 YouTube 视频，YouTube 视频资源链接是这样的： &lt;a href=&#34;https://www.youtube.com/watch?v=w7Ft2ymGmfc&#34;&gt;https://www.youtube.com/watch?v=w7Ft2ymGmfc&lt;/a&gt; ，插入该视频的 shortcode 如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; youtube w7Ft2ymGmfc &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者开启自动播放&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; youtube id=&amp;quot;w7Ft2ymGmfc&amp;quot; autoplay=&amp;quot;true&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vimeo-视频&#34;&gt;Vimeo 视频&lt;/h3&gt;

&lt;p&gt;同插入 YouTube 视频类似，假设资源链接为：&lt;a href=&#34;https://vimeo.com/channels/staffpicks/146022717&#34;&gt;https://vimeo.com/channels/staffpicks/146022717&lt;/a&gt; ，则插入语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; vimeo 146022717 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;speaker-deck-演示文稿&#34;&gt;Speaker Deck 演示文稿&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/&#34;&gt;Speaker Deck&lt;/a&gt; 是一个允许我们共享演示文稿的地方，我们可以将共享在其上的演示文稿插入到内容文档中，在 Speaker Deck 上点击分享后会生成一段 HTML 代码，假设其中的 &lt;code&gt;data-id=&amp;quot;123456&amp;quot;&lt;/code&gt; ，那么在文档中可以使用如下语法插入该演示文稿&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; speakerdeck 123456 &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;instagram-图片&#34;&gt;Instagram 图片&lt;/h3&gt;

&lt;p&gt;插入 Instagram 上的图片，假设某张图片链接为：&lt;a href=&#34;https://www.instagram.com/p/BMokmydjG-M/&#34;&gt;https://www.instagram.com/p/BMokmydjG-M/&lt;/a&gt; ，则插入该图片的语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; instagram BMokmydjG-M &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; instagram BMokmydjG-M hidecaption &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义-shortcode&#34;&gt;自定义 Shortcode&lt;/h2&gt;

&lt;h3 id=&#34;模板文件位置&#34;&gt;模板文件位置&lt;/h3&gt;

&lt;p&gt;shortcode 的工作机制就是将助记符关联的 HTML 模板片段渲染后插入到文档中。Hugo 支持自定义 shortcode ，需要做的十分简单，只要在模板目录 &lt;code&gt;layouts/shortcodes/&lt;/code&gt; 中创建模板文件即可，模板文件名即为 shortcode 的名称（除去文件名中的扩展名）。&lt;/p&gt;

&lt;p&gt;同时 Hugo 还支持检索主题资源中的 shortcode，因此 shortcode 的查找顺序如下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;/layouts/shortcodes/&amp;lt;SHORTCODE&amp;gt;.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/themes/&amp;lt;THEME&amp;gt;/layouts/shortcodes/&amp;lt;SHORTCODE&amp;gt;.html&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;模板文件内容&#34;&gt;模板文件内容&lt;/h3&gt;

&lt;p&gt;shortcode 的模板文件就是普通的 Hugo 模板文件。只不过在 shortcode 模板文件内，可以通过模板变量来访问传入 shortcode 的参数和开闭标记之间的内容。以及其它常规模板变量都可以在 shortcode 模板中访问。&lt;/p&gt;

&lt;h4 id=&#34;访问参数&#34;&gt;访问参数&lt;/h4&gt;

&lt;p&gt;虽然在使用 shortcode 时只可以传入位置和命名参数中的一种，但是在设计 shortcode 模板时却可以考虑接受这两种参数（当然不可能同时接受），为此可以通过模板变量 &lt;code&gt;.IsNamedParams&lt;/code&gt; 来判断，当前参数传入是位置的，还是命名的。&lt;/p&gt;

&lt;p&gt;在模板文件中，位置参数和命名参数都可以通过模板方法 &lt;code&gt;.Get&lt;/code&gt; 来访问：&lt;code&gt;{{ .Get 0 }}&lt;/code&gt; 和 &lt;code&gt;{{ .Get &amp;quot;name&amp;quot; }}&lt;/code&gt; 。或者使用 &lt;code&gt;with&lt;/code&gt; 语法来访问 &lt;code&gt;{{ with .Get &amp;quot;class&amp;quot;}}class=&amp;quot;{{.}}&amp;quot;{{ end }}&lt;/code&gt; 。此外还可以通过模板变量 &lt;code&gt;.Params&lt;/code&gt; 来访问参数。&lt;/p&gt;

&lt;h4 id=&#34;访问内容&#34;&gt;访问内容&lt;/h4&gt;

&lt;p&gt;使用 shortcode 时，位于开闭标记之间的内容，在模板文件中可以通过模板变量 &lt;code&gt;.Inner&lt;/code&gt; 来访问。&lt;/p&gt;

&lt;h4 id=&#34;访问父模板&#34;&gt;访问父模板&lt;/h4&gt;

&lt;p&gt;此外 shortcode 还支持嵌套，比如在内容文档中像下面这样插入 shortcode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; parentshortcode &amp;gt;}}
{{&amp;lt; childshortcode &amp;gt;}}
{{&amp;lt; /parentshortcode &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板文件 &lt;code&gt;layouts/shortcodes/childshortcode.html&lt;/code&gt; 中可以通过模板变量 &lt;code&gt;.Parent&lt;/code&gt; 来访问 &lt;code&gt;parendshortcode.html&lt;/code&gt; 的模板环境。&lt;/p&gt;

&lt;p&gt;总之 shortcode 模板文件跟普通的模板文件没有差别，基本就是 HTML 代码跟模板变量的混合体，不过 shortcode 模板除了可以访问常规模板变量外，还可以额外访问几个变量和方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Get 0 }}                    获取位置参数
{{ .Get &amp;quot;name&amp;quot; }}               获取命名参数
{{ with .Get &amp;quot;class&amp;quot;}} &amp;lt;p class=&amp;quot;{{.}}&amp;quot;&amp;gt; haha! &amp;lt;/p&amp;gt;{{ end }}
.Inner                          位于 shortcode 开闭之间的内容
.Params                         输入的参数列表
.IsNamedParams                  判断 shortcode 输入的是位置参数还是命名参数
.Parent                         shortcode 支持继承，该变量表示父 shortcode
.Page                           所有的页面变量在 shortcode 都可用
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;模板样例&#34;&gt;模板样例&lt;/h3&gt;

&lt;p&gt;年份，模板位置 &lt;code&gt;/layouts/shortcodes/year.html&lt;/code&gt; ，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Page.Now.Year }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;高亮，模板位置 &lt;code&gt;/layouts/shortcodes/highlight.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Get 0 | highlight .Inner  }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片，模板位置 &lt;code&gt;/layouts/shortcodes/figure.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;figure {{ with .Get &amp;quot;class&amp;quot; }}class=&amp;quot;{{.}}&amp;quot;{{ end }}&amp;gt;
    {{ with .Get &amp;quot;link&amp;quot;}}&amp;lt;a href=&amp;quot;{{.}}&amp;quot;&amp;gt;{{ end }}
        &amp;lt;img src=&amp;quot;{{ .Get &amp;quot;src&amp;quot; }}&amp;quot; {{ if or (.Get &amp;quot;alt&amp;quot;) (.Get &amp;quot;caption&amp;quot;) }}alt=&amp;quot;{{ with .Get &amp;quot;alt&amp;quot;}}{{.}}{{else}}{{ .Get &amp;quot;caption&amp;quot; }}{{ end }}&amp;quot;{{ end }} /&amp;gt;
    {{ if .Get &amp;quot;link&amp;quot;}}&amp;lt;/a&amp;gt;{{ end }}
    {{ if or (or (.Get &amp;quot;title&amp;quot;) (.Get &amp;quot;caption&amp;quot;)) (.Get &amp;quot;attr&amp;quot;)}}
    &amp;lt;figcaption&amp;gt;{{ if isset .Params &amp;quot;title&amp;quot; }}
        &amp;lt;h4&amp;gt;{{ .Get &amp;quot;title&amp;quot; }}&amp;lt;/h4&amp;gt;{{ end }}
        {{ if or (.Get &amp;quot;caption&amp;quot;) (.Get &amp;quot;attr&amp;quot;)}}&amp;lt;p&amp;gt;
        {{ .Get &amp;quot;caption&amp;quot; }}
        {{ with .Get &amp;quot;attrlink&amp;quot;}}&amp;lt;a href=&amp;quot;{{.}}&amp;quot;&amp;gt; {{ end }}
            {{ .Get &amp;quot;attr&amp;quot; }}
        {{ if .Get &amp;quot;attrlink&amp;quot;}}&amp;lt;/a&amp;gt; {{ end }}
        &amp;lt;/p&amp;gt; {{ end }}
    &amp;lt;/figcaption&amp;gt;
    {{ end }}
&amp;lt;/figure&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;YouTube 视频，模板位置 &lt;code&gt;/layouts/shortcodes/youtube.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;embed video-player&amp;quot;&amp;gt;
&amp;lt;iframe class=&amp;quot;youtube-player&amp;quot; type=&amp;quot;text/html&amp;quot; width=&amp;quot;640&amp;quot; height=&amp;quot;385&amp;quot; src=&amp;quot;http://www.youtube.com/embed/{{ index .Params 0 }}&amp;quot; allowfullscreen frameborder=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 模板template</title>
            <link>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_template/</link>
            <pubDate>Thu, 05 Oct 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_template/</guid>
            <description>

&lt;h3 id=&#34;模板变量&#34;&gt;模板变量&lt;/h3&gt;

&lt;p&gt;如果说模板是待填充的网页，则模板变量是用来填充模板的内容。Hugo 内置了许多可以在模板中访问的变量，这些变量可以分为以下几种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网站变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过网站变量，我们可以访问网站级别的配置和数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .Site.BaseURL 			配置文件中为网站指定的 basse URL
  .Site.RSSLink 			网站的 RSS 链接
  .Site.Taxonomies 		网站所有的分类标签
  .Site.Pages				网站所有页面（仅含当前语言）
  .Site.AllPages			网站所有页面（含多语言）
  .Site.Params			配置文件中通过 params 定义的网站参数
  .Site.Sections			网站所有 Section（也即网站的顶级目录）
  .Site.Title				配置文件中为网站指定的 title
  .Site.Author			配置文件中为网站指定的 author
  .Site.Copyright			配置文件中为网站指定的 copyright
  .Site.LastChange		网站最后更新时间，格式跟内容文档头部 date 保持一致
  .Site.Data				网站自定义数据文件的访问接口
  .Site.RegularPages		网站中所有常规页面
  .Site.Files				网站所有源文件
  .Site.Menus				网站所有菜单
  .Site.LanguageCode		配置文件中为网站指定的 language code
  .Site.DisqusShortname	配置文件中为网站指定的 disqus 评论id
  .Site.GoogleAnalytics   配置文件中为网站指定的 google analytics tracking code
  .Site.Permalinks		配置文件中为网站指定的 permalink format
  .Site.BuildDrafts		配置文件中为网站指定的 build drafts
  .Site.IsMultiLingual	网站是否支持多语言
  .Site.Language			配置文件中指定的 language
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;页面变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过页面变量，我们可以访问内容文档级别的配置和数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .Title					内容文档的标题
  .Content				内容文档的内容
  .Date					内容文档的日期
  .PublishDate			页面发布日期
  .FuzzyWordCount			内容的近似字数
  .WordCount				内容的字数
  .Type					内容文档的内容类型
  .URL					页面的相对 URL
  .UniqueID				内容文档路径的md5值
  .Weidht					内容文档中定义的排序权重
  .Kind					页面类型
  .Params					内容文档头部定义的任意元数据都可以通过 .Params 来访问（不同定义如何命名，均以字母小写的名字访问）
  						补充：网站变量中也有 .Site.Params 来定义网站参数，一般来说页面参数比网站参数更具体，
  						可以使用模板函数 $.Param &amp;quot;header_image&amp;quot; 来访问网站和页面的同名参数
  .IsHome					页面是否为首页
  .IsPage					是否为常规内容页面
  .Next					下一个页面（根据页面发布日期）
  .Prev					上一个页面（根据页面发布日期）
  .NextInSection			当天Section中的下一个页面（根据页面分布日期）
  .PrevInSection			当天Section中的上一个页面（根据页面分布日期）
  .TableOfContents		页面目录
  .Permalink				页面的永久链接
  .RelPermalink			页面永久链接的相对路径
  .RawContent				页面的 Markdown 内容，当想要在网站中集成https://github.com/gnab/remark时，就需要提取页面的 Markdown 内容了
  .ReadingTime			页面大概需要花费的阅读时间
  .Section				页面所在 Section
  .Summary				页面摘要
  .Truncated				摘要是否截断页面
  .Description			描述
  .Keywords				关键词
  .LinkTitle				链接到当前页面时使用的 title
  .ExpiryDate				页面失效日期
  .Draft					页面是否为草稿
  .IsTranslated			页面是否有多语言版本
  .Translations			页面的多语言页面
  .Lang					语言
  .Language				语言对象
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;文件变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当页面的生成来源于内容文档时，可以访问内容文档文件相关信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .File.Path				内容文档的相对路径，比如：content/posts/first.en.md
  .File.Dir				内容文档所在目录
  .File.LogicalName		内容文档文件名，比如：first.en.md
  .File.TranslationBaseName 内容文档根文件名，比如：first
  .File.Ext				内容文档扩展名，比如：md
  .File.Lang				内容文档的语言
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Hugo 变量&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  .Hugo.Generator			Hugo 版本号的 meta tag，例如：&amp;lt;meta name=&amp;quot;generator&amp;quot; content=&amp;quot;Hugo 0.15&amp;quot; /&amp;gt;
  .Hugo.Version			Hugo 二进制程序版本号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模板变量的作用域问题&lt;/p&gt;

&lt;p&gt;单页模板、Section 列表模板以及 Taxonomy 列表模板均可以访问网站变量和页面变量，此外Taxonomy 列表模板可以访问代表其自身的 &lt;code&gt;.Data.Singular&lt;/code&gt; 变量。&lt;/p&gt;

&lt;h3 id=&#34;模板角色&#34;&gt;模板角色&lt;/h3&gt;

&lt;p&gt;模板文件混杂了 HTML 代码和模板标识符，用来设计网页布局的。Hugo 支持 Go 语言的 HTML 模板库来对网站进行布局规划，虽然模板文件本质上没有不同，可 Hugo 结合常用网站布局结构的需要将模板分为了几种角色，下面将依次介绍这些模板角色&lt;/p&gt;

&lt;p&gt;也即页面类型&lt;/p&gt;

&lt;p&gt;page home section taxonomy or taxonomy Term&lt;/p&gt;

&lt;p&gt;rss sitemap robotsTXT 404&lt;/p&gt;

&lt;h4 id=&#34;首页模板&#34;&gt;首页模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用首页模板（homepage template）来渲染网站首页。一般来说网站首页同其它页面具有不一样的风格，因此需要专门为其使用特定的模板进行渲染。Hugo 在生成网站时，通常会依次从下面路径中查找首页模板，将找到的第一个文件作为首页模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- /layouts/index.html
- /layouts/_default/list.html
- /layouts/_default/single.html
- /themes/`THEME`/layouts/index.html
- /themes/`THEME`/layouts/_default/list.html
- /themes/`THEME`/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也即默认首页模板是 &lt;code&gt;index.html&lt;/code&gt; ，当该文件不存在时，依次使用 &lt;code&gt;list.html&lt;/code&gt; 和 &lt;code&gt;single.html&lt;/code&gt; 来充当首页模板。另外首页模板中可以通过模板变量 &lt;code&gt;.Data.Pages&lt;/code&gt; 来访问网站中所有内容文档，通常我们会遍历该变量在首页创建一个文档展示列表，不过Hugo 不会对模板的创建有任何限制，如何定义首页模板完全取决于自己。&lt;/p&gt;

&lt;h4 id=&#34;单页模板&#34;&gt;单页模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用单页模板（single template）来渲染内容文档。换句话说，内容文档的内容将嵌入单页模板设计好的网页结构中，以此生成网页。那么当生成静态网站时，Hugo 会使用哪个单页模板来渲染内容文档呢？Hugo 会依次从下面路径列表中查找可用的单页模板，将找到的第一个单页模板文件作为当前内容文档的渲染模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- /layouts/`TYPE`/`LAYOUT`.html
- /layouts/`SECTION`/`LAYOUT`.html
- /layouts/`TYPE`/single.html
- /layouts/`SECTION`/single.html
- /layouts/_default/single.html
- /themes/`THEME`/layouts/`TYPE`/`LAYOUT`.html
- /themes/`THEME`/layouts/`SECTION`/`LAYOUT`.html
- /themes/`THEME`/layouts/`TYPE`/single.html
- /themes/`THEME`/layouts/`SECTION`/single.html
- /themes/`THEME`/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;TYPE&lt;/code&gt; 表示内容文档的类型名称，&lt;code&gt;SECTION&lt;/code&gt; 表示内容文档的 Section ，&lt;code&gt;THEME&lt;/code&gt; 表示主题名称，&lt;code&gt;LAYOUT&lt;/code&gt; 表示内容文档指定的模板名。&lt;code&gt;TYPE&lt;/code&gt; 和 &lt;code&gt;LAYOUT&lt;/code&gt; 可分别通过内容文档头部的 &lt;code&gt;type&lt;/code&gt; （默认跟所在 Section 同名）和 &lt;code&gt;layout&lt;/code&gt; （默认为单页模板）进行设置 ，&lt;code&gt;SECTION&lt;/code&gt; 则由内容文档磁盘路径对应的 Section 决定。&lt;/p&gt;

&lt;p&gt;可以看出 Hugo 默认会先从 &lt;code&gt;TYPE&lt;/code&gt; 和 &lt;code&gt;SECTION&lt;/code&gt; 这些模板目录中查找文档指定的布局 &lt;code&gt;LAYOUT&lt;/code&gt; ，再查找相应的单页模板，然后再从网站源默认的布局目录 &lt;code&gt;_default&lt;/code&gt; 中查找单页模板，最后会查找当前主题的相关布局目录，可见 Hugo 奉行的准则是：先精确查找，再回退默认。&lt;/p&gt;

&lt;p&gt;在单页模板中可以访问网站变量和页面变量以及模板函数，通常我们会将内容文档的内容嵌入到单页模板中，有时也许还想为模板创建一个侧变量用来显示相关信息等，怎样定义单页模板完全取决于自己。&lt;/p&gt;

&lt;p&gt;一般情况下，当我们为网站添加过主题之后，主题都会有单页模板的，如果想要覆盖主题中定义的单页模板，可以在网站源的模板目录下面创建相应的单页模板，或者直接创建单页模板 &lt;code&gt;layouts/_default/single.html&lt;/code&gt; 作为内容文档未找到单页模板时的默认模板。&lt;/p&gt;

&lt;h4 id=&#34;内容视图&#34;&gt;内容视图&lt;/h4&gt;

&lt;p&gt;Hugo 使用内容视图（content views）来以不同于单页模板的方式展示内容文档。比如有时，我们只想要展示文档摘要或者文档列表项而非整个文档，内容视图在此时就特别有用了。&lt;/p&gt;

&lt;p&gt;内容视图也是普通的模板文件，Hugo 查找内容视图时会根据当前文档的内容类型进行查找，也就是说同名的内容视图对不同内容类型渲染效果是不同的。Hugo 会依次从以下路径列表中查找可用的内容视图，将找到的第一个模板文件来作为渲染模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- /layouts/`TYPE`/`VIEW`.html
- /layouts/_default/`VIEW`.html
- /themes/`THEME`/layouts/`TYPE`/`VIEW`.html
- /themes/`THEME`/layouts/_default/`view`.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定我们要为内容类型 &lt;code&gt;post&lt;/code&gt; 和 &lt;code&gt;project&lt;/code&gt; 分别创建内容视图 &lt;code&gt;li.html&lt;/code&gt;  ，则对应的模板文件路径为：&lt;code&gt;/layouts/post/li.html&lt;/code&gt; 和 &lt;code&gt;/layouts/project/li.html&lt;/code&gt; 。如果我们在网站首页使用如下代码罗列所有文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ range .Data.Pages }}
{{ .Render &amp;quot;li&amp;quot;}}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;{{ .Render &amp;quot;li&amp;quot; }}&lt;/code&gt; 表示引用当前内容文档对应内容视图 &lt;code&gt;li.html&lt;/code&gt; （&lt;code&gt;post&lt;/code&gt; 和 &lt;code&gt;project&lt;/code&gt; 使用各自的内容视图文件），在内容视图 &lt;code&gt;li.html&lt;/code&gt; 中可以访问任何页面变量，下面是 &lt;code&gt;li.html&lt;/code&gt; 示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;li&amp;gt;
&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;
&amp;lt;div class=&amp;quot;meta&amp;quot;&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/div&amp;gt;
&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;列表模板&#34;&gt;列表模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用列表模板（list template）渲染多个被罗列的内容文档，比如：分类标签页面和 Section 页面通常需要罗列逻辑上从属于该类别的所有文档。值得注意的是，不同于单页文档总是被内容文档填充，列表模板一般却不会被内容文档填充（下文会介绍什么情况下列表模板也会填充内容文档）。&lt;/p&gt;

&lt;p&gt;Hugo 中列表模板常见的应用场景有：Section 列表页、Taxonomy 列表页、Section RSS 以及 Taxonomy RSS等（注：网站首页虽然也是列表页，可因其特殊性，需要使用特定的模板渲染）。这些页面渲染后的 URL 路径分别如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Section 列表页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/SECTION/&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/post/&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Taxonomy 列表页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/PLURAL/TERM/&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/tags/python/&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Section RSS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/SECTION/index.html&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/post/index.html&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Taxonomy RSS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/PLURAL/TERM/index.html&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/tags/python/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此外，Hugo 会依次从路径列表中查找可用的列表模板，将找到的第一个列表模板文件来作为渲染模板。以上介绍的常见列表页面的查找路径如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Section 列表
  - /layouts/section/`SECTION`.html
  - /layouts/_default/section.html
  - /layouts/_default/list.html
  - /themes/`THEME`/layouts/section/`SECTION`.html
  - /themes/`THEME`/layouts/_default/section.html
  - /themes/`THEME`/layouts/_default/list.html
- Taxonomy 列表
  - /layouts/taxonomy/`SINGULAR`.html
  - /layouts/_default/taxonomy.html
  - /layouts/_default/list.html
  - /themes/`THEME`/layouts/taxonomy/`SINGULAR`.html
  - /themes/`THEME`/layouts/_default/taxonomy.html
  - /themes/`THEME`/layouts/_default/list.html
- Section RSS
  - /layouts/section/`SECTION`.rss.xml
  - /layouts/_default/rss.xml
  - /themes/`THEME`/layouts/section/`SECTION`.rss.xml
  - /themes/`THEME`/layouts/_default/rss.xml
- Taxonomy RSS
  - /layouts/taxonomy/`SINGULAR`.rss.xml
  - /layouts/_default/rss.xml
  - /themes/`THEME`/layouts/taxonomy/`SINGULAR`.rss.xml
  - /themes/`THEME`/layouts/_default/rss.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面模板的查找路径可以看出，Hugo 首先会查找为特定 &lt;code&gt;SECTION&lt;/code&gt; 和 &lt;code&gt;TAXONOMY&lt;/code&gt; 定义的模板文件，如果查找失败，会再查找 Section 和 Taxonomy 通用的模板文件，如果还是找不到就使用 &lt;code&gt;layouts/_defaults/list.html&lt;/code&gt; 和 &lt;code&gt;layouts/_defaults/rss.xml&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;既然知道了列表模板的用途，也知道了模板文件的查找路径，那么列表模板文件中该写些什么呢？列表文件也是一个普通的模板文件，在模板中可以使用任何 Go 内置模板函数，还可以访问网站模板变量和页面模板变量（用于 Taxonomy 的模板还可以访问代表当前分类的变量 &lt;code&gt;.Data.Singular&lt;/code&gt; ）。根据列表模板的用途一般来说会在模板中为内容文档创建一个展示列表，此外也许希望对这个内容文档分类或者剔除某些文档，利用简洁而强大的 Go 模板方法可以自定义任何复杂的列表页面。下面是一个用于 Section 的列表模板示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}
{{ partial &amp;quot;subheader.html&amp;quot; . }}

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
   &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
        &amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
            {{ range .Data.Pages }}
                {{ .Render &amp;quot;li&amp;quot;}}
            {{ end }}
        &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

{{ partial &amp;quot;footer.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分类模板&#34;&gt;分类模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用分类模板（taxonomy terms template）来渲染当前分类下的所有标签。&lt;/p&gt;

&lt;p&gt;要注意同Taxonomy 列表页相区分，Taxonomy 列表页用来罗列属于某个标签下所有的内容文档，优先查找模&lt;code&gt;/layouts/taxonomy/SINGULAR.html&lt;/code&gt; 作为该标签列表页的模板，且将页面渲染于 &lt;code&gt;baseURL/PLURAL/TERM/&lt;/code&gt; 。而分类模板页面是用来罗列当前分类下所有标签的，优先查找 &lt;code&gt;/layouts/taxonomy/SINGULAR.terms.html&lt;/code&gt; 作为页面模板，且渲染于 &lt;code&gt;baseURL/PLURAL/&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;Hugo 会依次从路径列表中查找可用的模板，将找到的第一个模板文件来作为渲染模板&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/layouts/taxonomy/&lt;code&gt;SINGULAR&lt;/code&gt;.terms.html&lt;/li&gt;
&lt;li&gt;/layouts/_default/terms.html&lt;/li&gt;
&lt;li&gt;/themes/&lt;code&gt;THEME&lt;/code&gt;/layouts/taxonomy/&lt;code&gt;SINGULAR&lt;/code&gt;.terms.html&lt;/li&gt;
&lt;li&gt;/themes/&lt;code&gt;THEME&lt;/code&gt;/layouts/_default/terms.html&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果以上模板都不存在，Hugo 就不会渲染分类标签页面。换句话说，分类标签页面的渲染也不一定必须单独使用一个模板文件，我们可以在页面侧边栏之类的地方来渲染分类标签（比如：侧边栏实现一个标签云）。&lt;/p&gt;

&lt;p&gt;分类模板中除了可以访问网站变量和页面变量外，还有一些关于分类标签的变量可供我们使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Data.Singular						分类的单数名称，比如：tag
.Data.Plural						分类的复数名称，比如：tags
.Data.Pages							属于当前分类的所有页面
.Data.Terms							属于当前分类的所有标签
.Data.Terms.Alphabetical			属于当前分类的所有标签（字母序）
.Data.Terms.ByCount					属于当前分类的所有标签（根据标签下文档数量排序）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个示例分类模板，该模板罗列出了当前分类下的所有标签，并给出了标签下所有文档的链接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}
{{ partial &amp;quot;subheader.html&amp;quot; . }}

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;

    {{ $data := .Data }}
    {{ range $key,$value := .Data.Terms.ByCount }}
    &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;quot;{{ .Site.LanguagePrefix }}/{{ $data.Plural }}/{{ $value.Name | urlize }}&amp;quot;&amp;gt;{{ $value.Name }}&amp;lt;/a&amp;gt; {{ $value.Count }}&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
    {{ range $value.Pages.ByDate }}
      &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    {{ end }}
    &amp;lt;/ul&amp;gt;
    {{ end }}
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

{{ partial &amp;quot;footer.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;片段模板&#34;&gt;片段模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用片段模板（partial template）作为其它模板文件的原材料，比如首页模板、单页模板、列表模板等这些模板通常会使用片段模板来创建。这里之所以将片段模板比作原材料，是因为片段模板通常包含了其它模板中的公共部分，反过来说，我们应该将多个模板中的公共内容分离出来创建片段模板文件，然后可以在其它模板中引用该片段文件。使用片段模板的好处在于，不需要重复定义相同的模板内容，而且片段模板十分有利于主题资源的开发，主题中应该将那些想要让用户覆盖的模板内容单独作为一个片段模板，这样主题的使用者只需要定义相同的片段模板就可以对主题片段模板进行替换，片段模板文件是比普通模板文件更加细粒度的模板内容容器。&lt;/p&gt;

&lt;p&gt;如何创建片段模板呢？Hugo 默认将模板目录 &lt;code&gt;/layouts/partials/&lt;/code&gt; 及其子目录中的模板文件看作片段模板，片段模板的内容如同普通模板一样可以访问各种模板变量和模板函数，不过片段模板可以访问到的模板变量取决于引用该模板时传入了怎样的变量进来（后面会有讲，如何引用片段模板以及如何传递变量到片段模板）。在网站中最为常见的片段模板也许就是网页头和网页脚，因为网页头和网页脚在网站大多数页面中都是相同的，将其分离于片段模板中是明智的选择，假设我们创建了 &lt;code&gt;/layouts/partials/header.html&lt;/code&gt; 和 &lt;code&gt;/layouts/partials/footer.html&lt;/code&gt; 片段模板文件，它们的内容分别为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html class=&amp;quot;no-js&amp;quot; lang=&amp;quot;en-US&amp;quot; prefix=&amp;quot;og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;

    {{ partial &amp;quot;meta.html&amp;quot; . }}

    &amp;lt;base href=&amp;quot;{{ .Site.BaseURL }}&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt; {{ .Title }} : spf13.com &amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;canonical&amp;quot; href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;
    {{ if .RSSLink }}&amp;lt;link href=&amp;quot;{{ .RSSLink }}&amp;quot; rel=&amp;quot;alternate&amp;quot; type=&amp;quot;application/rss+xml&amp;quot; title=&amp;quot;{{ .Title }}&amp;quot; /&amp;gt;{{ end }}

    {{ partial &amp;quot;head_includes.html&amp;quot; . }}
&amp;lt;/head&amp;gt;
&amp;lt;body lang=&amp;quot;en&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;footer&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;
    &amp;amp;copy; 2013-14 Steve Francia.
    &amp;lt;a href=&amp;quot;http://creativecommons.org/licenses/by/3.0/&amp;quot; title=&amp;quot;Creative Commons Attribution&amp;quot;&amp;gt;Some rights reserved&amp;lt;/a&amp;gt;;
    please attribute properly and link back. Hosted by &amp;lt;a href=&amp;quot;http://servergrove.com&amp;quot;&amp;gt;ServerGrove&amp;lt;/a&amp;gt;.
    &amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/footer&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;

  var _gaq = _gaq || [];
  _gaq.push([&#39;_setAccount&#39;, &#39;UA-XYSYXYSY-X&#39;]);
  _gaq.push([&#39;_trackPageview&#39;]);

  (function() {
    var ga = document.createElement(&#39;script&#39;);
    ga.src = (&#39;https:&#39; == document.location.protocol ? &#39;https://ssl&#39; :
        &#39;http://www&#39;) + &#39;.google-analytics.com/ga.js&#39;;
    ga.setAttribute(&#39;async&#39;, &#39;true&#39;);
    document.documentElement.firstChild.appendChild(ga);
  })();

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上模板内容除了常规的 HTML 代码外，还出现了像 &lt;code&gt;{{ partial &amp;quot;meta.html&amp;quot; . }}&lt;/code&gt; 这样的模板语句，这条语句在这里的作用是引用片段模板 &lt;code&gt;meta.html&lt;/code&gt; 到当前模板文件中（即 &lt;code&gt;header.html&lt;/code&gt; 片段模板文件），就是说 Hugo 允许我们在片段模板中再次引用片段模板。&lt;/p&gt;

&lt;p&gt;下面让我们研究一下，如何引用一个片段模板文件，引用片段模板的语法为：&lt;code&gt;{{ partial &amp;quot;path/to/file.html&amp;quot; variables }}&lt;/code&gt; ，其中 &lt;code&gt;path/to/file.html&lt;/code&gt; 表示被引用的片段模板文件相对于 &lt;code&gt;/layouts/partials/&lt;/code&gt; 目录的路径，比如想要引用 &lt;code&gt;/layouts/partials/post/sidebar.html&lt;/code&gt; ，则对应的引用路径为 &lt;code&gt;post/sidebar.html&lt;/code&gt; 。其中 &lt;code&gt;variables&lt;/code&gt; 表示要传入片段模板的变量（片段模板除了这些传入的变量，是无法访问其它变量的），通常我们会将代表当前模板内所有变量的 &lt;code&gt;.&lt;/code&gt; 作为 &lt;code&gt;variables&lt;/code&gt; 传入片段模板中。&lt;/p&gt;

&lt;p&gt;有没有想过，很多模板引用相同的片段模板文件，在生成网页时，这些片段模板是不是在每个引用模板中都要重新渲染一次呢？有没有办法减少片段模板的渲染次数，毕竟片段模板生成的网页片段除了根据传入变量不同会有改变外，基本的网页结构是相似的。如果想要让 Hugo 提升片段模板的渲染效率（Hugo 会自动缓存已经渲染好的片段模板供后续使用），可以在引用模板文件时用 &lt;code&gt;partialCached&lt;/code&gt; 来代替 &lt;code&gt;partial&lt;/code&gt; ，并且 Hugo 还支持用户按照类别缓存片段模板，比如： &lt;code&gt;{{ partialCached &amp;quot;footer.html&amp;quot; . .Section }}&lt;/code&gt; 的意思是，为每个 Section 渲染一次 &lt;code&gt;footer.html&lt;/code&gt; 模板。&lt;/p&gt;

&lt;h3 id=&#34;模板调试&#34;&gt;模板调试&lt;/h3&gt;

&lt;p&gt;模板编写中错误在所难免，可以使用模板函数 &lt;code&gt;printf&lt;/code&gt; 调试模板变量，下面是几个常见调试样例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ printf &amp;quot;%#v&amp;quot; . }}
{{ printf &amp;quot;%#v&amp;quot; $.Site }}
{{ printf &amp;quot;%#v&amp;quot; .Permalink }}
{{ range .Data.Pages }}
    {{/* The context, &amp;quot;.&amp;quot;, is now a Page */}}
    {{ printf &amp;quot;%#v&amp;quot; . }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 中的 Markdown 语法</title>
            <link>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_markdown/</link>
            <pubDate>Wed, 06 Sep 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_markdown/</guid>
            <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Hugo 中用于书写的标记语言主要是 Markdown。Markdown 作为一门标记语言，其核心&lt;a href=&#34;https://daringfireball.net/projects/markdown/&#34; title=&#34;Markdown Syntax&#34;&gt;语法&lt;/a&gt;十分精炼易用，有许多优秀的 Markdown 解释器可以将 Markdown 文档转换为 HTML 等便于阅览的文档。Markdown 的巨大优势在于，将内容创作和内容展示剥离开来，给予内容创作者极大的自由。&lt;/p&gt;

&lt;p&gt;不过 Markdown 的核心语法十分精炼，甚至某些功能是不被支持，比如任务列表。为此开发者们，开发出众多解释器来扩展 Markdown 核心语法。Hugo 支持两个 Markdown 扩展语法（解释器）：&lt;a href=&#34;https://github.com/russross/blackfriday&#34; title=&#34;Blackfriday Markdown&#34;&gt;Blackfriday&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/miekg/mmark&#34; title=&#34;Mmark Markdown&#34;&gt;Mmark&lt;/a&gt;。可以将 Blackfriday 看成是对基本 Markdown 语法的简单扩展，Mmark 是 Markdown 语法的超集。Hugo 通过文档后缀名或者文档头 Front Matter &lt;code&gt;markup&lt;/code&gt; 来识别这两类 Markdown 文档。Blackfriday Markdown 文档后缀名为 &lt;code&gt;.md&lt;/code&gt; 或者 &lt;code&gt;markup=&amp;quot;markdown&amp;quot;&lt;/code&gt; ，Mmark Markdown 文档后缀名为 &lt;code&gt;.mmark&lt;/code&gt; 或者 &lt;code&gt;markup=&amp;quot;mmark&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;配置-markdown-解释器&#34;&gt;配置 Markdown 解释器&lt;/h2&gt;

&lt;p&gt;Hugo 允许我们配置解释器，来扩展 Markdown 语法，改变解释器的工作过程。由于 Mmark 是 Markdown 语法的超集，语言本身就支持许多特色功能，是无需通过配置来扩展的，因此这里所说的配置是针对 Blackfriday 解释器而言的。更多关于 Mmark 语法参见&lt;a href=&#34;https://miek.nl/2016/March/05/mmark-syntax-document/&#34; title=&#34;Mmark Syntax&#34;&gt;此处&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;如何配置&#34;&gt;如何配置&lt;/h3&gt;

&lt;p&gt;既可以对解释器进行全局配置，也可以针对一个文档进行配置。全局配置是通过在网站配置文件中添加 &lt;code&gt;blackfriday&lt;/code&gt; 配置项来实现的，而针对文档的配置是通过文档头 Front Matter 中添加 &lt;code&gt;blackfriday&lt;/code&gt; 配置项来实现的，且后者配置的优先级高于前者。&lt;/p&gt;

&lt;p&gt;配置项 &lt;code&gt;blackfriday&lt;/code&gt;  又由许多配置子项组成的，因此 &lt;code&gt;blackfriday&lt;/code&gt; 的配置内容会被写为一个分组，下面分别用 TOML 和 YAML 语法来做样例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[blackfriday]
  angledQuotes = true
  fractions = false
  plainIDAnchors = true
  extensions = [&amp;quot;hardLineBreak&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;blackfriday:
  angledQuotes: true
  fractions: false
  plainIDAnchors: true
  extensions:
    - hardLineBreak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论是全局配置还是针对文档的配置，只要添加以上配置内容就可以改变 Markdown 解释器的行为。&lt;/p&gt;

&lt;h3 id=&#34;常用配置项&#34;&gt;常用配置项&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;taskLists&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt; 。控制是否支持 Github 风格的任务列表语法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smartypants&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt;。控制是否开启标点符号（双引号、分子符号、连字符）的转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;angledQuotes&lt;/code&gt;，默认为 &lt;code&gt;false&lt;/code&gt;。控制是否将中文双引号 &lt;code&gt;“hugo”&lt;/code&gt; 转换为 &lt;code&gt;«hugo»&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fractions&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt;。控制是否将分子式 &lt;code&gt;5/7&lt;/code&gt; 转换为 HTML 格式 &lt;code&gt;&amp;lt;sup&amp;gt;5&amp;lt;/sup&amp;gt;&amp;amp;frasl;&amp;lt;sub&amp;gt;7&amp;lt;/sub&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smartDashes&lt;/code&gt; 和 &lt;code&gt;latexDashes&lt;/code&gt; 共同控制多个连字符如何转换为 &lt;code&gt;–&lt;/code&gt; 和 &lt;code&gt;—&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hrefTargetBlank&lt;/code&gt;，默认为 &lt;code&gt;false&lt;/code&gt;。控制打开外部链接时是否打开新的浏览器窗口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plainIDAnchors&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt;。不向标题内容添加文档 ID。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extensions&lt;/code&gt;，是列表项。包含于该列表中的 Blackfriday Markdown 扩展语法标识，将开启对应的扩展语法的支持。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extensionsmask&lt;/code&gt;，是列表项。包含于该列表中的 Blackfriday Markdown 扩展语法标识，将关闭对应的扩展语法的支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;扩展语法支持&#34;&gt;扩展语法支持&lt;/h3&gt;

&lt;p&gt;Hugo 的 Blackfriday 解释器扩展了核心的 Markdown 语法，下面将介绍一些常用的扩展语法，更多扩展参见&lt;a href=&#34;https://gohugo.io/getting-started/configuration/#blackfriday-extensions&#34; title=&#34;Blackfriday Markdown Extensions&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;禁止解析单词内的下划线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;noIntraEmphasis&lt;/code&gt;，默认开启该扩展。由于 &lt;code&gt;_&lt;/code&gt; 字符是 Markdown 语法的组成部分，所以如果代码中出现类似 &lt;code&gt;init_priority_list&lt;/code&gt; 这样的内容，将会被误当成 Markdown 语法来解析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开启对表格语法的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;tables&lt;/code&gt;，默认开启该扩展。表格语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;     Name | Age
  --------|------
      Bob | 27
    Alice | 23
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;代码块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;fencedCode&lt;/code&gt;，默认开启该扩展。代码块语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;  ​```markdown
  # h1
  # h2
  ​```
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;自动转换 URL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;autolink&lt;/code&gt;，默认开启该扩展。将内容中那些没有使用 Markdown 语法书写的 URL，转换为 Markdown 格式的 URL。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;删除线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;strikethrough&lt;/code&gt;，默认开启该扩展。删除线使用两个波浪线的语法 &lt;code&gt;~~删除线~~&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;强制换行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;hardLineBreak&lt;/code&gt;，默认关闭该扩展。默认的 Markdown 语法中，没有用空行间隔开的多行内容最终会被转换为一行内容来输出。开启该扩展后，内容中只要有换行，输出中就会换行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tab 空格数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;tabSizeEight&lt;/code&gt;，默认关闭该扩展。开启该扩展后，每个制表符 Tab 将被转换为 8 个空格（默认是 4 个）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脚注&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;footnotes&lt;/code&gt;，默认开启该扩展。支持 Pandoc 风格的脚注语法，样例如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;  文章里有一个脚注[^1]

  定义在文档尾部的脚注内容如下
  [^1]: 这里是脚注的内容
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;标题 ID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;headerIds&lt;/code&gt;，默认开启该扩展。允许通过 &lt;code&gt;{#id}&lt;/code&gt; 来为标题指定 ID。此外还有另外一个扩展标识 &lt;code&gt;autoHeaderIds&lt;/code&gt;，用来控制是否自动为标题创建 ID。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义列表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;definitionLists&lt;/code&gt;，默认开启该扩展。定义列表的语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;  汽车
  : 汽车是一种机动车

  铁
  : 铁是广泛存在于自然界的一种常见元素，铁的冶炼和制作对现代工业革命中关键性的作用
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它标记语言&#34;&gt;其它标记语言&lt;/h2&gt;

&lt;p&gt;除了 Markdown 语言外，Hugo 还支持 Emacs Org-Mode 语言（文档后缀名为 &lt;code&gt;.org&lt;/code&gt; 或者 &lt;code&gt;markup=&amp;quot;org&amp;quot;&lt;/code&gt;）。此外 Hugo 还可以通过外部程序来支持其它标记语言，比如：&lt;a href=&#34;http://asciidoctor.org/&#34; title=&#34;Asciidoc&#34;&gt;Asciidoc&lt;/a&gt;, &lt;a href=&#34;http://docutils.sourceforge.net/rst.html&#34; title=&#34;reStructuredText&#34;&gt;reStructuredText&lt;/a&gt; 等。要使用这些标记语言来书写文档也十分简单，只要将文档的扩展名，命名为该标记语言标准的扩展名即可。Hugo 在生成静态网站时就会自动调用相应标记语言的解释器来渲染它们。当然，前提是已经在电脑上安装好了这些解释器。&lt;/p&gt;

&lt;h2 id=&#34;数学公式显示&#34;&gt;数学公式显示&lt;/h2&gt;

&lt;p&gt;可以借助一款 Javascript 函数库 &lt;a href=&#34;http://www.mathjax.org/&#34; title=&#34;MathJax&#34;&gt;MathJax&lt;/a&gt; 来显示嵌入在 HTML 文档中 LaTex 风格的数学公式。&lt;/p&gt;

&lt;h3 id=&#34;添加-mathjax-到模板中&#34;&gt;添加 MathJax 到模板中&lt;/h3&gt;

&lt;p&gt;为了可以在所有页面中显示数学公式，建议将使用 MathJax 的代码添加到被所有页面包含的模板文件中，比如 &lt;code&gt;footer.html&lt;/code&gt; 模板文件中。使用 MathJax 的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了上面这种方式使用 MathJax 外，还有&lt;a href=&#34;http://docs.mathjax.org/en/latest/configuration.html&#34; title=&#34;MathJax Loading&#34;&gt;其它方式&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;markdown-和-mathjax-的冲突&#34;&gt;Markdown 和 MathJax 的冲突&lt;/h3&gt;

&lt;p&gt;任何 MathJax 可以解析的数学公式&lt;a href=&#34;https://docs.mathjax.org/en/latest/start.html#putting-mathematics-in-a-web-page&#34; title=&#34;MathJax Syntax&#34;&gt;语法&lt;/a&gt;，都可以直接书写在 Markdown 文档中，在 Markdown 引擎将 Markdown 文档解析为 HTML 后，MathJax 会负责解析 HTML 文档中数学公式语法。&lt;/p&gt;

&lt;p&gt;不过这里有两个问题需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下划线 &lt;code&gt;_&lt;/code&gt; 同时是 Markdown 语法和数学公式语法的组成部分。解析 Markdown 文档时，文档中所有 &lt;code&gt;_&lt;/code&gt; 语法会被处理，甚至在数学公式中使用的 &lt;code&gt;_&lt;/code&gt; 也会被处理。而 Markdown 引擎处理了数学公式中的 &lt;code&gt;_&lt;/code&gt; ，将导致数学公式显示时出错。&lt;/li&gt;
&lt;li&gt;MathJax 要显示 HTML 文档中的数学公式，就需要某种机制来查找到这些数学公式代码。MathJax 是通过数学公式的定界符来查找数学公式的，并且支持自定义定界符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要解决 Mathdown 和 MathJax 对下划线解析的冲突问题，一种直观的方案是将 Markdown 文档中数学公式中的 &lt;code&gt;_&lt;/code&gt; 转义为 &lt;code&gt;\_&lt;/code&gt; 。Markdown 引擎处理过后，&lt;code&gt;\_&lt;/code&gt; 将会被转换为 &lt;code&gt;_&lt;/code&gt; ，因此数学公式语法是有效的。不过该方案一来要插入许多转义符，二来使得 Markdown 文档中书写的数学公式不直观。&lt;/p&gt;

&lt;p&gt;另外一种解决下划线冲突的方案是，使用 HTML 标签 &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 来将数学代码包含在内，由于 Markdown 引擎不会处理包含在 HTML 标签中的内容，因此 Markdown 引擎也就不会解析数学代码中的下划线了。不过这只适用于块级数学公式（即独立成行的数学公式），并不适用于行内数学公式（即嵌套在行内的数学公式），对于行内数学公式可以使用 Markdown 中的行内代码语法来包裹起来，这样 Markdown 引擎就不会处理里面的内容了，不过由于行内代码的显示样式跟普通文本不一样，所以需要利用 CSS 代码来将其更改为正常的文本样式，具体&lt;a href=&#34;http://doswa.com/2011/07/20/mathjax-in-markdown.html&#34; title=&#34;Markdown and MathJax&#34;&gt;方法&lt;/a&gt;如下：&lt;/p&gt;

&lt;p&gt;添加 Javascript 代码到所有页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]],
    displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]],
    processEscapes: true,
    processEnvironments: true,
    skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;],
    TeX: { equationNumbers: { autoNumber: &amp;quot;AMS&amp;quot; },
         extensions: [&amp;quot;AMSmath.js&amp;quot;, &amp;quot;AMSsymbols.js&amp;quot;] }
  }
});
&amp;lt;/script&amp;gt;

&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
  MathJax.Hub.Queue(function() {
    // Fix &amp;lt;code&amp;gt; tags after MathJax finishes running. This is a
    // hack to overcome a shortcoming of Markdown. Discussion at
    // https://github.com/mojombo/jekyll/issues/199
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i &amp;lt; all.length; i += 1) {
        all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;
    }
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 CSS 代码到所有页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151; /* 应该设置为跟 body 标签一样的颜色 */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终在 Markdown 文档中书写块级数学公式的语法为：&lt;code&gt;&amp;lt;div&amp;gt;$$TeX Code$$&amp;lt;/div&amp;gt;&lt;/code&gt;，行内数学公式的语法为：&lt;code&gt;&lt;code&gt;$ TeX Code $&lt;/code&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;code&gt;\( TeX Code \)&lt;/code&gt;&lt;/code&gt;。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 文档处理</title>
            <link>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_sort/</link>
            <pubDate>Tue, 15 Aug 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/hugo_sort/</guid>
            <description>&lt;h3 id=&#34;文档排序&#34;&gt;文档排序&lt;/h3&gt;

&lt;p&gt;当在列表页面展示多篇文档时，就涉及到文档先后顺序的问题了。Hugo 中文档默认是以元信息 &lt;code&gt;weight&lt;/code&gt; 来排序，当文档未指定 &lt;code&gt;weight&lt;/code&gt; 时，就以元信息 &lt;code&gt;date&lt;/code&gt; 来排序，如果这两项都没有指定的话，列表页面看到的文档就是无序的。&lt;/p&gt;

&lt;p&gt;不过除了上面 &lt;code&gt;weight&lt;/code&gt; 和 &lt;code&gt;date&lt;/code&gt; 外，Hugo 还支持我们以更多方式来排序列表页面，我们需要在列表模板文件中使用以下一些模板变量来控制文档的排序&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照元信息权重和日期排序（默认排序方式）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages }}
  &amp;lt;li&amp;gt;
  &amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;
  &amp;lt;div class=&amp;quot;meta&amp;quot;&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/div&amp;gt;
  &amp;lt;/li&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照元信息日期排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByDate }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照发布日期排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByPublishDate }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照失效日期排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByExpiryDate }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照修改日期排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByLastmod }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照文档内容长度排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByLength }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照文档标题排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByTitle }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照链接标题排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByLinkTitle }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照其它元信息排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range (.Date.Pages.ByParam &amp;quot;author.last_name&amp;quot;) }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;反转排序（以上所有排序都可反转）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByTitle.Reverse }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，文档还可以按照分类进行排序，而分类标签本身可以按照标签字母序来排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
{{ $data := .Data }}
{{ range $key, $value := .Data.Taxonomy.Alphabetical }}
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ .Site.LanguagePrefix }}/{{ $data.Plural }}/{{ $value.Name | urlize }}&amp;quot;&amp;gt; {{ $value.Name }} &amp;lt;/a&amp;gt; {{ $value.Count }} &amp;lt;/li&amp;gt;
{{ end }}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者按照关联到该分类标签的文档数量排序（即按照分类的热门程度排序）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
{{ $data := .Data }}
{{ range $key, $value := .Data.Taxonomy.ByCount }}
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ .Site.LanguagePrefix }}/{{ $data.Plural }}/{{ $value.Name | urlize }}&amp;quot;&amp;gt; {{ $value.Name }} &amp;lt;/a&amp;gt; {{ $value.Count }} &amp;lt;/li&amp;gt;
{{ end }}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属于某个分类的文档默认按照 &lt;code&gt;weight&lt;/code&gt; 和 &lt;code&gt;date&lt;/code&gt; 来排序，并且支持为文档指定分类排序时的权重，这样可以调整文档在分类中的顺序，这个功能通过文档中指定元数据 &lt;code&gt;taxonomyname_weight&lt;/code&gt; 来实现，其中 &lt;code&gt;taxonomyname&lt;/code&gt; 代表分类名。&lt;/p&gt;

&lt;h3 id=&#34;文档分组&#34;&gt;文档分组&lt;/h3&gt;

&lt;p&gt;当在列表页面展示多篇文档时，Hugo 支持我们根据文档类型、日期或者 Section 来分组显示文档。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照 Section 分组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupBy &amp;quot;Section&amp;quot; }}
  &amp;lt;h3&amp;gt;{{ .Key }}&amp;lt;/h3&amp;gt;
  &amp;lt;ul&amp;gt;
      {{ range .Pages }}
      &amp;lt;li&amp;gt;
      &amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;
      &amp;lt;div class=&amp;quot;meta&amp;quot;&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/div&amp;gt;
      &amp;lt;/li&amp;gt;
      {{ end }}
  &amp;lt;/ul&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照日期分组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot; }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照发布日期分组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByPublishDate &amp;quot;2006-01&amp;quot; }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照其它元信息分组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByParam &amp;quot;param_key&amp;quot; }}
    &amp;lt;!-- ... --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;反转分组排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range (.Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot;).Reverse }}
    &amp;lt;!-- 利用模板函数Reverse来反转 --&amp;gt;
  {{ end }}

  {{ range .Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot; &amp;quot;desc&amp;quot; }}
    &amp;lt;!-- 或者直接指定排序方向 --&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;组内文档排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot; &amp;quot;asc&amp;quot; }}
  &amp;lt;h3&amp;gt;{{ .Key }}&amp;lt;/h3&amp;gt;
  &amp;lt;ul&amp;gt;
      {{ range .Pages.ByTitle }}
      &amp;lt;!-- 可以按照之前介绍排序文档的各种方法来排序组内文档 --&amp;gt;
      {{ end }}
  &amp;lt;/ul&amp;gt;
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档过滤&#34;&gt;文档过滤&lt;/h3&gt;

&lt;p&gt;有时候也许想要排除某些文档在列表页面显示，Hugo 支持我们在列表页面限制文档显示数量以及限制显示的文档种类。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;限制文档显示数量&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range first 10 .Data.Pages }}
      &amp;lt;!-- 利用模板函数first，只显示排在前面的10篇文档 --&amp;gt;
      {{ .Render &amp;quot;summary&amp;quot; }}
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;根据条件过滤某些文档&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;post&amp;quot; }}
     &amp;lt;!-- 利用模板函数where，只筛选显示Section为post的文档 --&amp;gt;
     {{ .Content }}
  {{ end }}

  {{ range first 5 (where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;post&amp;quot;) }}
     &amp;lt;!-- 同时使用where和first --&amp;gt;
     {{ .Content }}
  {{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档摘要&#34;&gt;文档摘要&lt;/h3&gt;

&lt;p&gt;Hugo 默认会截取文档前70个词作为文档摘要，并将摘要内容存放在模板页面变量 &lt;code&gt;.Summary&lt;/code&gt; ，同时提供模板变量 &lt;code&gt;.Truncated&lt;/code&gt; 来记录截取的摘要是否包含了文档的全部内容。同时 Hugo 还支持我们在内容文档中明确指定将哪些内容作为该文档的摘要，具体来说需要在文档中插入一行 &lt;code&gt;&lt;/code&gt; 来标识位于该行之前的内容作为摘要，同理 Hugo 会将摘要存放在模板页面变量 &lt;code&gt;.Summary&lt;/code&gt; ，并用模板变量 &lt;code&gt;.Truncated&lt;/code&gt; 标识摘要是否包含了文档全部内容。&lt;/p&gt;

&lt;p&gt;利用文档的摘要功能可以实现“阅读更多&amp;hellip;”这样的功能，示例如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ range first 10 .Data.Pages }}
  &amp;lt;div class=&amp;quot;summary&amp;quot;&amp;gt;
    &amp;lt;h4&amp;gt;&amp;lt;a href=&amp;quot;{{ .RelPermalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/h4&amp;gt;
    {{ .Summary }}
  &amp;lt;/div&amp;gt;
  {{ if .Truncated }}
  &amp;lt;div class=&amp;quot;read-more-link&amp;quot;&amp;gt;
    &amp;lt;a href=&amp;quot;{{ .RelPermalink }}&amp;quot;&amp;gt;Read More…&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
  {{ end }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
        <item>
            <title>10个实用的PHP正则表达式</title>
            <link>//blog.pytool.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2015-01-01-10%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
            <pubDate>Thu, 15 Jun 2017 14:08:22 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2015-01-01-10%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
            <description>&lt;p&gt;正则表达式是程序开发中一个重要的元素，它提供用来描述或匹配文本的字符串，如特定的字符、词或算式等。但在某些情况下，用正则表达式去验证一个字符串比较复杂和费时。本文为你介绍10种常见的实用PHP正则表达式的写法，希望对你的工作有所帮助。
1. 验证E-mail地址&lt;/p&gt;

&lt;p&gt;这是一个用于验证电子邮件的正则表达式。但它并不是高效、完美的解决方案。在此不推荐使用。&lt;/p&gt;

&lt;p&gt;$email = &amp;ldquo;test@ansoncheung.tk&amp;rdquo;;
if(preg&lt;em&gt;match(&amp;lsquo;/^[^0-9][a-zA-Z0-9&lt;/em&gt;]+([.][a-zA-Z0-9&lt;em&gt;]+)*[@][a-zA-Z0-9&lt;/em&gt;]+([.][a-zA-Z0-9_]+)*[.][a-zA-Z]{2,4}$/&amp;lsquo;,$email)){
    echo &amp;ldquo;Your email is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong email address format&amp;rdquo;;
}&lt;/p&gt;

&lt;p&gt;为了更加有效验证电子邮件地址，推荐使用filer_var。&lt;/p&gt;

&lt;p&gt;if(filter_var(&amp;lsquo;test+email@ansoncheung&amp;rsquo;, FILTER_VALIDATE_EMAIL)){
    echo &amp;ldquo;Your email is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong email address format.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证用户名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一个用于验证用户名的实例，其中包括字母、数字（A-Z，a-z，0-9）、下划线以及最低5个字符，最大20个字符。同时，也可以根据需要，对最小值和最大值做合理的修改。&lt;/p&gt;

&lt;p&gt;$username = &amp;ldquo;user_name12&amp;rdquo;;
if(preg&lt;em&gt;match(&amp;lsquo;/^[a-z\d&lt;/em&gt;]{5,20}$/i&amp;rsquo;, $username)){
    echo &amp;ldquo;Your username is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong username format.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证电话号码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一个验证美国电话号码的实例。&lt;/p&gt;

&lt;p&gt;$phone = &amp;ldquo;(021)423-2323&amp;rdquo;;
if(preg_match(&amp;lsquo;/&lt;span class=&#34;MathJax_Preview&#34;&gt;(?\d{3})&lt;/span&gt;&lt;script type=&#34;math/tex&#34;&gt;?\d{3}&lt;/script&gt;?[-\s.]?\d{3}[-\s.]\d{4}/x&amp;rsquo;, $phone)){
    echo &amp;ldquo;Your phone number is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong phone number.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证IP地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一个用来验证IPv4地址的实例。&lt;/p&gt;

&lt;p&gt;$IP = &amp;ldquo;198.168.1.78&amp;rdquo;;
if(preg_match(&amp;lsquo;/^(([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]).){3}([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/&amp;lsquo;,$IP)) {
    echo &amp;ldquo;Your IP address is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong IP address.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证邮政编码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一个用来验证邮政编码的实例。&lt;/p&gt;

&lt;p&gt;$zipcode = &amp;ldquo;12345-5434&amp;rdquo;;
if(preg_match(&amp;ldquo;/^([0-9]{5})(-[0-9]{4})?$/i&amp;rdquo;,$zipcode)){
   echo &amp;ldquo;Your Zip code is ok.&amp;rdquo;;
}else{
   echo &amp;ldquo;Wrong Zip code.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证SSN（社会保险号）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一个验证美国SSN的实例。&lt;/p&gt;

&lt;p&gt;$ssn = &amp;ldquo;333-23-2329&amp;rdquo;;
if(preg_match(&amp;lsquo;/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;{3}-[\d]{2}-[\d]{4}$/&amp;lsquo;,$ssn)){
    echo &amp;ldquo;Your SSN is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong SSN.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证信用卡号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$cc = &amp;ldquo;378282246310005&amp;rdquo;;
if(preg_match(&amp;lsquo;/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6011[0-9]{12}|3(?:0[0-5]|[68][0-9])[0-9]{11}|3[47][0-9]{13})$/&amp;lsquo;, $cc)){
    echo &amp;ldquo;Your credit card number is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong credit card number.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证域名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$url = &amp;ldquo;&lt;a href=&#34;http://ansoncheung.tk/&amp;quot;&#34;&gt;http://ansoncheung.tk/&amp;quot;&lt;/a&gt;;
if (preg&lt;em&gt;match(&amp;lsquo;/^(http|https|ftp):\/\/([A-Z0-9][A-Z0-9&lt;/em&gt;-]&lt;em&gt;(?:.[A-Z0-9][A-Z0-9_-]&lt;/em&gt;)+):?(\d+)?\/?/i&amp;rsquo;, $url)) {
    echo &amp;ldquo;Your url is ok.&amp;rdquo;;
}else{
    echo &amp;ldquo;Wrong url.&amp;rdquo;;
}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从特定URL中提取域名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$url = &amp;ldquo;&lt;a href=&#34;http://ansoncheung.tk/articles&amp;quot;&#34;&gt;http://ansoncheung.tk/articles&amp;quot;&lt;/a&gt;;
preg_match(&amp;lsquo;@^(?:http://)?([^/]+)@i&amp;rsquo;, $url, $matches);
$host = $matches[1];
echo $host;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将文中关键词高亮显示&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$text = &amp;ldquo;Sample sentence from AnsonCheung.tk, regular expression has become popular in web programming. Now we learn regex. According to wikipedia, Regular expressions (abbreviated as regex or regexp, with plural forms regexes, regexps, or regexen) are written in a formal language that can be interpreted by a regular expression processor&amp;rdquo;;
$text = preg_replace(&amp;ldquo;/\b(regex)\b/i&amp;rdquo;, &amp;lsquo;&lt;span style=&#34;background:#5fc9f6&#34;&gt;\1&lt;/span&gt;&amp;rsquo;, $text);
echo $text;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:d&#34;&gt;\d &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
        <item>
            <title>正则表达式前端使用手册</title>
            <link>//blog.pytool.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2015-01-01-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
            <pubDate>Thu, 15 Jun 2017 14:08:22 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2015-01-01-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
            <description>&lt;p&gt;PS：正则表达式用于字符串处理、表单验证等场合，实用高效。以下表达式本人收集于网络，做了简单整理，以备不时之需。没有全部验证，可能会存在部分错误，读者请自己调试鉴别更正。&lt;/p&gt;

&lt;p&gt;匹配中文字符的正则表达式： [\u4e00-\u9fa5]
评注：匹配中文还真是个头疼的事，有了这个表达式就好办了&lt;/p&gt;

&lt;p&gt;匹配双字节字符(包括汉字在内)：[^\x00-\xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）&lt;/p&gt;

&lt;p&gt;匹配空白行的正则表达式：\n\s*\r
评注：可以用来删除空白行&lt;/p&gt;

&lt;p&gt;匹配HTML标记的正则表达式：&amp;lt;(\S&lt;em&gt;?)[^&amp;gt;]&lt;/em&gt;&amp;gt;.&lt;em&gt;?&amp;lt;/\1&amp;gt;|&amp;lt;.&lt;/em&gt;? /&amp;gt;
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力&lt;/p&gt;

&lt;p&gt;匹配首尾空白字符的正则表达式：^\s&lt;em&gt;|\s&lt;/em&gt;$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式&lt;/p&gt;

&lt;p&gt;匹配Email地址的正则表达式：\w+([-+.]\w+)&lt;em&gt;@\w+([-.]\w+)&lt;/em&gt;.\w+([-.]\w+)*
评注：表单验证时很实用&lt;/p&gt;

&lt;p&gt;匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求&lt;/p&gt;

&lt;p&gt;匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用&lt;/p&gt;

&lt;p&gt;匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}
评注：匹配形式如 0511-4405222 或 021-87888822&lt;/p&gt;

&lt;p&gt;匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10000开始&lt;/p&gt;

&lt;p&gt;匹配中国邮政编码：[1-9]\d{5}(?!\d)
评注：中国邮政编码为6位数字&lt;/p&gt;

&lt;p&gt;匹配身份证：\d{15}|\d{18}
评注：中国的身份证为15位或18位&lt;/p&gt;

&lt;p&gt;匹配ip地址：\d+.\d+.\d+.\d+
评注：提取ip地址时有用&lt;/p&gt;

&lt;p&gt;匹配特定数字：
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1-9&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;\d&lt;em&gt;$　 　 //匹配正整数
^-[1-9]\d&lt;/em&gt;$ 　 //匹配负整数
^-?[1-9]\d&lt;em&gt;$　　 //匹配整数
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1-9&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;\d&lt;/em&gt;|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]\d&lt;em&gt;|0$　　 //匹配非正整数（负整数 + 0）
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1-9&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;\d&lt;/em&gt;.\d&lt;em&gt;|0.\d&lt;/em&gt;[1-9]\d&lt;em&gt;$　　 //匹配正浮点数
^-([1-9]\d&lt;/em&gt;.\d&lt;em&gt;|0.\d&lt;/em&gt;[1-9]\d&lt;em&gt;)$　 //匹配负浮点数
^-?([1-9]\d&lt;/em&gt;.\d&lt;em&gt;|0.\d&lt;/em&gt;[1-9]\d&lt;em&gt;|0?.0+|0)$　 //匹配浮点数
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1-9&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;\d&lt;/em&gt;.\d&lt;em&gt;|0.\d&lt;/em&gt;[1-9]\d&lt;em&gt;|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]\d&lt;/em&gt;.\d&lt;em&gt;|0.\d&lt;/em&gt;[1-9]\d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
评注：处理大量数据时有用，具体应用时注意修正&lt;/p&gt;

&lt;p&gt;匹配特定字符串：
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:A-Za-z&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:A-Za-z&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;+$　　//匹配由26个英文字母组成的字符串
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:A-Z&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:A-Z&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;+$　　//匹配由26个英文字母的大写组成的字符串
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a-z&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a-z&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;+$　　//匹配由26个英文字母的小写组成的字符串
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:A-Za-z0-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:A-Za-z0-9&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;+$　　//匹配由数字和26个英文字母组成的字符串
^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串&lt;/p&gt;

&lt;p&gt;评注：上面是最基本也是最常用的一些表达式&lt;/p&gt;

&lt;p&gt;在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下:&lt;/p&gt;

&lt;p&gt;只能输入数字：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0-9&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;&lt;em&gt;$”
只能输入n位的数字：“^d{n}$”
只能输入至少n位数字：“^d{n,}$”
只能输入m-n位的数字：“^d{m,n}$”
只能输入零和非零开头的数字：“^(0|[1-9][0-9]&lt;/em&gt;)$”
只能输入有两位小数的正实数：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0-9&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;+(.[0-9]{2})?$”
只能输入有1-3位小数的正实数：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0-9&#34;&gt;11&lt;/a&gt;&lt;/sup&gt;+(.[0-9]{1,3})?$”
只能输入非零的正整数：“^+?[1-9][0-9]&lt;em&gt;$”
只能输入非零的负整数：“^-[1-9][0-9]&lt;/em&gt;$”
只能输入长度为3的字符：“^.{3}$”
只能输入由26个英文字母组成的字符串：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:A-Za-z&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:A-Za-z&#34;&gt;12&lt;/a&gt;&lt;/sup&gt;+$”
只能输入由26个大写英文字母组成的字符串：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:A-Z&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:A-Z&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;+$”
只能输入由26个小写英文字母组成的字符串：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a-z&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a-z&#34;&gt;14&lt;/a&gt;&lt;/sup&gt;+$”
只能输入由数字和26个英文字母组成的字符串：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:A-Za-z0-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:A-Za-z0-9&#34;&gt;15&lt;/a&gt;&lt;/sup&gt;+$”
只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”
验证用户密码:“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a-zA-Z&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a-zA-Z&#34;&gt;16&lt;/a&gt;&lt;/sup&gt;w{5,17}$”正确格式为：以字母开头，长度在6-18之间，&lt;/p&gt;

&lt;p&gt;只能包含字符、数字和下划线。
验证是否含有^%&amp;amp;’,;=?$”等字符：“[^%&amp;amp;’,;=?$x22]+”
只能输入汉字：“&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:u4e00-u9fa5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:u4e00-u9fa5&#34;&gt;17&lt;/a&gt;&lt;/sup&gt;,{0,}$”
验证Email地址：“^w+[-+.]w+)&lt;em&gt;@w+([-.]w+)&lt;/em&gt;.w+([-.]w+)&lt;em&gt;$”
验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;amp;=]&lt;/em&gt;)?$”
验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$”&lt;/p&gt;

&lt;p&gt;正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，&lt;/p&gt;

&lt;p&gt;“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。
验证身份证号（15位或18位数字）：“^d{15}|d{}18$”
验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”
验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”&lt;/p&gt;

&lt;p&gt;正确格式为：“01”“09”和“1”“31”。
表达式全集&lt;/p&gt;

&lt;p&gt;正则表达式有多种不同的风格。下表是在PCRE中元字符及其在正则表达式上下文中的行为的一个完整列表：
字符  描述&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\ 	将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\\”匹配“\”而“\(”则匹配“(”。
^ 	匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。
$ 	匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。
* 	匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。
+ 	匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。
? 	匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。
{n} 	n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。
{n,} 	n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。
{n,m} 	m和n均为非负整数，其中n&amp;lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。
? 	当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。
. 	匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“[.\n]”的模式。
(pattern) 	匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。
(?:pattern) 	匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。
(?=pattern) 	正向预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern) 	负向预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
x|y 	匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。
[xyz] 	字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。
[^xyz] 	负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。
[a-z] 	字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。
[^a-z] 	负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。
\b 	匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。
\B 	匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。
\cx 	匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。
\d 	匹配一个数字字符。等价于[0-9]。
\D 	匹配一个非数字字符。等价于[^0-9]。
\f 	匹配一个换页符。等价于\x0c和\cL。
\n 	匹配一个换行符。等价于\x0a和\cJ。
\r 	匹配一个回车符。等价于\x0d和\cM。
\s 	匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。
\S 	匹配任何非空白字符。等价于[^\f\n\r\t\v]。
\t 	匹配一个制表符。等价于\x09和\cI。
\v 	匹配一个垂直制表符。等价于\x0b和\cK。
\w 	匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。
\W 	匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
\xn 	匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;amp;1”。正则表达式中可以使用ASCII编码。.
\num 	匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。
\n 	标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。
\nm 	标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。
\nml 	如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。
\un 	匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（?）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是以PHP的语法所写的示例&lt;/p&gt;

&lt;p&gt;验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间&lt;/p&gt;

&lt;p&gt;&amp;lt;?php
$str = &amp;lsquo;a1234&amp;rsquo;;
if (preg_match(&amp;ldquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a-zA-Z0-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a-zA-Z0-9&#34;&gt;18&lt;/a&gt;&lt;/sup&gt;{4,16}$&amp;ldquo;, $str)) {
    echo &amp;ldquo;驗證成功&amp;rdquo;;
} else {
    echo &amp;ldquo;驗證失敗&amp;rdquo;;
}
?&amp;gt;&lt;/p&gt;

&lt;p&gt;简易的台湾身份证字号验证&lt;/p&gt;

&lt;p&gt;&amp;lt;?php
$str = &amp;lsquo;a1234&amp;rsquo;;
if (preg_match(&amp;ldquo;/^\w[12]\d{8}$/&amp;ldquo;, $str)) {
    echo &amp;ldquo;驗證成功&amp;rdquo;;
} else {
    echo &amp;ldquo;驗證失敗&amp;rdquo;;
}
?&amp;gt;&lt;/p&gt;

&lt;p&gt;以下示例是用 Perl 语言写的，与上面的示例功能相同&lt;/p&gt;

&lt;p&gt;print $str = &amp;ldquo;a1234&amp;rdquo; =~ m:&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a-zA-Z0-9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a-zA-Z0-9&#34;&gt;19&lt;/a&gt;&lt;/sup&gt;{4,16}$: ? &amp;ldquo;COMFIRM&amp;rdquo; : &amp;ldquo;FAILED&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;print $str = &amp;ldquo;a1234&amp;rdquo; =~ m&amp;rdquo;^\w[12]\d{8}$&amp;rdquo; ? &amp;ldquo;COMFIRM&amp;rdquo; : &amp;ldquo;INVAILD&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;如何写出高效率的正则表达式&lt;/p&gt;

&lt;p&gt;如果纯粹是为了挑战自己的正则水平，用来实现一些特效（例如使用正则表达式计算质数、解线性方程），效率不是问题；如果所写的正则表达式只是为了满足一两次、几十次的运行，优化与否区别也不太大。但是，如果所写的正则表达式会百万次、千万次地运行，效率就是很大的问题了。我这里总结了几条提升正则表达式运行效率的经验（工作中学到的，看书学来的，自己的体会），贴在这里。如果您有其它的经验而这里没有提及，欢迎赐教。&lt;/p&gt;

&lt;p&gt;为行文方便，先定义两个概念。&lt;/p&gt;

&lt;p&gt;误匹配：指正则表达式所匹配的内容范围超出了所需要范围，有些文本明明不符合要求，但是被所写的正则式“击中了”。例如，如果使用\d{11}来匹配11位的手机号，\d{11}不单能匹配正确的手机号，它还会匹配98765432100这样的明显不是手机号的字符串。我们把这样的匹配称之为误匹配。&lt;/p&gt;

&lt;p&gt;漏匹配：指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则没有将这种情况囊括在内。例如，使用\d{18}来匹配18位的身份证号码，就会漏掉结尾是字母X的情况。&lt;/p&gt;

&lt;p&gt;写出一条正则表达式，既可能只出现误匹配（条件写得极宽松，其范围大于目标文本），也可能只出现漏匹配（只描述了目标文本中多种情况种的一种），还可能既有误匹配又有漏匹配。例如，使用\w+.com来匹配.com结尾的域名，既会误匹配abc_.com这样的字串（合法的域名中不含下划线，\w包含了下划线这种情况），又会漏掉ab-c.com这样的域名（合法域名中可以含中划线，但是\w不匹配中划线）。&lt;/p&gt;

&lt;p&gt;精准的正则表达式意味着既无误匹配且无漏匹配。当然，现实中存在这样的情况：只能看到有限数量的文本，根据这些文本写规则，但是这些规则将会用到海量的文本中。这种情况下，尽可能地（如果不是完全地）消除误匹配以及漏匹配，并提升运行效率，就是我们的目标。本文所提出的经验，主要是针对这种情况。&lt;/p&gt;

&lt;p&gt;掌握语法细节。正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_]；perl正则式不支持肯定逆序环视中使用可变的重复（variable repetition inside lookbehind，例如(?&amp;lt;=.*)abc），但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视（Lookbehind,如(?&amp;lt;=ab)c）都不支持，而perl和python是支持的。《精通正则表达式》第3章《正则表达式的特性和流派概览》明确地列出了各大派系正则的异同，这篇文章也简要地列出了几种常用语言、工具中正则的比较。对于具体使用者而言，至少应该详细了解正在使用的那种工作语言里正则的语法细节。&lt;/p&gt;

&lt;p&gt;先粗后精，先加后减。使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，再逐步在局步实现细节。仍举刚才的手机号的例子，先界定\d{11}，总不会错；再细化为1[358]\d{9}，就向前迈了一大步（至于第二位是不是3、5、8，这里无意深究，只举这样一个例子，说明逐步细化的过程）。这样做的目的是先消除漏匹配（刚开始先尽可能多地匹配，做加法），然后再一点一点地消除误匹配（做减法）。这样有先有后，在考虑时才不易出错，从而向“不误不漏”这个目标迈进。&lt;/p&gt;

&lt;p&gt;留有余地。所能看到的文本sample是有限的，而待匹配检验的文本是海量的，暂时不可见的。对于这样的情况，在写正则表达式时要跳出所能见到的文本的圈子，开拓思路，作出“战略性前瞻”。例如，经常收到这样的垃圾短信：“发*票”、“发#漂”。如果要写规则屏蔽这样烦人的垃圾短信，不但要能写出可以匹配当前文本的正则表达式 发&lt;a href=&#34;?:票|漂&#34;&gt;*#&lt;/a&gt;，还要能够想到 发.(?:票|漂|飘)之类可能出现的“变种”。这在具体的领域或许会有针对性的规则，不多言。这样做的目的是消除漏匹配，延长正则表达式的生命周期。&lt;/p&gt;

&lt;p&gt;明确。具体说来，就是谨慎用点号这样的元字符，尽可能不用星号和加号这样的任意量词。只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。例如，写析取twitter消息的脚本，假设一条消息的xml正文部分结构是&lt;span class=”msg”&gt;…&lt;/span&gt;且正文中无尖括号，那么&lt;span class=”msg”&gt;[^&amp;lt;]{1,480}&lt;/span&gt;这种写法的思路要好于&lt;span class=”msg”&gt;.*&lt;/span&gt;，原因有二：一是使用[^&amp;lt;]，它保证了文本的范围不会超出下一个小于号所在的位置；二是明确长度范围，{1,480}，其依据是一条twitter消息大致能的字符长度范围。当然，480这个长度是否正确还可推敲，但是这种思路是值得借鉴的。说得狠一点，“滥用点号、星号和加号是不环保、不负责任的做法”。&lt;/p&gt;

&lt;p&gt;不要让稻草压死骆驼。每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。这样的正则表达式、无限次地运行次数，无异于一根根稻草的堆加，终于能将骆驼压死。养成合理使用(?:…)括号的习惯。&lt;/p&gt;

&lt;p&gt;宁简勿繁。将一条复杂的正则表达式拆分为两条或多条简单的正则表达式，编程难度会降低，运行效率会提升。例如用来消除行首和行尾空白字符的正则表达式s/^\s+|\s+$//g;，其运行效率理论上要低于s/^\s+//g; s/\s+$//g; 。这个例子出自《精通正则表达式》第五章，书中对它的评论是“它几乎总是最快的，而且显然最容易理解”。既快又容易理解，何乐而不为？工作中我们还有其它的理由要将C==(A|B)这样的正则表达式拆为A和B两条表达式分别执行。例如，虽然A和B这两种情况只要有一种能够击中所需要的文本模式就会成功匹配，但是如果只要有一条子表达式（例如A）会产生误匹配，那么不论其它的子表达式（例如B）效率如何之高，范围如何精准，C的总体精准度也会因A而受到影响。&lt;/p&gt;

&lt;p&gt;巧妙定位。有时候，我们需要匹配的the，是作为单词的the（两边有空格），而不是作为单词一部分的t-h-e的有序排列（例如together中的the）。在适当的时候用上^，$，\b等等定位锚点，能有效提升找到成功匹配、淘汰不成功匹配的效率。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1-9&#34;&gt;1-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:1-9&#34;&gt;1-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:1-9&#34;&gt;1-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:1-9&#34;&gt;1-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:A-Za-z&#34;&gt;A-Za-z &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:A-Za-z&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:A-Z&#34;&gt;A-Z &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:A-Z&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a-z&#34;&gt;a-z &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a-z&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:A-Za-z0-9&#34;&gt;A-Za-z0-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:A-Za-z0-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0-9&#34;&gt;0-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0-9&#34;&gt;0-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0-9&#34;&gt;0-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:A-Za-z&#34;&gt;A-Za-z &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:A-Za-z&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:A-Z&#34;&gt;A-Z &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:A-Z&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a-z&#34;&gt;a-z &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a-z&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:A-Za-z0-9&#34;&gt;A-Za-z0-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:A-Za-z0-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a-zA-Z&#34;&gt;a-zA-Z &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a-zA-Z&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:u4e00-u9fa5&#34;&gt;u4e00-u9fa5 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:u4e00-u9fa5&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a-zA-Z0-9&#34;&gt;a-zA-Z0-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a-zA-Z0-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a-zA-Z0-9&#34;&gt;a-zA-Z0-9 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a-zA-Z0-9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
        <item>
            <title>正则表达式前端使用手册</title>
            <link>//blog.pytool.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2015-01-01-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
            <pubDate>Thu, 15 Jun 2017 14:08:22 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2015-01-01-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
            <description>

&lt;p&gt;title: 正则表达式前端使用手册
date: 2017-06-15T14:08:22+08:00
categories: [正则]
author: louis
authorLink: &lt;a href=&#34;http://louiszhai.github.io&#34;&gt;http://louiszhai.github.io&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://www.regexr.com/&#34;&gt;http://www.regexr.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;关于&#34;&gt;关于&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;我的博客：&lt;a href=&#34;http://louiszhai.github.io&#34;&gt;louis blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SF专栏：&lt;a href=&#34;https://segmentfault.com/blog/louiszhai&#34;&gt;路易斯前端深度课&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文链接：&lt;a href=&#34;http://louiszhai.github.io/2016/06/13/regular/&#34;&gt;正则表达式前端使用手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;导读&#34;&gt;导读&lt;/h3&gt;

&lt;p&gt;08 08 BS  \b 退格(BS) ，将当前位置移到前一列&lt;/p&gt;

&lt;p&gt;09 09 HT \t 水平制表(HT) （跳到下一个TAB位置）
10 0A LF \n 换行(LF) ，将当前位置移到下一行开头
11 0B VT \v 垂直制表(VT)
12 0C FF \f 换页(FF)，将当前位置移到下页开头
13 0D CR \r 回车(CR) ，将当前位置移到本行开头
32 20       空格
\s 等价 [ \t\n\v\f\r]&lt;/p&gt;

&lt;p&gt;你有没有在搜索文本的时候绞尽脑汁, 试了一个又一个表达式, 还是不行.&lt;/p&gt;

&lt;p&gt;你有没有在表单验证的时候, 只是做做样子(只要不为空就好), 然后烧香拜佛, 虔诚祈祷, 千万不要出错.&lt;/p&gt;

&lt;p&gt;你有没有在使用sed 和 grep 命令的时候, 感觉莫名其妙, 明明应该支持的元字符, 却就是匹配不到.&lt;/p&gt;

&lt;p&gt;甚至, 你压根没遇到过上述情况, 你只是一遍又一遍的调用 replace 而已 (把非搜索文本全部替换为空, 然后就只剩搜索文本了), 面对别人家的简洁高效的语句, 你只能在心中呐喊, replace 大法好.&lt;/p&gt;

&lt;p&gt;为什么要学正则表达式. 有位网友这么说: 江湖传说里, 程序员的正则表达式和医生的处方, 道士的鬼符齐名, 曰: 普通人看不懂的三件神器. 这个传说至少向我们透露了两点信息: 一是正则表达式很牛, 能和医生的处方, 道士的鬼符齐名, 并被大家提起, 可见其江湖地位. 二是正则表达式很难, 这也从侧面说明了, 如果你可以熟练的掌握并应用它, 在装逼的路上, 你将如日中天 (别问我中天是谁……) !&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;显然, 有关正则表达的介绍, 无须我多言. 这里就借助 Jeffrey Friedl 的《精通正则表达式》一书的序言正式抛个砖.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;​    &amp;ldquo;如果罗列计算机软件领域的伟大发明, 我相信绝对不会超过二十项, 在这个名单当中, 当然应该包括分组交换网络, Web, Lisp, 哈希算法, UNIX, 编译技术, 关系模型, 面向对象, XML这些大名鼎鼎的家伙, 而正则表达式也绝对不应该被漏掉.&lt;/p&gt;

&lt;p&gt;​     对很多实际工作而言, 正则表达式简直是灵丹妙药, 能够成百倍的提高开发效率和程序质量, 正则表达式在生物信息学和人类基因图谱的研究中所发挥的关键作用, 更是被传为佳话. CSDN的创始人蒋涛先生在早年开发专业软件产品时, 就曾经体验过这一工具的巨大威力, 并且一直印象深刻.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此, 我们没有理由不去了解正则表达式, 甚至是熟练掌握并运用它.&lt;/p&gt;

&lt;p&gt;本文以正则基础语法开篇, 结合具体实例, 逐步讲解正则表达式匹配原理. 代码实例使用语言包括 js, php, python, java(因有些匹配模式, js并未支持, 需要借助其他语言讲解). 内容包括初阶技能和高阶技能, 适合新手学习和进阶. 本文力求简单通俗易懂, 同时为求全面, 涉及知识较多, 共计12k字, 篇幅较长, 请耐心阅读, 如有阅读障碍请及时&lt;a href=&#34;#respond&#34;&gt;联系我&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;回顾历史&#34;&gt;回顾历史&lt;/h3&gt;

&lt;p&gt;要论正则表达式的渊源, 最早可以追溯至对人类神经系统如何工作的早期研究. Warren McCulloch 和 Walter Pitts 这两位神经大咖 (神经生理学家) 研究出一种数学方式来描述这些神经网络.&lt;/p&gt;

&lt;p&gt;1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上, 发表了一篇标题为&amp;rdquo;神经网事件的表示法&amp;rdquo;的论文, 引入了正则表达式的概念.&lt;/p&gt;

&lt;p&gt;随后, 发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究中. 而 Ken Thompson 又是 Unix 的主要发明人. 因此半个世纪以前的Unix 中的 qed 编辑器(1966 qed编辑器问世) 成了第一个使用正则表达式的应用程序.&lt;/p&gt;

&lt;p&gt;至此之后, 正则表达式成为家喻户晓的文本处理工具, 几乎各大编程语言都以支持正则表达式作为卖点, 当然 JavaScript 也不例外.&lt;/p&gt;

&lt;h3 id=&#34;正则表达式的定义&#34;&gt;正则表达式的定义&lt;/h3&gt;

&lt;p&gt;正则表达式是由普通字符和特殊字符(也叫元字符或限定符)组成的文字模板. 如下便是简单的匹配连续数字的正则表达式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/[0-9]+/
/\d+/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;\d&amp;rdquo; 就是元字符, 而 &amp;ldquo;+&amp;rdquo; 则是限定符.&lt;/p&gt;

&lt;h4 id=&#34;元字符&#34;&gt;元字符&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;元字符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;.&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配除换行符以外的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\d&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配数字, 等价于字符组[0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\w&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配字母, 数字, 下划线或汉字&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\s&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配任意的空白符(包括制表符,空格,换行等)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\b&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配单词开始或结束的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;^&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配行首&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;反义元字符&#34;&gt;反义元字符&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;元字符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\D&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配非数字的任意字符, 等价于[^0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\W&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配除字母,数字,下划线或汉字之外的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\S&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配非空白的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配非单词开始或结束的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[^x]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配除x以外的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看出正则表达式严格区分大小写.&lt;/p&gt;

&lt;h4 id=&#34;重复限定符&#34;&gt;重复限定符&lt;/h4&gt;

&lt;p&gt;限定符共有6个, 假设重复次数为x次, 那么将有如下规则:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;限定符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x&amp;gt;=0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;+&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x&amp;gt;=1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;?&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x=0 or x=1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n}&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x=n&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n,}&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;x&amp;gt;=n&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n,m}&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;n&amp;lt;=x&amp;lt;=m&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;字符组&#34;&gt;字符组&lt;/h4&gt;

&lt;p&gt;[&amp;hellip;] 匹配中括号内字符之一. 如: [xyz]  匹配字符 x, y 或 z. 如果中括号中包含元字符, 则元字符降级为普通字符, 不再具有元字符的功能, 如 [+.?] 匹配 加号, 点号或问号.&lt;/p&gt;

&lt;h4 id=&#34;排除性字符组&#34;&gt;排除性字符组&lt;/h4&gt;

&lt;p&gt;[^…] 匹配任何未列出的字符,. 如:  [^x]  匹配除x以外的任意字符.&lt;/p&gt;

&lt;h4 id=&#34;多选结构&#34;&gt;多选结构&lt;/h4&gt;

&lt;p&gt;| 就是或的意思, 表示两者中的一个. 如: a|b 匹配a或者b字符.&lt;/p&gt;

&lt;h4 id=&#34;括号&#34;&gt;括号&lt;/h4&gt;

&lt;p&gt;括号 常用来界定重复限定符的范围, 以及将字符&lt;strong&gt;分组&lt;/strong&gt;. 如: (ab)+ 可以匹配abab..等, 其中 ab 便是一个分组.&lt;/p&gt;

&lt;h4 id=&#34;转义字符&#34;&gt;转义字符&lt;/h4&gt;

&lt;p&gt;\ 即转义字符, 通常 &lt;strong&gt;\ * + ? | { [ ( ) ] }^ $ . # 和 空白&lt;/strong&gt; 这些字符都需要转义.&lt;/p&gt;

&lt;h4 id=&#34;操作符的运算优先级&#34;&gt;操作符的运算优先级&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;\ 转义符&lt;/li&gt;
&lt;li&gt;(), (?:), (?=), [] 圆括号或方括号&lt;/li&gt;
&lt;li&gt;*, +, ?, {n}, {n,}, {n,m} 限定符&lt;/li&gt;
&lt;li&gt;^, $ 位置&lt;/li&gt;
&lt;li&gt;| &amp;ldquo;或&amp;rdquo; 操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;测试&#34;&gt;测试&lt;/h4&gt;

&lt;p&gt;我们来测试下上面的知识点, 写一个匹配手机号码的正则表达式, 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(\+86)?1\d{10}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;① &amp;ldquo;\+86&amp;rdquo; 匹配文本 &amp;ldquo;+86&amp;rdquo;, 后面接元字符问号, 表示可匹配1次或0次, 合起来表示 &amp;ldquo;(\+86)?&amp;rdquo; 匹配 &amp;ldquo;+86&amp;rdquo; 或者 &amp;ldquo;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;② 普通字符&amp;rdquo;1&amp;rdquo; 匹配文本 &amp;ldquo;1&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;③ 元字符 &amp;ldquo;\d&amp;rdquo; 匹配数字0到9, 区间量词 &amp;ldquo;{10}&amp;rdquo; 表示匹配 10 次, 合起来表示 &amp;ldquo;\d{10}&amp;rdquo; 匹配连续的10个数字.&lt;/p&gt;

&lt;p&gt;以上, 匹配结果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://louiszhai.github.io/docImages/regexp01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;修饰符&#34;&gt;修饰符&lt;/h3&gt;

&lt;p&gt;javaScript中正则表达式默认有如下五种修饰符:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;g (全文查找), 如上述截图, 实际上就开启了全文查找模式.&lt;/li&gt;
&lt;li&gt;i (忽略大小写查找)&lt;/li&gt;
&lt;li&gt;m (多行查找)&lt;/li&gt;
&lt;li&gt;y (ES6新增的粘连修饰符)&lt;/li&gt;
&lt;li&gt;u (ES6新增)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;常用的正则表达式&#34;&gt;常用的正则表达式&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;汉字: &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:u4e00-u9fa5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:u4e00-u9fa5&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;{0,}$&lt;/li&gt;
&lt;li&gt;Email: ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&lt;/li&gt;
&lt;li&gt;URL: ^https?://([\w-]+.)+[\w-]+(/[\w-./?%&amp;amp;=]*)?$&lt;/li&gt;
&lt;li&gt;手机号码: ^1\d{10}$&lt;/li&gt;
&lt;li&gt;身份证号: ^(\d{15}|\d{17}(\d|X))$&lt;/li&gt;
&lt;li&gt;中国邮政编码: [1-9]\d{5}(?!\d) (邮政编码为6位数字)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;密码验证&#34;&gt;密码验证&lt;/h4&gt;

&lt;p&gt;密码验证是常见的需求, 一般来说, 常规密码大致会满足规律: 6-16位, 数字, 字母, 字符至少包含两种, 同时不能包含中文和空格. 如下便是常规密码验证的正则描述:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var reg = /(?!^[0-9]+$)(?!^[A-z]+$)(?!^[^A-z0-9]+$)^[^\s\u4e00-\u9fa5]{6,16}$/;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;正则的几大家族&#34;&gt;正则的几大家族&lt;/h3&gt;

&lt;h4 id=&#34;正则表达式分类&#34;&gt;正则表达式分类&lt;/h4&gt;

&lt;p&gt;在 linux 和 osx 下, 常见的正则表达式, 至少有以下三种:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基本的正则表达式( Basic Regular Expression 又叫 Basic RegEx  简称 &lt;strong&gt;BREs&lt;/strong&gt; )&lt;/li&gt;
&lt;li&gt;扩展的正则表达式( Extended Regular Expression 又叫 Extended RegEx 简称 &lt;strong&gt;EREs&lt;/strong&gt; )&lt;/li&gt;
&lt;li&gt;Perl 的正则表达式( Perl Regular Expression 又叫 Perl RegEx 简称 &lt;strong&gt;PREs&lt;/strong&gt; )&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;正则表达式比较&#34;&gt;正则表达式比较&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;Basic RegEx&lt;/th&gt;
&lt;th&gt;Extended RegEx&lt;/th&gt;
&lt;th&gt;python RegEx&lt;/th&gt;
&lt;th&gt;Perl regEx&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;转义&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配行首，例如&amp;rsquo;^dog&amp;rsquo;匹配以字符串dog开头的行（注意：awk 指令中，&amp;rsquo;^&amp;lsquo;则是匹配字符串的开始）&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配行尾，例如：&amp;rsquo;^、dog\$&amp;rsquo; 匹配以字符串 dog 为结尾的行（注意：awk 指令中，&amp;rsquo;$&amp;lsquo;则是匹配字符串的结尾）&lt;/td&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^$&lt;/td&gt;
&lt;td&gt;匹配空行&lt;/td&gt;
&lt;td&gt;^$&lt;/td&gt;
&lt;td&gt;^$&lt;/td&gt;
&lt;td&gt;^$&lt;/td&gt;
&lt;td&gt;^$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^string$&lt;/td&gt;
&lt;td&gt;匹配行，例如：&amp;rsquo;^dog$&amp;lsquo;匹配只含一个字符串 dog 的行&lt;/td&gt;
&lt;td&gt;^string$&lt;/td&gt;
&lt;td&gt;^string$&lt;/td&gt;
&lt;td&gt;^string$&lt;/td&gt;
&lt;td&gt;^string$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;匹配单词，例如：&amp;rsquo;&amp;lt;frog&amp;rsquo; （等价于&amp;rsquo;\bfrog&amp;rsquo;），匹配以 frog 开头的单词&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（但可以使用\b来匹配单词，例如：&amp;rsquo;\bfrog&amp;rsquo;）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;匹配单词，例如：&amp;rsquo;frog&amp;gt;&amp;lsquo;（等价于&amp;rsquo;frog\b &amp;lsquo;），匹配以 frog 结尾的单词&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（但可以使用\b来匹配单词，例如：&amp;rsquo;frog\b&amp;rsquo;）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;x&amp;gt;&lt;/td&gt;
&lt;td&gt;匹配一个单词或者一个特定字符，例如：&amp;rsquo;&amp;lt;frog&amp;gt;&amp;lsquo;（等价于&amp;rsquo;\bfrog\b&amp;rsquo;）、&amp;rsquo;&amp;lt;G&amp;gt;&amp;lsquo;&lt;/td&gt;
&lt;td&gt;&amp;lt;x&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;x&amp;gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（但可以使用\b来匹配单词，例如：&amp;rsquo;\bfrog\b&amp;rsquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;匹配表达式，例如：不支持&amp;rsquo;（frog）&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（但可以使用，如：dog&lt;/td&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;匹配表达式，例如：不支持&amp;rsquo;（frog）&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同())&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同())&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同())&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;？&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 0 次或 1 次（等价于{0,1}），例如：where(is)?能匹配&amp;rdquo;where&amp;rdquo; 以及&amp;rdquo;whereis&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同\?)&lt;/td&gt;
&lt;td&gt;？&lt;/td&gt;
&lt;td&gt;？&lt;/td&gt;
&lt;td&gt;？&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\?&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 0 次或 1 次（等价于&amp;rsquo;{0,1}&amp;lsquo;），例如：&amp;rsquo;whereis\? &amp;lsquo;能匹配 &amp;ldquo;where&amp;rdquo;以及&amp;rdquo;whereis&amp;rdquo;&lt;/td&gt;
&lt;td&gt;\?&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同?)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同?)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同?)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;当该字符紧跟在任何一个其他限制符（*, +, ?, {n},{n,}, {n,m}） 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 &amp;ldquo;oooo&amp;rdquo;，&amp;rsquo;o+?&amp;rsquo; 将匹配单个&amp;rdquo;o&amp;rdquo;，而 &amp;lsquo;o+&amp;rsquo; 将匹配所有 &amp;lsquo;o&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除换行符（&amp;rsquo;\n&amp;rsquo;）之外的任意单个字符（注意：awk 指令中的句点能匹配换行符）&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;.（如果要匹配包括“\n”在内的任何一个字符，请使用: [\s\S]&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;.（如果要匹配包括“\n”在内的任何一个字符，请使用：&amp;rsquo; [.\n] &amp;lsquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 0 次或多次（等价于{0, }），例如：zo* 能匹配 &amp;ldquo;z&amp;rdquo;以及 &amp;ldquo;zoo&amp;rdquo;&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 1 次或多次（等价于&amp;rsquo;{1, }&amp;lsquo;），例如：&amp;rsquo;whereis+ &amp;lsquo;能匹配 &amp;ldquo;whereis&amp;rdquo;以及&amp;rdquo;whereisis&amp;rdquo;&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同+)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同+)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同+)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 1 次或多次（等价于{1, }），例如：zo+能匹配 &amp;ldquo;zo&amp;rdquo;以及 &amp;ldquo;zoo&amp;rdquo;，但不能匹配 &amp;ldquo;z&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同\+)&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;n 必须是一个 0 或者正整数，匹配子表达式 n 次，例如：zo{2}能匹配&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同\{n\})&lt;/td&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n,}&lt;/td&gt;
&lt;td&gt;&amp;ldquo;zooz&amp;rdquo;，但不能匹配 &amp;ldquo;Bob&amp;rdquo;n 必须是一个 0 或者正整数，匹配子表达式大于等于 n次，例如：go{2,}&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同\{n,\})&lt;/td&gt;
&lt;td&gt;{n,}&lt;/td&gt;
&lt;td&gt;{n,}&lt;/td&gt;
&lt;td&gt;{n,}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;能匹配 &amp;ldquo;good&amp;rdquo;，但不能匹配 godm 和 n 均为非负整数，其中 n &amp;lt;= m，最少匹配 n 次且最多匹配 m 次 ，例如：o{1,3}将配&amp;rdquo;fooooood&amp;rdquo; 中的前三个 o（请注意在逗号和两个数之间不能有空格）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同\{n,m\})&lt;/td&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x l y&lt;/td&gt;
&lt;td&gt;匹配 x 或 y&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;（同x \l y&lt;/td&gt;
&lt;td&gt;x l y&lt;/td&gt;
&lt;td&gt;x l y&lt;/td&gt;
&lt;td&gt;x l y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[0-9]&lt;/td&gt;
&lt;td&gt;匹配从 0 到 9 中的任意一个数字字符（注意：要写成递增）&lt;/td&gt;
&lt;td&gt;[0-9]&lt;/td&gt;
&lt;td&gt;[0-9]&lt;/td&gt;
&lt;td&gt;[0-9]&lt;/td&gt;
&lt;td&gt;[0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[xyz]&lt;/td&gt;
&lt;td&gt;字符集合，匹配所包含的任意一个字符，例如：&amp;rsquo;[abc]&amp;lsquo;可以匹配&amp;rdquo;lay&amp;rdquo; 中的 &amp;lsquo;a&amp;rsquo;（注意：如果元字符，例如：. *等，它们被放在[ ]中，那么它们将变成一个普通字符）&lt;/td&gt;
&lt;td&gt;[xyz]&lt;/td&gt;
&lt;td&gt;[xyz]&lt;/td&gt;
&lt;td&gt;[xyz]&lt;/td&gt;
&lt;td&gt;[xyz]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[^xyz]&lt;/td&gt;
&lt;td&gt;负值字符集合，匹配未包含的任意一个字符（注意：不包括换行符），例如：&amp;rsquo;[^abc]&amp;rsquo; 可以匹配 &amp;ldquo;Lay&amp;rdquo; 中的&amp;rsquo;L&amp;rsquo;（注意：[^xyz]在awk 指令中则是匹配未包含的任意一个字符+换行符）&lt;/td&gt;
&lt;td&gt;[^xyz]&lt;/td&gt;
&lt;td&gt;[^xyz]&lt;/td&gt;
&lt;td&gt;[^xyz]&lt;/td&gt;
&lt;td&gt;[^xyz]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[A-Za-z]&lt;/td&gt;
&lt;td&gt;匹配大写字母或者小写字母中的任意一个字符（注意：要写成递增）&lt;/td&gt;
&lt;td&gt;[A-Za-z]&lt;/td&gt;
&lt;td&gt;[A-Za-z]&lt;/td&gt;
&lt;td&gt;[A-Za-z]&lt;/td&gt;
&lt;td&gt;[A-Za-z]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[^A-Za-z]&lt;/td&gt;
&lt;td&gt;匹配除了大写与小写字母之外的任意一个字符（注意：写成递增）&lt;/td&gt;
&lt;td&gt;[^A-Za-z]&lt;/td&gt;
&lt;td&gt;[^A-Za-z]&lt;/td&gt;
&lt;td&gt;[^A-Za-z]&lt;/td&gt;
&lt;td&gt;[^A-Za-z]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配从 0 到 9 中的任意一个数字字符（等价于 [0-9]）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配非数字字符（等价于 [^0-9]）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配任何非空白字符（等价于[^\f\n\r\t\v]）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配任何空白字符，包括空格、制表符、换页符等等（等价于[ \f\n\r\t\v]）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配任何非单词字符 (等价于[^A-Za-z0-9_])&lt;/td&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配包括下划线的任何单词字符（等价于[A-Za-z0-9_]）&lt;/td&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;匹配非单词边界，例如：&amp;rsquo;er\B&amp;rsquo; 能匹配 &amp;ldquo;verb&amp;rdquo; 中的&amp;rsquo;er&amp;rsquo;，但不能匹配&amp;rdquo;never&amp;rdquo; 中的&amp;rsquo;er&amp;rsquo;&lt;/td&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;匹配一个单词边界，也就是指单词和空格间的位置，例如： &amp;lsquo;er\b&amp;rsquo; 可以匹配&amp;rdquo;never&amp;rdquo; 中的 &amp;lsquo;er&amp;rsquo;，但不能匹配 &amp;ldquo;verb&amp;rdquo; 中的&amp;rsquo;er&amp;rsquo;&lt;/td&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;匹配一个横向制表符（等价于 \x09和 \cI）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;匹配一个垂直制表符（等价于 \x0b和 \cK）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;匹配一个换行符（等价于 \x0a 和\cJ）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;匹配一个换页符（等价于\x0c 和\cL）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;匹配一个回车符（等价于 \x0d 和\cM）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;匹配转义字符本身&amp;rdquo;\&amp;rdquo;&lt;/td&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\cx&lt;/td&gt;
&lt;td&gt;匹配由 x 指明的控制字符，例如：\cM匹配一个Control-M 或回车符，x 的值必须为A-Z 或 a-z 之一，否则，将 c 视为一个原义的 &amp;lsquo;c&amp;rsquo; 字符&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;\cx&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\xn&lt;/td&gt;
&lt;td&gt;匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长，例如：&amp;rsquo;\x41&amp;rsquo; 匹配 &amp;ldquo;A&amp;rdquo;。&amp;rsquo;\x041&amp;rsquo; 则等价于&amp;rsquo;\x04&amp;rsquo; &amp;amp; &amp;ldquo;1&amp;rdquo;。正则表达式中可以使用 ASCII 编码&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;\xn&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\num&lt;/td&gt;
&lt;td&gt;匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;\num&lt;/td&gt;
&lt;td&gt;\num&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:alnum:]&lt;/td&gt;
&lt;td&gt;匹配任何一个字母或数字（[A-Za-z0-9]），例如：&amp;rsquo;[[:alnum:]] &amp;lsquo;&lt;/td&gt;
&lt;td&gt;[:alnum:]&lt;/td&gt;
&lt;td&gt;[:alnum:]&lt;/td&gt;
&lt;td&gt;[:alnum:]&lt;/td&gt;
&lt;td&gt;[:alnum:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:alpha:]&lt;/td&gt;
&lt;td&gt;匹配任何一个字母（[A－Za－z]）， 例如：&amp;rsquo; [[:alpha:]] &amp;lsquo;&lt;/td&gt;
&lt;td&gt;[:alpha:]&lt;/td&gt;
&lt;td&gt;[:alpha:]&lt;/td&gt;
&lt;td&gt;[:alpha:]&lt;/td&gt;
&lt;td&gt;[:alpha:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:digit:]&lt;/td&gt;
&lt;td&gt;匹配任何一个数字（[0-9]），例如：&amp;rsquo;[[:digit:]] &amp;lsquo;&lt;/td&gt;
&lt;td&gt;[:digit:]&lt;/td&gt;
&lt;td&gt;[:digit:]&lt;/td&gt;
&lt;td&gt;[:digit:]&lt;/td&gt;
&lt;td&gt;[:digit:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:lower:]&lt;/td&gt;
&lt;td&gt;匹配任何一个小写字母（[a-z]）， 例如：&amp;rsquo; [[:lower:]] &amp;lsquo;&lt;/td&gt;
&lt;td&gt;[:lower:]&lt;/td&gt;
&lt;td&gt;[:lower:]&lt;/td&gt;
&lt;td&gt;[:lower:]&lt;/td&gt;
&lt;td&gt;[:lower:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:upper:]&lt;/td&gt;
&lt;td&gt;匹配任何一个大写字母（[A-Z]）&lt;/td&gt;
&lt;td&gt;[:upper:]&lt;/td&gt;
&lt;td&gt;[:upper:]&lt;/td&gt;
&lt;td&gt;[:upper:]&lt;/td&gt;
&lt;td&gt;[:upper:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:space:]&lt;/td&gt;
&lt;td&gt;任何一个空白字符： 支持制表符、空格，例如：&amp;rsquo; [[:space:]] &amp;lsquo;&lt;/td&gt;
&lt;td&gt;[:space:]&lt;/td&gt;
&lt;td&gt;[:space:]&lt;/td&gt;
&lt;td&gt;[:space:]&lt;/td&gt;
&lt;td&gt;[:space:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:blank:]&lt;/td&gt;
&lt;td&gt;空格和制表符（横向和纵向），例如：&amp;rsquo;[[:blank:]]&amp;lsquo;ó&amp;rsquo;[\s\t\v]&amp;rsquo;&lt;/td&gt;
&lt;td&gt;[:blank:]&lt;/td&gt;
&lt;td&gt;[:blank:]&lt;/td&gt;
&lt;td&gt;[:blank:]&lt;/td&gt;
&lt;td&gt;[:blank:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:graph:]&lt;/td&gt;
&lt;td&gt;任何一个可以看得见的且可以打印的字符（注意：不包括空格和换行符等），例如：&amp;rsquo;[[:graph:]] &amp;lsquo;&lt;/td&gt;
&lt;td&gt;[:graph:]&lt;/td&gt;
&lt;td&gt;[:graph:]&lt;/td&gt;
&lt;td&gt;[:graph:]&lt;/td&gt;
&lt;td&gt;[:graph:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:print:]&lt;/td&gt;
&lt;td&gt;任何一个可以打印的字符（注意：不包括：[:cntrl:]、字符串结束符&amp;rsquo;\0&amp;rsquo;、EOF 文件结束符（-1）， 但包括空格符号），例如：&amp;rsquo;[[:print:]] &amp;lsquo;&lt;/td&gt;
&lt;td&gt;[:print:]&lt;/td&gt;
&lt;td&gt;[:print:]&lt;/td&gt;
&lt;td&gt;[:print:]&lt;/td&gt;
&lt;td&gt;[:print:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:cntrl:]&lt;/td&gt;
&lt;td&gt;任何一个控制字符（ASCII 字符集中的前 32 个字符，即：用十进制表示为从 0 到31，例如：换行符、制表符等等），例如：&amp;rsquo; [[:cntrl:]]&amp;rsquo;&lt;/td&gt;
&lt;td&gt;[:cntrl:]&lt;/td&gt;
&lt;td&gt;[:cntrl:]&lt;/td&gt;
&lt;td&gt;[:cntrl:]&lt;/td&gt;
&lt;td&gt;[:cntrl:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:punct:]&lt;/td&gt;
&lt;td&gt;任何一个标点符号（不包括：[:alnum:]、[:cntrl:]、[:space:]这些字符集）&lt;/td&gt;
&lt;td&gt;[:punct:]&lt;/td&gt;
&lt;td&gt;[:punct:]&lt;/td&gt;
&lt;td&gt;[:punct:]&lt;/td&gt;
&lt;td&gt;[:punct:]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[:xdigit:]&lt;/td&gt;
&lt;td&gt;任何一个十六进制数（即：0-9，a-f，A-F）&lt;/td&gt;
&lt;td&gt;[:xdigit:]&lt;/td&gt;
&lt;td&gt;[:xdigit:]&lt;/td&gt;
&lt;td&gt;[:xdigit:]&lt;/td&gt;
&lt;td&gt;[:xdigit:]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;js中支持的是EREs.&lt;/li&gt;
&lt;li&gt;当使用 BREs ( 基本正则表达式 ) 时，必须在下列这些符号(?,+,|,{,},(,))前加上转义字符 \ .&lt;/li&gt;
&lt;li&gt;上述[[:xxxx:]] 形式的正则表达式, 是php中内置的通用字符簇, js中并不支持.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;linux-osx下常用命令与正则表达式的关系&#34;&gt;linux/osx下常用命令与正则表达式的关系&lt;/h3&gt;

&lt;p&gt;我曾经尝试在 grep 和 sed 命令中书写正则表达式, 经常发现不能使用元字符, 而且有时候需要转义, 有时候不需要转义, 始终不能摸清它的规律. 如果恰好你也有同样的困惑, 那么请往下看, 相信应该能有所收获.&lt;/p&gt;

&lt;h4 id=&#34;grep-egrep-sed-awk-正则表达式特点&#34;&gt;grep , egrep , sed , awk  正则表达式特点&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;grep 支持：BREs、EREs、PREs 正则表达式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;grep 指令后不跟任何参数, 则表示要使用 &amp;ldquo;BREs&amp;rdquo;&lt;/p&gt;

&lt;p&gt;grep 指令后跟 ”-E&amp;rdquo; 参数, 则表示要使用 &amp;ldquo;EREs&amp;rdquo;&lt;/p&gt;

&lt;p&gt;grep 指令后跟 “-P&amp;rdquo; 参数, 则表示要使用 &amp;ldquo;PREs&amp;rdquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;egrep 支持：EREs、PREs 正则表达式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;egrep 指令后不跟任何参数, 则表示要使用 &amp;ldquo;EREs&amp;rdquo;&lt;/p&gt;

&lt;p&gt;egrep 指令后跟 “-P&amp;rdquo; 参数, 则表示要使用 &amp;ldquo;PREs&amp;rdquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;sed 支持: BREs、EREs&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sed 指令默认是使用 &amp;ldquo;BREs&amp;rdquo;&lt;/p&gt;

&lt;p&gt;sed 指令后跟 &amp;ldquo;-r&amp;rdquo; 参数 , 则表示要使用“EREs&amp;rdquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;awk 支持 EREs, 并且默认使用 &amp;ldquo;EREs&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;正则表达式初阶技能&#34;&gt;正则表达式初阶技能&lt;/h3&gt;

&lt;h4 id=&#34;贪婪模式与非贪婪模式&#34;&gt;贪婪模式与非贪婪模式&lt;/h4&gt;

&lt;p&gt;默认情况下, 所有的限定词都是贪婪模式, 表示尽可能多的去捕获字符; 而在限定词后增加?, 则是非贪婪模式, 表示尽可能少的去捕获字符. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var str = &amp;quot;aaab&amp;quot;,
    reg1 = /a+/, //贪婪模式
    reg2 = /a+?/;//非贪婪模式
console.log(str.match(reg1)); //[&amp;quot;aaa&amp;quot;], 由于是贪婪模式, 捕获了所有的a
console.log(str.match(reg2)); //[&amp;quot;a&amp;quot;], 由于是非贪婪模式, 只捕获到第一个a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var str = &amp;quot;&amp;lt;div class=&#39;v1&#39;&amp;gt;&amp;lt;div class=&#39;v2&#39;&amp;gt;test&amp;lt;/div&amp;gt;&amp;lt;input type=&#39;text&#39;/&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;;
var reg1 = /&amp;lt;div.*&amp;lt;\/div&amp;gt;/; //方案一,贪婪匹配
var reg2 = /&amp;lt;div.*?&amp;lt;\/div&amp;gt;/;//方案二,非贪婪匹配
console.log(str.match(reg1));//&amp;quot;&amp;lt;div class=&#39;v1&#39;&amp;gt;&amp;lt;div class=&#39;v2&#39;&amp;gt;test&amp;lt;/div&amp;gt;&amp;lt;input type=&#39;text&#39;/&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;
console.log(str.match(reg2));//&amp;quot;&amp;lt;div class=&#39;v1&#39;&amp;gt;&amp;lt;div class=&#39;v2&#39;&amp;gt;test&amp;lt;/div&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;区间量词的非贪婪模式&#34;&gt;区间量词的非贪婪模式&lt;/h5&gt;

&lt;p&gt;一般情况下, 非贪婪模式, 我们使用的是&amp;rdquo;*?&amp;ldquo;, 或 &amp;ldquo;+?&amp;rdquo; 这种形式, 还有一种是 &amp;ldquo;{n,m}?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;区间量词&amp;rdquo;{n,m}&amp;rdquo; 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而&amp;rdquo;{n,m}?&amp;rdquo; 则表示在区间范围内, 尽可能少的匹配.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;能达到同样匹配结果的贪婪与非贪婪模式, 通常是贪婪模式的匹配效率较高.&lt;/li&gt;
&lt;li&gt;所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.&lt;/li&gt;
&lt;li&gt;贪婪模式可以与&lt;code&gt;固化分组&lt;/code&gt;(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;分组&#34;&gt;分组&lt;/h4&gt;

&lt;p&gt;正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后可以紧跟限定词表示重复次数. 如下, 小括号内包裹的abc便是一个分组:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/(abc)+/.test(&amp;quot;abc123&amp;quot;) == true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么分组有什么用呢? 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获, 请往下看.&lt;/p&gt;

&lt;h4 id=&#34;捕获性分组&#34;&gt;捕获性分组&lt;/h4&gt;

&lt;p&gt;捕获性分组, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, js中主要是通过 &lt;code&gt;$+编号&lt;/code&gt; 或者 &lt;code&gt;\+编号&lt;/code&gt; 表示法进行引用. 如下便是一个捕获性分组的例子.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var color = &amp;quot;#808080&amp;quot;;
var output = color.replace(/#(\d+)/,&amp;quot;$1&amp;quot;+&amp;quot;~~&amp;quot;);//自然也可以写成 &amp;quot;$1~~&amp;quot;
console.log(RegExp.$1);//808080
console.log(output);//808080~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上, (\d+) 表示一个捕获性分组, &lt;code&gt;RegExp.$1&lt;/code&gt; 指向该分组捕获的内容. &lt;code&gt;$+编号&lt;/code&gt; 这种引用通常在正则表达式之外使用. &lt;code&gt;\+编号&lt;/code&gt; 这种引用却可以在正则表达式中使用, 可用于匹配不同位置相同部分的子串.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var url = &amp;quot;www.google.google.com&amp;quot;;
var re = /([a-z]+)\.\1/;
console.log(url.replace(re,&amp;quot;$1&amp;quot;));//&amp;quot;www.google.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上, 相同部分的&amp;rdquo;google&amp;rdquo;字符串只被替换一次.&lt;/p&gt;

&lt;h4 id=&#34;非捕获性分组&#34;&gt;非捕获性分组&lt;/h4&gt;

&lt;p&gt;非捕获性分组, 通常由一对括号加上&amp;rdquo;?:&amp;ldquo;加上子表达式组成, 非捕获性分组不会创建反向引用, 就好像没有括号一样. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var color = &amp;quot;#808080&amp;quot;;
var output = color.replace(/#(?:\d+)/,&amp;quot;$1&amp;quot;+&amp;quot;~~&amp;quot;);
console.log(RegExp.$1);//&amp;quot;&amp;quot;
console.log(output);//$1~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上, (?:\d+) 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, &lt;code&gt;RegExp.$1&lt;/code&gt; 就指向了空字符串.&lt;/p&gt;

&lt;p&gt;同时, 由于&lt;code&gt;$1&lt;/code&gt; 的反向引用不存在, 因此最终它被当成了普通字符串进行替换.&lt;/p&gt;

&lt;p&gt;实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.&lt;/p&gt;

&lt;h4 id=&#34;命名分组&#34;&gt;命名分组&lt;/h4&gt;

&lt;p&gt;语法: (?&lt;name&gt;&amp;hellip;)&lt;/p&gt;

&lt;p&gt;命名分组也是捕获性分组,  它将匹配的字符串捕获到一个组名称或编号名称中, 在获得匹配结果后, 可通过分组名进行获取. 如下是一个python的命名分组的例子.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re
data = &amp;quot;#808080&amp;quot;
regExp = r&amp;quot;#(?P&amp;lt;one&amp;gt;\d+)&amp;quot;
replaceString = &amp;quot;\g&amp;lt;one&amp;gt;&amp;quot; + &amp;quot;~~&amp;quot;
print re.sub(regExp,replaceString,data) # 808080~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python的命名分组表达式与标准格式相比, 在 ? 后多了一大写的 P 字符, 并且python通过“\g&amp;lt;命名&amp;gt;&amp;ldquo;表示法进行引用. (如果是捕获性分组, python通过&amp;rdquo;\g&amp;lt;编号&amp;gt;&amp;ldquo;表示法进行引用)&lt;/p&gt;

&lt;p&gt;与python不同的是, javaScript 中并不支持命名分组.&lt;/p&gt;

&lt;h4 id=&#34;固化分组&#34;&gt;固化分组&lt;/h4&gt;

&lt;p&gt;固化分组, 又叫原子组.&lt;/p&gt;

&lt;p&gt;语法: (?&amp;gt;&amp;hellip;)&lt;/p&gt;

&lt;p&gt;如上所述, 我们在使用非贪婪模式时, 匹配过程中可能会进行多次的回溯, 回溯越多, 正则表达式的运行效率就越低. 而固化分组就是用来减少回溯次数的.&lt;/p&gt;

&lt;p&gt;实际上, 固化分组(?&amp;gt;…)的匹配与正常的匹配并无分别, 它并不会改变匹配结果. 唯一的不同就是: 固化分组匹配结束时, 它匹配到的文本已经固化为一个单元, 只能作为整体而保留或放弃, 括号内的子表达式中未尝试过的备用状态都会被放弃, 所以回溯永远也不能选择其中的状态(因此不能参与回溯). 下面我们来通过一个例子更好地理解固化分组.&lt;/p&gt;

&lt;p&gt;假如要处理一批数据, 原格式为 123.456, 因为浮点数显示问题, 部分数据格式会变为123.456000000789这种, 现要求只保留小数点后2~3位, 但是最后一位不能为0, 那么这个正则怎么写呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var str = &amp;quot;123.456000000789&amp;quot;;
str = str.replace(/(\.\d\d[1-9]?)\d*/,&amp;quot;$1&amp;quot;); //123.456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的正则, 对于&amp;rdquo;123.456&amp;rdquo; 这种格式的数据, 将白白处理一遍. 为了提高效率, 我们将正则最后的一个&amp;rdquo;*&amp;ldquo;改为&amp;rdquo;+&amp;ldquo;. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var str = &amp;quot;123.456&amp;quot;;
str = str.replace(/(\.\d\d[1-9]?)\d+/,&amp;quot;$1&amp;quot;); //123.45
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时, &amp;ldquo;\d\d[1-9]?&amp;rdquo; 子表达式, 匹配是 &amp;ldquo;45&amp;rdquo;, 而不是 &amp;ldquo;456&amp;rdquo;, 这是因为正则末尾使用了&amp;rdquo;+&amp;ldquo;, 表示末尾至少要匹配一个数字, 因此末尾的子表达式&amp;rdquo;\d+&amp;rdquo; 匹配到了 &amp;ldquo;6&amp;rdquo;. 显然 &amp;ldquo;123.45&amp;rdquo; 不是我们期望的匹配结果, 那我们应该怎么做呢? 能否让 &amp;ldquo;[1-9]?&amp;rdquo; 一旦匹配成功, 便不再进行回溯, 这里就要用到我们上面说的固化分组.&lt;/p&gt;

&lt;p&gt;&amp;rdquo;(\.\d\d(?&amp;gt;[1-9]?))\d+&amp;rdquo; 便是上述正则的固化分组形式. 由于字符串 &amp;ldquo;123.456&amp;rdquo; 不满足该固化分组的正则, 所以, 匹配会失败, 符合我们期望.&lt;/p&gt;

&lt;p&gt;下面我们来分析下固化分组的正则 (\.\d\d(?&amp;gt;[1-9]?))\d+ 为什么匹配不到字符串&amp;rdquo;123.456&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;很明显, 对于上述固化分组, 只存在两种匹配结果.&lt;/p&gt;

&lt;p&gt;情况①: 若 [1-9] 匹配失败, 正则会返回 ? 留下的备用状态. 然后匹配脱离固化分组, 继续前进到[\d+]. 当控制权离开固化分组时, 没有备用状态需要放弃(因固化分组中根本没有创建任何备用状态).&lt;/p&gt;

&lt;p&gt;情况②: 若 [1-9] 匹配成功, 匹配脱离固化分组之后,  ? 保存的备用状态仍然存在, 但是, 由于它属于已经结束的固化分组, 所以会被抛弃.&lt;/p&gt;

&lt;p&gt;对于字符串 &amp;ldquo;123.456&amp;rdquo;, 由于 [1-9] 能够匹配成功, 所以它符合情况②. 下面我们来还原情况②的执行现场.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;匹配所处的状态:  匹配已经走到了 &amp;ldquo;6&amp;rdquo; 的位置, 匹配将继续前进;==&amp;gt;&lt;/li&gt;
&lt;li&gt;子表达式 \d+ 发现无法匹配, 正则引擎便尝试回溯;==&amp;gt;&lt;/li&gt;
&lt;li&gt;查看是否存在备用状态以供回溯?==&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;rdquo;?&amp;rdquo; 保存的备用状态属于已经结束的固化分组, 所以该备用状态会被放弃;==&amp;gt;&lt;/li&gt;
&lt;li&gt;此时固化分组匹配到的 &amp;ldquo;6&amp;rdquo;, 便不能用于正则引擎的回溯;==&amp;gt;&lt;/li&gt;
&lt;li&gt;尝试回溯失败;==&amp;gt;&lt;/li&gt;
&lt;li&gt;正则匹配失败.==&amp;gt;&lt;/li&gt;
&lt;li&gt;文本 &amp;ldquo;123.456&amp;rdquo; 没有被正则表达式匹配上, 符合预期.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;相应的流程图如下:&lt;/p&gt;

&lt;style&gt;

img[src$=&#34;louiszhai.github.io/docImages/regexp02.png&#34;]{height:500px;width:396px;}

&lt;/style&gt;

&lt;p&gt;&lt;img src=&#34;http://louiszhai.github.io/docImages/regexp02.png&#34; alt=&#34;正则表达式流程图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;遗憾的是, javaScript, java 和 python中并不支持固化分组的语法, 不过, 它在php和.NET中表现良好. 下面提供了一个php版的固化分组形式的正则表达式, 以供尝试.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$str = &amp;quot;123.456&amp;quot;;
echo preg_replace(&amp;quot;/(\.\d\d(?&amp;gt;[1-9]?))\d+/&amp;quot;,&amp;quot;\\1&amp;quot;,$str); //固化分组
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不仅如此, php还提供了占有量词优先的语法. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$str = &amp;quot;123.456&amp;quot;;
echo preg_replace(&amp;quot;/(\.\d\d[1-9]?+)\d+/&amp;quot;,&amp;quot;\\1&amp;quot;,$str); //占有量词优先
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然java不支持固化分组的语法, 但java也提供了占有量词优先的语法, 同样能够避免正则回溯. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String str = &amp;quot;123.456&amp;quot;;
System.out.println(str.replaceAll(&amp;quot;(\\.\\d\\d[1-9]?+)\\d+&amp;quot;, &amp;quot;$1&amp;quot;));// 123.456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是: java中 replaceAll 方法需要转义反斜杠.&lt;/p&gt;

&lt;h3 id=&#34;正则表达式高阶技能-零宽断言&#34;&gt;正则表达式高阶技能-零宽断言&lt;/h3&gt;

&lt;p&gt;如果说正则分组是写轮眼, 那么零宽断言就是万花筒写轮眼终极奥义-须佐能乎(这里借火影忍术打个比方). 合理地使用零宽断言, 能够能分组之不能, 极大地增强正则匹配能力, 它甚至可以帮助你在匹配条件非常模糊的情况下快速地定位文本.&lt;/p&gt;

&lt;p&gt;零宽断言, 又叫环视. 环视只进行子表达式的匹配, 匹配到的内容不保存到最终的匹配结果, 由于匹配是零宽度的, 故最终匹配到的只是一个位置.&lt;/p&gt;

&lt;p&gt;环视按照方向划分, 有顺序和逆序两种(也叫前瞻和后瞻), 按照是否匹配有肯定和否定两种, 组合之, 便有4种环视. 4种环视并不复杂, 如下便是它们的描述.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;strong&gt;字符&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(?:&lt;em&gt;pattern&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;非捕获性分组, 匹配pattern的位置, 但不捕获匹配结果.也就是说不创建反向引用, 就好像没有括号一样.&lt;/td&gt;
&lt;td&gt;&amp;lsquo;abcd(?:e)匹配&amp;rsquo;abcde&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(?=&lt;em&gt;pattern&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;顺序肯定环视&lt;/strong&gt;, 匹配后面是pattern 的位置, 不捕获匹配结果.&lt;/td&gt;
&lt;td&gt;&amp;lsquo;Windows (?=2000)&amp;lsquo;匹配 &amp;ldquo;Windows2000&amp;rdquo; 中的 &amp;ldquo;Windows&amp;rdquo;; 不匹配 &amp;ldquo;Windows3.1&amp;rdquo; 中的 &amp;ldquo;Windows&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(?!&lt;em&gt;pattern&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;顺序否定环视&lt;/strong&gt;, 匹配后面不是 pattern 的位置, 不捕获匹配结果.&lt;/td&gt;
&lt;td&gt;&amp;lsquo;Windows (?!2000)&amp;lsquo;匹配 &amp;ldquo;Windows3.1&amp;rdquo; 中的 &amp;ldquo;Windows&amp;rdquo;; 不匹配 &amp;ldquo;Windows2000&amp;rdquo; 中的 &amp;ldquo;Windows&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(?&amp;lt;=&lt;em&gt;pattern&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;逆序肯定环视&lt;/strong&gt;, 匹配前面是 pattern 的位置, 不捕获匹配结果.&lt;/td&gt;
&lt;td&gt;&amp;rsquo;(?&amp;lt;=Office)2000&amp;rsquo;匹配 &amp;ldquo; Office2000&amp;rdquo; 中的 &amp;ldquo;2000&amp;rdquo;; 不匹配 &amp;ldquo;Windows2000&amp;rdquo; 中的 &amp;ldquo;2000&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(?&amp;lt;!&lt;em&gt;pattern&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;逆序否定环视&lt;/strong&gt;, 匹配前面不是 pattern 的位置, 不捕获匹配结果.&lt;/td&gt;
&lt;td&gt;&amp;rsquo;(?&amp;lt;!Office)2000&amp;rsquo;匹配 &amp;ldquo; Windows2000&amp;rdquo; 中的 &amp;ldquo;2000&amp;rdquo;; 不匹配 &amp;ldquo; Office2000&amp;rdquo; 中的 &amp;ldquo;2000&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;非捕获性分组由于结构与环视相似, 故列在表中, 以做对比. 以上4种环视中, 目前 javaScript 中只支持前两种, 也就是只支持 &lt;strong&gt;顺序肯定环视&lt;/strong&gt; 和 &lt;strong&gt;顺序否定环视&lt;/strong&gt;. 下面我们通过实例来帮助理解下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var str = &amp;quot;123abc789&amp;quot;,s;
//没有使用环视,abc直接被替换
s = str.replace(/abc/,456);
console.log(s); //123456789

//使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456
s = str.replace(/3(?=abc)/,3456);
console.log(s); //123456abc789

//使用了顺序否定环视,由于3后面跟着abc,不满意条件,故捕获失败,所以原字符串没有被替换
s = str.replace(/3(?!abc)/,3456);
console.log(s); //123abc789
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面通过python来演示下 &lt;strong&gt;逆序肯定环视&lt;/strong&gt; 和 &lt;strong&gt;逆序否定环视&lt;/strong&gt; 的用法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re
data = &amp;quot;123abc789&amp;quot;
# 使用了逆序肯定环视,替换左边为123的连续的小写英文字母,匹配成功,故abc被替换为456
regExp = r&amp;quot;(?&amp;lt;=123)[a-z]+&amp;quot;
replaceString = &amp;quot;456&amp;quot;
print re.sub(regExp,replaceString,data) # 123456789

# 使用了逆序否定环视,由于英文字母左侧不能为123,故子表达式[a-z]+捕获到bc,最终bc被替换为456
regExp = r&amp;quot;(?&amp;lt;!123)[a-z]+&amp;quot;
replaceString = &amp;quot;456&amp;quot;
print re.sub(regExp,replaceString,data) # 123a456789
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是: python 和 perl 语言中的 &lt;strong&gt;逆序环视&lt;/strong&gt; 的子表达式只能使用定长的文本. 比如将上述 &amp;ldquo;(?&amp;lt;=123)&amp;rdquo; (逆序肯定环视)子表达式写成 &amp;ldquo;(?&amp;lt;=[0-9]+)&amp;ldquo;, python解释器将会报错: &amp;ldquo;error: look-behind requires fixed-width pattern&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;场景回顾&#34;&gt;场景回顾&lt;/h4&gt;

&lt;h5 id=&#34;获取html片段&#34;&gt;获取html片段&lt;/h5&gt;

&lt;p&gt;假如现在, js 通过 ajax 获取到一段 html 代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;var responseText = &amp;quot;&amp;lt;div data=&#39;dev.xxx.txt&#39;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;img src=&#39;dev.xxx.png&#39; /&amp;gt;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现我们需要替换img标签的src 属性中的 &amp;ldquo;dev&amp;rdquo;字符串 为 &amp;ldquo;test&amp;rdquo; 字符串.&lt;/p&gt;

&lt;p&gt;① 由于上述 responseText 字符串中包含至少两个子字符串 &amp;ldquo;dev&amp;rdquo;, 显然不能直接 replace 字符串 &amp;ldquo;dev&amp;rdquo;为 &amp;ldquo;test&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;② 同时由于 js 中不支持逆序环视, 我们也不能在正则中判断前缀为 &amp;ldquo;src=&amp;lsquo;&amp;rdquo;, 然后再替换&amp;rdquo;dev&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;③ 我们注意到 img 标签的 src 属性以 &amp;ldquo;.png&amp;rdquo; 结尾, 基于此, 就可以使用顺序肯定环视. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var reg = /dev(?=[^&#39;]*png)/; //为了防止匹配到第一个dev, 通配符前面需要排除单引号或者是尖括号
var str = responseText.replace(reg,&amp;quot;test&amp;quot;);
console.log(str);//&amp;lt;div data=&#39;dev.xxx&#39;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;img src=&#39;test.xxx.png&#39; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然, 以上不止顺序肯定环视一种解法, 捕获性分组同样可以做到. 那么环视高级在哪里呢? 环视高级的地方就在于它通过一次捕获就可以定位到一个位置, 对于复杂的文本替换场景, 常有奇效, 而分组则需要更多的操作. 请往下看.&lt;/p&gt;

&lt;h5 id=&#34;千位分割符&#34;&gt;千位分割符&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;千位分隔符, 顾名思义, 就是数字中的逗号. 参考西方的习惯, 数字之中加入一个符号, 避免因数字太长难以直观的看出它的值. 故而数字之中, 每隔三位添加一个逗号, 即千位分隔符.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么怎么将一串数字转化为千位分隔符形式呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var str = &amp;quot;1234567890&amp;quot;;
(+str).toLocaleString();//&amp;quot;1,234,567,890&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上, &lt;code&gt;toLocaleString()&lt;/code&gt; 返回当前对象的&amp;rdquo;本地化&amp;rdquo;字符串形式.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果该对象是Number类型, 那么将返回该数值的按照特定符号分割的字符串形式.&lt;/li&gt;
&lt;li&gt;如果该对象是Array类型, 那么先将数组中的每项转化为字符串, 然后将这些字符串以指定分隔符连接起来并返回.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;toLocaleString&lt;/code&gt; 方法特殊, 有本地化特性, 对于天朝, 默认的分隔符是英文逗号. 因此使用它恰好可以将数值转化为千位分隔符形式的字符串. 如果考虑到国际化, 以上方法就有可能会失效了.&lt;/p&gt;

&lt;p&gt;我们尝试使用环视来处理下.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function thousand(str){
  return str.replace(/(?!^)(?=([0-9]{3})+$)/g,&#39;,&#39;);
}
console.log(thousand(str));//&amp;quot;1,234,567,890&amp;quot;
console.log(thousand(&amp;quot;123456&amp;quot;));//&amp;quot;123,456&amp;quot;
console.log(thousand(&amp;quot;1234567879876543210&amp;quot;));//&amp;quot;1,234,567,879,876,543,210&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述使用到的正则分为两块. &lt;code&gt;(?!^)&lt;/code&gt; 和 &lt;code&gt;(?=([0-9]{3})+$)&lt;/code&gt;. 我们先来看后面的部分, 然后逐步分析之.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;ldquo;[0-9]{3}&amp;rdquo; 表示连续3位数字.&lt;/li&gt;
&lt;li&gt;&amp;rdquo;([0-9]{3})+&amp;rdquo; 表示连续3位数字至少出现一次或更多次.&lt;/li&gt;
&lt;li&gt;&amp;rdquo;([0-9]{3})+$&amp;rdquo; 表示连续3的正整数倍的数字, 直到字符串末尾.&lt;/li&gt;
&lt;li&gt;那么 &lt;code&gt;(?=([0-9]{3})+$)&lt;/code&gt; 就表示匹配一个零宽度的位置, 并且从这个位置到字符串末尾, 中间拥有3的正整数倍的数字.&lt;/li&gt;
&lt;li&gt;正则表达式使用全局匹配g, 表示匹配到一个位置后, 它会继续匹配, 直至匹配不到.&lt;/li&gt;
&lt;li&gt;将这个位置替换为逗号, 实际上就是每3位数字添加一个逗号.&lt;/li&gt;
&lt;li&gt;当然对于字符串&amp;rdquo;123456&amp;rdquo;这种刚好拥有3的正整数倍的数字的, 当然不能在1前面添加逗号. 那么使用 &lt;code&gt;(?!^)&lt;/code&gt; 就指定了这个替换的位置不能为起始位置.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;千位分隔符实例, 展示了环视的强大, 一步到位.&lt;/p&gt;

&lt;h3 id=&#34;正则表达式在js中的应用&#34;&gt;正则表达式在JS中的应用&lt;/h3&gt;

&lt;h4 id=&#34;es6对正则的扩展&#34;&gt;ES6对正则的扩展&lt;/h4&gt;

&lt;p&gt;ES6对正则扩展了又两种修饰符(其他语言可能不支持):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;y (粘连sticky修饰符), 与g类似, 也是全局匹配, 并且下一次匹配都是从上一次匹配成功的下一个位置开始, 不同之处在于, g修饰符只要剩余位置中存在匹配即可, 而y修饰符确保匹配必须从剩余的第一个位置开始.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &amp;quot;abc_ab_a&amp;quot;;
var r1 = /[a-z]+/g;
var r2 = /[a-z]+/y;
console.log(r1.exec(s),r1.lastIndex); // [&amp;quot;abc&amp;quot;, index: 0, input: &amp;quot;abc_ab_a&amp;quot;] 3
console.log(r2.exec(s),r2.lastIndex); // [&amp;quot;abc&amp;quot;, index: 0, input: &amp;quot;abc_ab_a&amp;quot;] 3

console.log(r1.exec(s),r1.lastIndex); // [&amp;quot;ab&amp;quot;, index: 4, input: &amp;quot;abc_ab_a&amp;quot;] 6
console.log(r2.exec(s),r2.lastIndex); // null 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上, 由于第二次匹配的开始位置是下标3,  对应的字符串是 &amp;ldquo;_&amp;ldquo;, 而使用y修饰符的正则对象r2, 需要从剩余的第一个位置开始, 所以匹配失败, 返回null.&lt;/p&gt;

&lt;p&gt;正则对象的 sticky 属性, 表示是否设置了y修饰符. 这点将会在后面讲到.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u 修饰符, 提供了对正则表达式添加4字节码点的支持. 比如 &amp;ldquo;𝌆&amp;rdquo; 字符是一个4字节字符, 直接使用正则匹配将会失败, 而使用u修饰符后, 将会等到正确的结果.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &amp;quot;𝌆&amp;quot;;
console.log(/^.$/.test(s));//false
console.log(/^.$/u.test(s));//true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;ucs-2字节码&#34;&gt;UCS-2字节码&lt;/h5&gt;

&lt;p&gt;有关字节码点, 稍微提下. javaScript 只能处理UCS-2编码(js于1995年5月被Brendan Eich花费10天设计出来, 比1996年7月发布的编码规范UTF-16早了一年多, 当时只有UCS-2可选). 由于UCS-2先天不足, 造成了所有字符在js中都是2个字节. 如果是4个字节的字符, 将会默认被当作两个双字节字符处理. 因此 js 的字符处理函数都会受到限制, 无法返回正确结果. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &amp;quot;𝌆&amp;quot;;
console.log(s == &amp;quot;\uD834\uDF06&amp;quot;);//true 𝌆相当于UTF-16中的0xD834DF06
console.log(s.length);//2 长度为2, 表示这是4字节字符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幸运的是, ES6可以自动识别4字节的字符.因此遍历字符串可以直接使用for of循环. 同时, js中如果直接使用码点表示Unicode字符, 对于4字节字符, ES5里是没办法识别的. 为此ES6修复了这个问题, 只需将码点放在大括号内即可.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(s === &amp;quot;\u1D306&amp;quot;);//false   ES5无法识别𝌆
console.log(s === &amp;quot;\u{1D306}&amp;quot;);//true  ES6可以借助大括号识别𝌆
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;附-es6新增的处理4字节码的函数&#34;&gt;附: ES6新增的处理4字节码的函数&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;String.fromCodePoint()&lt;/strong&gt;：从Unicode码点返回对应字符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String.prototype.codePointAt()&lt;/strong&gt;：从字符返回对应的码点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String.prototype.at()&lt;/strong&gt;：返回字符串给定位置的字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关js中的unicode字符集, 请参考阮一峰老师的 &lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/12/unicode.html&#34;&gt;&lt;code&gt;Unicode与JavaScript详解&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;以上是ES6对正则的扩展. 另一个方面, 从方法上看, javaScript 中与正则表达式有关的方法有:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名&lt;/th&gt;
&lt;th&gt;compile&lt;/th&gt;
&lt;th&gt;test&lt;/th&gt;
&lt;th&gt;exec&lt;/th&gt;
&lt;th&gt;match&lt;/th&gt;
&lt;th&gt;search&lt;/th&gt;
&lt;th&gt;replace&lt;/th&gt;
&lt;th&gt;split&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;所属对象&lt;/td&gt;
&lt;td&gt;RegExp&lt;/td&gt;
&lt;td&gt;RegExp&lt;/td&gt;
&lt;td&gt;RegExp&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由上, 一共有7个与js相关的方法, 这些方法分别来自于 RegExp 与 String 对象. 首先我们先来看看js中的正则类 RegExp.&lt;/p&gt;

&lt;h4 id=&#34;regexp&#34;&gt;RegExp&lt;/h4&gt;

&lt;p&gt;RegExp 对象表示正则表达式, 主要用于对字符串执行模式匹配.&lt;/p&gt;

&lt;p&gt;语法: new RegExp(pattern[, flags])&lt;/p&gt;

&lt;p&gt;参数 &lt;em&gt;pattern&lt;/em&gt; 是一个字符串, 指定了正则表达式字符串或其他的正则表达式对象.&lt;/p&gt;

&lt;p&gt;参数 &lt;em&gt;flags&lt;/em&gt; 是一个可选的字符串, 包含属性 &amp;ldquo;g&amp;rdquo;、&amp;rdquo;i&amp;rdquo; 和 &amp;ldquo;m&amp;rdquo;, 分别用于指定全局匹配、区分大小写的匹配和多行匹配. 如果&lt;em&gt;pattern&lt;/em&gt; 是正则表达式, 而不是字符串, 则必须省略该参数.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var pattern = &amp;quot;[0-9]&amp;quot;;
var reg = new RegExp(pattern,&amp;quot;g&amp;quot;);
// 上述创建正则表达式对象,可以用对象字面量形式代替,也推荐下面这种
var reg = /[0-9]/g;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上, 通过对象字面量和构造函数创建正则表达式, 有个小插曲.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;对于正则表达式的直接量, ECMAscript 3规定在每次它时都会返回同一个RegExp对象, 因此用直接量创建的正则表达式的会共享一个实例. 直到ECMAScript 5才规定每次返回不同的实例.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;所以, 现在我们基本不用担心这个问题, 只需要注意在低版本的非IE浏览器中尽量使用构造函数创建正则(这点上, IE一直遵守ES5规定, 其他浏览器的低级版本遵循ES3规定).&lt;/p&gt;

&lt;p&gt;RegExp 实例对象包含如下属性:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;实例属性&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;global&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;是否包含全局标志(true/false)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ignoreCase&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;是否包含区分大小写标志(true/false)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;multiline&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;是否包含多行标志(true/false)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;source&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回创建RegExp对象实例时指定的表达式文本字符串形式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;lastIndex&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;表示原字符串中匹配的字符串末尾的后一个位置, 默认为0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;flags(ES6)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;返回正则表达式的修饰符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;sticky(ES6)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;是否设置了y(粘连)修饰符(true/false)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;compile&#34;&gt;compile&lt;/h5&gt;

&lt;p&gt;compile 方法用于在执行过程中改变和重新编译正则表达式.&lt;/p&gt;

&lt;p&gt;语法: compile(pattern[, flags])&lt;/p&gt;

&lt;p&gt;参数介绍请参考上述 RegExp 构造器. 用法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var reg = new RegExp(&amp;quot;abc&amp;quot;, &amp;quot;gi&amp;quot;);
var reg2 = reg.compile(&amp;quot;new abc&amp;quot;, &amp;quot;g&amp;quot;);
console.log(reg);// /new abc/g
console.log(reg2);// undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见 compile 方法会改变原正则表达式对象, 并重新编译, 而且它的返回值为空.&lt;/p&gt;

&lt;h5 id=&#34;test&#34;&gt;test&lt;/h5&gt;

&lt;p&gt;test 方法用于检测一个字符串是否匹配某个正则规则, 只要是字符串中含有与正则规则匹配的文本, 该方法就返回true, 否则返回 false.&lt;/p&gt;

&lt;p&gt;语法: test(string), 用法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(/[0-9]+/.test(&amp;quot;abc123&amp;quot;));//true
console.log(/[0-9]+/.test(&amp;quot;abc&amp;quot;));//false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上, 字符串&amp;rdquo;abc123&amp;rdquo; 包含数字, 故 test 方法返回 true; 而 字符串&amp;rdquo;abc&amp;rdquo; 不包含数字, 故返回 false.&lt;/p&gt;

&lt;p&gt;如果需要使用 test 方法测试字符串是否完成匹配某个正则规则, 那么可以在正则表达式里增加开始(^)和结束($)元字符. 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(/^[0-9]+$/.test(&amp;quot;abc123&amp;quot;));//false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上, 由于字符串&amp;rdquo;abc123&amp;rdquo; 并非以数字开始, 也并非以数字结束, 故 test 方法返回false.&lt;/p&gt;

&lt;p&gt;实际上, 如果正则表达式带有全局标志(带有参数g)时, test 方法还受正则对象的lastIndex属性影响,如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var reg = /[a-z]+/;//正则不带全局标志
console.log(reg.test(&amp;quot;abc&amp;quot;));//true
console.log(reg.test(&amp;quot;de&amp;quot;));//true

var reg = /[a-z]+/g;//正则带有全局标志g
console.log(reg.test(&amp;quot;abc&amp;quot;));//true
console.log(reg.lastIndex);//3, 下次运行test时,将从索引为3的位置开始查找
console.log(reg.test(&amp;quot;de&amp;quot;));//false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该影响将在exec 方法讲解中予以分析.&lt;/p&gt;

&lt;h5 id=&#34;exec&#34;&gt;exec&lt;/h5&gt;

&lt;p&gt;exec 方法用于检测字符串对正则表达式的匹配, 如果找到了匹配的文本, 则返回一个结果数组, 否则返回null.&lt;/p&gt;

&lt;p&gt;语法: exec(string)&lt;/p&gt;

&lt;p&gt;exec 方法返回的数组中包含两个额外的属性, index 和 input. 并且该数组具有如下特点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第 0 个项表示正则表达式捕获的文本&lt;/li&gt;
&lt;li&gt;第 1~n 项表示第 1~n 个反向引用, 依次指向第 1~n 个分组捕获的文本, 可以使用RegExp.$ + &amp;ldquo;编号1~n&amp;rdquo;  依次获取分组中的文本&lt;/li&gt;
&lt;li&gt;index 表示匹配字符串的初始位置&lt;/li&gt;
&lt;li&gt;input 表示正在检索的字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论正则表达式有无全局标示&amp;rdquo;g&amp;rdquo;, exec 的表现都相同. 但正则表达式对象的表现却有些不同. 下面我们来详细说明下正则表达式对象的表现都有哪些不同.&lt;/p&gt;

&lt;p&gt;假设正则表达式对象为 reg , 检测的字符为 string , reg.exec(string) 返回值为 array.&lt;/p&gt;

&lt;p&gt;若 reg 包含全局标示&amp;rdquo;g&amp;rdquo;, 那么 reg.lastIndex 属性表示原字符串中匹配的字符串末尾的后一个位置, 即下次匹配开始的位置, 此时 reg.lastIndex == array.index(匹配开始的位置) + array[0].length(匹配字符串的长度). 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var reg = /([a-z]+)/gi,
    string = &amp;quot;World Internet Conference&amp;quot;;
var array = reg.exec(string);
console.log(array);//[&amp;quot;World&amp;quot;, &amp;quot;World&amp;quot;, index: 0, input: &amp;quot;World Internet Conference&amp;quot;]
console.log(RegExp.$1);//World
console.log(reg.lastIndex);//5, 刚好等于 array.index + array[0].length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随着检索继续, array.index 的值将往后递增, 也就是说, reg.lastIndex 的值也会同步往后递增. 因此, 我们也可以通过反复调用 exec 方法来遍历字符串中所有的匹配文本. 直到 exec 方法再也匹配不到文本时, 它将返回 null, 并把 reg.lastIndex 属性重置为 0.&lt;/p&gt;

&lt;p&gt;接着上述例子, 我们继续执行代码, 看看上面说的对不对, 如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;array = reg.exec(string);
console.log(array);//[&amp;quot;Internet&amp;quot;, &amp;quot;Internet&amp;quot;, index: 6, input: &amp;quot;World Internet Conference&amp;quot;]
console.log(reg.lastIndex);//14

array = reg.exec(string);
console.log(array);//[&amp;quot;Conference&amp;quot;, &amp;quot;Conference&amp;quot;, index: 15, input: &amp;quot;World Internet Conference&amp;quot;]
console.log(reg.lastIndex);//25

array = reg.exec(string);
console.log(array);//null
console.log(reg.lastIndex);//0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码中, 随着反复调用 exec 方法, reg.lastIndex 属性最终被重置为 0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题回顾&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 test 方法的讲解中, 我们留下了一个问题. 如果正则表达式带有全局标志g, 以上 test 方法的执行结果将受 reg.lastIndex影响, 不仅如此, exec 方法也一样. 由于 reg.lastIndex 的值并不总是为零, 并且它决定了下次匹配开始的位置, 如果在一个字符串中完成了一次匹配之后要开始检索新的字符串, 那就必须要手动地把 lastIndex 属性重置为 0. 避免出现下面这种错误:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var reg = /[0-9]+/g,
    str1 = &amp;quot;123abc&amp;quot;,
    str2 = &amp;quot;123456&amp;quot;;
reg.exec(str1);
console.log(reg.lastIndex);//3
var array = reg.exec(str2);
console.log(array);//[&amp;quot;456&amp;quot;, index: 3, input: &amp;quot;123456&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码, 正确执行结果应该是 &amp;ldquo;123456&amp;rdquo;,  因此建议在第二次执行 exec 方法前, 增加一句 &amp;ldquo;reg.lastIndex = 0;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;若 reg 不包含全局标示&amp;rdquo;g&amp;rdquo;, 那么 exec 方法的执行结果(array)将与 string.match(reg) 方法执行结果完全相同.&lt;/p&gt;

&lt;h4 id=&#34;string&#34;&gt;String&lt;/h4&gt;

&lt;p&gt;match, search, replace, split 方法请参考 &lt;a href=&#34;http://louiszhai.github.io/2016/01/12/js.String/&#34;&gt;&lt;code&gt;字符串常用方法&lt;/code&gt;&lt;/a&gt; 中的讲解.&lt;/p&gt;

&lt;p&gt;如下展示了使用捕获性分组处理文本模板, 最终生成完整字符串的过程:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var tmp = &amp;quot;An ${a} a ${b} keeps the ${c} away&amp;quot;;
var obj = {
  a:&amp;quot;apple&amp;quot;,
  b:&amp;quot;day&amp;quot;,
  c:&amp;quot;doctor&amp;quot;
};
function tmpl(t,o){
  return t.replace(/\${(.)}/g,function(m,p){
    console.log(&#39;m:&#39;+m+&#39; p:&#39;+p);
    return o[p];
  });
}
tmpl(tmp,obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述功能使用ES6可这么实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {
  a:&amp;quot;apple&amp;quot;,
  b:&amp;quot;day&amp;quot;,
  c:&amp;quot;doctor&amp;quot;
};
with(obj){
  console.log(`An ${a} a ${b} keeps the ${c} away`);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;正则表达式在h5中的应用&#34;&gt;正则表达式在H5中的应用&lt;/h3&gt;

&lt;p&gt;H5中新增了 pattern 属性, 规定了用于验证输入字段的模式, pattern的模式匹配支持正则表达式的书写方式. 默认 pattern 属性是全部匹配, 即无论正则表达式中有无 &amp;ldquo;^&amp;rdquo;, &amp;ldquo;$&amp;rdquo; 元字符, 它都是匹配所有文本.&lt;/p&gt;

&lt;p&gt;注: pattern 适用于以下 input 类型：text, search, url, telephone, email 以及 password. 如果需要取消表单验证, 在form标签上增加 novalidate 属性即可.&lt;/p&gt;

&lt;h3 id=&#34;正则引擎&#34;&gt;正则引擎&lt;/h3&gt;

&lt;p&gt;目前正则引擎有两种, DFA 和 NFA, NFA又可以分为传统型NFA和POSIX NFA.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DFA Deterministic finite automaton 确定型有穷自动机&lt;/li&gt;
&lt;li&gt;NFA Non-deterministic finite automaton　非确定型有穷自动机&lt;/li&gt;
&lt;li&gt;Traditional NFA&lt;/li&gt;
&lt;li&gt;POSIX NFA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DFA引擎不支持回溯, 匹配快速, 并且不支持捕获组, 因此也就不支持反向引用. 上述awk, egrep命令均支持 DFA引擎.&lt;/p&gt;

&lt;p&gt;POSIX NFA主要指符合POSIX标准的NFA引擎, 像 javaScript, java, php, python, c#等语言均实现了NFA引擎.&lt;/p&gt;

&lt;p&gt;有关正则表达式详细的匹配原理, 暂时没在网上看到适合的文章, 建议选读 Jeffrey Friedl 的 &amp;lt;精通正则表达式&amp;gt;[第三版] 中第4章-表达式的匹配原理(p143-p183), Jeffrey Friedl 对正则表达式有着深刻的理解, 相信他能够帮助您更好的学习正则.&lt;/p&gt;

&lt;p&gt;有关NFA引擎的简单实现, 可以参考文章 &lt;a href=&#34;http://www.cnblogs.com/catch/p/3722082.html&#34;&gt;基于ε-NFA的正则表达式引擎 - twoon&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;在学习正则的初级阶段, 重在理解 ①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组, ④命名分组, ⑤固化分组, 体会设计的精妙之处. 而高级阶段, 主要在于熟练运用⑥零宽断言(或环视)解决问题, 并且熟悉正则匹配的原理.&lt;/p&gt;

&lt;p&gt;实际上, 正则在 javaScript 中的功能不算强大, js 仅仅支持了①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组 以及 ⑥零宽断言中的顺序环视. 如果再稍微熟悉些 js 中7种与正则有关的方法(compile, test, exec, match, search, replace, split), 那么处理文本或字符串将游刃有余.&lt;/p&gt;

&lt;p&gt;正则表达式, 在文本处理方面天赋异禀, 它的功能十分强大, 很多时候甚至是唯一解决方案. 正则不局限于js, 当下热门的编辑器(比如Sublime, Atom) 以及 IDE(比如WebStorm, IntelliJ IDEA) 都支持它. 您甚至可以在任何时候任何语言中, 尝试使用正则解决问题, 也许之前不能解决的问题, 现在可以轻松的解决.&lt;/p&gt;

&lt;p&gt;附其他语言正则资料:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.ubuntu.org.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97&#34;&gt;Python正则表达式操作指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/allwefantasy/article/details/3136570/&#34;&gt;java正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与&lt;a href=&#34;#respond&#34;&gt;留言和评论&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;本文作者: &lt;a href=&#34;https://github.com/Louiszhai&#34;&gt;louis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文简介: 本文断断续续历时两个月而成, 共计12k字, 为求简洁全面地还原前端场景中正则的使用规律, 搜集了大量正则相关资料, 并剔除不少冗余字句, 码字不易, 喜欢的请点个赞👍或者收藏, 我将持续保持更新.&lt;/p&gt;

&lt;p&gt;本文链接: &lt;a href=&#34;http://louiszhai.github.io/2016/06/13/regular/&#34;&gt;http://louiszhai.github.io/2016/06/13/regular/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文章&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Jeffrey Friedl 的 &amp;lt;精通正则表达式&amp;gt;[第三版]&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/fdl19881/article/details/7800877&#34;&gt;linux shell 正则表达式(BREs,EREs,PREs)差异比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jb51.net/article/28035.htm&#34;&gt;正则表达式之捕获组/非捕获组介绍_正则表达式_脚本之家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/kissdodog/archive/2013/04/22/3036649.html&#34;&gt;正则表达式(一) &amp;ndash; 元字符 - 逆心 - 博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/hguisu/article/details/8244560&#34;&gt;正则表达式详解 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/taek/archive/2012/02/08/2342741.html&#34;&gt;正则表达式之固化分组 - taek - 博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jb51.net/article/31491.htm&#34;&gt;正则表达式之 贪婪与非贪婪模式详解（概述）_正则表达式_脚本之家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/nebula1982/article/details/6659702&#34;&gt;JAVASCRIPT 正则表达式学习&amp;ndash;&amp;gt;基础与零宽断言（转自司徒正美） - 随风之羽 - 博客频道 - CSDN.NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/12/unicode.html&#34;&gt;Unicode与JavaScript详解 - 阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:u4e00-u9fa5&#34;&gt;\u4e00-\u9fa5 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:u4e00-u9fa5&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
        <item>
            <title>职业教育解决方案</title>
            <link>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E7%94%B5%E5%95%86/2016-06-01-%E8%81%8C%E4%B8%9A%E6%95%99%E8%82%B2/</link>
            <pubDate>Mon, 12 Jun 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E7%94%B5%E5%95%86/2016-06-01-%E8%81%8C%E4%B8%9A%E6%95%99%E8%82%B2/</guid>
            <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;瑞森教育 &lt;a href=&#34;http://www.1234567890.cc&#34;&gt;http://www.1234567890.cc&lt;/a&gt;
功能比较全，但是比较老气 研发风格不适合现代。代表网站 中国职教城网 &lt;a href=&#34;http://www.vecity.cn/&#34;&gt;http://www.vecity.cn/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;慕课先生 &lt;a href=&#34;http://mooc.101.com/&#34;&gt;http://mooc.101.com/&lt;/a&gt;
视频教育 偏向于职业教育大学 公共课程,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;智慧职教 &lt;a href=&#34;http://www.icve.com.cn&#34;&gt;http://www.icve.com.cn&lt;/a&gt;
视频教育 专业课程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;行知学徒网 &lt;a href=&#34;http://www.ixueto.com&#34;&gt;http://www.ixueto.com&lt;/a&gt;
视频直播教育 偏职业教育专业课程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;职教mooc &lt;a href=&#34;http://www.icourses.cn/vemooc/&#34;&gt;http://www.icourses.cn/vemooc/&lt;/a&gt;
视频教育 公共课程+专业课程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;山东职业教育平台 &lt;a href=&#34;http://zyjy.sdei.edu.cn&#34;&gt;http://zyjy.sdei.edu.cn&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;中国职业教育云平台 &lt;a href=&#34;http://www.worlduc.com/zhijiao/index.aspx&#34;&gt;http://www.worlduc.com/zhijiao/index.aspx&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
