---
title:  (双引号)与(单引号)的区别
date: 2016-01-09T14:01:36+08:00
update: 2016-01-01
categories:
tags:
---
## (双引号")与 (单引号')的区别

　
　　你在shell prompt后面敲打键盘、直到按下enter的时候，你输入的文字就是command line了，然后shell才会以进程方式执行你所提交的命令。但是，你又可知道：你在command line输入的每一个文字，对shell来说，有什么类别之分呢？

简单而言，command line的每一个charactor分为如下两种：
   *literal：也就是普通纯文字，对shell来说没有特殊功能。
   *meta：对shell来说，具有特定功能的保留字。
literal没有什么好说的，凡是 abcd、123456 等这些“文字”都是literal。但是meta确常使我们困惑。事实上，前两章我们在command line中已碰到两个几乎每次都会碰到的meta：
    *IFS：由<space> <tab> <enter>三者之一组成（我们常用space）。
    *CR：由<enter>产生。
IFS是用来拆分command line的每一个词（word）用的，因为shell command line是按词来处理的。而CR则是用来结束command line用的，这也是为何我们敲<enter>命令就会执行的原因。除了IFS和CR外，常用的meta还有：
= ：  设定变量。
$ ：  做变量或运算替换(请不要与 shell prompt 搞混了)。
> ：  重定向 stdout。
> < ：  重定向 stdin。
> |：   管道命令。
> & ：  重定向 file descriptor ，或将命令置于后台执行。
> ( )： 將其內的命令置于 nested subshell 执行，或用于运算或命令替换。
> { }： 將其內的命令置于 non-named function 中执行，或用在变量替换的界定范围。
> ; ：  在前一个命令结束时，而忽略其返回值，继续执行下一個命令。
> && ： 在前一個命令结束时，若返回值为 true，继续执行下一個命令。
> || ： 在前一個命令结束时，若返回值为 false，继续执行下一個命令。
> !：   执行 history 列表中的命令
> ....
> 假如我们要在command line中将这些保留元字符的功能关闭的话，就要用到 quoting 处理了。
> 在bash中，我们常用的 quoting有如下三种方法：
    *hard quote：''（单引号），凡在hard quote中的所有meta均被关闭。
    *soft quote：""（双引号），在soft quote中的大部分meta都会被关闭，但某些保留（如$）。
    *escape：\ （反斜线），只有紧接在escape（跳脱字符）之后的单一meta才被关闭。

下面的例子將有助于我们对 quoting 的了解：

        $ A=B C        # 空白键未被关闭，作为IFS 处理。
        $ C: command not found.
        $ echo $A
    
        $ A="B C"        # 空白键已被关闭，仅作空白符号处理。
        $ echo $A
        B C

在第一次设定 A 变量时，由于空白键没有被关闭，command line 将被解读为：
* A=B 然后碰到<IFS>，再执行 C 命令
  在第二次设定 A 变量时，由于空白键置于 soft quote 中，因此被关闭，不再作为 IFS ：
* A=B<space>C
  事实上，空白键无论在 soft quote 还是在 hard quote 中，均会被关闭。Enter 鍵亦然：
        $ A='B
        > C
        > '
        $ echo "$A"
        B
        C

在上例中，由于 <enter> 被置于 hard quote 当中，因此不再作为 CR 字符來处理。
这里的 <enter> 单纯只是一个断行符号(new-line)而已，由于 command line 并沒得到 CR 字符，
因此进入第二個 shell prompt (PS2，以 > 符号表示)，command line 并不会结束，
直到第三行，我们输入的 <enter> 并不在  hard quote 里面，因此并沒被关闭，
此时，command line 碰到 CR 字符，于是结束、交给 shell 來处理。

上例的 <enter> 要是被置于 soft quote 中的话， CR 也会同样被关闭：
        $ A="B
        > C
        > "
        $ echo $A
        B C

然而，由于 echo $A 时的变量沒置于 soft quote 中，因此当变量替换完成后并作命令行重组时，<enter> 会被解释为 IFS ，而不是解释为 New Line 字符。

同样的，用 escape 亦可关闭 CR 字符：
        $ A=B\
        > C\
        >
        $ echo $A
        BC

上例中，第一个 <enter> 跟第二个 <enter> 均被 escape 字符关闭了，因此也不作为 CR 來处理，
但第三个 <enter> 由于没有被跳脱，因此作为 CR 结束 command line 。
但由于 <enter> 鍵本身在 shell meta 中的特殊性，在 \ 跳脱后面，仅仅取消其 CR 功能，而不会保留其 IFS 功能。

您或许发现光是一个 <enter> 鍵所产生的字符就有可能是如下这些可能：
CR
IFS
NL(New Line)
FF(Form Feed)
NULL
...


至于 soft quote 跟 hard quote 的不同，主要是对于某些 meta 的关闭与否，以 $ 來作说明：
        $ A=B\ C
        $ echo "$A"
        B C
        $ echo '$A'
        $A

在第一个 echo 命令行中，$ 被置于 soft quote 中，將不被关闭，因此继续处理变量替换，
因此 echo 將 A 的变量值输出到屏幕，也就得到  "B C" 的结果。
在第二个 echo 命令行中，$ 被置于 hard quote 中，则被关闭，因此 $ 只是一个 $ 符号，
并不会用來作变量替换处理，因此结果是 $ 符号后面接一个 A 字母：$A 。

--------------------------------------
练习与思考：如下结果为何不同？
        $ A=B\ C
        $ echo '"$A"'        # 最外面的是单引号
        "$A"
        $ echo "'$A'"        # 最外面的是双引号
        'B C'

--------------------------------------

在 CU 的 shell 版里，我发现有很多初学者的问题，都与 quoting 理解的有关。
比方说，若我们在 awk 或 sed 的命令参数中调用之前设定的一些变量时，常会问及为何不能的问题。
要解决这些问题，关键点就是：
* 区分出 shell meta 与 command meta

前面我们提到的那些 meta ，都是在 command line 中有特殊用途的，
比方说 { } 是將其內一系列 command line 置于不具名的程序中执行(可简单视为 command block )，
但是，awk 却需要用 { } 來区分出 awk 的命令区段(BEGIN, MAIN, END)。
若你在 command line 中如此输入：
$ awk {print $0} 1.txt

由于  { } 在 shell 中并没关闭，那 shell 就將 {print $0} 视为 command block ，
但同时又沒有" ; "符号作命令区隔，因此就出现 awk 的语法错误結果。

要解決之，可用 hard quote ：

$ awk '{print $0}' 1.txt

上面的 hard quote 应好理解，就是將原本的 {、<space>、$(注三)、} 这几个 shell meta 关闭，
避免掉在 shell 中遭到处理，而完整的成为 awk 参数中的 command meta 。
( 注三：而其中的 $0 是 awk 內建的 field number ，而非  awk 的变量，
awk 自身的变量无需使用 $ 。)
要是理解了 hard quote 的功能，再來理解 soft quote 与 escape 就不难：

awk "{print \$0}" 1.txt
awk \{print\ \$0\} 1.txt

然而，若你要改变 awk 的 $0 的 0 值是从另一个 shell 变量读进呢？
比方说：已有变量 $A 的值是 0 ，那如何在 command line 中解決 awk 的 $$A 呢？
你可以很直接否定掉 hard quoe 的方案：

$ awk '{print $$A}' 1.txt

那是因为 $A 的 $ 在 hard quote 中是不能替换变量的。

聪明的读者(如你!)，经过本章学习，我想，应该可以解释为何我们可以使用如下操作了吧：

A=0
awk "{print \$$A}" 1.txt
awk \{print\ \$$A\} 1.txt
awk '{print $'$A'}' 1.txt
awk '{print $'"$A"'}' 1.txt     # 注："$A" 包在 soft quote 中


单引号和双引号都能关闭shell对特殊字符的处理。不同的是，双引号没有单引号严格，单引号关闭所有有特殊作用的字符，而双引号只要求shell忽略大多数，具体的说，就是①美元符号②反引号③反斜杠，这3种特殊字符不被忽略。 不忽略美元符号意味着shell在双引号内部也进行变量名替换。

下面用一个简单的shell程序要说明一下。

debian:~/learn/shell# cat phonebook

Alice Chebba 973-555-2015

Barbara Swingle 201-555-9257

Liz Stachiw 212-555-2298

Susan Goldberg 201-555-7776

Susan Topple 212-555-4932

Tony Iannino 973-555-1295

Stromboli Pizza 973-555-9478

debian:~/learn/shell#

debian:~/learn/shell# cat lu

# Look someone up in the phone book

grep "$1" phonebook

debian:~/learn/shell#

这是正确的lu程序，下面是运行结果。

debian:~/learn/shell# ./lu 'Susan T'

Susan Topple 212-555-4932

debian:~/learn/shell# ./lu Tony

Tony Iannino 973-555-1295

debian:~/learn/shell#

如果lu写成①grep $1 phonebook或者②grep '$1' phonebook，就会出现下面的错误结果（为什么？）。

①的结果：

debian:~/learn/shell# ./lu Tony //这种情况结果正确

Tony Iannino 973-555-1295

debian:~/learn/shell# ./lu 'Susan T' //这种情况结果错误

grep: T: No such file or directory

phonebook:Susan Goldberg 201-555-7776

phonebook:Susan Topple 212-555-4932

debian:~/learn/shell#

②的结果：

debian:~/learn/shell# ./lu Tony //这种情况结果错误

debian:~/learn/shell# ./lu 'Susan T' //这种情况结果也错误

debian:~/learn/shell#
