---
title: STM32_GPIO模式
date: 2015-12-04T10:54:16+08:00
update: 2016-01-01
categories: [嵌入式STM32]
tags: [stm32,GPIO]
---
所有的开漏输出都需要接上拉电阻。

 ## 1、普通推挽输出（GPIO_Mode_Out_PP）:
使用场合：一般用在0V和3.3V的场合。线路经过两个P_MOS 和N_MOS 管，负责上拉和下拉电流。
使用方法：直接使用
输出电平：推挽输出的低电平是0V，高电平是3.3V。
## 2、普通开漏输出（GPIO_Mode_Out_OD）：
使用场合：一般用在电平不匹配的场合，如需要输出5V的高电平。
使用方法：就需要再外部接一个上拉电阻，电源为5V，把GPIO设置为开漏模式， 当输出高组态时，由上拉电阻和电源向外输出5V的电压。
输出电平：在开漏输出模式时，如果输出为0，低电平，则使N_MOS 导通，使输 出接地。若控制输出为1（无法直接输出高电平），则既不输出高电平 也不输出低电平，为高组态。为正常使用，必须在外部接一个上拉电 阻。
特性： 它具“线与”特性，即很多个开漏模式 引脚连接到一起时，只有当所有 引脚都输出高阻态，才由上拉电阻提供高电平，此高电平的电压为外部 上拉电阻所接的电源的电压。若其中一个引脚为低电平，那线路就相当 于短路接地，使得整条线路都为低电平，0 伏。
## 3、复用推挽输出（GPIO_Mode_AF_PP）:用作串口的输出。
## 4、复用开漏输出（GPIO_Mode_AF_OD）：用在IIC。


STM8 GPIO测试

    GPIO_Init(GPIOD, (GPIO_Pin_TypeDef)GPIO_PIN_4, GPIO_MODE_OUT_PP_HIGH_FAST);
    while(1){
        GPIOD->ODR=0;
        GPIOD->ODR=0x10;
        GPIOD->ODR=1;
        GPIOD->ODR=0x10;
        GPIOD->ODR=2;
        GPIOD->ODR=0x10;
        GPIOD->ODR=3;
        GPIOD->ODR=0x10;
    }
    转换频率 3.937MHZ 周期 254ns 上升时间 22ns 下降时间 26ns
GPIO_MODE_OUT_PP_HIGH_SLOW
  转换频率 3.968MHZ 周期 252ns 上升时间 30ns 下降时间 30ns


STM32 GPIO测试

    GPIO_InitTypeDef GPIO_InitStructure; //定义结构体
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    GPIO_Init(GPIOE, &GPIO_InitStructure);

    while(1){
    GPIOE->BRR = GPIO_Pin_2;
    GPIOE->BSRR = GPIO_Pin_2;
    GPIOE->BRR = GPIO_Pin_2;
    GPIOE->BSRR = GPIO_Pin_2;
    GPIOE->BRR = GPIO_Pin_2;
    GPIOE->BSRR = GPIO_Pin_2;
    GPIOE->BRR = GPIO_Pin_2;
    GPIOE->BSRR = GPIO_Pin_2;
    GPIOE->BRR = GPIO_Pin_2;
    GPIOE->BSRR = GPIO_Pin_2;
    }
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 转换频率 12MHZ 周期 83.2ns 上升时间 15ns 下降时间 15ns
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 转换频率 11.96MHZ 周期 83.2ns 上升时间 20ns 下降时间 20ns


STM8 中断时间解析
    __IO uint32_t g_uiDelayCount = 0;
    extern void SysTick_ISR(void);
    INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 23)
    {

            TIM4->SR1 = (uint8_t)(~TIM4_IT_UPDATE
    }
执行一次中断 2.2us
TIM4->SR1 = (uint8_t)(~TIM4_IT_UPDATE

执行一次全局赋值 12.6us
g_uiDelayCount++;

一次函数调用 11 us
    TIM4_ClearITPendingBit(TIM4_IT_UPDATE);
10us
2. 中断频率 1分频 160 us 一次中断 20us    中断时间
2. 中断频率 2分频 80 us 一次中断 20us     中断时间
2. 中断频率 4分频 40 us 一次中断 20.8us   中断时间
2. 中断频率 8分频 20 us 一次中断 20.8us   中断时间
2. 中断频率 16分频 10 us 一次中断 21.6us  中断时间
20us
3. 中断频率 2分频 160 us 一次中断 20us    中断时间 18.4
3. 中断频率 4分频 80 us 一次中断 20.8us   中断时间
3. 中断频率 8分频 40 us 一次中断 20.8us   中断时间
3. 中断频率 16分频 20 us 一次中断 21.6us  中断时间
3. 中断频率 32分频 10 us 一次中断 20us    中断时间

40us
3. 中断频率 4分频  160 us 一次中断 41.2us 中断时间 18.4
3. 中断频率 8分频  80 us 一次中断         中断时间
3. 中断频率 16分频 40 us 一次中断         中断时间
3. 中断频率 32分频 20 us 一次中断         中断时间
3. 中断频率 64分频 10 us 一次中断         中断时间
50us
3. 中断频率 4分频  200us 一次中断 52     中断时间 17.6
3. 中断频率 8分频  100us 一次中断 52     中断时间 17.6
3. 中断频率 16分频 50 us 一次中断 52    中断时间 17.6
3. 中断频率 32分频 25 us 一次中断         中断时间
80us
3. 中断频率 8分频  160us 一次中断 82.4us  中断时间 17.6 12.8 1.28 11.2
3. 中断频率 16分频 80 us 一次中断         中断时间
3. 中断频率 32分频 40 us 一次中断         中断时间
3. 中断频率 64分频 20 us 一次中断         中断时间
3. 中断频率 4分频  10  us 一次中断        中断时间
100us
3. 中断频率 8分频  200us 一次中断 102     中断时间 17.6
3. 中断频率 16分频 100 us 一次中断 102    中断时间 17.6
3. 中断频率 32分频 50 us 一次中断         中断时间
3. 中断频率 64分频 25 us 一次中断         中断时间
160us
3. 中断频率 16分频 160us 一次中断 162     中断时间 17.6
3. 中断频率 32分频 80 us 一次中断         中断时间
3. 中断频率 64分频 40 us 一次中断         中断时间
3. 中断频率 4分频  20  us 一次中断        中断时间
2. 中断频率 16分频 10 us 一次中断
200us
3. 中断频率 16分频 160us 一次中断 162     中断时间 17.6
