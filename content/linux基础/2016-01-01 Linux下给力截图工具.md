---
title: Linux下给力截图工具归纳
date: 2016-09-27T15:58:27+08:00
update: 2016-09-27 16:03:41
categories: [Linux基础]
tags: [timezone]
---
[Linux下给力截图工具归纳 - oZuiJiaoWeiYang的专栏 - 博客频道 - CSDN.NET](http://blog.csdn.net/ozuijiaoweiyang/article/details/44804787)
# 1、系统自带 gnome-screenshot
截取自定义区域
gnome-screenshot -a
快捷键
对窗口截屏 alt+ printscreen
自定义选取截屏 shift+ printscreen
复制截图到剪切版 ctrl+ printscreen
复制框口截图到剪切版 ctrl+alt+printscreen
复制特定选区到剪切版
gnome3可以直接按键盘上的截屏键截屏的。同时按住shift键可以自定义区域
![Markdown](http://i1.piimg.com/585302/243d3a3c97d7877a.png)
2. ImageMagick
`import filename.png` #filename是你的截图名
`import -frame Image6.png ` #截取窗口
`import -window root -resize 640 -pause 4 Pictures/Image7.png`
```bash
#!/bin/bash
# https://github.com/Ceryn/img
# Call with '-s' to target only a selection of the screen.

clientid='3e7a4deb7ac67da'
img=$(mktemp '/tmp/img-XXXXXX.png')

scrot -z "$@" $img >/dev/null 2>&1 || exit
res=$(curl -sH "Authorization: Client-ID $clientid" -F "image=@$img" "https://api.imgur.com/3/upload")

echo $res | grep -qo '"status":200' && link=$(echo $res | sed -e 's/.*"link":"\([^"]*\).*/\1/' -e 's/\\//g')
test -n "$link" && (printf $link | xclip; printf "\a" && rm "$img") || echo "$res" > "$img.error"

```
# 3、Scrot
1.安装很简单，像安装其他软件一样，Fedora下 yum install scrot ， Ubuntu下apt-get install scrot就可以。
2.一般用法，使用 scrot 可以抓取整个桌面、某个指定的窗口、以及选择的矩形区域。
　　抓取桌面：scrot desktop.png，该命令将当前的整个桌面抓取下来，并保存为 desktop.png 文件。可以在当前的目录中找到此图像文件。
　　抓取窗口：scrot -bs window.png，选项 b 使 scrot 在抓取窗口时一同将外边框抓取下来，而 s 选项则让用户选择所要抓取的是何窗口。
　　抓取区域：scrot -s rectangle.png，在执行此命令后，使用鼠标拖曳的矩形区域将被 scrot 抓取下来，并保存为 rectangle.png 文件。
3.高级用法，对于普通的抓取，使用 scrot 的基础便足以应付了。但在某些特殊情况之下，使用 scrot 抓取图像需要讲究一些技巧。
　　延时抓取：scrot -cd 10 menu.png，此命令中的 d 选项用于延时抓取图像，其后的 10 代表延时 10 秒;前面的选项 c 显示倒计时。在抓取菜单或是命令提示时，该技巧将充分展示其魔力。
　　生成缩图：scrot -t 50% thumb.png，这个命令在抓取图像的同时生成该图像的缩略图。选项 t 将打开此功能，其后的 50% 为原图的缩放百分比。
　　更改品质：scrot -q 70 quality.jpg，此命令中的 q 选项用于更改所抓图像的品质，其数值介于 1-100 之间，默认为 75。数值越大，意味着图像品质越高;同时，图像的压缩率也就越低，占用空间越大。
　　操作抓图：scrot action.png -e ‘mv $f ~/images/’，该命令将抓取的图像移动到 ~/images/ 目录。显然，操作图像的功能由 e 选项开启，其中的 $f 代表原图的路径/文件名。
　　以上示例皆指定了需要保存的抓图的文件名称。实际上，如果不指定名称，那么 scrot 在抓取图像后会自动使用当前的日期时间、宽度高度的组合来生成文件名称。如：2012-07-21-154232_238x148_scrot.png

　　然而这样还是不太方便。可以新建一个文件，如screenshot
　　touch screenshot
　　vim screenshot（如果没有安装vim，可以执行sudo apt-get install vim进行安装）
　　输入 scrot -s -e ‘mv $f ~/screenshots’（注：mv $f ~/screenshots命令两边为单引号）
　　保存退出vim，然后 chmod u+x screenshot
　　这样就可以通过运行screenshot文件来执行scrot了。或者可以通过建立软链接来使用scrot。比如：在/usr/bin目录下执行sudo ln -s ~/screenshot scs。以后直接在终端里输入scs即可用鼠标截图。
操作抓图：scrot action.png -e 'mv $f ~/images/'，该命令将抓取的图像移动到 ~/images/ 目录。显然，操作图像的功能由 e 选项开启，其中的 $f 代表原图的路径／文件名。
下面是方便截图的一个脚本，放在/usr/local/bin下，在方便的地方建个快捷方式，一单击即可进入截图状态
#!/bin/bash
# 注意下面的“＋”号要紧接着％Y。（我之前没注意到这点，哎，截了半天也没截出东西
/soft/scrot/bin/scrot -s /home/用户名/picture/`date -d yesterday
+%Y-%m-%d-%H-%M-%S`.jpg
4. Deepin-ScreenShot



```bash
#!/bin/bash
# linux deps: xsel espeak scrot rsync
# osx deps: none
# assumptions: authorized to ssh into host w/o password

OS=`uname`

# Remote server to upload to
HOST="yourhost.com"

# Remote user to login to HOST with
USER="user"

# Path on remote server to upload to
UPLOAD_PATH="/path/to/www-img"

# Base path where image will be accessible from
BASE_URL="http://yourhost.com/img"

# Temp file to store screen shot
TEMP_FILE="$(mktemp /tmp/screenshot.XXXXX.png)"

# Take screen shot, save to temp file
if [[ "$OS" == "Linux" ]]; then
    scrot -s $TEMP_FILE
else
    screencapture -s $TEMP_FILE
fi

# Houston, we have a problem!
if [[ $? -ne 0 ]]; then
    if [[ "$OS" == "Linux" ]]; then
        espeak error &>/dev/null &
    else
        say error &
    fi
    exit 1
fi

# Create filename based on MD5 to guarantee uniqueness
if [[ "$OS" == "Linux" ]]; then
    MD5="$(cat $TEMP_FILE | md5sum)"
else
    MD5="$(cat $TEMP_FILE | md5)"
fi

# Only take first five characters from MD5
IMAGE_NAME="${MD5:0:5}.png"

# Copy file to remote server
rsync --chmod=u=rw,g=r,o=r --perms $TEMP_FILE $USER@$HOST:$UPLOAD_PATH/$IMAGE_NAME

# Copy link to clipboard
if [[ "$OS" == "Linux" ]]; then
    echo "$BASE_URL/$IMAGE_NAME" | tr -d '\n' | xsel --clipboard --input
else
    echo "$BASE_URL/$IMAGE_NAME" | tr -d '\n' | pbcopy
fi

# Cleanup
rm $TEMP_FILE

if [[ "$OS" == "Linux" ]]; then
    espeak ding &>/dev/null &
else
    say ding &
fi
```
