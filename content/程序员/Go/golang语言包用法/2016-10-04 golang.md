---
title: golang
date: 2016-10-04T04:15:26+08:00
update: 2016-10-04 04:15:26
categories: [golang]
tags: [golang]
---
## go librarys
  https://golang.org/pkg/
  http://go-search.org/
## go
# [install](https://golang.org/doc/install)
  1. curl -O https://storage.googleapis.com/golang/go1.7.3.linux-amd64.tar.gz
  2. tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
     `sudo tar -zxf go1.7.3.linux-amd64.tar.gz -C /usr/local`
# 环境变量配置
GOROOT: golang可执行程序本身的路径
  `export GOROOT=/usr/local/go/bin`
GOPATH: 当有多个GOPATH时，默认会将go get的内容放在第一个目录下[golang库的路径]
  - Windows是[; 分号 semicolon-separated]
  - Linux系统是[: 冒号 colon-separated]
```
  export GOPATH=$HOME/work
  export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
```
# Go命令详解
go env #查看GO变量

go build
    如果是普通包，当你执行go build命令后，不会产生任何文件。
    如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。
    如果需要在$GOPATH/bin木下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/a.exe。
go install 命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。
go get 命令本质上可以理解为：首先通过源码工具clone代码到src目录，然后执行go install; go get = git clone + go install
  -d 只下载不安装
  -f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用
  -fix 在获取源码之后先运行fix，而后再进行编译和安装。
  -t 同时也下载需要为运行测试所需要的包
  -u 强制使用网络去更新包和它的依赖包 默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 |
  -v 显示执行的命令
go test 命令，会自动读取源码目录下面名为*_ test.go的文件，生成并运行测试用的可执行文件。输出的信息类似

## Go 语言包管理：gopm
`go get -u github.com/gpmgo/gopm`
  list     list all dependencies of current project
  gen      generate a gopmfile for current Go project
  get      fetch remote package(s) and dependencies
  bin      download and link dependencies and build binary
  config   configure gopm settings
  run      link dependencies and go run
  test     link dependencies and go test
  build    link dependencies and go build
  install  link dependencies and go install
  clean    clean all temporary files
  update   check and update gopm resources including itself
  help, h  Shows a list of commands or help for one command
# 包管理工具:govendor
## Install
`go get -u -v github.com/kardianos/govendor`

## 使用
export GO15VENDOREXPERIMENT=1

# 创建vendor
`govendor init`
`govendor fetch golang.org/x/net/context`

# Add existing GOPATH files to vendor.
govendor add +external
# View your work.
govendor list
# Look at what is using a package
govendor list -v fmt
# Specify a specific version or revision to fetch
govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55
govendor fetch golang.org/x/net/context@v1   # Get latest v1.*.* tag or branch.
govendor fetch golang.org/x/net/context@=v1  # Get the tag or branch named "v1".

# Update a package to latest, given any prior version constraint
`govendor fetch golang.org/x/net/context`

# Format your repository only
govendor fmt +local

# Build everything in your repository only
govendor install +local

# Test your repository only
govendor test +local

cd goproj & govendor init
goverdor --list
goverdor --list -v
Copy existing dependencies from $GOPATH with `govendor add/update`.
If you ignore vendor/* /, restore dependencies with `govendor sync`.
Pull in new dependencies or update existing dependencies directly from remotes with govendor fetch.
Migrate from legacy systems with `govendor migrate`.

## 包管理工具:godep
godep save

## 包管理工具:glide
curl https://glide.sh/get | sh
glide init
edit glide.yaml
glide update
glide install
glide get github.com/foo/bar#^1.2.3
################################################################################
# vscode调试工具:delve
go get github.com/derekparker/delve/cmd/dlv

`anInt, _ = strconv.Atoi(origStr)`
_ 无视错误
 一个特殊的变量名是 _ （下划线）。任何赋给它的值都被丢弃。

多个defer的执行顺序为“后进先出”；
defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。

一个新定义的或者没有任何指向的指针，有值 nil。在其他语言中，这经常被叫做空（NULL）指针，在 Go 中就是 nil
# import
  1) import后面的最后一个元素应该是路径，就是目录，并非包名 使用的时包名
  2) 同一个目录下只能有一个包名

## 匿名函数 （闭包）
赋值 fplus := func(x, y int) int { return x + y }
直接运行 func(x, y int) int { return x + y } (3, 4)
## 函数方法 类的内部方法 a.poll
func (a *Agent) Poll() error {	return nil }
