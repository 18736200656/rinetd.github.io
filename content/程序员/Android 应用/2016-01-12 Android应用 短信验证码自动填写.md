---
title: 自动填写短信验证码
date: 2016-01-11T14:10:29+08:00
update: 2016-01-01
categories: [Android]
tags:
---
这个也不是什么新东西，目前很多app都有这个功能，最近有几个小伙伴问我是怎么实现的，索性写一篇博客来为大家解答。
实现思路很简单：
1、在需要输入验证码的Activity代码注册监听短信的广播
2、拦截短信，获取其中的验证码
3、回写到EditText
```
    private SmsReciver smsReciver = new SmsReciver();  
    /** 收到短信Action **/  
    String ACTION_SMS_RECIVER = "android.provider.Telephony.SMS_RECEIVED";  
/**
 * 注册广播接受者监听短信验证码自动回写  可在onCreate()中进行注册;
 */  
private void registSmsReciver() {  
    IntentFilter filter = new IntentFilter();  
    filter.addAction(ACTION_SMS_RECIVER);  
    // 设置优先级 不然监听不到短信   
    filter.setPriority(1000);  
    registerReceiver(smsReciver, filter);  
    }  

      /**
   * 短信广播接受者 用户监听短信，自动填写验证码
   */  
      private class SmsReciver extends BroadcastReceiver {  

    @Override  
    public void onReceive(Context context, Intent intent) {  
        Object[] objs = (Object[]) intent.getExtras().get("pdus");  
          for (Object obj : objs) {  
              yte[] pdu = (byte[]) obj;  
             SmsMessage sms = SmsMessage.createFromPdu(pdu);  
             // 短信的内容  
             String message = sms.getMessageBody();  
             Log.d("log", "message     " + message);  
            // 短息的手机号，如果你们公司发送验证码的号码是固定的这里可以进行一个号码的校验  
             String from = sms.getOriginatingAddress();  
             Log.d("log", "from     " + from);  
             analysisVerify(message);  

        }  
     }  

}  

 /**
 * 解析短信并且回写  这里解析的是纯数字的短信，如果小伙伴的验证码包含字母的话，可用正则替换
  *  
  * @param message
  */  
private void analysisVerify(String message) {  
    char[] msgs = message.toCharArray();  
     StringBuffer sb = new StringBuffer();  
    for (int i = 0; i < msgs.length; i++) {  
        if ('0' <= msgs[i] && msgs[i] <= '9') {  
                        sb.append(msgs[i]);  
        }  
    }  

    mEtVerifyCode.setText(sb.toString());  
 }  

@Override  
protected void onDestroy() {  
    super.onDestroy();  
    // 取消短信广播注册  
    if (smsReciver != null) {  
        unregisterReceiver(smsReciver);  
        smsReciver = null;  
    }  
}  
```
可以看到代码逻辑比较简单，需要注意的有几点。我们这里用的代码注册广播，之所以不采取全局广播的形式原因有两天，在高版本的api，注册全局的短信监听会失效。而且就业务而言，我们监听短信只会在输入验证码的Activity里面才会用到，采用代码注册的形式，在当前Activity销毁的时候取消广播注册，更符合我们的预期，提高应用的性能。第二个需要注意的问题是优先级的问题

    filter.setPriority(1000);  

可以看到，我们这里把优先级设置成了最大。保证我们的应用能够尽可能的接受到短信。注意，我使用的是“尽可能”，也就是说我们不能保证短信自动填写一定能执行成功，有个小伙伴可能会问，我们不是把优先级设置成了最高了吗？为什么还不能保证了？ 原因其实很简单，你能把监听短信的优先级设置成最大，同样的，其他的应用也能把短信监听的优先级设置成最大。比如说，你的手机安装有360安全卫士，把你们公司的验证码视为垃圾短信拦截了，这个时候短信拦截就失效了。
