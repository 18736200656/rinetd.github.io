---
title: Meteor
date: 2016-03-29T20:57:24+08:00
update: 2016-01-01
categories:
tags: [Meteor]
---
[Meteor Session is not defined](http://blog.csdn.net/dijason/article/details/9093069)

Meteor Session is not defined

之所以会产生这样的问题，是因为包含有Session的代码被server加载了，而 **Session只是在client服务**，那什么时候用了Session的代码会被server加载呢，

这就要对Meteor的文件加载规则有所了解了。根据Meteor文件加载规则，除了client和test文件夹之外的所有文件夹都会在server加载。所以如果你的Session是在这样的

目录结构下的文件的话，就会导致Meteor Session is not defined。

client  
  ---c1.html
  --c1.js
server
  --server.js
public
  --hello.png
app
  --hasSession.js   //使用了Session，并且使用Session的源码的地方没有包含在Meteor.isClient中
app文件夹会在client和server都加载，但由于hasSession.js中含有Session，但server是没有Session的定义，所以会报错。
解决办法有两个
1 将使用了Session的代码放到Meteor.isClient内
  if (Meteor.isClient) {
    //Session code
 }
2 将hasSession.js放进某个client文件夹里，在上例中，可以这么做
app
   client
       --hasSeesion.js
因为是放在client文件夹里，所以不会在server端加载。


[Meteor 登录后立即退出解决 ](http://blog.csdn.net/dijason/article/details/8674518)

[Meteor多APP合并](https://cnodejs.org/topic/52131a200a746c580b4cba7e)
搭建MutilMeteorApps

通过Meteor官网的项目示例，我们可以很快做出我们的Web应用。但是在实际的开发当中，我们往往由多人开发，每个人可能负责开发几个项目，却发布在一个服务器应用中。这种是如何实现的呢？通常我们可以使用服务器的反向代理机制将不同的Web项目映射到同一个端口中，现在我们就来实现搭建一个MutilMeteorApps。

首先，我们创建一个文件夹MutilMeteorApps，里面会有很多单独的MeteorApp。

$ mkdir MutilMeteorApps
$ cd MutilMeteorApps

接着，我们创建一个frame项目，这个项目作为整个MutilMeteorApps的框架项目。

$ meteor create frame

因为frame项目仅仅为集群项目提供框架，我们删除所有默认文件，新建/lib/config.js文件。

__meteor_runtime_config__.serverId = "myServerId";

然后我们新建一个/client/frame.html：

<head>
  <title>项目主框架</title>
</head>
<body>
  <div>
    <a href="/app1" target="showFrame">app1</a>    
    <a href="/app2" target="showFrame">app2</a>    
    <a href="/app3" target="showFrame">app3</a>    
  </div>
  <div id="main">
      <iframe frameborder=0 width="100%" height="800" marginheight=0 marginwidth=0 scrolling=no src="/app1" name="showFrame">
  </div>
</body>

接下来我们就来构造我们的三个app项目，这三个项目我们不用自己做，我们就用Meteor官方提供的项目就可以了：

$ meteor create --example leaderboard
$ meteor create --example todos
$ meteor create --example wordplay

Meteor内部就提供了node的一个modules，名字叫http-proxy，这是一个用node做的http代理模块。我们在MutilMeteorApps文件夹新建如下文件和文件夹：

/MutilMeteorApps
      |-- /proxy
            |-- proxy.js
            |-- node_modules

将http-proxy模块复制到node_modules文件夹中，然后修改proxy.js文件：

var proxy = require('http-proxy');
var options = {
  replaceRelativePath:true,
  pathnameOnly:true,
  router:{
    //package和sockjs从框架中找
    '/packages':'192.168.30.100:3000/packages',
    '/sockjs':'192.168.30.100:3000/sockjs',
    //各个项目从不同端口找
    '/app1':'192.168.30.100:4000/',
    '/app2':'192.168.30.100:5000/',
    '/app3':'192.168.30.100:6000/',
    //设置根目录
    '/':'192.168.30.100:3000/',
  }
};
proxy.createServer(options).listen(80);

需要注意的是，host尽量配置为本机ip地址或者域名ip地址。这样，我们就将不同端口的项目代理到同一端口80下了。接着我们运行所有的项目以及proxy.js这个node程序：

## 启动frame项目 ##
$ meteor --port 3000
## 启动leaderboard项目 ##
$ meteor --port 4000
## 启动todos项目 ##
$ meteor --port 5000
## 启动wordplay项目 ##
$ meteor --port 6000
## 启动proxy代理 ##
$ node proxy.js

我们可以试一试每个项目单独启动能否成功，答案是显然的，因为端口都没有冲突。然后我们试着访问http://127.0.0.1，点击这些链接。先不管为什么frame为什么没出来，但是我们发现点出来的项目虽然出来了，但是不停的再刷新。

这是为什么呢？其实我也不知道，但是我发现他刷新的速度和socket刷新的速度是一致的。于是我猜测，可能他认为这是几个不同的项目，所以出现这种不断比较不断刷新的递归现象，时间长了自然会对服务器有影响。还记得我们之前为frame配置的lib目录吗，这是我花了很久才找到的配置方法，中间走了不少弯路。只要将这个目录为你所有的项目中添加，告诉他们之间其实是同一个项目即可。

此时，三个项目都没出现刷新的问题，但是因为没有数据，所以三个显示的都不怎么好看。思考了一下，可能是三个都是连接各自的数据库，因此，我们统一数据库好了，设置环境变量set MONGO_URL=mongodb://192.168.30.100:27017，再次运行所有项目。

依然没有达到我们都目的，好的，我们再来做大胆的尝试。我觉得是因为不同端口的项目都在尝试连接80端口的项目，而80端口被映射到了3000端口上。因此，我们将所有项目拆解为client/server/public/collections几个文件夹来试一试。最后，将所有的服务器资源（public、server）统统放到frame项目中去。

最后成功！但是使用nodejs启动有点麻烦，如果Meteor框架frame自己能启动就最好了。很简单，Meteor虽然不能使用nodejs代码，但是能通过全局变量Npm获取nodejs模块，使用方法为Npm.require()，之后改动就很简单了吧！
