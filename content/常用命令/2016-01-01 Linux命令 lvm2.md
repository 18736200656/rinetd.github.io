---
title: Linux命令 lvm2
date: 2016-01-06T16:46:14+08:00
update: 2016-01-01
categories: [linux_base]
tags: [lvm2]
---
[Linux中LVM2原理及制作LVM2 - 兰枫 - CSDN博客](http://blog.csdn.net/u013008795/article/details/51151624)
[LVM逻辑卷管理器配置小结](https://segmentfault.com/a/1190000004632775)
[Linux存储入门：简易数据恢复方案--分区和LVM实战-博客-云栖社区-阿里云](https://yq.aliyun.com/articles/120473?spm=5176.8067842.tagmain.31.wWJdsP)
[LVM简明教程](https://linux.cn/article-3218-2.html)

lsblk  能够显示每个设备的更多信息，如标签和型号，更多请查看信息手册。
blkid  显示块设备（分区和存储介质）属性，例如UUID和文件系统类型，不报告分区空间

一、LVM原理
【MD】:Multi Device 多设备  [RAID]
      Mdadm是一个用户空间工具，是RAID的管理工具，与真正的RAID工作没有太大关系。真正的RAID集成在linux内核中
【DM】Device Mapper设备映射也是linux中一种常用的管理机制 [LVM2]
     DM 与MD近似，也能够提供一种逻辑设备
     DM比MD的功能要强大。因为DM不仅仅能提供MD的RAID的功能，它还是逻辑卷（LVM2）基础，同时，在逻辑卷的基础上我们也能实现RAID0,RAID1。这样的功能。所有DM与MD中有某些功能是重叠的，但并不完全重叠。所以，我们通常使用MD做RAID用DM做LVM2
RAID：只是为了避免硬件损坏而导致业务终止或数据损失的。并不能保证人为错误的操作，导致数据损失。说以通常即使有RAID后数据依然要做备份。
DM除了快照外，还支持动态缩减磁盘大小。
# 拓普扩容
lvextend -l +100%FREE /dev/VolGroup/lv_root
e2fsck -f /dev/mapper/VolGroup-lv_root   //调整大小前要做的步骤
resize2fs /dev/mapper/VolGroup-lv_root

1. 创建分区
fdisk /dev/sdb
n
p

w

2. 创建文件系统
mkfs.ext4 /dev/vdb1

mount /dev/vdb1 /mnt/

# linux  无损扩展分区
1. 检查文件系统
fsck -f /dev/vdb1

2. 按d删除现在的分区1，注意：删除后千万不要按w保存！直接按n创建新的分区，然后从原有的柱面开始，一直分到最后的尺寸(默认值两次回车即可，如果之前的分区不是从第一柱面开始，则需要记录之前分区的起始柱面)，新的分区操作完毕后，按w保存
fdisk /dev/xvdc < <EOF
d
n
p

w
EOF

3. resize2fs /dev/vdb1



# LVM2
## 问题解决
/run/lvm/lvmetad.socket: connect failed: No such file or directory
WARNING: Failed to connect to lvmetad. Falling back to internal scanning.

`vi /etc/lvm/lvm.conf` and change use_lvmetad=1 to `use_lvmetad=0`

1. 创建lvm分区

fdisk /dev/vdb
n    #创建分区
p    
+10G #指定大小10G
t    #更改分区类型为[8e] linux lvm
8e
w

2. 将物理分区PE与硬盘创建为物理卷PV (pvcreate)
 `pvcreate /dev/sdb[1-3] `                      #将sdb上的三个分区创建为物理卷
 pvcreate /dev/sdc                            #将硬盘sdc创建为物理卷
 pvs                                          #查看创建的物理卷

3. 将物理卷(pv)创建为卷组（vgcreate），名为myvg：
 `vgcreate VolGroup /dev/sdb[1-3] /dev/sdc`     #创建卷组（VG），卷组名为VolGroup，使用物理卷:
 vgcreate VolGroup -s 8M /dev/sdb{10,11,12}   #指定VG的pe大小为8MB
 vgs                                          #查看创建的卷组；

4. 在卷组里创建逻辑卷并格式化、挂载使用；
 `lvcreate -l +100%FREE -n lv_data VolGroup `   #使用全部物理卷创建逻辑卷
 lvcreate -L 5G -n lv_data VolGroup           #创建逻辑卷，卷名为lv_data，卷大小为5G；
 lvs                                          #查看逻辑卷；

#格式化逻辑卷
mkfs -t ext4 /dev/VolGroup/lv_data
`mkfs.ext4 /dev/VolGroup/lv_data`

#挂载逻辑卷
mkdir /docker

#修改fstab
vi /etc/fstab
/dev/VolGroup/lv_data /docker ext4 dafualts 0 0
#测试lv是否可以挂载
mount -a
mount /dev/VolGroup/lv_data /docker
df -h
这里我们可以看到挂载的lv_data是/dev/mapper/VolGroup-lv_data，其实/dev/mapper/VolGroup-lv_data才是真正的设备文件，在/dev/VolGroup/lv_data只是个链接文件。

#删除逻辑卷
fuser -m /docker
umount /docker
lvremove /dev/VolGroup/lv_data


## 扩展[无损]
1. pvcreate /dev/sdc                         
2. vgextend VolGroup /dev/vdb2
3. lvextend -l +100%FREE /dev/VolGroup/lv_data

## 缩减[有损] 当想移除卷时必须删除逻辑卷
1. lvremove /dev/VolGroup/lv_data
2. vgreduce VolGroup /dev/vdb2         # 将/dev/vdb2从VolGroup移除 必须先移除lv_data才能执行
3. vgremove VolGroup                   # 移除VolGroup
4. pvremove /dev/vdb2

一、扩展逻辑卷：
【lvextend 】扩展磁盘的逻辑卷
             -L [+]# /PATH/TO/LV
【resize2fs】扩展文件系统逻辑编辑
            resize2fs /PATH/TO/LV 5G

 例如：#lvextend -L 7G /dev/myvg/testlv    //将testlv物理边界扩展为7G
      #resize2fs  -p /dev/myvg/testlv     //将testlv的文件系统边界扩展为最大（即物理边界有多少就用多少）

## 扩容 先扩展物理边界`pvresize` 后扩展逻辑边界`lvextend` 最后扩展文件系统边界`resize2fs`
1. 扩展物理分区
`fdisk /dev/vdb`
p   # 记下扩容前的
d   # 要扩展分区
n   # 创建新分区
p

t   # 分区类型为 linux lvm
8e
w

`partprobe`包含在parted的rpm软件包中。partprobe可以修改kernel中分区表，使kernel重新读取分区表。
因此，使用该命令就可以创建分区并且在不重新启动机器的情况下系统能够识别这些分区。
2. 扩展pv
pvresize /dev/vdb1  # 单分区扩容

pvcreate /dev/vdb2  # 多分区扩容
vgextend VolGroup /dev/vdb2
3. 扩展 lv
`lvextend -l +100%FREE /dev/VolGroup/lv_data`
`lvextend -l 100%VG /dev/VolGroup/lv_data`
4. 扩展文件系统
`e2fsck -f /dev/mapper/VolGroup-lv_data`
`resize2fs /dev/mapper/VolGroup-lv_data`
`mount /dev/mapper/VolGroup-lv_data  /data/`
`df -h`


二、缩减逻辑卷：
注意：1、不能在线缩减，得先卸载;
    2、确保缩减后的空间大小依然能存储原有的所有数据：
    3、在缩减之前应该先强行检查文件，以确保文件系统处于以至性状态

# 缩减一个LVM卷 先缩小文件系统边界`resize2fs` 后缩小逻辑边界`lvresize,lvreduce` 最后缩小物理边界`pv`
注意减少逻辑卷的大小值若小于储存的数据大小，存储在后面的数据会丢失。

1. 首先，卸载掉卷。
# `umount /dev/mapper/VolGroup-lv_data`

2. 然后，检测磁盘错误。
# `e2fsck -f /dev/mapper/VolGroup-lv_data `

3. 接下来缩小文件系统，更新ext4信息。
# `resize2fs /dev/mapper/VolGroup-lv_data 30G`

4. 完成以后，减少逻辑卷大小
# `lvresize -L -30G /dev/mapper/VolGroup-lv_data`

5. 最后，验证调整后的逻辑卷大小。
# `lvdisplay `


Lvm详解
【pv】Physical Volume 物理卷
【vg】Volume Group VG卷组
【lv】logical Volume逻辑卷

创建pv及查看pv相关命令
pv ：注意pv是由磁盘分区构成，分区格式为（8e(linux)）
         【pvcreate】创建pv
                            例如：
                                               pvcreate/dev/sda1 /dev/sda2   //级可以将sda1和sda2设备创建称为pv设备
         【pvremove】删除pv
         【pvscan】扫描pv(扫描系统上有多少个pv物理磁盘)
         【pvdisplay】查看系统上pv的详细信息
         【pvs】查看当前系统上的pv设备(简单查看)
         【pvmove】移动pv

vg:注意：vg是由pv构成构成后对系统看来相当于一个磁盘
         【vgcreate】创建vg将pv创建为vg
                                                        例如：
                                                        vgcreatemyvg /dev/sdb1 /dev/sdb2  //将已经用pv创建好了的磁盘sdb1和sdb2创建成vg名称为myvg
                                               参数：
                                                        【-s #】指定盘区大小（PESize）默认盘区大小为4MB
                                                                 例如：
                                                                           gcreate-s 8M myvg /dev/sdb{5,6} //创建名称为myvg 使用pv已经创建好了的设备sdb5,sdb6构成，盘区PE大小为8M

         【vgremove】移除vg                            
                   例如：     #vgremovemyvg  //将myvg删除
         【vgmove】移动，把物理盘区移动到其他设备上         #pvmove/dev/sdb5  //将物理盘区sdb5上的数据移走（方便之后卸载该物理盘区）
         【vgdisplay】查看vg设备的详细信息
         【vgs】查看vg设备的基本信息
         【vgscan】扫描系统上有多少个vg设备
         【vgchange】
              vgchange -ay VolGroup #激活
              vgchange -an VolGroup #失效
         【vgreduce】缩减vg   
           #vgreduce myvg /dev/sdb5 //将myvg设备上的sda5移除（即myvg的空间会缩小）
           #pvremove /dev/sdb5(接着可以将pv磁盘设备sdb5移除)
         【vgxtend】扩展vg     
             #vgextendmyvg /dev/sdb7 //将myvg设备扩展个pv的磁盘sdb7
             #pvcreate/dev/sdb7(在上面之前要先创建)

lv ：注意：lv是属于vg的，需要在vg中创建
【lvcreate】创建lv需要在vg上创建

参数：
         【-n】:指定名称
         【-L】:指定空间大小
              例如：lvcreate -L 50M -n testlv myvg      //在myvg中创建一个lv，名称为testlv，大小为50M
                   mke2fs -j /dev/myvg/testlv          //即格式化testlv.格式化的文件系统为ext3
                   mount /dev/myvg/testlv /mnt         //将testlv挂载到mnt目录下面
         【-p】:指定权限
         【-s】:指定为快照卷

【创建快照卷】
1、生命周期为整个数据时长:在这段时长内，数据的增长量不能超出快照卷大小：
2、快照卷应该是只读的：
3、快照卷和原卷在同一卷组内
语法【lvcreate-L # -n SLV_NAME -p r /PATH/TO/LV】
          #lvcreate -L 50M -n lv1-snap -s -p r/dev/myvg/lv1  //为lv1设备创建一个大小为50M,名称为：lv1-snap，权限为只读的快照卷
          #mount /dev/myvg/lv1-snap /ftpftp/gandian     //将快照卷挂载在gandian文件夹下
          #tar -jcf /beifeng.tar.bz2 /ftpftp/gandian     //将快照卷内容全部备份为beifeng.tar.bz2文件
          #umount /dev/myvg/lv1-snap                         //卸载快照卷
          #lvremove /dev/myvg/lv1-snap                              //移除快照卷（即将快照卷删除）

相关命令
lv ：注意：lv是属于vg的，需要在vg中创建
         【lvremove】移除       
         #lvremove /dev/myvg/testlv  //将testlv移除
         #lvremove /dev/mapper/myvg-testlv      //也可以移除testlv(注意：/dev/myvg/testlv只是个连接文件，真正的文件在/dev/mapper/myvg-testlv)
         【lvs】
         【lvdisplay】
         【lvcan】
         【lvextend】扩展
          #lvextend -L 7G /dev/myvg/testlv     //将testlv物理边界扩展到7G
          #resize2fs  -p /dev/myvg/testlv      //将testlv的文件系统边界扩展为最大（即物理边界有多少就用多少）

         【lvreduce】缩小
                   注意：    1、不能在线缩减，得先卸载;
                            2、确保缩减后的空间大小依然能存储原有的所有数据：
                            3、在缩减之前应该先强行检查文件，以确保文件系统处于以至性状态
                   例如：
                            #df -lh               //查看文件系统大小，以及已经使用大小
                            #umount/dev/myvg/testlv          //卸载testlv设备
                            #e2fsck -k/dev/myvg/testlv               //强行检查testlv设备的文件系统
                            #resize2fs/dev/myvg/testlv 1G            //缩减文件系统大小到1G
                            #lvreduce -L 1G/dev/myvg/testlv          //缩减testlv物理边界到1G
                            #mount/dev/myvg/testlv /users                   //挂载
         【lvresize】既可以扩展又可以缩小


######
#sda为HDD   sdb为SSD

1、创建物理卷
pvcreate /dev/sda
pvcreate /dev/sdb

2、创建卷组vg
vgcreate vg /dev/sda
vgextend vg /dev/sdb

3、创建逻辑卷(data为存储卷，cache为缓存卷,meta为缓冲卷索引,其中cache:meta不能大于1000：1,meta最小为8M)
lvcreate -L 500G -n data /dev/sda
lvcreate -L 220G -n cache /dev/sdb
lvcreate -L 220M -n meta  /dev/sdb

4、创建缓存池(注意cache和meta的顺序不能颠倒)
lvconvert --type cache-pool --poolmetadata vg/meta vg/cache

5、将存储卷加入到缓存池中（cachemode有writeback和writethrough两种模式，默认为writethrough）
lvconvert --type cache --cachepool vg/cache --cachemode writeback vg/data
注：writeback会在写入cache完成后，再写入date中
    writethrough会在写入cache的同时，写入date（写入date慢于cache）
    两种模式比较下writeback在使用过程中写入加速，但如果数据在缓存层中服务器掉电数据会丢失（现在已解决丢失问题，未研究）
    writethrough写入较慢，但数据不易丢失



 I've seen the same error today on a laptop running Ubuntu 15.10 which I always kept up-to-date but had not rebooted for a month until I wanted to test a current kernel (i.e., there might have been a recent change).

 Anyways, I found that in my case the underlying cause was actually a "missing" swap partition due to a setup glitch when following the above tutorial. If this is the case and/or you're actually using lvm, you might be able to skip step 2 below. Of course, you might also see the above error message in case your system (or a secondary data) partition has been damaged or cannot be found (see step 3).

 Step 1: Mount your system, boot partitions following the aformentioned tutorial

 Let's say your (ext2) boot partition is /dev/sdX1, your (encrypted) swap partition is /dev/sdX2, your (encrypted) data partition is /dev/sdX3 and you've successfully decrypted the latter using cryptsetup luksOpen /dev/sdX3 data, followed by mounting it: mkdir /tmp/data; mount /dev/mapper/data /tmp/data.

 Pay attention to the bind mounts in the tutorial and make sure to mount /dev/sdX1 so that you can access it from your system partition's /boot directory (this is crucial as we have to execute update-initramfs).

 In the following, we're assuming you've sucessfully executed chroot /tmp/data/@ubuntu1510 (or whatever your mounted system partition is called)

 Step 2: Get rid of the above error message

 I'm using btrfs (as you might have guessed from the mentioned subvolume name), so lvmetad can easily be disabled as follows without loss of functionality:

 edit /etc/lvm/lvm.conf and change use_lvmetad=1 to use_lvmetad=0
 execute update-initramfs -k *KERNEL_VERSION* -u ; sync
 Now, you could reboot and the error message should be gone. However, in my case, the next error message[1] pointed me to the underlying problem mentioned above, so while we're at it, ...

 Step 3: Make sure that /etc/crypttab points to the correct, undamaged partitions

 First, run sfdisk --list /dev/sdX and check that your encrypted swap partition (in my case, /dev/sdX2) actually does not show up as a (normal) swap partition. If it did (as in my case), this meant that booting, e.g., using a rescue disk will likely make use of that available swap partition, thereby overwriting your cryptsetup related metadata (keyphrase and UUID).

 Next, have a look at /dev/disk/by-uuid and compare the respective UUIDs of your encrypted partitions with those contained in /etc/crypttab. My guess at this point: In your case, there's a mismatch.

 If the dedicated encrypted swap partition is nowhere to be found below /dev/disk/by-uuid, that's because it's currently in use by your rescue system. In that case, do the following:

 make sure to stop using the partition: swapoff -a
 reformat it: mkfs.ext2 /dev/sdX2 (this is crucial, especially when using GPT partitions[2], as it undoes the glitch I mentioned earlier. The likely cause of the partition showing up as type "swap" in the sfdisk listing is that you/I mistakenly used mkswap /dev/sdX2 when setting up the partition in the beginning.)
 follow the tutorial to encrypt the partition and set a passphrase; afterwards, open it using cryptsetup and properly reformat the now-decrypted partition (using something like mkswap /dev/mapper/swap)
 ensure that sfdisk --list /dev/sdX will not identify the swap partition as such (in that case, repeat the last steps)
 Now, recheck that the UUIDs listed in /etc/crypttab are in line which what you see below /dev/disk/by-uuid for your respective encrypted partitions.

 Again, to make the changes permanent, you must execute update-initramfs as shown above.

 If you're satisfied, make sure everything is written to disk and reboot the system (no need to unmount everything manually). Afterwards, your problem should be gone.

 [1] maybe I did not pay attention the first time or the first error message "masked" the second one; i.e., only after rebooting (with use_lvmetad=0), I was presented with "Reading all physical volumes. This may take a while..." (repeated multiple times), followed by "ALERT! /dev/disk/by-uuid/... does not exist.". (It should be noted that update-initramfs also complained about a missing partition.)

 [2] because their type is deducted from analysing their contents and not ultimately specified by a flag/byte (that's why there's no easy way to, e.g., change the GPT file system type using [g]parted.)
