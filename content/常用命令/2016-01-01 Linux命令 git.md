---
title: Linux命令 git
date: 2016-01-06T16:46:14+08:00
update: 2016-01-01
categories: [linux_base]
tags: [git]
---
[](https://github.com/brigade/overcommit)
![](http://img.blog.csdn.net/20131102012925234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2NjX3NreQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
[高富帅们的Git技巧 - 新闻 - SegmentFault](https://segmentfault.com/a/1190000002448847)


## git代理设置方法解决

git config --global https.proxy http://127.0.0.1:1080

git config --global https.proxy https://127.0.0.1:1080

git config --global --unset http.proxy

git config --global --unset https.proxy

npm config delete proxy

git config --global http.proxy 'socks5://127.0.0.1:1080'
git config --global https.proxy 'socks5://127.0.0.1:1080'

### 对比指定目录与上次提交之间的差别(或者更准确的 说是在当前分支)。
git diff HEAD -- ./lib
### 恢复指定目录文件
git checkout HEAD~ application/admin/

### 这条命令把hello.rb从HEAD中签出并且把它恢复成未修改时的样子.
 git checkout -- hello.rb

                                         remote repo
working            staging               local repo
工作区               暂存区                  本地仓库
        add          ->           commit    ->  
  <-   rm --cached   <-         reset --soft      
  <-                 checkout

当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用
git rm file_path          同时删除 staging staging
当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用
git rm --cached file_path 仅删除staging 保留staging


`git rm -r --cached .`

# filter-branch
--tree-filter表示修改文件列表。
--msg-filter表示修改提交信息，原提交信息从标准输入读入，新提交信息输出到标准输出。
--prune-empty表示如果修改后的提交为空则扔掉不要。在一次试运行中我发现虽然文件被删除了，但是还剩下个空的提交，就查了下 man 文档，找到了这个选项。
-f --force  是忽略备份。不加这个选项第二次运行这个命令时会出错，意思是 git 上次做了备份，现在再要运行的话得处理掉上次的备份。
--all是针对所有的分支。

## Removing sensitive data from a repository 移除项目中的敏感信息

git filter-branch --force --index-filter \
'git rm --cached --ignore-unmatch 要删除的文件名' \
--prune-empty --tag-name-filter cat -- --all

echo "YOUR-FILE-WITH-SENSITIVE-DATA" >> .gitignore
git add .gitignore
git commit -m "Add YOUR-FILE-WITH-SENSITIVE-DATA to .gitignore"

git push origin --force --all
git push origin --force --tags

彻底删除已经从本地仓库缓存的文件
git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
git reflog expire --expire=now --all
git gc --prune=now

# filter-branch全局修改邮箱地址
```
git filter-branch --commit-filter '
       if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
       then
               GIT_AUTHOR_NAME="Scott Chacon";
               GIT_AUTHOR_EMAIL="schacon@example.com";
               git commit-tree "$@";
       else
               git commit-tree "$@";
       fi' HEAD
```
name and email。 一句话不割:
`git filter-branch -f --env-filter "GIT_AUTHOR_NAME='Newname'; GIT_AUTHOR_EMAIL='newemail'; GIT_COMMITTER_NAME='Newname'; GIT_COMMITTER_EMAIL='newemail';" HEAD`

# filter-branch从每一个提交移除一个文件或目录
`git filter-branch --tree-filter 'rm -rf *~'`
`git filter-branch -f --tree-filter 'rm -rf *~' HEAD`
`git filter-branch -f --all --tree-filter 'rm -rf *~' HEAD` #作用于所有分支

# filter-branch一个子目录做为新子项目
`git filter-branch --subdirectory-filter subdir HEAD`
`git filter-branch --prune-empty --subdirectory-filter SUB_FOLDER BRANCH-NAME `
`git subtree split --prefix=SUB_FOLDER -b BRANCH-NAME`


## 清理 .git 目录大小
git gc

## Git合并branch上的指定文件
git checkout -p dev A.h //不切换branch，把RemLan上的A.h更新到当前分支
git checkout dev .drone* //去掉-p参数，新增 .drone.yml .drone.yml.sig 文件
## 允许空提交
git commit --allow-empty -m "Initializing gh-pages branch"

## lfs
Apt/deb repos: curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
Yum/rpm repos: curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash
sudo apt-get install git-lfs

## 关键Hooks
1. post-commit
2. pre-push
## 服务端
3. post-receive
当从本地版本库完成一个推送，并且在远程服务器上所有引用都更新完毕后执行。该脚本可以用于对其他镜像版本库的更新，或向用户发送提示（直接通过服务器端的echo命令）。如上文我提到的利用Git实现生产代码的自动化部署，就可以通过这个脚本完成。
# github Emoji表情包
http://www.webpagefx.com/tools/emoji-cheat-sheet/

# touch .gitignore 井号开头的这行都是注释
* .md #忽略根目录下所有.md后缀的文件
!README.md #但README.md除外
dir #忽略根目录dir目录
dir/ #忽略根目录下的dir/目录下的所有文件
`*/dir` #忽略根目录下的dir目录及dir目录下的所有文件
`**/dir` 忽略所有目录下的dir目录及dir目录下的所有文件  ** 忽略多层文件夹,git1.8.2及更高版本才支持

## 关闭git pull 弹出的merge 信息
`git reset --hard origin/master `
```
[core]
    mergeoptions = --no-edit
```
`git config --global core.mergeoptions --no-edit`
#.gitignore无效解决办法
git rm -r --cached . #删除所有缓存
git checkout --track origin/develop   #
git submodule update --init --recursive  #ycmd

## 添加空目录
 `find . -type d -empty -exec touch {}/.gitignore \;`


#.git 文件太大时怎样处理
clone的时候，可以指定深度，如下，为1即表示只克隆最近一次commit.
git clone --depth 1 git@github.com:/

# subtree
1、初始化子项目Subtree
通过
cd P1项目的路径
`git subtree add --prefix=用来放S项目的相对路径 git地址 xxx分支`
这样的命令，把S项目（我们姑且叫他S项目）的代码下载到--prefix所指定的目录——我们姑且叫他S目录把，并在P1项目里自动产生一个commit（就是把S目录的内容提交到P1项目里）。
对于P2项目也做同样的操作
2、像往常一样更新代码
大家在P1项目里各种提交commit，其中有些commit会涉及到S目录的更改，正如前面提到的，这是没任何关系的，大家也不会感受到有任何不一样。
3、提交更改到子项目的Git服务器
关键的地方来了：
当维护这个S项目 Subtree 的人希望把最近这段时间对S目录的更改提交到S项目的 Git 服务器上时，他执行一段类似于这样的命令：
cd P1项目的路径
`git subtree push --prefix=S项目的路径 git地址 xxx分支`
Git 会遍历所有的commit，从中找出针对S目录的更改，然后把这些更改记录提交到S项目的Git服务器上
4、更新子项目新的代码到父项目
OK，现在S项目有大量的新代码了，P2项目也想使用这些新代码，维护P2这个Subtree的人只要执行：
`git subtree pull --prefix=S项目的路径 git地址 xxx分支`
这样就可以将P2项目里S项目目录里的内容更新为S项目xxx分支的最新代码了。

## Git多账号切换
有时候会遇到需要使用多个git账号的情况，手动切换是在过于麻烦。
于是就有了一下的解决方案：
首先，切换到ssh的key目录下：
cd ~/.ssh
然后使用ssh-keygen命令创建一个新的SSH key:
ssh-keygen -t rsa -C  "sencond@mail.com" -f id_rsa_second
其中id_rsa_second表示保存的key的名称,可以自定义，命令执行之后会在.ssh目录里出现两个文件其中id_rsa_second.pub表示公钥。后面会用到。
由于默认情况下，每次进行SSH连接时默认发送本地钥匙（默认为~/.ssh/id_rsa）。所以之前生成的id_rsa_second在默认情况下是没有被用到的。
这时就需要在~/.ssh 目录创建config文件，该文件用于配置钥匙对应的服务器信息。具体语法如下：
Host    别名
    HostName        主机名
    Port            端口
    User            用户名
    IdentityFile    密钥文件的路径
其中Host别名自己任意给出，能方便记忆就行。给出一个示例配置以供参考：
# Default github user(first@mail.com)
Host github.com
     HostName github.com
     User git
     IdentityFile ~/.ssh/id_rsa
# second user(second@mail.com)
Host github-second
     HostName github.com
     User git
     IdentityFile ~/.ssh/id_rsa_second
配置完成之后，在连接非默认账号需要修改一下远程库的地址，
如本来的远程库地址为git@github:sencond/test.git
现在就需要改为git@github-second:sencond/test.git。
而且通过 ssh + 别名就能登录远程库
注意：
    切换账号的时候要修改相应的配置文件
     git config --global user.name 用户名
     git config --global user.email second@email.com
    在远程端添加前面生成的id_rsa_second.pub的公钥到远程库里。
    使用对应的ssh key密码。
Enjoy it
################################################################################



    本文由作者@PengEdy将其发表在Segmentfault上的两篇文章联合修订而成。

什么是Git Hooks？

话说，如同其他许多的版本控制系统一样，Git也具有在特定事件发生之前或之后执行特定脚本代码功能（从概念上类比，就与监听事件、触发器之类的东西类似）。Git Hooks就是那些在Git执行特定事件（如commit、push、receive等）后触发运行的脚本。

按照Git Hooks脚本所在的位置可以分为两类：

    本地Hooks，触发事件如commit、merge等。
    服务端Hooks，触发事件如receive等。

Git Hooks能做什么？

Git Hooks是定制化的脚本程序，所以它实现的功能与相应的git动作相关；在实际工作中，Git Hooks还是相对比较万能的。下面仅举几个简单的例子：

    pre-commit: 检查每次的commit message是否有拼写错误，或是否符合某种规范。
    pre-receive: 统一上传到远程库的代码的编码。
    post-receive: 每当有新的提交的时候就通知项目成员（可以使用Email或SMS等方式）。
    post-receive: 把代码推送到生产环境。（这就是我想要做的）
    etc...

更多的功能可以按照生产环境的需求写出来。
Git Hooks是如何工作的？

每一个Git repo下都包含有.git/hoooks这个目录（没错，本地和远程都是这样），这里面就是放置Hooks的地方。你可以在这个目录下自由定制Hooks的功能，当触发一些Git行为时，相应地Hooks将被执行。

这里是一个Git Hooks列表，现在如果觉得不是很明白，不用担心，以后我会继续讲：

    applypatch-msg
    pre-applypatch
    post-applypatch
    pre-commit
    prepare-commit-msg
    commit-msg
    post-commit
    pre-rebase
    post-checkout
    post-merge
    pre-receive
    update
    post-receive
    post-update
    pre-auto-gc
    post-rewrite

image图中是我一个本地repo的git hooks示例。
如何开始使用Git Hooks？

好了，前面啰嗦一大堆，这里才是重点。

如图中所示的文件，是由本地执行的脚本语言写成的，尽管这些文件默认会是Shell Script，你完全可以给它替换成自己喜欢的Ruby，Python或者Perl。

举个例子，它是这个样子的：

image

关于这些脚本文件的命名，细心的读者就会发现图中的文件都是上面Git行为列表中列出的名称加上后缀.sample。没错就是这样，把那些文件的后缀去掉，或者以列表中的名字直接命名，就会把该脚本绑定到特定的Git行为上。

所以说，Git Hooks的正确操作方式是：写脚本。
Git Hooks脚本分类

Git Hooks脚本可以按照运行环境分为两类：本地Hooks与服务端Hooks。
Client Side

也就是上面提到的本地hooks。 其实本地hooks还是占大多数的，可以给它们分成三类：

    commit hooks
    e-mail hooks
    其他

Commit Hooks

与git commit相关的hooks一共有四个，均由git commit命令触发调用，按照一次发生的顺序分别是：

    pre-commit
    prepare-commit-msg
    commit-msg
    post-commit

其中，pre-commit是最先触发运行的脚本。在提交一个commit之前，该hook有能力做许多工作，比如检查待提交东西的快照，以确保这份提交中没有缺少什么东西、文件名是否符合规范、是否对这份提交进行了测试、代码风格是否符合团队要求等等。 这个脚本可以通过传递--no-verify参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。

prepare-commit-msg脚本会在默认的提交信息准备完成后但编辑器尚未启动之前运行。 这个脚本的作用是用来编辑commit的默认提交说明。 该脚本有1~3个参数：包含提交说明文件的路径，commit类型（message, template, merge, squash），一个用于commit的SHA1值。这个脚本用的机会不是太多，主要是用于能自动生成commit message的情况。 该不会因为--no-verify参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。

commit-msg包含有一个参数，用来规定提交说明文件的路径。 该脚本可以用来验证提交说明的规范性，如果作者写的提交说明不符合指定路径文件中的规范，提交就会被终止。 该脚本可以通过传递--no-verify参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。

post-commit脚本发生在整个提交过程完成之后。这个脚本不包含任何参数，也不会影响commit的运行结果，可以用于发送new commit通知。

需要注意到，这几个脚本并不会通过clone传到项目中，而且既然是完全运行在本地，那就无法完全保证验证能起到作用（可以随便修改），但为了保证一些项目的可靠性，还需要开发者们自觉遵守这些规则。
E-mail Hooks

与git am相关的脚本由三个，均由git am触发运行，按顺序依次是：

    applypatch-msg
    pre-applypatch
    post-applypaych

如果在工作流中用不到这个命令，那也就无所谓了。不过，如果要用git format-patch命令通过Email提交补丁，这部分内容还是比较有用的。

applypatch-msg脚本最先被触发，它包含一个参数，用来规定提交说明文件的路径。该脚本可以修改文件中保存的提交说明，以便规范提交说明以符合项目标准。如果提交说明不符合规定的标准，脚本返回非零值，git终止提交。

说明一点，这个脚本看上去和commit-msg作用几乎一样。没错，默认情况下该脚本是这样写的：

也就是说，该脚本会调用commit-msg并执行。实际上，这一切都是可修改的。

pre-applypatch会在补丁应用后但尚未提交前运行。这个脚本没有参数，可以用于对应用补丁后的工作区进行测试，或对git tree进行检查。如果不能通过测试或检查，脚本返回非零值，git终止提交。 同样需要注意，git提供的此默认脚本中只是简单调用了pre-commit，因此在实际工作中需要视情况修改。

post-applypatch脚本会在补丁应用并提交之后运行，它不包含参数，也不会影响git am的运行结果。该脚本可以用来向工作组成员或补丁作者发送通知。
其他Hooks

    pre-rebase

由git rebase命令调用，运行在rebase执行之前，可以用来阻止任何已发发生过的提交参与变基（字面意思，找不到合适的词汇了）。默认的pre-rebase确实是这么做的，不过脚本中的next是根据Git项目自身而写的分支名，在使用过程中应该将其改成自己的稳定分支名称。

    post-checkout

由git checkout命令调用，在完成工作区更新之后执行。该脚本由三个参数：之前HEAD指向的引用，新的HEAD指向的引用，一个用于标识此次检出是否是分支检出的值（0表示文件检出，1表示分支检出）。

也可以被git clone触发调用，除非在克隆时使用参数--no-checkout。在由clone调用执行时，三个参数分别为null, 1, 1。

这个脚本可以用于为自己的项目设置合适的工作区，比如自动生成文档、移动一些大型二进制文件等，也可以用于检查版本库的有效性。

    post-merge

由git merge调用，在merge成功后执行。该脚本有一个参数，标识合并是否为压缩合并。该脚本可以用于对一些Git无法记录的数据的恢复，比如文件权限、属主、ACL等。
Server Side

除了本地执行的Hooks脚本之外，还有一些放在Git Server上的Hooks脚本，作为管理员，可以利用这些服务端的脚本来强制确保项目的任何规范。这些运行在服务端的脚本，会在push命令发生的前后执行。pre系列的脚本可以在任何时候返回非零值来终止某次push，并向push方返回一个错误说明。

这里简单介绍这几个脚本：

    pre-receive

由服务器端的git receive-pack命令调用，当从本地版本库完成一个推送之后，远端服务器开始批量更新之前，该脚本被触发执行。该脚本会从标准输入中读入一连串push过来的引用，如果这里面存在任何非零值，这批更新将不会被服务器接受。可以利用这个脚本来检查推送过来的提交是否合法。

    post-receive

由服务器端的gir receive-pack命令调用，当从本地版本库完成一个推送，并且在远程服务器上所有引用都更新完毕后执行。该脚本可以用于对其他镜像版本库的更新，或向用户发送提示（直接通过服务器端的echo命令）。如上文我提到的利用Git实现生产代码的自动化部署，就可以通过这个脚本完成。

    update 这是一个强大的hook脚本。它和pre-recieve有些类似，只是它会为推送过来的更新中涉及到的每一个分支都做一次检查，而后者则至始至终只有一次检查。另外，它不是从标准输入中读取数据，而是包含三个参数：
        要更新的引用或分支的名称
        引用中保存的旧对象名称（SHA1）
        将要保存到引用中的新对象名称(SHA1)

如果检查到返回非零值，之后返回非零值的引用会被拒绝，其他正常的引用更新都会被接受。除此之外，该脚本还可以用来防止引用被强制更新，因为它可以通过这些参数来检查新旧引用对象中是否存在继承关系，从而提供更细致的推送授权。

在Gitolite中，该脚本有更强大的应用实例。
Git Hooks项目介绍

    node-hooks: 一个命令行下的Git Hooks管理工具
    git-hooks: 一个全面的Git Hooks管理工具
    Git::Hooks: 一个实现Git Hooks的框架
    etc...
