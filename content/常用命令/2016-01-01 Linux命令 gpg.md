---
title: Linux命令 gpg openssl
date: 2017-01-06T16:46:14+08:00
update: 2017-03-01
categories: [linux_base]
tags: [gpg,openssl]
---

计算机技术发展这么多年，安全验证的技术也是很多种，大家熟悉有： BaseAuth, Oauth, Oauth2，基于Token的认证等机制。现在比较流行，大家常用的就是token认证的方式。
   token的生成一般是采用uuid保证唯一性，当用户登录时为其生成唯一的token，存储一般保存在数据库中。token过期时间采用把token二次保存在cookie或session里面，根据cookie和session的过期时间去维护token的过期时间。至于采用那种存储一般需要根据应用程序部署的环境，如果你的应用部署在多台机器上，使用nginx进行负载均衡，那么需要把token二次保存在cookie中。
   怎么保证用户使用状态下token持续时间的一直有效？这需要依赖框架的一种机制，大家应该都挺熟悉的，那就是aop技术（面向切面编程），在Yii2框架里面一般采用behavior来实现，主要内容就是在给用户行为的api controller添加一个before action。在action里面，从cookie中获取token,拿取用户信息，如果用户有操作的权限，就根据当前时间去更新cookie的过期时间，从而维护token的持续时间，使得token在给定时间内不会过期，这样可以使用户的操作体验达到最佳，又能起到保护程序安全的作用。


支持方式	支持内容
公钥	    RSA,RSA-E,RSA-S,ELG-E,DSA
对称加密   3DES,CAST5,BLOWFISH,AES,AES192,AES256,TWOFISH
散列0	    MD5,SHA1,SHA160,SHA256,SHA384,SHA512
压缩	   不压缩，ZIP,ZLIB,BZIP2

# gpg 对称加密 密码
gpg -c test.cpp         #加密
gpg -o output.cpp test.cpp.gpg 解密

# GPG 非对称加密 公钥+私钥
在 Unix 上密钥存储在 ~/.gnupg/ 中
~/.gnupg/pubring.gpg                 # 包含你的公钥和所有其他导入的信息
~/.gnupg/secring.gpg                 # 可包含多个私钥
# 配置文件介绍
GPG 配置文件目录:~/.gnupg
~/.gnupg/gpg.conf – 配置文件
~/.gnupg/trustdb.gpg – 信任库
~/.gnupg/pubring.gpg – 公钥库
~/.gnupg/secring.gpg – 私钥库


常用选项的简短描述：

-e 加密数据
-d 解密数据
-r 为某个收件者加密('全名' 或者 'email@domain')
-a 输出经过 ascii 封装的密钥
-o 指定输出文件

-o, --output
-r, --recipient NAME
-a, --armor   ascii  表示加内容转换成可见的 ASCII 码输出
-e, --encrypt
-s, --sign [file]  
-d, --decrypt
-se -r Bob [file]          sign and encrypt for user Bob

1. 查看本机钥匙信息
`gpg --list-keys`

2. 生成钥匙对
`gpg --gen-key`
    输入 name email passwd

3. 为了将自己的公钥发送给他人，你需要把公钥导出成为一个文件：
`gpg  -a --export [UID|name|email] --output key.pub`
      -a 表示输出文本文件格式。默认输出是二进制格式，因为二进制格式不太方便在网络（比如论坛或者博客）上展示，所以推荐文本格式。
      --output 指定输出文件的名字，你可以更改为其他名字。
      --export 表示执行输出公钥操作，后面的 UID 为你要输出的公钥的标识。

  私钥导出：
  `gpg -ao seckey.asc --export-secret-keys mykeyID`
4. 把公钥发布到公钥服务器
$ `gpg --keyserver keys.gnupg.net --send-key [公钥的标识（id）]`
注： --keyserver 可以不加，默认为 keys.gnupg.net
5. 在公钥服务器搜索公钥
$ `gpg --keyserver keys.gnupg.net --search-key [UID|name|email]`
6. 公钥并导入到本机
$ `gpg --keyserver keys.gnupg.net --recv-key 72E75B05`
        72E75B05 是这个公钥的id，这个id跟uid都是用于标识这个公钥的，因为uid是用户随便输入的所以会有重复的情况，因此在某些需要明确指定公钥的命令，需要用id而不能用uid表示这个公钥。
$ `gpg --import key.public`
7. 核对公钥的指纹值并签收公钥
$ `gpg --fingerprint`
8. 公钥进行签收（sign key）：
$ `gpg --sign-key [UID|name|email]`
  把对方的公钥导入到本机后，就已经可以用它来加密信息或者用于校验我的数字签名。不过这样每次操作时都会提示公钥不可信，因为虽然你导入了我的公钥，但存在导入冒充者的公钥的可能性。所以你需要进一步跟我核对公钥是否正确，然后签收（sign key）它

9. 密钥的回收
 `gpg -o revoke.asc –gen-revoke jianxiangqiao`
 选择吊销的原因：0=未指定原因，1=密钥已泄露，2=密钥被替换，3=密钥不再使用，Q=取消。

 密钥回收:当您的密钥对生成之后，您应该立即做一个公钥回收证书，如果您忘记了您的私钥的口令或者您的私钥丢失或者被盗窃，您可以发布这个证书来声明以前的公钥不再有效。 生成回收证书

 gpg --output revoke.asc --gen-revoke mykeyID

 导入回收证书
 gpg --import revoke.asc
 发送回收证书到服务器，声明原 GPG Key 作废
 gpg --keyserver keyserverAddress --send mykeyID


9. 删除密钥
先删除私钥
`gpg --delete-secret-keys jianxiangqiao`
再删除公钥
`gpg --delete-keys jianxiangqiao`
############################
# 加密一个文件 默认：
10. 加密一个文件
$ `gpg -a --output message-ciper.txt -r ivarptr@126.com -e message.txt`

  -a 表示输出文本文件格式。
  --output 指定输出（即加密后）的文件名。
  -r 指定信息的接收者（recipient）公钥的uid，可以是名字也可以是email地址。
  -e 表示这次要执行的是加密（encrypt）操作

11. 解密一个文件
  现在假设我已经收到你寄过来的加密文件 message-ciper.txt，使用如下的命令解密：
  $ `gpg --output message-plain.txt -d message-ciper.txt`

      --output 指定输出（即解密后）的文件名。
      -d 表示这次要执行的是解密（decrypt）操作
####################################################################
# GPG数字签名：用来检验一个文件是否被修改 默认:SHA256
12. 生成独立的签名文件 abc.txt + abc.txt.asc
      $ `gpg -a -b abc.txt`
    -a 表示输出文本文件格式。
    -b 表示以生成独立的签名文件的方式进行签名

13. 数字签名一个文件的方法B abc.txt.asc
    如果不想生成一个独立的签名文件，则还可以用如下的命令进行签名：
    `$ gpg -a --clearsign abc.txt`
    跟方法A不同的地方是用参数 –clearsign 替代了参数 -b参数 clearsign 表示将签名和原信息合并在一起，并生成一个新文件。

14. 然后使用如下命令进行检验：
    $ `gpg --verify abc.txt.asc`
15. 使用如下命令可以把原始信息提取出来：
    $ `gpg --output message-original.txt -d abc.txt.asc`

## GPG常用参数:
-s, --sign [文件名]        生成一份签字
--clearsign [文件名]       生成一份明文签字
-b, --detach-sign         生成一份分离的签字
-e, --encrypt             加密数据
-c, --symmetric           仅使用对称加密
-d, --decrypt             解密数据(默认)
--verify                  验证签字
--list-keys               列出密钥
--list-sigs               列出密钥和签字
--check-sigs              列出并检查密钥签字
--fingerprint             列出密钥和指纹
-K, --list-secret-keys    列出私钥
--gen-key                 生成一副新的密钥对
--delete-keys             从公钥钥匙环里删除密钥
--delete-secret-keys      从私钥钥匙环里删除密钥
--sign-key                为某把密钥添加签字
--lsign-key               为某把密钥添加本地签字
--edit-key                编辑某把密钥或为其添加签字
--gen-revoke              生成一份吊销证书
--export                  导出密钥
--send-keys               把密钥导出到某个公钥服务器上
--recv-keys               从公钥服务器上导入密钥
--search-keys             在公钥服务器上搜寻密钥
--refresh-keys            从公钥服务器更新所有的本地密钥
--import                  导入/合并密钥
--card-status             打印卡状态
--card-edit               更改卡上的数据
--change-pin              更改卡的 PIN
--update-trustdb          更新信任度数据库
--print-md 算法 [文件]     使用指定的散列算法打印报文散列值

选项：

-a, --armor               输出 ASCII 文本文件
-r, --recipient           为收件者“UID”加密
-u, --local-user          使用这个用户标识来签字或解密
-z N                      设定压缩等级为 N (0 表示不压缩)
--textmode                使用标准的文本模式
-o, --output              指定输出文件
-v, --verbose             详细模式
-n, --dry-run             不做任何改变
-i, --interactive         覆盖前先询问
--openpgp                 行为严格遵循 OpenPGP 定义
--pgp2                    生成与 PGP 2.x 兼容的报文

(请参考在线说明以获得所有命令和选项的完整清单)

范例：
-se -r Bob [文件名]          为 Bob 这个收件人签字及加密
--clearsign [文件名]         做出明文签字
--detach-sign [文件名]       做出分离式签字

### GPG 加密解密简明教程

大家都知道，互联网上充斥着大量的明文传输方式，可以说绝对是不安全地带。那么，我们如何保证在不安全的互联网中更可靠的传输重要数据呢？个人认为最好的方式之一就是使用 GPG 工具进行加密。此文只是简单介绍了 GPG 的常规用法，重在推广和普及 GPG 加密工具，详细的使用请参见 GPG 手册。

#### 名词解释

RSA / DSA / ElGamal : 是指加密算法

GPG :（全称 GnuPG ) 是一款非对称加密(PGP)的免费软件，非对称加密方式简单讲就是指用公钥加密文件，用私钥解密文件。如果你想给谁发送加密信息，首先你要得到他的公钥，然后通过该公钥加密后传给他，对方利用自已的私钥就可解密并读取文件了。

    # 配置文件介绍
    GPG 配置文件目录:~/.gnupg
    ~/.gnupg/gpg.conf – 配置文件
    ~/.gnupg/trustdb.gpg – 信任库
    ~/.gnupg/pubring.gpg – 公钥库
    ~/.gnupg/secring.gpg – 私钥库

#### 基本操作

- 生成密钥对
    `gpg --gen-key`

生成过程中会让你选择加密方式，一般选 (1) RSA and RSA (default) 就可以了，然后还需要选择加密位数、过期日期及输入姓名，邮件地址，备注，Passphrase(访问密码）等信息。最后你就可以干点别的事，比如上上网，玩玩游戏什么的，以便让机器生成一些随机数，回头你就可以看到密钥对已经生成完毕。

- 传播公钥：
导出公钥:生成后你可以把公钥中公钥库中导出来，以便传播给你的朋友。

    `gpg --export --armor mykeyID > gpgkey.pub.asc` # mykeyID 部分可以用 name 或 mail 地址代替


注： - -armor 表示加内容转换成可见的 ASCII 码输出,否则是二进制不可见内容。
现在你可以把导出的公钥通过 Email 等途径发送给你的朋友了，或者你也可以不导出公钥直接上传公钥到密钥服务器。

    `gpg --keyserver keyserverAddress --send mykeyID`

注： --keyserver 可以不加，默认为 keys.gnupg.net
然后只要把公钥 ID 和服务器地址告诉给朋友就可以了，朋友可以通过搜索你的 公钥 ID ，Email 地址或名字来获取并导入你的公钥，如下：

    `gpg --keyserver keyserverAddress --search-keys keyid/name/Email`
比如搜索我的：

    `gpg --keyserver keyserver.ubuntu.com --search-keys rikulu`

- 导入朋友的公钥

当你获得朋友的公钥文件后，你首先需要导入公钥到公钥库

    `gpg --import gpgkey.pub.asc`

或直接从公钥服务器导入

`gpg --keyserver keyserverAddress --recv-keys pubkeyID`

#### 私钥备份与密钥回收

- 密钥的导出和导入:以便用来备份密钥或导入到其它机器上。
1. 导出私钥
    `gpg -oa seckey.asc --export-secret-keys mykeyID`
2. 导入私钥
    `gpg --import seckey.asc`

- 密钥回收:当您的密钥对生成之后，您应该立即做一个公钥回收证书，如果您忘记了您的私钥的口令或者您的私钥丢失或者被盗窃，您可以发布这个证书来声明以前的公钥不再有效。
1. 生成回收证书
    `gpg --output revoke.asc --gen-revoke mykeyID`
2. 导入回收证书
    `gpg --import revoke.asc`
3. 发送回收证书到服务器，声明原 GPG Key 作废
    `gpg --keyserver keyserverAddress --send mykeyID`

#### 列出机器中保存的所有密钥

列出所有公钥
    gpg -k

列出所有私钥
    gpg -K


#### 常规使用
- 对称加密与解密： 有时候没有得到对方的公钥，而且资料不是太重要，此时还可以使用简单的对称加密方式(加密及解密都使用相同的密钥/密码)，加密过程中提示输出对称密钥/密码，注意:此密码是临时用的密码,不要设置和自己的私钥保护密码一样，以防别人猜测及盗用!

密码加密
    `gpg -c filename`   
         -c, --symmetric               仅使用对称加密

密码解密
    `gpg -d filename.gpg`
         -d, --decrypt                 解密数据(默认)

- 非对称文件加密与解密：

公钥加密：当你导入完好友的公钥后，就可以用朋友的公钥加密文件了，
    `gpg -e -r username filename (-r 表示指定用户)`

私钥解密：上面的操作会生成 filename.gpg 加密文件，之后你可以把此文件发送给好友了，对方就可以用自已的密钥来解密文件了。
    `gpg -d filename.gpg`

- 对文件签名

1. 数字签名 二进制
    `gpg -o doc.sig -s doc`
    `gpg --sign test.txt` >> test.txt.gpg
其中doc是原文件，doc.sig包含了原文件和签名，是二进制的。这个命令会要求你输入你的私钥的密码句。
    `gpg -o doc.sig -ser name doc` 既签名又加密
    `gpg -o doc -d doc.sig`        解密时自动校验签名
    `gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt test.txt`
    -u, --local-user 参数指定用发信者的私钥签名，
    -r, --recipient  参数指定用接收者的公钥加密，
    -a, --armor      参数表示采用ASCII码形式显示，
    -s, --sign       signature参数表示需要签名，
    -e, --encrypt    encrypt参数表示加密源文件。
2. 文本签名 ANSCII
    `gpg -o doc.sig --clearsign doc`

这样产生的doc.sig同样包含原文件和签名，其中签名是文本的，而原文件不变。

3. 分离式签名
    `gpg -o doc.sig -ab doc`

doc.sig仅包括签名，分离式签名的意思是原文件和签名是分开的。
b 表示分离式签名detach-sign

  如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。

  `gpg --detach-sign test.txt`
  是一个二进制的数据，如果想采用ASCII码形式，要加上armor参数
  `gpg --armor --detach-sign test.txt`

4. 验证签名
    `gpg --verify doc.sig [doc]`
    `gpg --verify test.txt.asc test.txt`
5. 修改信任等级
    `gpg --edit-key "rinetd" trust quit`
请选择您要使用的密钥种类：
(1) DSA 和 ElGamal (默认)
(2) DSA (仅用于签名)
(5) RSA (仅用于签名)
您的选择？ 1  ←只有1可以用于加密，其他种类只能用于签名
DSA 密钥对会有 1024 位。
ELG-E 密钥长度应在 1024 位与 4096 位之间。

您想要用多大的密钥尺寸？(2048)  ←选择密码的位数，位数越大，越安全，但速度越慢
您所要求的密钥尺寸是 2048 位

请设定这把密钥的有效期限。
0 = 密钥永不过期
<n>  = 密钥在 n 天后过期
<n>w = 密钥在 n 周后过期
<n>m = 密钥在 n 月后过期
<n>y = 密钥在 n 年后过期
密钥的有效期限是？(0) 0  ←根据实际情况选择密钥期限
密钥永远不会过期
以上正确吗？(y/n)y  ←确认

您需要一个用户标识来辨识您的密钥；本软件会用真实姓名、注释和电子邮件地址组合
成用户标识，如下所示：
“Heinrich Heine (Der Dichter) <heinrichh@duesseldorf.de>”

真实姓名：Hyphen Wang  ←请填入真实姓名，后面会用到
电子邮件地址：gpgencrypt@linuxfly.org  ←邮件作为标记之一，不能重复
注释：Use for GPG Encrypt  ←仅是注释而已
您选定了这个用户标识：
“Hyphen Wang (Use for GPG Encrypt) <gpgencrypt@linuxfly.org>”

更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？O  ←输入“O”确认
您需要一个密码来保护您的私钥。  ←输入两次用于访问私钥的密码，紧记，不能公开或丢失

我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动
鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。
++++++++++...++++++++++..++++++++

随机字节不够多。请再做一些其他的琐事，以使操作系统能搜集到更多的熵数！
(还需要274字节)  ←运行一些的程序，以便在内存中获得更多随机数
我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动
鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。
+++++++++++++++++++++++++.+++++.+++++.++++++++++.+++<+++++..+++++^^^
gpg: 密钥 A3942296 被标记为绝对信任  ←密钥ID
公钥和私钥已经生成并经签名。

gpg: 正在检查信任度数据库
gpg: 需要 3 份勉强信任和 1 份完全信任，PGP 信任模型
gpg: 深度：0 有效性：  2 已签名：  0 信任度：0-，0q，0n，0m，0f，2u
pub   1024D/A3942296 2008-12-19
密钥指纹 = E95E 1F77 6C4E 33BD 740C  19AB EEF9 A67E A394 2296
uid                  Hyphen Wang (Use for GPG Encrypt) <gpgencrypt@linuxfly.org>
sub   2048g/911E677B 2008-12-19

2. 密钥的回收
当您的密钥对生成之后，您应该立即做一个公钥回收证书，如果您忘记了您的私钥的口令或者您的私钥丢失或者被盗窃，您可以发布这个证书来声明以前的公钥不再有效。生成回收证书的选项是"--gen-revoke"。
`gpg --output revoke.asc --gen-revoke mykeyID`

其中mykey 参数是可以表示的密钥标识，产生的回收证书放在revoke.asc文件里，一旦回收证书被发放，以前的证书就不能再被其他用户访问，因此以前的公钥也就失效了。

PS:如果一旦决定撤销已经上传的公钥，就需要将该密钥的回收证书上传至密钥服务器完成回收工作。

`gpg --keyserver Server Address --send-keys mykeyID`

3.密钥的上传

当上述工作完成以后，为了让尽可能多的人获取您的公钥，您可以将公钥邮寄出去，或者贴在自己的个人主页上，当然还有一种更好的方法就是上传到全球性的密钥服务器，其他用户可以通过您提供的公钥ID来搜索并获得您的公钥。

通过如下命令可以将你的key发布到服务器上：

gpg --keyserver Server Address --send-keys mykeyID
PS:当然您也可以定义默认的服务器key server，一般安装好后的默认key server都是subkeys.pgp.net。你也可以通过修改.gnupg/gpg.conf中的keyserver信息来改变你的key server。
4.密钥的导出／导入

我们通常需要导出公钥和私钥保存起来，当然公钥是可以满世界的泼洒，但是私钥请务必保存好，否则你的密钥对将会永久性的失去威力。
公钥的导出：
gpg -o keyfilename --export mykeyID

如果没有mykeyID则是备份所有的公钥，-o表示输出到文件keyfilename中，如果加上-a的参数则输出文本格式( ASCII )的信息，否则输出的是二进制格式信息。

私钥的导出：
gpg -o keyfilename --export-secret-keys mykeyID

如果没有mykeyID则是备份所有的私钥，-o表示输出到文件keyfilename中，如果加上-a的参数则输出文本格式的信息，否则输出的是二进制格式信息。

密钥的导入：
gpg --import filename

PS:用户可以使用gpg --list-keys命令查看是否成功导入了密钥。

5.加密解密和数字签名

通过上述的密钥生成以及公钥分发后，加密和解密数据变得非常容易，用户可以通过使用该功能来达到安全地在网络上传输自己的隐密数据的目的。

如果用户patterson要给用户liyang发送一个加密文件，则他可以使用liyang的公钥加密这个文件，并且这个文件也只有liyang使用自己的密钥才可以解密查看。下面给出加解密的步骤：

用户patterson使用liyang的公钥加密文件test，使用下面的指令：
# gpg -e test

You did not specify a user ID. (you may use "-r")

Enter the user ID. End with an empty line: liyang

Added 1024g/C50E455A 2006-01-02 "liyang (hello) < liyang@sina.com>"

这样，就可以将gpg.conf文件加密成test.gpg，一般用户是无法阅读的

PS:当然你也可以直接指定使用哪个用户的公钥进行加密:

gpg -e -r liyang test  (-r 表示指定用户)

还可以加上参数 -a 来输出ASCII编码的文件test.asc(test.gpg是二进制编码的，不可用文本读)

gpg -ea -r liyang test

用户liyang 使用自己的私钥来解密该文件，如下所示：
# gpg -d test.gpg

You need a passphrase to unlock the secret key for

user: "liyang (hello) < liyang@sina.com>"

1024-bit ELG-E key, ID C50E455A, created 2006-01-02 (main key ID 378D11AF)

GnuPG提示用户，需要输入生成私钥使用的密码：

Enter passphrase:

gpg: encrypted with 1024-bit ELG-E key, ID C50E455A, created 2006-01-02

"liyang (hello) < liyang@sina.com>"

PS:无论加密解密，都可以加上-o参数来指定加密和解密后的输出文件，例如

#gpg -o doc.gpg -er name doc
其中name是选择谁的公钥加密，即谁是文件的接收者。
doc为要加密的文件，即原文件
doc.gpg为命令执行后生成的加密的文件，这里要先指定好文件名

对文件进行签名
1、数字签名
命令格式：
#gpg -o doc.sig -s doc
其中doc是原文件，doc.sig包含了原文件和签名，是二进制的。这个命令会要求你输入你的私钥的密码句。
#gpg -o doc.sig -ser name doc
既签名又加密

2、文本签名
#gpg -o doc.sig --clearsign doc
这样产生的doc.sig同样包含原文件和签名，其中签名是文本的，而原文件不变。

3、分离式签名
#gpg -o doc.sig -ab doc
doc.sig仅包括签名，分离式签名的意思是原文件和签名是分开的。
b 表示分离式签名detach-sign

4、验证签名
#gpg --verify doc.sig [doc]
验证之前必须导入文件作者的公钥，对于分离式签名，最后还要加上原文件，即后面的doc。

密匙签名和用户信任(进阶功能)
尽管在理论上讲，具备了公匙和私匙就可以实现安全的信息通讯，但是在实际应用中，还必须对公匙进行有效确认。因为，确实存在伪造公匙信息的可能。

由此，在GPG中引入了一个复杂的信任系统，以帮助我们区分哪些密匙是真的，哪些密匙是假的。这个信任系统是基于密匙的，主要包括密匙签名。

当收到熟人的公匙并且GPG告知不存在任何实体可信信息附加于这个公匙后，首要的事情就是对这个密匙进行“指纹采样”（fingerprint）。例如，我们对来自mike的公匙进行了导入操作，并且GPG告知我们不存在这个密匙的附加可信信息，这时候，我们首先要做的工作就是对这个新密匙进行“指纹采样 ”，相关命令及执行情况如下：

$ gpg --fingerprint mike@hairnet.orgpub 1024D/4F03BD39 2001-01-15 Mike Socks (I'm WIRED) Key fingerprint = B121 5431 8DE4 E3A8 4AA7 737D 20BE 0DB8 4F03 BD39sub 1024g/FDBB477D 2001-01-15$

这样，就从密匙数据中生成了其指纹信息，并且应该是唯一的。然后，我们打电话给mike，确认两件事情。首先，他是否发送给我们了密匙；其次，他的公匙的指纹信息是什么。如果Mike确认了这两件事情，我们就可以确信这个密匙是合法的。接下来，我们对密匙进行签名操作，以表示这个密匙来自Mike而且我们对密匙的信任，相关命令及执行情况如下：

$ gpg --sign-key mike@hairnet.orgpub 1024D/4F03BD39 created: 2001-01-15 expires: neversub 1024g/FDBB477D created: 2001-01-15 expires: never(1) Mike Socks (I'm WIRED) pub 1024D/4F03BD39 created: 2001-01-15 expires: neverFingerprint = B121 5431 8DE4 E3A8 4AA7 737D 20BE 0DB8 4F03 BD39Mike Socks (I'm WIRED) Are you really sure that you want to sign this keywith your key: Ima User (I'm just ME) Really sign? yYou need a passphrase to unlock the secret key foruser: Ima User (I'm just ME) 1024-bit DSA key, ID D9BAC463, created 2001-01-03Enter passphrase:$

执行到此，使用我们的私匙完成了对Mike的公匙的签名操作，任何持有我们的公匙的人都可以查证签名确实属于我们自己。这个附加到Mike的公匙上的签名信息将随它环游Internet世界，我们使用个人信誉，也就是我们自己的私匙，保证了那个密匙确实属于Mike。这是一个多么感人的充满诚信的故事啊 :-) 现实世界的人们是否应该从这严格的技术标准中反思些什么呢？

还是回到这里。获取附加于一个公匙上的签名信息列表的命令是：

gpg --check-sigs mike@hairnet.org

签名列表越长，密匙的可信度越大。其实，正是签名系统本身提供了密匙查证功能。假设我们接收到一个签名为Mike的密匙，通过Mike的公匙，我们验证出签名确实属于Mike，那么我们就信任了这个密匙。推而广之，我们就可以信任Mike签名的任何密匙。

为了更加稳妥，GPG还引入了另一个附加功能：可信级别（trust level）。使用它，我们可以为我们拥有的任何密匙的所有者指定可信级别。例如，即使我们知道Mike的公匙是可信的，但是事实上我们不能信任Mike在对其他密匙签名时的判断；我们会想，Mike也许只对少数密匙进行了签名，但却没有好好地检查一遍。

设置可信级别的命令及执行情况如下：

$ gpg --edit-key mike@hairnet.orgpub 1024D/4F03BD39 created: 2001-01-15 expires: never trust: -/fsub 1024g/FDBB477D created: 2001-01-15 expires: never(1) Mike Socks (I'm WIRED) Command> trust 1 = Don't know 2 = I do NOT trust 3 = I trust marginally 4 = I trust fully s = please show me more information m = back to the main menuYour decision? 2Command> quit$

在命令编辑环境中执行trust，然后选择级别2（I do NOT trust），这样我们割断了任何信任链，使每个密匙都必须经过Mike的签名。

6.删除密钥

从私钥钥匙环里删除密钥：

# gpg --delete-secret-keys hyphenwang@redflag-linux.com
gpg (GnuPG) 1.4.5; Copyright (C) 2006 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
sec  1024D/A3942296 2008-12-19 Hyphen Wang (Use for GPG Encrypt) <gpgencrypt@linuxfly.org>

要从钥匙环里删除这把密钥吗？(y/N)y
这是一把私钥！――真的要删除吗？(y/N)y

必须先删除私钥，然后才能删除公钥。
从公钥钥匙环里删除密钥：

# gpg --delete-keys hyphenwang@redflag-linux.com
gpg (GnuPG) 1.4.5; Copyright (C) 2006 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
sec  1024D/A3942296 2008-12-19 Hyphen Wang (Use for GPG Encrypt) <gpgencrypt@linuxfly.org>

要从钥匙环里删除这把密钥吗？(y/N)y

三.对称加密:
当然GPG同样具备普通的对称加密功能，这时候就不需要密钥，直接用密码加密即可（注意，这里的密码不一定是你私钥的密码，您大可以随意设定）

gpg -o doc.gpg -c doc

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

四.GPG常用参数:
语法：gpg [选项] [文件名]
签字、检查、加密或解密
默认的操作依输入数据而定
指令：

-s, --sign [文件名]           生成一份签字
--clearsign [文件名]      生成一份明文签字
-b, --detach-sign             生成一份分离的签字
-e, --encrypt                 加密数据
-c, --symmetric               仅使用对称加密
-d, --decrypt                 解密数据(默认)
--verify                  验证签字
--list-keys               列出密钥
--list-sigs               列出密钥和签字
--check-sigs              列出并检查密钥签字
--fingerprint             列出密钥和指纹
-K, --list-secret-keys        列出私钥
--gen-key                 生成一副新的密钥对
--delete-keys             从公钥钥匙环里删除密钥
--delete-secret-keys      从私钥钥匙环里删除密钥
--sign-key                为某把密钥添加签字
--lsign-key               为某把密钥添加本地签字
--edit-key                编辑某把密钥或为其添加签字
--gen-revoke              生成一份吊销证书
--export                  导出密钥
--send-keys               把密钥导出到某个公钥服务器上
--recv-keys               从公钥服务器上导入密钥
--search-keys             在公钥服务器上搜寻密钥
--refresh-keys            从公钥服务器更新所有的本地密钥
--import                  导入/合并密钥
--card-status             打印卡状态
--card-edit               更改卡上的数据
--change-pin              更改卡的 PIN
--update-trustdb          更新信任度数据库
--print-md 算法 [文件]    使用指定的散列算法打印报文散列值

选项：

-a, --armor                   输出 ASCII 文本文件
-r, --recipient               为收件者“UID”加密
-u, --local-user              使用这个用户标识来签字或解密
-z N                          设定压缩等级为 N (0 表示不压缩)
--textmode                    使用标准的文本模式
-o, --output                  指定输出文件
-v, --verbose                 详细模式
-n, --dry-run                 不做任何改变
-i, --interactive             覆盖前先询问
--openpgp                 行为严格遵循 OpenPGP 定义
--pgp2                    生成与 PGP 2.x 兼容的报文

(请参考在线说明以获得所有命令和选项的完整清单)

范例：

-se -r Bob [文件名]          为 Bob 这个收件人签字及加密
--clearsign [文件名]         做出明文签字
--detach-sign [文件名]       做出分离式签字
--list-keys [某甲]           显示密钥
--fingerprint [某甲]         显示指纹
