---
title: Linux命令 sed
date: 2016-09-27T15:57:46+08:00
update: 2017-03-28 09:50:19
categories: [linux_base]
tags: [sed]
---

简介
sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上。
sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。
[Sed 命令地址匹配问题总结](http://kodango.com/sed-address-matching-summary)


## 谍中谍，sed中sed

## 匹配替换 key
'Key' => env('ms_door_key',    '35gh6djhd8imd92ed'),
`sed "/'Key'/s/'[^']*'/'11111111111'/3" config.php`
'Secret' => env(ms_door_secret),'9kd7dnc0667sni82n28dd'),
`sed "/'Secret'/{s/'[^']*'/'222222222'/3;t;s//'222222222'/2}" config.php`


cat /etc/passwd |sed -n '10,$p' #显示 10-最后


cat /etc/passwd |tail -n+10|head -n10
等价
cat /etc/passwd |sed -n '10,19p'

## sed 插入数据
```
RUN  sed -i '/client\]/a  max_allowed_packet = 48M ' /etc/mysql/my.cnf
RUN  sed -i '/mysqld\]/a   \
event_scheduler=ON   \n\
default-storage-engine=INNODB   \n\
#default-character-set=utf8    \n\
character-set-server = utf8    \n\
max_allowed_packet = 16M    \n\
wait_timeout	= 500    \n\
interactive_timeout	= 500    \n\
connect_timeout = 20    \n\
' /etc/mysql/my.cnf
```

ENV LS_SETTINGS_DIR /etc/logstash
## 删除首次匹配表达式行 ·之前|之后· 所有的行
sed '/^title/,$!d' file  ## 删除到 title 行 （不包含）
sed '/^title/,$d' file   ## 从 title 开始删除
sed  '0,/---/d' A.txt    ## 删除到 --- 行 (包含)

#添加/移除注释
sed -i '/iptables/s/^#//'   # 取消注释
sed -i '/iptables/s/^/#/'   # 增加注释

`sed -ri 's/^path\.config:/#&/g' "$LS_SETTINGS_DIR/logstash.yml";`

## 批量替换
`find . -name "*.htm" -type f -print | xargs sed -i 's#http://aywusq#https://aywusq#g'`
`find ./ -path "./file" -prune -o -name "*.htm" |xargs grep -ins bizchinalinyi`
# sed使用参数
[root@www ~]# sed [-nefr] [动作]

参数：
```
-e ：多点编辑
-i --in-place ：直接修改文件内容((危险动作))，而不是输出到终端。
-r --regexp-extended ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
```
## 1. 定址
1，3表示1，2，3行，美元符号($)表示最后一行。
## 2. 定界符/分隔符
  sed s后加@,#,$ / 分隔符

  `echo this is a test line | sed 's/\w\+/[&]/g'`
  [this] [is] [a] [test] [line]

0. s命令后面的第一个字段就是定界符,可以使用任意字符作为定姐夫@,#,$ / ：| +
1. sed 只替换匹配中的内容
2. `\w\+` 匹配每一个单词        
3. `& `   对应于之前所匹配到的单词
4. `^ `  从开头匹配
5. `.*`  匹配任意字符
6. `# *` 匹配#后面连续多个空格

定界符
```
1、空(默认)：表示在全文范围
2、单地址：
　　n：指定行；
　　/pattern/：被此模式所匹配到的每一行；
3、地址范围：
　　n,N：从起始行到结束行
　　n,+N：从第起始行，向后数多少行
　　n,/par1/：从起始行到pat1第一次匹配到的行
　　/pat1/,/pat2/：从pat1第一次匹配到的行到pat2第一次匹配到的行
　　$：最后一行
```
命令: 组合命令{} 命令分隔 ;
```
模式空间(pattern space): [操作区,命令行]
a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～

r : /PATH/FROM/FILE：读取指定文件的内容，追加到当前模式空间后面
= ：显示行号                                           sed -n '/music/=' quote.txt
! ：命令前加!,给定界符取反，不在定界范围内才执行命令
s ：替换，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！
      修饰标记：
       /g：全局替换，没有此标记，只替换正则匹配到的第一项
       /w /PATH/TO/FILE：将替换后的内容保存一份至指定文件
       /p：将替换成功的内容送至标准输出

n ：读取文件下一行到[pattern]模式空间中
N ：读取文件下一行追加到[pattern]模式空间中
d ：删除模式空间中的行
D ：删除模式空间中的所有行

保持空间(hold space): 缓冲区
sed每次执行时还拥有一个保持空间(hold space)缓冲区,用来临时保存内容，开始时默认是一个空行。
保持空间用于保存模式空间的内容，模式空间的内容可以复制到保持空间，同样地保持空间的内容可以复制回模式空间。sed提供了几组命令用来完成复制的工作，其它命令无法匹配也不能修改模式空间的内容
H: 保存（Hold) 	h/H 	将[模式空间pattern]的内容copy或者append到[保持空间hold --缓存区]
G: 取回（Get） 	g/G 	将[保持空间hold]的内容copy或者append到[模式空间pattern]
x: 交换（Exchange） 	x 	交换模式空间和保持空间的内容

一、标签[文本编辑的一点心得--sed篇](http://bbs.chinaunix.net/thread-1762006-1-1.html)
b label ,无条件跳转到标签label,如果label没有指定,跳转到命令的结尾
t label ,如果最后一次输入的最后一个 s/// 子命令执行成功,跳转到标签label,如果label没有指定,跳转到命令的结尾
:a                   #定义标签a
$!N                  #不是最后一行，执行N命令
/ms$/s/\n/ /         #如果以ms结尾，将\n替换为空格
ta                   #如果s///命令执行成功，跳转到标签a处
P                    #打印pattern space的第一行
D                    #删除pattern space的第一行，循环

```
#正则匹配：
```
^ 行的开始 如：/^sed/匹配所有以sed开头的行。   
$ 行的结束 如：/sed$/匹配所有以sed结尾的行。   
. 匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。   
* 匹配零或多个字符 如：`/ *sed/`匹配所有模板是一个或多个空格后紧跟sed的行。  
[] 匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。  
[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。  
\(..\) 保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。  
& 保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
  用来精确匹配一个单词 sed -n '/\<acc=701\>/'p
\< 锚定单词的开始，如:/\<love/匹配包含以love开头的单词的行。   
\> 锚定单词的结束，如/love\>/匹配包含以love结尾的单词的行。   

x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。   
x\{m,\}重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。   
x\{m,n\}重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5--10个o的行。
```
## 多空行合并为一行
sed '/^$/{N/^\n$/D'}
`sed -i -rn 'h;n;:a;H;n;$!ba;g;s/(\n){2,}/\n\n/g;p' test.txt`
!{$!ba}就是如果不满足前面的条件，就执行$!ba
{}就是把要执行的命令括起来
！{}就是括号里的都不执行

## 删除重复行 uniq
# 只保留重复行中的第一行，其他行删除
 `sed '$!N; /^\(.*\)\n\1$/!P; D'`
 $!N; 不是最后一行 读取下一行到模式空间
 两行合并到一行 匹配两行如果一样就删除


## sed行首删除一个字符
## sed行首添加一个字符
sed '1 a\string1\n\string2\n' /etc/passwd 在第1行后插入两行字符串。
sed '1 i\string1\n\string2\n' /etc/passwd 在第1行前插入两行字符串

```sh
# enable snd-soc-wmt-fm34  
sed -i '/snd-soc-wmt-fm34/s/^#//' fs_patch/load_drivers.sh  

# s/^#//表示将字符串开头的#字符替换为空(即去除行首的#字符)
# /snd-soc-wmt-fm34/表示匹配含有snd-soc-wmt-fm34字符串的行

# disable snd-soc-wmt-fm34 back  
sed -i '/snd-soc-wmt-fm34/s/^/#&/' fs_patch/load_drivers.sh  

# 这里和上面的删除操作唯一的不同就在于s/^/#&/部分。其中，^字符匹配行首，#字符是一般字符表示添加该字符
```
`find . -name '*.php'  -exec sed -rni 'h;n;:a;H;n;$!ba;g;s/(\n){2,}/\n\n/g;p' "{}" \;`
################################################################################
### 匹配不替换 不匹配替换
sed '/^1/!s/1/X/g'

## 排序删除重复行
file='test.txt'  
sort -n $file | uniq  
sort -n $file | awk '{if($0!=line)print; line=$0}'  
sort -n $file | sed '$!N; /^.∗\n\1$/!P; D'
## 移动行
一、把上面的某行移动到下面是容易的，用 h 存到保留区，用 G 取出就行了，例如，把第六行变成第九行：
sed '6{h;d};9G' #第6行存到暂存区并删除 第9行取出并追加
二、由于sed是按顺序读取文本，所以把下面的行移动到上面稍微复杂一些，例如，把第七行放到第二行：
sed -n '2!{p;d};:1;6!{N;b1};h;n;p;g;p'
前面的数字是移动后的位置，后面的数字是将要被移动的行数减一。

##  sed 转义单引号的问题
sed命令中，使用单引号来制定操作，如sed 's/regular/replace/'。如果想在单引号中转义单引号采用转义字符是不行的。解决的方法是把sed部分用单引号分割开，在外面转义。

如：A:  nl /etc/passwd | sed '2a I\'am Dophi!'     --------错误
      B: nl /etc/passwd | sed '2a I'\''am Dophi'    ---------正确，都是单引号，单引号之间没有空格
`  sed -i "s|\('debug' =>\) .*|\1 ${DEBUG},|" config.php`


## rvm采用国内镜像
sed -i -e 's/ftp\.ruby-lang\.org\/pub\/ruby/ruby\.taobao\.org\/mirrors\/ruby/g' ~/.rvm/config/db

## 多文件字符替換
`sed 's/localhost/127.0.0.1/g' mysql_virtual_*.cf  `
## 删除一个文本文件中不包含某几个关键词的所有行
sed -i '/aa|bb|ggg/!d' a.txt
## 删除file文件所有包含某几个关键词的所有行  
sed -i '/abc/d;/efg/d' a.txt  // 删除含字符串"abc"或“efg"的行

# 将 #!/bin/bash 替换为 #!/usr/bin/env bash
sed -i '/#!/bin/bash: /d'

# hexo 相关
## 匹配第二行的内容 并替换成当前日期
`sed -i -u -E "2s#^date:.+#date: $(date "+%Y-%m-%d %H:%M:%S" )#g" sed.md`

## 找到所有文章,并删除所有包含update:
`find . -name "*.md" -type f -exec sed -i '/layout: /d' {} \;`
`find . -name "*.md" -type f -exec sed -i '/update: /d' {} \;` # 删除 update: 行
`find . -name "*.md" -type f -exec sed -i '3i update: ' {} \;` # 第三行插入 update:
`find . -name "*.md" -type f -exec sed -i '1{h;d};3G' {} \;`   # 下移2行
`find . -name "*.md" -type f -exec sed -i '2h;3G' {} \;`       # 复制第2行
`find . -name "*.md" -type f -exec sed -i 's/^category :/categories:/' {} \;`   # 替换category为categories
# hexo2hugo


## 去重 删除重复的 --- 行
 `sed -e 'N; /^\(.*\)\n\1$/!P; D'` ## 任意去重
 `sed -e 'N; /^\(---\)\n\1$/!P; D'`
## 去除windows \r
`sed -i 's/\r//g' *.md `

`sed -i '9,$s/$/  /g' *.md`
## 0. 首行插入 ---
 ` sed -i '1i ---' **/*.md `
## 1. 修改date 格式为rfc3339
date: 2016-09-27T15:57:46+08:00 --> 2017-09-28T11:11:13+08:00
`sed -i -E '/^date:/s/([0-9]{4}-[0-9]{2}-[0-9]{2})[ T]([0-9]{2}:[0-9]{2}:[0-9]{2})(\+[0-9]{2}:[0-9]{2})?/\1T\2+08:00/' **/*.md`

## 2. 实现添加[]并将里面的空格替换为，  (合并下面两条命令)
      tags: arp,linux --> tags: [arp,linux]
 ` sed -i -E -e '/^categories:/{s# ([^\r\n\t]*)# [\1]#;s/ /,/2g}' -e '/^tags/{s# ([^\r\n\t]*)# [\1]#;s/ /,/2g}' **/*.md`
  ##  categories 修正为数组
    ` sed -i -E -e '/^categories:/s# ([^\r\n\t]*)# [\1]#' -e '/^tags/s# ([^\r\n\t]*)# [\1]#' *.md `
  ##  从第二个空格起替换为,
    `sed -E '/categories: /s/ /,/2g' *.md`

##  在第3行插入
`sed -i '3i update: 2016-01-01' *.md`
#
`sed -i '1d' *.md`

##  在文件首行前 加入指定文字
`sed -i '1i title: 内存对齐\ndate: $dt\ncategories: 朴素linux\ntags: linux\n---\n' *.md`

## 批量在行尾添加空格
`find . -type f -name '*.php' -exec sed '$a\\n' {} \;`
1) # sed '/$/a\\n' test.txt，可以在文件的每行末尾添加一个回车
2) # sed '$a\eof' test.txt，可以在文件的末尾添加'eof'

## 删除全部空行 包括空格
`sed '/^ *$/d'test.txt`
`%s/^n//g`  全局替换所有以回车开头的字符，替换为空。
`%s/^n$//g` 如果有多个连续的空行，想保留一行

## 替换部分
'DB_HOST'   => 'localhost', // 服务器地址
DB_HOST=127.0.0.1   # 服务器地址
`sudo sed -i -u -E "s#'DB_HOST'\s+=> '[a-zA-Z0-9._]+'#'DB_HOST'   => '$DB_HOST'#g" config.php
`
## 获取本机的ip  `192.168.1.100`
1. 将 IP 前面的部分予以删除
`ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g'`
192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
2. 将 IP 后面的部分予以删除
`ifconfig enp3s0 | grep 'inet addr' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g'`
192.168.1.100


# 移除大部分的HTML标签（包括跨行标签）
`sed -e :a -e 's/<[^>]*>//g;/ `

1、定位行：
sed -n '12,~3p' pass #从第12行开始，直到下一个3的倍数行（12-15行）
sed -n '12,+4p' pass #从第12行开始，连续4行（12-16行）
sed -n '12~3p' pass #从第12行开始，间隔3行输出一次（12，15，18，21...）
sed -n '10,$p' pass   #从第10行至结尾
sed -n '4!p' pass   #除去第4行

2、正则：'/正则式/'
sed -n '/root/p' /etc/passwd
sed -n '/^root/p' /etc/passwd
sed -n '/bash$/p' /etc/passwd
sed -n '/ro.t/p' /etc/passwd
sed -n '/ro*/p' /etc/passwd
sed -n '/[ABC]/p' /etc/passwd
sed -n '/[A-Z]/p' /etc/passwd
sed -n '/[^ABC]/p' /etc/passwd
sed -n '/^[^ABC]/p' /etc/passwd
sed -n '/\<root/p' /etc/passwd
sed -n '/root\>/p' /etc/passwd

3、扩展正则：
sed -n '/root\|yerik/p' /etc/passwd #拓展正则需要转义
sed -nr '/root|yerik/p' /etc/passwd #加-r参数支持拓展正则
sed -nr '/ro(ot|ye)rik/p' /etc/passwd #匹配rootrik和royerik单词
sed -nr '/ro?t/p' /etc/passwd   #?匹配0-1次前导字符
sed -nr '/ro+t/p' /etc/passwd   #匹配1-n次前导字符
sed -nr '/ro{2}t/p' /etc/passwd   #匹配2次前导字符
sed -nr '/ro{2,}t/p' /etc/passwd   #匹配多于2次前导字符
sed -nr '/ro{2，4}t/p' /etc/passwd #匹配2-4次前导字符
sed -nr '/(root)*/p' /etc/passwd   #匹配0-n次前导单词

4、sed编辑（对行的插入、删除、替换操作）
sed '/root/a admin' /etc/passwd   #在root行后追加一个admin行
sed '/root/i admin' /etc/passwd   #在root行前插入一个admin
sed '/root/c admin' /etc/passwd   #将root行替换为admin
sed '/root/d' /etc/passwd    #删除含有root的行

s替换
sed -n 's/root/admin/p' /etc/passwd
sed -n 's/root/admin/2p' /etc/passwd        #在每行的第2个root作替换
sed -n 's/root/admin/gp' /etc/passwd
sed -n '1,10 s/root/admin/gp' /etc/passwd
sed -n 's/root/AAA&BBB/2p' /etc/passwd       #将root替换成AAArootBBB，&作反向引用，代替前面的匹配项
sed -ne 's/root/AAA&BBB/' -ne 's/bash/AAA&BBB/p' /etc/passwd #-e将多个命令连接起来，将root或bash行作替换
sed -n 's/root/AAA&BBB/;s/bash/AAA&BBB/p' /etc/passwd   #与上命令功能相同
sed -nr 's/(root)(.*)(bash)/\3\2\1/p' /etc/passwd     #将root与bash位置替换，两标记替换
或sed -n 's/\(root\)\(.*\)\(bash\)/\3\2\1/p' /etc/passwd
bash:x:0:0:root:/root:/bin/root

y替换
echo "sorry"|sed 'y/ory/ABC/' #一一对应替换（sABBC）


6、sed的模式空间和保持空间
h：模式---->保持
H：模式--->>保持
x：模式<--->保持
g：保持---->模式
G：保持--->>模式

例如：
111
222
333
444
# sed '1h;2,3H;4G'

分析
CMD         模式     保持
111         111     \n
1h          111     111
----------->111
222         222     111
2,3H        222     111\n222
----------->222
333         333     111\n222
2,3H        333     111\n222\n333
----------->333
444         444     111\n222\n333
4G          444\n111\n222\n333
----------->444\n111\n222\n333


1－10
11－22
22－33
11－22
34－END

7、sed特殊用法
sed -n '/root/w a.txt'    #将匹配行输出到文件
sed '/root/r abc.txt' /etc/passwd #把abc.txt的文件内容读入到root匹配行后
sed -n '/root/w a.txt'
sed -n '/root/{=;p}' /etc/passwd #打印行号和匹配root的行
sed -n '/root/{n;d}' /etc/passwd #将匹配root行的下一行删除
sed -n '/root/{N;d}' /etc/passwd #将匹配root行和下一行都删除
sed '22{h;d};23,33{H;d};44G' pass

8、sed 脚本编写方法
<1>从文件读入命令
sed -f sed.sh
sed.sh文件内容：
s/root/yerik/p
s/bash/csh/p

<2>直接运行脚本 ./sed.sh /etc/passwd
#!/bib/sed -f
s/root/yerik/p
s/bash/csh/p


###################################
二、Sed练习

1，删除文件每行的第一个字符。
sed -n 's/^.//gp' /etc/passwd
sed -nr 's/(.)(.*)/\2/p' /etc/passwd
2，删除文件每行的第二个字符。
sed -nr 's/(.)(.)(.*)/\1\3/p' /etc/passwd

3，删除文件每行的最后一个字符。
sed -nr 's/.$//p' /etc/passwd
sed -nr 's/(.*)(.)/\1/p' /etc/passwd

4，删除文件每行的倒数第二个字符。
sed -nr 's/(.*)(.)(.)/\1\3/p' /etc/passwd

5，删除文件每行的第二个单词。
sed -nr 's/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\2\3\5/p' /etc/passwd

6，删除文件每行的倒数第二个单词。
sed -nr 's/(.*)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]*)/\1\2\4\5\6/p' /etc/samba/smb.conf

7，删除文件每行的最后一个单词。
sed -nr 's/(.*)([^a-Z]+)([a-Z]+)([^a-Z]*)/\1\2\4/p' /etc/samba/smb.conf

8，交换每行的第一个字符和第二个字符。
sed -nr 's/(.)(.)(.*)/\2\1\3/p' /etc/passwd

9，交换每行的第一个单词和第二个单词。
sed -nr 's/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\4\3\2\5/p' /etc/samba/smb.conf

10，交换每行的第一个单词和最后一个单词。
sed -nr 's/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\4\3\2\5/p' /etc/passwd

11，删除一个文件中所有的数字。
sed 's/[0-9]*//g' /etc/passwd

12，删除每行开头的所有空格。
sed -n 's/^\ *//p' /etc/samba/smb.conf
sed -nr 's/( *)(.*)/\2/p' testp

13，用制表符替换文件中出现的所有空格。
sed -n 's/\ /\t/gp' pass

14，把所有大写字母用括号（）括起来。
sed -nr 's/([A-Z])/(&)/gp' testp
sed -n 's/[A-Z]/(&)/gp' testp

15，打印每行3次。
sed 'p;p' pass

16，隔行删除。
sed -n '1~2p' pass

17，把文件从第22行到第33行复制到第44行后面。
sed '1,21h;22h;23,33H;44G' pass

18，把文件从第22行到第33行移动到第44行后面。
sed '22{h;d};23,33{H;d};44G' pass

19，只显示每行的第一个单词。
sed -nr 's/([^a-Z]*)([a-Z]+)([^a-Z]+)(.*)/\2/p' /etc/passwd

20，打印每行的第一个单词和第三个单词。
sed -nr 's/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\2--\4/p' /etc/passwd

21，将格式为    mm/yy/dd    的日期格式换成   mm；yy；dd
date +%m/%Y/%d |sed -n 's#/#;#gp'

22, 逆向输出
cat a.txt
ABC
DEF
XYZ
输出样式变成
XYZ
DEF
ABC




一、文本间距
------------

**二倍行距**

    sed G

**在含空行的文件的行与行之间添加空行。输出文件的行与行之间的空行数不会多于一行。**

    sed '/^$/d; G'

**三倍行距**

    sed 'G; G'

**取消二倍行距（假定偶数行为空行）**

    sed 'n; d'

<span id="more-455230"></span>

二、编号方式
------------

**标记行号（纯左对齐）。使用tab替代space可以保持页边距。**

    sed = filename | sed 'N; s/n/t/'

**标记行号（号码在左，文本右对齐）。**

    sed = filename | sed 'N; s/^/ /; s/*(.{6,})n/1 /'

**标记行号，但只输出非空的行。**

    sed '/./=' filename | sed '/./N; s/n/ /'

**计算行数（类似于”wc -l”）**

    SED -N '$='

三、文本转换与替换
------------------

**UNIX环境下：将DOS换行符转(CR/LF)换成Unix格式**

    sed 's/.$//' #假定所有行均以CR/LF结尾
    sed 's/^M$//' #在bash/tcsh下，按Ctrl-V然后按Ctrl-M
    sed 's/x0D$//' #gsed 3.02.80中可用，但第一个脚本更简单一些

**UNIX环境下：将UNIX换行符转换成DOS格式**

    sed "s/$/'echo -e r'/" #ksh命令行模式下
    sed 's/$'"/'echo r'/" #bash命令行模式下
    sed "s/$/'echo r'/" #zsh命令行模式下
    sed 's/$/r/' #gsed 3.02.80

**DOS环境下：将Unix换行符(LF)转换成DOS格式**

    sed "s/$//" #方法一
    sed -n p #方法二

**DOS环境下：将DOS换行符（CR/LF）转换成Unix格式**

    #此操作不能在DOS版的sed中实现。转用tr来代替
    tr -d r outfile #GNU tr version 1.22或以上

**删除行首空白（space, tab），使文本全部左移。**

    sed 's/^[ t]*//' #请参照文末关于't'的注解

**删除行末空白（space, tab）**

    sed 's/[ t]*$//' #请参照文末关于't'的注解

**同时删除行首行尾空白（space， tab）**

    sed 's/^[ t]*//; s/[ t]*$//'

**在每行行首插入5个空格（使页面右移）**

    sed 's/^/ /'

**使文本全部靠右对齐（宽度为79列）**

    sed -e; a -e 's/^.{1, 78]$/ &/;ta'

**使文本居中（宽度为79列）。**

    #方法一中，行首空格仍然有效，行尾被加上了空白以填补不足。
    #方法二中，行首空白在居中过程中被抛弃，行尾也没有补白的空白。
    sed -e :a -e 's/^.{1, 77}$/ &/;ta' #方法一
    sed -e :a -e 's/^.{1, 77}$/ &/;ta' -e 's/( *)1/1/' #方法二

**查找与替换：将每行中的”foo”替换成”bar”**

    sed 's/foo/bar/' #只替换每行中的第一个实例
    sed 's/foo/bar/4′ #只替换每行中的第四个实例
    sed 's/foo/bar/g' #替换一行中出现的所有实例
    sed 's/(.*)foo(.*foo)/1bar2/' #替换每行倒数第二个实例
    sed 's/(.*)foo/1bar/' #只替换替换每行倒数第一个实例

**查找与替换：将不含”baz”的行中的”foo”替换成”bar”**

    sed '/baz/!s/foo/bar/g'

**将”scarlet””ruby””puce”换为”red”**

    sed 's/scarlet/red/g; s/ruby/red/g; s/puce/red/g' #适用于大部分sed
    gsed 's/scarlet|ruby|puce/red/g' #只适用于GNU的sed

**颠倒行序（使末行变首行，首行变末行） （类似tac）**

    #HHsed的特性（或者是Bug）会导致空行被删除
    sed '1!G;h;$!d' #方法一
    sed -n '1!G; h; $p' #方法二

**反序输出每一行（类似rev）**

    sed '/n/!G;s/(.)(.*n)/&21/;//D;s/.//' /*这里似乎有点问题*/

**如果某行以反斜线结尾，则将下一行接在它的后面**

    sed -e :a -e '/$/N; s/n//; ta'

**如果某行以等号开头，
则将它接在上一行的行尾，并将等号用一个空格来替换**

    sed -e :a -e '$!N; s/n=/ /; ta' -e 'P;D'

**给数值字符串加逗点，如将”1234567″变为”1,234,567″**

    gsed ':a; s/B[0-9]{3}>/,&/;ta' #GNU sed
    sed -e :a -e 's/(.*[0-9]([0-9]{3})/1,2/;ta' #其它sed

**给带小数点和负号的数字加逗点（GNU sed）**

    gsed ':a;s/(^|[^0-9])([0-9]+)([0-9]{3}/12,3/g;ta'

**每隔五行加入一个空行**

    gsed '0~5G' #只适用于GNU sed
    sed 'n;n;n;n;G' #其它sed

四、选择输出特定的行
--------------------

**输出文件的前十行（与head类似）**

    sed 10q

**输出文件和第一行**

    sed q

**输出文件和末尾10行（与tail类似）**

    sed -e :a -e '$q; N;11, $D;ba'

**输出文件的最后两行**

    sed '$!N; $!D'

**输出文件的末行**

    sed '$!d' #方法一
    sed -n '$p' #方法二

**输出符合正则表达式的行（类似grep）**

    sed -n '/regexp/p' #方法一
    sed '/regexp/!d/ #方法二

**输出不符合正则表达式的行（类似grep -v）**

    sed -n '/regexp/!p' #方法一，其实现与上面的描述是一致的
    sed '/regexp/d' #方法二，这样的语法更简单

**输出某一正则表达式之前的一行，但不输出含有该正则表达式的行**

    sed -n '/regexp/{g;1!p;};h'

**输出某一正则表达式之后的一行，但不输出含有该正则表达式的行**

    sed -n'/regexp/{n;p;}'

**输出某一正则表达式之前和之后的一行，以及该正则表达式出现的行的行号（与”grep
-A1 -B1″）**

    sed -n -e '/regexp/{=;x;l!p;g;$!N;p;D;}' -e h

**提取含AAA和BBB和CCC（任意顺序）的行**

    sed '/AAA/!d; /BBB/!d; /CCC/!d'

**提取含AAA和BBB和CCC（按该顺序）的行**

    sed '/AAA.*BBB.*CCC/!d'

**提取含AAA或BBB或CCC的行（类似于egrep）**

    sed -e '/AAA/b' -e '/BBB/b' -e'/CCC/b' -e d #适用于大部分sed
    gsed '/AAA|BBB|CCC/!d' #只适用于GNU sed

**输出含有AAA的段落（空行分隔段落）**

    #以下脚本在HHsed v1.5 中要在'x;'后加上'G;'
    sed -e '/./{H;$!d;}' -e 'x; /AAA/!d;'

**输出含AAA和BBB和CCC（任意顺序）的段落**

    sed -e '/./{H; $!d;}' -e 'x;/AAA/!d; /BBB/!d; /CCC/!d'

**输出含AAA或BBB或CCC的段落**

    sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
    gsed '/./{H;$!d;};x;/AAA|BBB|CCC/b;d' #只适用于GNU sed

**输出长度不小于65个字符的行**

    sed -n '/^.{65}/p'

**输出长度小于65个字符的行**

    sed -n '/^.{65}/!p' #方法一，其实现与上面的描述是一致的
    sed '/^.{65}/d' #方法二，这样的语法更简单

**输出从给定正则表达式到文件末尾的部分**

    sed -n '/regexp/,$p'

**输出指定行号的部分（如输出8-12行，包括本身）**

    sed -n '8, 12p'

**输出第52行**

    sed -n '52p' #方法一
    sed '52!d' #方法二
    sed '52q;d' #方法三（在文件较大时效率更高）

**从第三行开始，每七行输出一次**

    gsed -n '3~7p' #只适用于GNU sed
    sed -n '3,${p;n;n;n;n;n;n;} #适用于其它sed

**输出两个正则表达式之间的部分（包含本身）**

    sed -n "/regexp1/,/regexp2/p' #大小写敏感

五、选择性删除特定行
--------------------

**输出除两正则表达式之间部分之外的全部**

    sed '/regexp1/,/regexp2/d'

**删除重复、连续的行（类似uniq）**

    #一系列重复的行中的第一行将被保留，其余的被删除
    sed '$!N; /^(.*)n1$/!P; D'

**删除重复、不连续的行**

    #注意不要造成缓冲区溢出，否则使用GNU sed
    sed -n 'G; s/n/&&/; /^([ -~]*n).*n1/d; s/n//; h; P'

**删除文件的前十行**

    sed '1, 10d'

**删除文件的末行**

    sed '$d'

**删除文件的最后两行**

    sed 'N; $!P;$!D;$d'

**删除文件的最后10行**

    sed -e :a -e '$d;N;2,10ba' -e 'P;D' #方法一
    sed -n -e :a -e '1, 10!{P;N;D;};N;ba' #方法二

**每8行删除一次**

    gsed '0~8d' #只适用于GNU sed
    sed 'n;n;n;n;n;n;n;d;' #适用于其它sed

**删除文件中连续的空行（只保留一个空行），包括开头和结尾 （类似cat
-s）**

    sed '/./,/^$/!d' #方法一，文件开头无空行，结尾保留一个空行
    sed '/^$/N;/n$/D' #方法二，文件开头允许一个空行，结尾无空行

**删除所有连续的空行，除了前两个之外**

    sed '/^$/N;/n$/N;//D'

**删除文首所有的空行**

    sed '/./,$!d'

**删除文末所有空行**

    sed -e :a -e '/^n*$/{$d;N;ba' -e '}' #适用于所有sed
    sed -e :a -e '/^n*$/N;/n$/ba' #同上，但不包括gsed 3.02*

**删除每一段落的最后一行**

    sed -n '/^$/{p;h;};/./{x;/./p;}'

六、特殊用法
------------

**去除man文档中的特殊字符（char，backspace）**

    #如果你使用Unix System V 或者 bash shell，'echo'命令需要一个'-e'参数
    sed "s/.`echo b`//g" #Unix 环境下双引号是必需的
    sed 's/.^H//g' #在bash/tcsh, 按Ctrl+V 然后按Ctrl+H
    sed 's/.x08//g' #sed v1.5的十六进制表达式

**获取Usenet/e-mail的头信息**

    sed '/^$/q' #删除第一个空行后的所有行

**获取Subject头信息，但是要删除原始的”Subject:”部分**

    sed '/^Subject: */!d; s///;q'

**获取返回地址头信息**

    sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

**为每一行行首添加一个尖括号和一个空格（引用）**

    sed 's/^ /> /'

**删除行首的尖括号和空格（去除引用）**

    sed 's/^> //'

**去除大部分HTML标签（适用于多行标签）**

    sed -e :a -e 's/<[^>]*>//g;/

**提取多部分的UU编码的二进制文件，删除不必要的头信息，只留下UU编码的部分**

    #传送给sed的文件必须按适当的顺序
    #版本一可以在命令行下输入
    #版本二可以写成可执行的Unix脚本
    sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode #版本一
    sed '/^end/,/^begin/d' "$@" | uudecode #版本二

七、典型用法
------------

sed接受一个或多个命令并按顺序对每一行输入执行全部这些命令。当所有的命令都对第一行执行以后，这一行被输出，然后开始对第二行进行处理，如此循环。前面的例子假定输入来自标准输入设备（如控制台，一般是通过管道的输入）。如果输入不来自stdin，可以在命令行中添加一个或多个文件名。输出将被送到标准输出设备。

如：

    cat filename | sed '10q' #使用管道输入
    sed '10q' filename #同样的效果，不过免去了使用cat
    sed '10q' filename > newfile #重定向输出到磁盘

更多语法讲解，包括用包含编辑命令的文件来代替命令行输入，请参阅

-   《sed&awk，2nd Edition》by Dale Dougherty & Arnold Robbins(O’Reilly,
    1997; http://www.ora.com)
-   《UNIX Text Processing》by Dale Dougherty & Tim O’reilly(Hayden
    Books, 1987)

或者参考Mike Arst写的教程。

要想发掘出sed的全部力量，你必须懂得”正则表达式”。关于正则表达式，请参阅：

-   《Mastering Regular Expressions》 by Jeffrey Freidl (O’Reilly, 1997)

Unix系统中的man手册也会有所帮助（试试”man sed”，”man regexp”，
或者看看”man
ed”中关于正则表达式的部分），不过man手册是出了名的难懂。它并不是用来教那些sed和正则表达式的初学者的，它是一个写给那些已经掌握了这些工具的人的手册。

八、引号的语法
--------------

以上的例子使用单引号而不是双引号来容纳编辑命令，因为sed通常用于Unix平台。单引号可以防止Unix
shell对’\$”\`’这样的字符进行解释和展开，如果它们被包含在双引号中，那么这些就会发生。使用csh或其衍生而来的shell的人，即使是在单引号中，还需要把’!’前加上反斜线才能正确的运行上面的例子。DOS版本的sed总是要求用双引号而不是单引号来包含编辑命令。

九、在sed脚本中使用’t’
----------------------

为了文档的清晰，我们使用了表达式’t’来代表一个脚本中的制表符。但是多数sed版本不识别’t’这个缩写，因此，在编写这些脚本时你要按TAB键。’t’这个缩写是为awk,perl,HHsed,sedmod,GNU
sed v3.02.80的正则表达式所支持的元字符。

十、sed的版本
-------------

sed的版本之间确不太一样，可能在语法上有些许的不同。具体说来，很多版本不支持编辑命令中的标签（:name）或分支符（b，t），除了尾部的这些元素。我们使用了可以为大多数sed用户移植的语法，尽管GNU版本的sed允许更简洁的语法。\
当读者看到一个相当长的命令像：

    sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

知道GNU可以让你把它减缩为：

    sed '/AAA/b;/BBB/b;/CCC/b;d' #或者更简单
    sed '/AAA|BBB|CCC/b;d'

是很令人高兴的。

另外，记住：很多sed的版本接受这样的命令像”/one/ s/RE1/RE2/”,
有一些不允许”/one/!
s/RE1/RE2/”这样在’s’前包含空格的命令。这时，在输入命令的时候要去除空格。

十一、优化速度
--------------

当执行速度需要优化（由于输入文件很大或者处理器、CPU较慢）时，如果的替换命令前给出查找命令，替换操作会变得更快。如：

    sed 's/foo/bar/g' filename #标准的替换操作
    sed '/foo/ s/foo/bar/g' filename #这样执行起来更快
    sed '/foo/ s//bar/g' filename #sed速记语法

在进行行的选择和删除操作时，如果你操作的行只是包含在文件前面的一部分时，在脚本中加入一个退出命令’q’会大幅缩减处理大文件的时间。如：

    sed -n '45,50p' filename #输出45-50行
    sed -n '51q; 45,50p' filename #同样的功能，但执行得更快

---
[IBM Knowledge Center - sed 命令](https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds5/sed.htm)

[sed介绍 - 简书](http://www.jianshu.com/p/3fc90059f750)

[Sed and awk 笔记之 sed 篇：简单介绍 - 简书](http://www.jianshu.com/p/304400856e1e)

[Linux之Sed工具的使用详解 - 简书](http://www.jianshu.com/p/9d9a34e2b2dd)

[sed一句话技巧 « Zhiyan - 段志岩](https://zhiyan.de/sed1line/)
