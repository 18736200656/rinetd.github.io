<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Hardwares on 时光小栈</title>
        <link>//blog.pytool.com/hardware/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Sat, 04 Feb 2017 02:17:22 CST</updated>
        
        <item>
            <title>CANBUS协议解析</title>
            <link>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-canbus%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</link>
            <pubDate>Sat, 04 Feb 2017 02:17:22 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-canbus%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/pejoicen/p/3986587.html&#34; target=&#34;_blank&#34;&gt;CAN协议，系统结构和帧结构&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.tyncar.com/News/hy/20160828_23101.html&#34; target=&#34;_blank&#34;&gt;一张图诠释CAN标准帧和扩展帧的区别&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/wshngyf/article/details/45851453&#34; target=&#34;_blank&#34;&gt;简单学习STM32CAN协议&lt;/a&gt;&lt;br /&gt;
[](&lt;a href=&#34;http://blog.csdn.net/mao0514/article/details/48131597&#34; target=&#34;_blank&#34;&gt;http://blog.csdn.net/mao0514/article/details/48131597&lt;/a&gt;)&lt;br /&gt;
1. RTR Remote Transmission Request 远程帧 [ 隐性(1)为远程帧 )&lt;br /&gt;
2. IDE Identifier Extension 扩展帧 [ 隐性(1) 为扩展帧]&lt;br /&gt;
3. r0 r1 总是用隐性来填充&lt;br /&gt;
CAN BUS（Controller Area Network）即控制器局域网，是国际上应用最广泛的现场总线之一。起先，CAN BUS被设计作为汽车环境中的微控制器通讯，在车载各电子控制装置ECU之间交换信息，形成汽车电子控制网络。比如：发动机管理系统、变速箱控制器、仪表装备、电子主干系统中，均嵌入CAN控制装置。&lt;br /&gt;
CAN BUS是一种多主方式的串行通讯总线，基本设计规范要求有高的位速率，高抗电磁干扰性，而且能够检测出产生的任何错误。当信号传输距离达到10Km时，CAN BUS仍可提供高达5Kbps的数据传输速率。由于CAN串行通讯总线具有这些特性，它很自然地在汽车电子行业中受到广泛应用。&lt;br /&gt;
下面从与我们工作相关的物理层特性、帧格式、命令交互等三个方面来介绍CAN BUS协议。&lt;br /&gt;
Ø  物理层特性：可分为单线CAN协议和双线CAN协议。单线CAN协议目前主要出现在GM车系里面，1号脚通讯，波特率为33.3K。双线CAN协议常见的波特率有500K(&lt;sup&gt;6&lt;/sup&gt;&amp;frasl;&lt;sub&gt;14&lt;/sub&gt;)、250K(&lt;sup&gt;6&lt;/sup&gt;&amp;frasl;&lt;sub&gt;14&lt;/sub&gt;)和125K(&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)，括号内为通讯脚位。单、双线CAN协议的命令交互格式基本一致。&lt;br /&gt;
Ø  帧格式：&lt;br /&gt;
CAN2.0A标准帧为11个字节，包括信息和数据两部分，前3个字节为信息部分。&lt;br /&gt;
    7   6   5   4   3   2   1   0&lt;br /&gt;
字节1     FF  RTR     x   x   DLC   数据长度&lt;br /&gt;
字节2     报文识别码      ID.10-ID.3&lt;br /&gt;
字节3     ID.2-ID.0   x   x   x   x   x&lt;br /&gt;
字节4     数据1&lt;br /&gt;
字节5     数据2&lt;br /&gt;
字节6     数据3&lt;br /&gt;
字节7     数据4&lt;br /&gt;
字节8     数据5&lt;br /&gt;
字节9     数据6&lt;br /&gt;
字节10    数据7&lt;br /&gt;
字节11    数据8&lt;br /&gt;
字节1 为帧信息 第7位FF  表示帧格式（在标准帧中FF＝0，在扩展帧中FF＝1）　　　　　&lt;br /&gt;
第6位RTR 表示帧的类型（RTR=0表示为数据帧　RTR=1表示为远程帧）　　&lt;br /&gt;
DLC      表示在数据帧时实际的数据长度&lt;br /&gt;
       字节2-3  为报文识别码11位有效&lt;br /&gt;
字节4-11为数据帧的实际数据，远程帧时无效&lt;/p&gt;

&lt;p&gt;命令帧示例：&lt;br /&gt;
Tools: 08H 07H E0H 03H 19H 02H FFH 00H 00H 00H 00H&lt;br /&gt;
ECU  : 08H 07H E8H 10H 0FH 59H 02H FFH 01H 80H 00H&lt;br /&gt;
通常情况下，标准CAN协议的响应帧报文识别码就是请求帧的报文识别码加上8，即0x7E8，左移5位后就是我们所看到的FD 00。&lt;/p&gt;

&lt;p&gt;CAN2.0B扩展帧信息为13个字节，包括信息和数据两部分，前5个字节为信息部分。&lt;br /&gt;
    7   6   5   4   3   2   1   0&lt;br /&gt;
字节1     FF  RTR     x   x   DLC   数据长度&lt;br /&gt;
字节2     报文识别码              ID.28-ID.21&lt;br /&gt;
字节3     ID.20-ID.13&lt;br /&gt;
字节4     ID.12-ID.5&lt;br /&gt;
字节5     ID.4-ID.0   x   x   x&lt;br /&gt;
字节6     数据1&lt;br /&gt;
字节7     数据2&lt;br /&gt;
字节8     数据3&lt;br /&gt;
字节9     数据4&lt;br /&gt;
字节10    数据5&lt;br /&gt;
字节11    数据6&lt;br /&gt;
字节12    数据7&lt;br /&gt;
字节13    数据8&lt;br /&gt;
       字节1　为帧信息  第7位FF　表示帧格式（在标准帧中FF＝0，在扩展帧中FF＝1） 　　　　　&lt;br /&gt;
第6位RTR 表示帧的类型（RTR=0表示为数据帧　RTR=1表示为远程帧）&lt;br /&gt;
DLC 　　　表示在数据帧时实际的数据长度&lt;br /&gt;
字节2－5  为报文识别码其高29位有效&lt;br /&gt;
字节6－13 为数据帧的实际数据，远程帧时无效&lt;br /&gt;
命令帧示例：&lt;br /&gt;
Tools: 88H 18H DAH 11H F1H 03H 19H 02H FFH 00H 00H 00H 00H&lt;br /&gt;
ECU  : 88H 18H DAH F1H 11H 10H 0FH 59H 02H 01H FFH 01H 00H&lt;br /&gt;
通常情况下，响应帧的报文识别码只需要把目标地址和源地址交换位置即可。&lt;/p&gt;

&lt;p&gt;Ø  命令交互：&lt;br /&gt;
CAN协议的主要命令交互形式有发1帧回1帧、发1帧回多帧、发多帧回1帧及发多帧回多帧，下面分别举例说明。&lt;br /&gt;
发1帧回1帧：&lt;br /&gt;
Tools: 08H 07H E0H 03H 19H 02H FFH 00H 00H 00H 00H&lt;br /&gt;
ECU  : 08H 07H E8H 04H 59H 02H FFH 01H 80H 01H 00H&lt;br /&gt;
第一个字节的低4位表示除报文识别码的两个字节外其他字节的长度，第四个字节03表示后面有效数据的长度。&lt;br /&gt;
发1帧回多帧：&lt;br /&gt;
Tools: 08H 07H E0H 03H 19H 02H FFH 00H 00H 00H 00H&lt;br /&gt;
ECU  : 08H 07H E8H 10H 0FH 59H 02H FFH 01H 80H 00H&lt;br /&gt;
Tools: 08H 07H E0H 30H 00H 00H 00H 00H 00H 00H 00H&lt;br /&gt;
ECU  : 08H 07H E8H 21H FFH 01H 79H F1H E3H 01H 62H&lt;br /&gt;
ECU  : 08H 07H E8H 22H F1H FFH 00H 00H 00H 00H 00H&lt;br /&gt;
发出第一条请求帧后，如果响应帧的第四个字节高四位大于0，则表示回多帧。响应帧的有效数据长度为0x100F&amp;amp;0x0FFF=0x0F，表示有15个有效数据的回复帧。设备紧跟着发送流控制帧Tools: 08H 07H E0H 30H 00H 00H 00H 00H 00H 00H 00H来接收下面的有效回复数据，这个流控制帧在不同的车上可能会不一样。&lt;br /&gt;
发多帧回1帧：&lt;br /&gt;
Tools: 08H 07H E0H 10H 09H 01H 02H 03H 04H 05H 06H&lt;br /&gt;
ECU  : 08H 07H E8H 30H 00H 00H 00H 00H 00H 00H 00H&lt;br /&gt;
Tools: 08H 07H E0H 21H 07H 08H 09H 00H 00H 00H 00H&lt;br /&gt;
ECU  : 08H 07H E8H 04H 59H 02H FFH 01H 80H 01H 00H&lt;br /&gt;
发第一条请求帧的时候，如果请求帧第4个字节高四位大于0，则表示发多帧，发送的命令数据长度有第4，第5个字节一起决定，在这里数据长度为9，这时候ECU响应0x30的流控制帧，Tools继续发送请求帧，蓝色为有效数据，发送完后，ECU响应正确的命令回复。&lt;br /&gt;
发多帧回多帧：&lt;br /&gt;
Tools: 08H 07H E0H 10H 09H 01H 02H 03H 04H 05H 06H&lt;br /&gt;
ECU  : 08H 07H E8H 30H 00H 00H 00H 00H 00H 00H 00H&lt;br /&gt;
Tools: 08H 07H E0H 21H 07H 08H 09H 00H 00H 00H 00H&lt;br /&gt;
ECU  : 08H 07H E8H 10H 0FH 59H 02H FFH 01H 80H 00H&lt;br /&gt;
Tools: 08H 07H E0H 30H 00H 00H 00H 00H 00H 00H 00H&lt;br /&gt;
ECU  : 08H 07H E8H 21H FFH 01H 79H F1H E3H 01H 62H&lt;br /&gt;
ECU  : 08H 07H E8H 22H F1H FFH 00H 00H 00H 00H 00H&lt;br /&gt;
在这种情况下的交互，将发1帧回多帧和发多帧回1帧结合就可以了。需要注意的是，对于不同的ECU，由于细微协议的区别，在对于通过流控制帧来发送或接收剩余数据是不一样的，有的时候会通过一条流控制帧将所有数据一次收完，有时候则是采用1对1的方式。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>BOSCH协议解析</title>
            <link>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-bosch%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</link>
            <pubDate>Sat, 04 Feb 2017 02:15:52 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-bosch%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</guid>
            <description>&lt;p&gt;BOSCH协议是BOSCH公司开发的一种通信协议，符合ISO9141标准。下面从物理层特性、系统进入、帧结构、命令交互、交互时间参数、常用命令字等几个方面来介绍这种协议。
Ø  物理层特性：空闲电平通常为12V；数据位格式为1+8+1，没有校验位。本协议的波特率在进入系统后确定。确定方法如下：&lt;br /&gt;
进入系统时，Ecu接到Tools以5bps的波特率发送的地址码后，向Tools发送 0X55H，Tools通过计算0X55H的波特率，并把此波特率做为Tools的通讯波特率，并且在整个通讯过程中，波特率固定不变。&lt;br /&gt;
Ø  系统进入初始化：&lt;br /&gt;
本协议使用K、L的方式通讯，因此，需要用K线和L 线进行触发，唤醒Ecu，进入系统，具体步骤如下：&lt;br /&gt;
u  Tools在K、L线上同时以5bps的波特率发送地址码，以进入地址码所对应的系统。&lt;br /&gt;
u  关闭L线；&lt;br /&gt;
u  Tools等待接收Ecu回送0X55H，接到后计算出0X55H的波特率并设置通讯波率；&lt;br /&gt;
u  Tools继续接收Ecu发送的Keyword 1和Keyword 2，在接收到Keyword2后，延时20ms将Keyword2取反发回给ECU。&lt;br /&gt;
u  在整个系统进入过程中Tools接收一个byte最长等待时间为2s。若系统进入有错误必须保证通讯线上有3s的时间无任何数据传输，确保Ecu已经是睡眠状态，再按以上步骤重新触发，进入系统。&lt;br /&gt;
u  Ecu接收到求反的 Keyword2后，将发送第一帧系统信息，并在收到链路保持命令继续（03h,xxh,09h,03h）时按顺序发送其它系统信息。&lt;br /&gt;
u  系统信息的解释与读取系统版本信息同。&lt;br /&gt;
u  系统初始化请见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031039005035.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031039115437.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
                         图2-5-1&lt;/p&gt;

&lt;p&gt;Ø  帧结构：&lt;/p&gt;

&lt;p&gt;长度  记数字节    命令字     数据区     结束标志&lt;br /&gt;
长度:1个字节，表示本命令中长度字节后跟随的字节数。&lt;br /&gt;
记数字节：命令计数器，1个字节，每一条命令都会在上一条命令的命令记数字节基础上加1，作为本次通信数据的命令记数值，以保证接收发送的连续性校验。&lt;br /&gt;
命令字：1个字节，表明所要做的操作。&lt;br /&gt;
数据区：附加信息，若干字节不定。&lt;br /&gt;
结束标志：固定以03H为Request命令的结束符。&lt;br /&gt;
举例如下：&lt;br /&gt;
04H  01H  29H  01H  03H&lt;br /&gt;
第一个字节04H为长度信息&lt;br /&gt;
第二个字节01H为命令计数器&lt;br /&gt;
第三个字节29H为命令字，表示读取数据流&lt;br /&gt;
第四个字节01H为附加信息，表示读取通道01的数据&lt;br /&gt;
最后一个字节03H为结束标志&lt;br /&gt;
Ø  命令交互：在命令交互过程中，接收方每接到一个byte，就立即取反发回，直到接收到结束标志为止（注：结束标志0x03不取反发回）。一旦接到结束标志，接收方则可以开始下一帧命令的发送。基本交互模型下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031039309388.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/20140103103941251.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                        图 2-5-2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际命令如下：&lt;br /&gt;
   Tools：03H  01H  09H  03H&lt;br /&gt;
   ECU：  03H  02H  09H  03H&lt;br /&gt;
Ø  交互时间参数：包括4个时间参数，如下：&lt;br /&gt;
ECU返回keywod2与设备发送/keyword2的时间间隔：40ms&lt;br /&gt;
设备接收到ECU命令字到发送命令字取反的时间间隔：2ms&lt;br /&gt;
设备发送命令字到ECU发送命令字取反的时间间隔：2ms&lt;br /&gt;
设备发送完一帧命令后等待ECU响应的时间，通常为75ms~90ms&lt;br /&gt;
设备接收到ECU响应后到发送下一帧命令的时间，通常为20ms~26ms&lt;br /&gt;
Ø  常用命令字：&lt;br /&gt;
链路保持：09H&lt;br /&gt;
读故障码：07H&lt;br /&gt;
清除故障码：05H&lt;br /&gt;
读版本信息：00H&lt;br /&gt;
读数据流：29H&lt;br /&gt;
系统退出：06H&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>VPW协议解析</title>
            <link>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-vpw%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</link>
            <pubDate>Sat, 04 Feb 2017 02:15:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-vpw%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</guid>
            <description>&lt;p&gt;SAE J1850 VPW协议也是OBD II标准中的一种，通常应用于GM车系中。VPW英文全称是Variable Pulse Width Modulated，即可变脉宽调制。下面从物理层特性、电平接口、帧结构、命令交互、交互时间参数、常用命令字等几个方面来介绍这种协议。
Ø  物理层特性：&lt;br /&gt;
采用10.4KB/S的波特率；通讯电平通常为7.5V；每个字节采用8位二进制数形式，没有起始位、停止位和校验位；通讯引脚为J1850 BUS+，既为OBD-2PIN。&lt;br /&gt;
Ø  电平接口：&lt;br /&gt;
协议通讯采用10.4Kbps VPW方式，初始电平为0V，在第1帧数据前有一个163至239微秒（us）的高电平表示SOF（帧头即数据开始标志），接下来以不同长短的高低电平表示二进制数据0或1，其中：&lt;br /&gt;
高电平宽度介于34-96us表示“1”，高电平宽度介于96-163us表示“0”，&lt;br /&gt;
低电平宽度介于34-96us表示“0”，低电平宽度介于96-163us表示“1”，&lt;br /&gt;
传输时按字节顺序，且每个字节都是高位在前，低位在后的顺序，高低电平相间用于表示传输的数据，字节与字节之间没有间隔，传送完一帧数据之后有一个宽度大于239us的低电平表示EOF（帧尾即帧结束标志）。&lt;br /&gt;
Ø  帧结构：&lt;br /&gt;
GM车型中的帧结构：&lt;br /&gt;
Tools: 0x6C + ECU地址 + 设备地址 + Fun_ID + (command information) + CRC&lt;br /&gt;
ECU:   0x6C + 设备地址 + ECU地址 + Fun_ID + (command information) + CRC&lt;br /&gt;
OBDII中的帧结构：&lt;br /&gt;
Tools: 0x68 + 0x6A + ECU地址 + Fun_ID + (command information) + CRC&lt;br /&gt;
ECU:   0x48 + 0x6B + 设备地址 + Fun_ID + (command information) + CRC&lt;br /&gt;
ECU地址为每个系统的标示号，设备地址一般为0xF1或0xF0；而Fun_ID为不同功能的标示号，ECU响应的Fun_ID在tools命令的基础上+0x40；CRC（循环冗余校验）为校验字节。&lt;br /&gt;
Ø  命令交互:命令交互通常情况下为1对1，但也存在1对多或者多对1的情况。下面是两组命令交互举例：&lt;br /&gt;
    GM:&lt;br /&gt;
Tools: 6CH 10H F1H 20H 64H&lt;br /&gt;
ECU:   6CH F1H 10H 60H 72H&lt;br /&gt;
OBDII:&lt;br /&gt;
Tools: 68H 6AH F1H 01H 00H 17H&lt;br /&gt;
ECU:   48H 6BH 10H 41H 00H BEH 3FH B8H 10H C9H&lt;br /&gt;
在交互中，因为发送命令的对象不一样，所以目标地址和源地址是进行了互换；同时，ECU响应设备的命令字在设备命令字的基础上+0x40&lt;br /&gt;
Ø  交互时间参数：&lt;br /&gt;
设备发出命令后到ECU应答命令的时间间隔为320微秒(us)到100毫秒（ms）。&lt;br /&gt;
ECU应答命令后到设备发下一条命令的时间间隔为320微秒(us)到100ms。&lt;br /&gt;
如果设备或ECU同时发送多帧命令时，每帧之间的时间间隔为3到5ms。&lt;br /&gt;
同一帧命令中的字节与字节之间无时间间隔。&lt;br /&gt;
Ø  常用命令字：&lt;br /&gt;
GM车型中的常用命令字：&lt;br /&gt;
系统进入：20H&lt;br /&gt;
数据流设置：2CH&lt;br /&gt;
数据流读取：2AH&lt;br /&gt;
读故障码：19HH&lt;br /&gt;
清除故障码：14H&lt;br /&gt;
读版本信息：3CH&lt;br /&gt;
OBD II中常用命令字：&lt;br /&gt;
读数据流：01H&lt;br /&gt;
读故障码：03H&lt;br /&gt;
清除故障码：04H&lt;br /&gt;
读版本信息：09H&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>PWM协议解析</title>
            <link>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-pwm%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</link>
            <pubDate>Sat, 04 Feb 2017 02:13:53 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-pwm%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</guid>
            <description>&lt;p&gt;SAEJ1850 PWM协议也是OBD II标准中的一种，通常应用在FORD车系汽车中，已知的还有JAGUAR，MAZDA。PWM英文全称是Pulse Width Modulation，即脉宽调制。下面从物理层特性、帧结构、命令交互、交互时间参数、常用命令字等几个方面来介绍这种协议。&lt;/p&gt;

&lt;p&gt;Ø  物理层特性：波特率为41.7kbps；线路物理特性：双线，双向，半双工（差分信号）。通信电平通常为12V。数据位描述，位1见图2-3-1，位0见图2-3-2：&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031036106384.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图2-3-1&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031036302143.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图2-3-2&lt;/p&gt;

&lt;p&gt;时间参数定义如下：&lt;br /&gt;
TP1：常规为8us，取值范围，在发送命令中7&amp;lt;=TP1&amp;lt;=9，在接收命令时，6&amp;lt;=TP1&amp;lt;=11&lt;br /&gt;
TP2：常规为16us，取值范围，在发送命令中15&amp;lt;=TP1&amp;lt;=17，在接收命令时，14&amp;lt;=TP1&amp;lt;=19&lt;br /&gt;
TP3(一个位的时间长度)：常规为24us，取值范围，在发送命令中23&amp;lt;=TP1&amp;lt;=25.5，在接收命令时，22&amp;lt;=TP1&amp;lt;=27&lt;br /&gt;
图2-3-3是MAZDA原厂设备IDS系统进入命令的一部分波形&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031036381863.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
图2-3-3&lt;/p&gt;

&lt;p&gt;Ø  帧结构：命令头（3个字节）+ 数据区 + CRC校验。一帧命令最长为12个字节。&lt;br /&gt;
在命令头中，包括以下几个部分的内容：格式字节(C4H)+目标地址+源地址。&lt;br /&gt;
请参见图2-3-4和图2-3-5&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031036486852.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                             图2-3-4  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031036565651.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
                                                        图2-3-5&lt;br /&gt;
TP4：SOF（帧起始标志）时间，常规为48us，取值范围，发送时47&amp;lt;=TP4&amp;lt;=51,接收时46&amp;lt;=TP4&amp;lt;=63&lt;br /&gt;
TP5：EOF（帧结束标志）时间，常规为72us，取值范围，发送时70&amp;lt;=TP5&amp;lt;=76.5，接收时TP5》=70&lt;br /&gt;
命令体的内容中：命令字+命令内容。命令内容可以没有。&lt;br /&gt;
举例如下：&lt;br /&gt;
C4H  10H  F5H  13H  C7H&lt;br /&gt;
第一个字节C4H为格式&lt;br /&gt;
第二个字节10H为目标地址&lt;br /&gt;
第三个字节F5H为源地址&lt;br /&gt;
第四个字节（PID，功能号）13H为命令字，表示系统读码&lt;br /&gt;
最后一个字节04H为前面4个字节的校验和&lt;/p&gt;

&lt;p&gt;Ø  命令交互：命令交互通常情况下为1对1，但也存在1对多的情况。下面是一组命令交互举例：&lt;br /&gt;
Tools: C4H  10H  F5H  22H  11H  00H  3BH&lt;br /&gt;
Ecu:   C4H  F5H  10H  62H  11H  00H  09H  FFH  00H  00H  6AH&lt;br /&gt;
在交互中，因为发送命令的对象不一样，所以目标地址和源地址是进行了互换；同时，ECU响应设备的命令字在设备命令字的基础上+0x40&lt;br /&gt;
注：无链路保持。&lt;br /&gt;
Ø  常用命令字：&lt;br /&gt;
读故障码：13H&lt;br /&gt;
清除故障码：14H&lt;br /&gt;
读数据流：22H&lt;br /&gt;
读版本信息：1AH&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>ISO9141-2协议解析</title>
            <link>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-iso9141-2%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</link>
            <pubDate>Sat, 04 Feb 2017 02:12:52 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-iso9141-2%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</guid>
            <description>&lt;p&gt;ISO-9141-2协议是最常用的通信协议之一，也是属于OBD II标准协议的一种。下面从物理层特性、系统进入、帧结构、命令交互、交互时间参数、常用命令字等几个方面来介绍这种协议。
Ø  物理层特性：空闲电平通常为12V；数据位格式为1+8+1，没有校验位；使用的波特率通常为10416BPS和9600BPS两种。&lt;br /&gt;
Ø  系统进入初始化：ISO协议采用地址码进入方式，先使用5BPS发送地址码，ECU响应55H，KW1，KW2，设备对KW2取反发回给ECU，ECU对地址码取反发回给设备，完成系统初始化交互。其中55H这个字节用来规定后面的通信波特率。参见下图：&lt;br /&gt;
       Tool————&amp;gt;    &amp;lt;—   &amp;lt;—   &amp;lt;—      —&amp;gt;     &amp;lt;—   ECU&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031028319025.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
                 T1 |&amp;lt;-&amp;gt;|  T2 |&amp;lt;-&amp;gt;|T3|&amp;lt;-&amp;gt;|T4|&amp;lt;-&amp;gt;| T5  |&amp;lt;-&amp;gt;|  T6 |&amp;lt;-&amp;gt;|  T7&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                                    图 2-2-1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：           T1 ≥ 300  ms&lt;br /&gt;
               60 ms ≤ T2≤ 300 ms&lt;br /&gt;
5  ms ≤ T3 ≤20 ms&lt;br /&gt;
0  ms ≤ T4 ≤ 20 ms&lt;br /&gt;
25 ms ≤ T5 ≤ 50 ms&lt;br /&gt;
25 ms ≤ T6 ≤ 50 ms&lt;br /&gt;
55 ms ≤ T7 ≤ 5000 ms&lt;/p&gt;

&lt;p&gt;Ø  帧结构：帧头（3个字节）+数据（最大为7个字节）+校验（通常为校验和）。数据帧有两种：命令帧和响应帧。命令帧由Tools发出，响应帧是ECU对命令帧的响应。帧头结构如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;帧头字节1   帧头字节2   帧头字节3  
Priority/Type   目标地址    源地址  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Request(Tools-&amp;gt;ECU)     68H     6AH     F1H&lt;br /&gt;
Response(ECU-&amp;gt;Tools)    48H     6BH     28H&lt;br /&gt;
                     图 2-2-2&lt;/p&gt;

&lt;p&gt;数据区包含传送的数据。对于命令帧，DATA区是命令字节及命令参数；对于响应帧，DATA区是命令响应及响应的数据。&lt;br /&gt;
校验是校验字节，为前面字节的累加和，包括帧头和数据区。&lt;/p&gt;

&lt;p&gt;Ø  命令交互：命令交互通常情况下为1对1，但也存在1对多或者多对1的情况。下面是一组命令交互举例：&lt;br /&gt;
Tools: 68H  6AH  F1H  BEH  81H&lt;br /&gt;
ECU:   48H  6BH  28H  FEH  31H  32H  33H  40H  42H  43H  34H&lt;br /&gt;
在命令中，目标地址是固定的；ECU响应设备的命令字在设备命令字的基础上+0x40。&lt;br /&gt;
Ø  交互时间参数：包括4个时间参数，如下：&lt;br /&gt;
设备发送命令字节间的时间间隔P1，通常为5ms-20ms，取6ms；&lt;br /&gt;
ECU返回命令字节间的时间间隔P2，通常为0ms&lt;br /&gt;
设备发送完一帧命令后等待ECU响应的时间P3，为25ms-50ms，一般取30ms；&lt;br /&gt;
设备接收到ECU响应后到发送下一帧命令的时间P4，通常为55ms-5000ms，一般取60ms。&lt;/p&gt;

&lt;p&gt;Ø  常用命令字：&lt;br /&gt;
系统退出：20H&lt;br /&gt;
读故障码：03H&lt;br /&gt;
清除故障码：14H&lt;br /&gt;
读版本信息：BEH&lt;br /&gt;
读数据流：B1H&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>KWP2000协议解析</title>
            <link>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-kwp2000%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</link>
            <pubDate>Sat, 04 Feb 2017 02:09:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/%E8%BD%A6%E8%81%94%E7%BD%91/2017-02-04-kwp2000%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</guid>
            <description>&lt;p&gt;KWP 2000协议是最常用的通信协议之一，是属于OBD II标准协议的一种。KWP系统又称为关键字协议，因为这种协议在系统进入时，会涉及到关键字的校验而得名。下面从物理层特性、系统进入、帧结构、命令交互、交互时间参数、常用命令字等几个方面来介绍这种协议。
Ø  物理层特性：通常采用10416BPS的波特率；空闲电平通常为12V；数据位格式为1+8+1，没有校验位。&lt;br /&gt;
Ø  系统进入初始化：有两种初始化方式。第一种由设备先发送25ms的拉低电平，然后是25ms的高电平（空闲电平），然后再发送系统进入数据，系统进入数据通常为5个字节，ECU响应7个字节，完成系统初始化交互。请参见下图：&lt;br /&gt;
设备 ————&amp;gt;&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031023341789.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&amp;lt;—————ECU&lt;br /&gt;
&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031023567343.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;|&amp;lt;———————数据区————————&amp;gt;|&lt;/p&gt;

&lt;p&gt;第二种初始化方式为设备发送5BPS或者200BPS的地址码，ECU响应55H，KW1，KW2，设备对KW2取反发回给ECU，ECU对地址码取反发回给设备，完成系统初始化交互。其中55H这个字节用来规定后面的通信波特率。参见下图&lt;/p&gt;

&lt;p&gt;Tool——&amp;gt;            &amp;lt;—         &amp;lt;—        &amp;lt;—              —&amp;gt;             &amp;lt;—   ECU&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.dpfdoctor.net/upLoad/news/month_1401/201401031024105210.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ø  帧结构：命令头（1个或多个字节）+命令体（1个或多个字节）+校验（通常为和校验）。&lt;br /&gt;
在命令头中，包括以下几个部分的内容：格式+目标地址+源地址+长度字节。长度信息有时候在格式字节中体现，则不需要另外的长度字节，长度信息用以表示命令体的内容；目标地址和源地址有时候也会没有。&lt;br /&gt;
命令体的内容中：命令字+命令内容。命令内容可以没有。&lt;br /&gt;
举例如下：&lt;br /&gt;
81H  11H  F1H  81H  04H&lt;br /&gt;
第一个字节81H为格式+长度信息（80+1）&lt;br /&gt;
第二个字节11H为目标地址&lt;br /&gt;
第三个字节F1H为源地址&lt;br /&gt;
第四个字节81H为命令字，表示系统进入&lt;br /&gt;
最后一个字节04H为前面4个字节的校验和&lt;br /&gt;
同样，也可能表现如下：&lt;br /&gt;
80H  11H  F1H  01H  3EH  C1H&lt;br /&gt;
这种情况下，长度字节放在源地址之后&lt;br /&gt;
还可能表现为：&lt;br /&gt;
02H  1AH  9AH  B6H&lt;br /&gt;
这种情况下，格式字节和目标地址源地址都已经没有了&lt;br /&gt;
还有一种特殊的情况，在上一种情况的基础上，在帧数据之前，加一个00，例如：&lt;br /&gt;
00H  02H  1AH  9AH  B6H&lt;br /&gt;
但这种帧结构的情况极少。&lt;br /&gt;
Ø  命令交互：命令交互通常情况下为1对1，但也存在1对多或者多对1的情况。下面是一组命令交互举例：&lt;br /&gt;
Tools: 81H  31H  F1H  81H  24H&lt;br /&gt;
ECU:   83H  F1H  31H  C1H  E9H  8FH  DEH&lt;br /&gt;
在交互中，因为发送命令的对象不一样，所以目标地址和源地址是进行了互换；同时，ECU响应设备的命令字在设备命令字的基础上+0x40。&lt;br /&gt;
Ø  交互时间参数：包括4个时间参数，如下：&lt;br /&gt;
设备发送命令字节间的时间间隔P1，通常为5ms&lt;br /&gt;
ECU返回命令字节间的时间间隔P2，通常为0ms&lt;br /&gt;
设备发送完一帧命令后等待ECU响应的时间P3，通常为75ms~90ms&lt;br /&gt;
设备接收到ECU响应后到发送下一帧命令的时间P4，通常为20ms~26ms&lt;br /&gt;
Ø  常用命令字：&lt;br /&gt;
系统进入：81H&lt;br /&gt;
系统退出：82H&lt;br /&gt;
链路保持：3EH&lt;br /&gt;
读故障码：18H&lt;br /&gt;
清除故障码：14H&lt;br /&gt;
读版本信息：1AH&lt;br /&gt;
读数据流：21H&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>编程基础</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-07-linux%E5%86%85%E6%A0%B8-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</link>
            <pubDate>Mon, 07 Mar 2016 15:36:55 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-07-linux%E5%86%85%E6%A0%B8-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://zh-google-styleguide.readthedocs.org/en/latest/contents/&#34; target=&#34;_blank&#34;&gt;Google 开源项目风格指南&lt;/a&gt;
&lt;a href=&#34;http://www.ibm.com/developerworks/cn/aix/library/au-unix-getopt.html&#34; target=&#34;_blank&#34;&gt;使用 getopt() 进行命令行处理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/yby4769250/article/details/7294696&#34; target=&#34;_blank&#34;&gt;C/C++ 中的0长数组（柔性数组）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EOF是ASCII码为255的字符，对应的有符号数是-1&lt;br /&gt;
#define EOF (-1)&lt;br /&gt;
Windows Ctrl-Z&lt;br /&gt;
Linux Ctrl-D&lt;/p&gt;

&lt;h2 id=&#34;linux如何查看与-dev-input目录下的event对应的设备&#34;&gt;Linux如何查看与/dev/input目录下的event对应的设备&lt;/h2&gt;

&lt;p&gt;ls /dev/input #查看所有Input输入事件 event0~x&lt;br /&gt;
 cat /proc/bus/input/devices  #查看event和input 关联&lt;/p&gt;

&lt;h1 id=&#34;查看中断&#34;&gt;查看中断&lt;/h1&gt;

&lt;p&gt;cat /proc/interrupts&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Android GPIO输入</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-gpio%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/</link>
            <pubDate>Mon, 11 Jan 2016 14:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-gpio%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf&#34; target=&#34;_blank&#34;&gt;petazzoni-device-tree-dummies&lt;/a&gt;
&lt;a href=&#34;http://android.cloudchou.com/&#34; target=&#34;_blank&#34;&gt;Android编译系统参考手册&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/kangear/article/details/42265927&#34; target=&#34;_blank&#34;&gt; 键值从键盘到Linux内核传输过程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.2cto.com/kf/201405/298944.html&#34; target=&#34;_blank&#34;&gt;Android4.2.2自增物理按键frameworks&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/mcgrady_tracy/article/details/47358689&#34; target=&#34;_blank&#34;&gt;android kl文件&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.9ria.com/thread-244419-1-1.html&#34; target=&#34;_blank&#34;&gt;android4.0 添加一个新的android 键值&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/kangear/article/details/12110951&#34; target=&#34;_blank&#34;&gt;按键从Linux到Android&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/tkwxty/article/details/43338921&#34; target=&#34;_blank&#34;&gt;Android下添加新的自定义键值和按键处理流程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/mr_raptor/article/details/8053871&#34; target=&#34;_blank&#34;&gt;android 添加新的键值，自定义按键&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;android添加新键值实现-http-blog-csdn-net-linuxdriverdeveloper-article-details-7241999&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/linuxdriverdeveloper/article/details/7241999&#34; target=&#34;_blank&#34;&gt;Android添加新键值实现&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;扫描码是Linux Input系统中规定的码值 /kernel/include/input.h&lt;br /&gt;
Android也定义了一套码，叫作键盘码 .kl&lt;/p&gt;

&lt;h2 id=&#34;android-kl文件优先级&#34;&gt;android kl文件优先级&lt;/h2&gt;

&lt;p&gt;/system/usr/keylayout/Vendor_XXXX_Product_XXXX_Version_XXXX.kl&lt;br /&gt;
/system/usr/keylayout/Vendor_XXXX_Product_XXXX.kl&lt;br /&gt;
/system/usr/keylayout/DEVICE_NAME.kl&lt;br /&gt;
/data/system/devices/keylayout/Vendor_XXXX_Product_XXXX_Version_XXXX.kl&lt;br /&gt;
/data/system/devices/keylayout/Vendor_XXXX_Product_XXXX.kl&lt;br /&gt;
/data/system/devices/keylayout/DEVICE_NAME.kl&lt;br /&gt;
/system/usr/keylayout/Generic.kl&lt;br /&gt;
/data/system/devices/keylayout/Generic.kl&lt;/p&gt;

&lt;p&gt;#查看事件和设备的关联&lt;br /&gt;
&lt;code&gt;adb shell cat /proc/bus/input/devices&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I: Bus=0000 Vendor=0000 Product=0000 Version=0000&lt;br /&gt;
N: Name=&amp;ldquo;qpnp_pon&amp;rdquo;&lt;br /&gt;
P: Phys=qpnp_pon/input0&lt;br /&gt;
S: Sysfs=/devices/virtual/input/input2&lt;br /&gt;
U: Uniq=&lt;br /&gt;
H: Handlers=kbd event2 cpufreq cpufreq&lt;br /&gt;
B: PROP=10&lt;br /&gt;
B: EV=3&lt;br /&gt;
B: KEY=140000 0 0 0&lt;/p&gt;

&lt;p&gt;#获取输入事件&lt;br /&gt;
&lt;code&gt;adb shell getevent&lt;/code&gt;&lt;br /&gt;
root@M120D:/ # getevent&lt;br /&gt;
add device 1: /dev/input/event4&lt;br /&gt;
  name:     &amp;ldquo;msm8x10-skuaa-snd-card Headset Jack&amp;rdquo;&lt;br /&gt;
add device 2: /dev/input/event3&lt;br /&gt;
  name:     &amp;ldquo;msm8x10-skuaa-snd-card Button Jack&amp;rdquo;&lt;br /&gt;
add device 3: /dev/input/event1&lt;br /&gt;
  name:     &amp;ldquo;qpnp_pon&amp;rdquo;&lt;br /&gt;
add device 4: /dev/input/event0&lt;br /&gt;
  name:     &amp;ldquo;acc&amp;rdquo;&lt;br /&gt;
add device 5: /dev/input/event2&lt;br /&gt;
  name:     &amp;ldquo;gpio-keys&amp;rdquo;&lt;br /&gt;
  //press Volume UP&lt;br /&gt;
/dev/input/event2: 0001 0073 00000001&lt;br /&gt;
/dev/input/event2: 0000 0000 00000000&lt;br /&gt;
/dev/input/event2: 0001 0073 00000000&lt;br /&gt;
/dev/input/event2: 0000 0000 00000000&lt;br /&gt;
//press Volume DOWN&lt;br /&gt;
/dev/input/event1: 0001 0072 00000001&lt;br /&gt;
/dev/input/event1: 0000 0000 00000000&lt;br /&gt;
//release&lt;br /&gt;
/dev/input/event1: 0001 0072 00000000&lt;br /&gt;
/dev/input/event1: 0000 0000 00000000&lt;br /&gt;
//press POWER&lt;br /&gt;
/dev/input/event1: 0001 0074 00000001&lt;br /&gt;
/dev/input/event1: 0000 0000 00000000&lt;br /&gt;
//release&lt;br /&gt;
/dev/input/event1: 0001 0074 00000000&lt;br /&gt;
/dev/input/event1: 0000 0000 00000000&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              Type  code value  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux上传的Code是0x0073 对应10进制115&lt;br /&gt;
Kernel/include/input.h KEY_VOLUMEUP 115&lt;/p&gt;

&lt;p&gt;模拟按键&lt;/p&gt;

&lt;h1 id=&#34;press-power-button-don-t-release&#34;&gt;Press power button(Don&amp;rsquo;t release)&lt;/h1&gt;

&lt;p&gt;$ adb shell sendevent /dev/input/event2 1 $((0x74)) 1&lt;br /&gt;
$ adb shell sendevent /dev/input/event2 0 0 0&lt;/p&gt;

&lt;h1 id=&#34;release-power-button&#34;&gt;Release power button&lt;/h1&gt;

&lt;p&gt;$ adb shell sendevent /dev/input/event5 1 $((0x74)) 0&lt;br /&gt;
$ adb shell sendevent /dev/input/event5 0 0 0&lt;/p&gt;

&lt;p&gt;Linux&lt;/p&gt;

&lt;p&gt;#define KEY_POWER       116 //SC System Power Down&lt;br /&gt;
Android也定义了一套码，叫作键盘码，power 0x74 116&lt;br /&gt;
通过一个/system/usr/keylayout/来将两套码对应起来&lt;br /&gt;
1.&lt;br /&gt;
frameworks/base/&lt;em&gt;core&lt;/em&gt;/java/android/view/KeyEvent.java&lt;br /&gt;
410    public static final int KEYCODE_F1              = 131;&lt;/p&gt;

&lt;p&gt;638    // NOTE: If you add a new keycode here you must also add it to:&lt;br /&gt;
    //  isSystem()&lt;br /&gt;
    //  frameworks/native/include/android/keycodes.h&lt;br /&gt;
    //  frameworks/base/include/androidfw/KeycodeLabels.h&lt;br /&gt;
    //  external/webkit/WebKit/android/plugins/ANPKeyCodes.h&lt;br /&gt;
    //  frameworks/base/core/res/res/values/attrs.xml&lt;br /&gt;
    //  emulator?&lt;br /&gt;
    //  LAST_KEYCODE&lt;br /&gt;
    //  KEYCODE_SYMBOLIC_NAMES&lt;br /&gt;
    //&lt;br /&gt;
    //  Also Android currently does not reserve code ranges for vendor-&lt;br /&gt;
    //  specific key codes.  If you have new key codes to have, you&lt;br /&gt;
    //  MUST contribute a patch to the open source project to define&lt;br /&gt;
    //  those new codes.  This is intended to maintain a consistent&lt;br /&gt;
    //  set of key code definitions across all Android devices.&lt;br /&gt;
    // Symbolic names of all key codes.&lt;br /&gt;
    private static final SparseArray&lt;String&gt; KEYCODE_SYMBOLIC_NAMES = new SparseArray&lt;String&gt;();&lt;br /&gt;
    private static void populateKeycodeSymbolicNames() {&lt;br /&gt;
        SparseArray&lt;String&gt; names = KEYCODE_SYMBOLIC_NAMES;&lt;br /&gt;
658        names.append(KEYCODE_UNKNOWN, &amp;ldquo;KEYCODE_UNKNOWN&amp;rdquo;);&lt;br /&gt;
789        names.append(KEYCODE_F1, &amp;ldquo;KEYCODE_F1&amp;rdquo;);&lt;br /&gt;
2.&lt;br /&gt;
frameworks/native/include/android/keycodes.h&lt;/p&gt;

&lt;p&gt;frameworks/base/&lt;em&gt;policy&lt;/em&gt;/src/com/android/internal/policy/impl/PhoneWindowManager.java&lt;/p&gt;

&lt;p&gt;2030 if ((keyCode == KeyEvent.KEYCODE_F1) &amp;amp;&amp;amp; down) {&lt;br /&gt;
     Intent intent4 = new Intent();&lt;br /&gt;
     //ComponentName cn4 = new ComponentName(&amp;ldquo;com.android.camera&amp;rdquo;, &amp;ldquo;com.android.camera.Camera&amp;rdquo;);&lt;br /&gt;
     ComponentName cn4 = new ComponentName(&amp;ldquo;com.android.camera2&amp;rdquo;, &amp;ldquo;com.android.camera.CameraLauncher&amp;rdquo;);&lt;br /&gt;
     intent4.setComponent(cn4);&lt;br /&gt;
     intent4.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&lt;br /&gt;
     intent4.setAction(&amp;ldquo;android.intent.action.MAIN&amp;rdquo;);&lt;br /&gt;
     mContext.startActivity(intent4);&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;}&lt;/h2&gt;

&lt;p&gt;/M120D/target/product/M120D/obj/KERNEL_OBJ/scripts/dtc/dtc -p 1024 -O dtb -o&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-rumi.dts;&lt;/p&gt;

&lt;p&gt;./kernel/arch/arm/boot/dts/msm8610-sim.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v1-cdp.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v1-mtp.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v1-qrd-skuaa.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v1-qrd-skuab-dvt2.dts;&lt;/p&gt;

&lt;p&gt;./kernel/arch/arm/boot/dts/msm8610-v1-qrd-skuab.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v2-cdp.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v2-mtp.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v2-qrd-skuaa.dts;&lt;br /&gt;
./kernel/arch/arm/boot/dts/msm8610-v2-qrd-skuab-dvt2.dts;&lt;/p&gt;

&lt;h2 id=&#34;kernel-arch-arm-boot-dts-msm8610-v2-qrd-skuab-dts&#34;&gt;./kernel/arch/arm/boot/dts/msm8610-v2-qrd-skuab.dts;&lt;/h2&gt;

&lt;p&gt;/kernel/arch/arm/boot/dts/msm8610-mdss.dtsi&lt;/p&gt;

&lt;p&gt;qcom,platform-lcd-power-en-gpio = &amp;lt;&amp;amp;pm8110_gpios 2 0&amp;gt;;去掉&lt;/p&gt;

&lt;p&gt;//&lt;br /&gt;
msm-pm8100.dtsi 电源键配置&lt;br /&gt;
1. 将GPIO_78 配置为 keycode 59&lt;br /&gt;
/kernel/arch/arm/boot/dts/msm8610-qrd.dtsi&lt;br /&gt;
                key_f1 {&lt;br /&gt;
                        label = &amp;ldquo;key_f1&amp;rdquo;;&lt;br /&gt;
                        gpios = &amp;lt;&amp;amp;msmgpio &lt;em&gt;78&lt;/em&gt; 0x1&amp;gt;;&lt;br /&gt;
                        linux,input-type = &lt;1&gt;;&lt;br /&gt;
                        linux,code = &amp;lt;&lt;em&gt;59&lt;/em&gt;&amp;gt;;&lt;br /&gt;
                        gpio-key,wakeup;&lt;br /&gt;
                        debounce-interval = &lt;15&gt;;&lt;br /&gt;
        };&lt;br /&gt;
2./kernel/arch/arm/mach-msm/board-8610-gpiomux.c&lt;br /&gt;
.gpio = 78,&lt;br /&gt;
.settings = {&lt;br /&gt;
  [GPIOMUX_ACTIVE]  = &amp;amp;m120ay_custom_gpio_config,&amp;ndash;&amp;gt;gpio_keys_active&lt;br /&gt;
  [GPIOMUX_SUSPENDED]   = &amp;amp;m120ay_custom_gpio_config,&amp;ndash;&amp;gt;gpio_keys_suspend&lt;br /&gt;
},&lt;br /&gt;
3.//实现 将Linux key code 59 映射为F1&lt;br /&gt;
/device/reach/M120D/gpio-keys.kl&lt;br /&gt;
key 59   F1  WAKE&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;4&gt;[ 3170.548611] /mnt/M120D_Release/kernel/drivers/misc/ytgpio_ctrl.c:yt_gpio_init:166: yt_gpio_init:gpio: = 76 GPIO_9&lt;br /&gt;
&lt;4&gt;[ 3170.568567] /mnt/M120D_Release/kernel/drivers/misc/ytgpio_ctrl.c:yt_gpio_init:166: yt_gpio_init:gpio: = 83 GPIO_3&lt;br /&gt;
&lt;4&gt;[ 3170.588833] /mnt/M120D_Release/kernel/drivers/misc/ytgpio_ctrl.c:yt_gpio_init:166: yt_gpio_init:gpio: = 86&lt;br /&gt;
&lt;4&gt;[ 3170.608561] /mnt/M120D_Release/kernel/drivers/misc/ytgpio_ctrl.c:yt_gpio_init:166: yt_gpio_init:gpio: = 88&lt;br /&gt;
&lt;4&gt;[ 3170.628554] /mnt/M120D_Release/kernel/drivers/misc/ytgpio_ctrl.c:yt_gpio_init:166: yt_gpio_init:gpio: = 89&lt;/p&gt;

&lt;p&gt;引出的引脚为 GPIO_7 6 1 5 4&lt;br /&gt;
对应的gpio号为 78 77 9&lt;br /&gt;
SWDCLK&lt;br /&gt;
VCC3.3&lt;br /&gt;
GND&lt;br /&gt;
GND&lt;br /&gt;
GPIO_7  pin25   GPIO_7        gpio_78&lt;br /&gt;
GPIO_6  pin25   GPIO_8        gpio_77&lt;br /&gt;
GPIO_1  PIN_79  BLSP3_UART_RX gpio_9&lt;br /&gt;
GPIO_5  PIN_69  UIM1_RESET    gpio_38&lt;br /&gt;
GPIO_4  PIN_68  SDC2_CARD_DET gpio_42&lt;br /&gt;
MISO    PIN_78 BLSP1_SPI_MISO gpio_87&lt;br /&gt;
CE0     PIN_21 BLSP1_SPI_CS_N gpio_88&lt;br /&gt;
MOSI    PIN_22 BLSP1_SPI_MOSI gpio_86&lt;br /&gt;
SCLK    PIN_77 BLSP1_SPI_CLK  gpio_89&lt;/p&gt;

&lt;p&gt;#######BUG&lt;br /&gt;
/kernel/arch/arm/mach-msm/board-8610-gpiomux.c:1242&lt;br /&gt;
static struct gpiomux_setting interrupt_gpio_suspend_pulldown = {&lt;br /&gt;
    .func = GPIOMUX_FUNC_GPIO,&lt;br /&gt;
    .drv = GPIOMUX_DRV_6MA,&lt;br /&gt;
    .pull = GPIOMUX_PULL_UP,&amp;gt;&amp;gt;&amp;gt;GPIOMUX_PULL_DOWN&lt;br /&gt;
};&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Android LED 输出</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-led/</link>
            <pubDate>Mon, 11 Jan 2016 14:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-led/</guid>
            <description>&lt;p&gt;1.2 LED使用1.2.1前言
Firefly-RK3288开发板上有 2 个 LED 灯，如下表所示：&lt;br /&gt;
LED GPIO ref. GPIO number&lt;br /&gt;
Blue GPIO8_A1 257&lt;br /&gt;
Yellow GPIO8_A2 258&lt;br /&gt;
可通过使用 LED 设备子系统或者直接操作 GPIO 控制该 LED。&lt;br /&gt;
1.2.2以设备的方式控制 LED&lt;br /&gt;
标准的 Linux 专门为 LED 设备定义了 LED 子系统。 在 Firefly-RK3288 开发板中的两个 LED 均以设备的形式被定义。&lt;br /&gt;
用户可以通过 /sys/class/leds/ 目录控制这两个LED。&lt;br /&gt;
更详细的说明请参考 leds-class.txt 。&lt;br /&gt;
开发板上的 LED 的默认状态为：&lt;br /&gt;
§ Blue:系统上电时打开&lt;br /&gt;
§ Yellow：用户自定义&lt;br /&gt;
用户可以通过 echo 向其 trigger 属性输入命令控制每一个 LED：&lt;br /&gt;
root@firefly:~ # echo none &amp;gt;/sys/class/leds/firefly:blue:power/trigger&lt;br /&gt;
root@firefly:~ # echo default-on &amp;gt;/sys/class/leds/firefly:blue:power/trigger&lt;br /&gt;
用户还可以使用 cat 命令获取 trigger 的可用值：&lt;br /&gt;
root@firefly:~ # cat /sys/class/leds/firefly:blue:power/trigger&lt;br /&gt;
none [ir-power-click] test_ac-online test_battery-charging-or-full test_battery-chargingtest_battery-full test_battery-charging-blink-full-solid test_usb-online mmc0 mmc1 mmc2backlight default-on rfkill0 rfkill1 rfkill2&lt;br /&gt;
1.2.3 在内核中操作 LED&lt;br /&gt;
在内核中操作 LED 的步骤如下：&lt;br /&gt;
1、在 dts 文件中定义 LED 节点“leds”&lt;br /&gt;
在kernel/arch/arm/boot/dts/firefly-rk3288.dts 文件中定义LED节点，具体定义如下：&lt;br /&gt;
leds {&lt;br /&gt;
  compatible =&amp;ldquo;gpio-leds&amp;rdquo;;&lt;br /&gt;
  power {&lt;br /&gt;
    label =&amp;ldquo;firefly:blue:power&amp;rdquo;;&lt;br /&gt;
    linux,default-trigger =&amp;ldquo;ir-power-click&amp;rdquo;;&lt;br /&gt;
    default-state =&amp;ldquo;on&amp;rdquo;;&lt;br /&gt;
    gpios =&amp;lt;&amp;amp;gpio8 GPIO_A1 GPIO_ACTIVE_LOW&amp;gt;;&lt;br /&gt;
    };&lt;br /&gt;
  user{&lt;br /&gt;
    label =&amp;ldquo;firefly:yellow:user&amp;rdquo;;&lt;br /&gt;
    linux,default-trigger =&amp;ldquo;ir-user-click&amp;rdquo;;&lt;br /&gt;
    default-state =&amp;ldquo;off&amp;rdquo;;&lt;br /&gt;
    gpios =&amp;lt;&amp;amp;gpio8 GPIO_A2 GPIO_ACTIVE_LOW&amp;gt;;&lt;br /&gt;
    };&lt;br /&gt;
  };&lt;/p&gt;

&lt;p&gt;注意：compatible 的值要跟 drivers/leds/leds-gpio.c 中的 .compatible 的值要保持一致。&lt;br /&gt;
2、在驱动文件包含头文件&lt;br /&gt;
#include &lt;linux/leds.h&gt;&lt;br /&gt;
3、在驱动文件中控制 LED。&lt;br /&gt;
（1）、定义 LED 触发器&lt;br /&gt;
DEFINE_LED_TRIGGER(ledtrig_ir_click);&lt;br /&gt;
（2）、注册该触发器&lt;br /&gt;
led_trigger_register_simple(&amp;ldquo;ir-power-click&amp;rdquo;,&amp;amp;ledtrig_ir_click);&lt;br /&gt;
（3）、控制 LED 的亮灭。&lt;br /&gt;
led_trigger_event(ledtrig_ir_click, LED_FULL);//亮&lt;br /&gt;
led_trigger_event(ledtrig_ir_click, LED_OFF);//灭&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Android gpio输出</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-gpio-%E8%BE%93%E5%87%BA/</link>
            <pubDate>Mon, 11 Jan 2016 14:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-gpio-%E8%BE%93%E5%87%BA/</guid>
            <description>&lt;p&gt;使用手册
&lt;a href=&#34;http://files.cnblogs.com/files/pengdonglin137/Power_ePAPR_APPROVED_v1.1.pdf&#34; target=&#34;_blank&#34;&gt;Power_ePAPR_APPROVED_v1.1.pdf&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.chinaunix.net/uid-27717694-id-3701921.html&#34; target=&#34;_blank&#34;&gt;GPIO接口解析 &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.wowotech.net/device_model/dt_basic_concept.html&#34; target=&#34;_blank&#34;&gt;Device Tree（二）：基本概念&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/loongembedded/article/details/48973861&#34; target=&#34;_blank&#34;&gt; Linux加载DTS设备节点的过程(以高通8974平台为例)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/hongzg1982/article/details/47784627&#34; target=&#34;_blank&#34;&gt;msm平台GPIO相关的device tree设置&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.th7.cn/system/lin/201512/147714.shtml&#34; target=&#34;_blank&#34;&gt;我眼中的Linux设备树(四 中断)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/hongzg1982/article/details/47660649&#34; target=&#34;_blank&#34;&gt;Linux 中断(irq)控制器以及device tree设置&lt;/a&gt;&lt;br /&gt;
源码分析&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/hongzg1982/article/details/47308321&#34; target=&#34;_blank&#34;&gt;Linux驱动基础：device tree&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/hongzg1982/article/details/47784627&#34; target=&#34;_blank&#34;&gt;msm平台GPIO相关的device tree设置&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.360doc.com/content/14/0813/17/14530056_401586832.shtml&#34; target=&#34;_blank&#34;&gt;GIC 驱动代码分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.wowotech.net/linux_kenrel/gic_driver.html&#34; target=&#34;_blank&#34;&gt;linux kernel的中断子系统之（七）：GIC代码分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://developer.toradex.com/knowledge-base/gpio-%28linux%29&#34; target=&#34;_blank&#34;&gt;GPIO (Linux)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.ednchina.com/BLOG_ARTICLE_3027425.HTM&#34; target=&#34;_blank&#34;&gt;为AM335x移植Linux内核主线代码(34)GPIO的dts及驱动&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/maopig/article/details/7428561&#34; target=&#34;_blank&#34;&gt;gpio_request 原形代码&lt;/a&gt;&lt;br /&gt;
gpio键盘active_low参数 的作用&lt;br /&gt;
active_low = 1，还是active_low =0，要根据硬件的连接，如果按下按键为高电平那么active_low =0，如果按下按键为低电平那么active_low =1.如果这个参数搞错了，按键松开后就不断发按键键码，表现为屏幕上乱动作。&lt;br /&gt;
在gpio和中断debug方法&lt;/p&gt;

&lt;p&gt;在debug目录下，可以查到每个gpio的输入输出设置，以及当前的值。&lt;br /&gt;
查看所有可操作的GPIO&lt;br /&gt;
&lt;code&gt;cat /sys/kernel/debug/gpio&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;#cat /d/gpio&lt;br /&gt;
//这个命令只会显示AP设置的GPIO信息，不显示Modem设置的GPIO信息&lt;/p&gt;

&lt;p&gt;如果想看更详细的GPIO设置的话&lt;/p&gt;

&lt;p&gt;#cat /d/gpiomux&lt;br /&gt;
//显示AP,CP所有的GPIO的信息&lt;/p&gt;

&lt;p&gt;//开始操作GPIO的时候必须要先执行&lt;br /&gt;
#echo 30 &amp;gt; /sys/class/gpio/export&lt;/p&gt;

&lt;p&gt;//设置GPIO 30的输入输出&lt;br /&gt;
#echo &amp;ldquo;out&amp;rdquo; &amp;gt; /sys/class/gpio/gpio30/direction&lt;br /&gt;
#echo &amp;ldquo;in&amp;rdquo;  &amp;gt; /sys/class/gpio/gpio30/direction&lt;/p&gt;

&lt;p&gt;//改变GPIO 30的值&lt;br /&gt;
#echo 1 &amp;gt; /sys/class/gpio/gpio30/value&lt;br /&gt;
#echo 0 &amp;gt; /sys/class/gpio/gpio30/value&lt;/p&gt;

&lt;p&gt;//操作完毕需要执行如下命令&lt;br /&gt;
#echo 30 &amp;gt; /sys/class/gpio/unexport&lt;/p&gt;

&lt;p&gt;查找Wakeup IRQ等&lt;/p&gt;

&lt;p&gt;#echo 1 &amp;gt; /sys/module/msm_show_resume_irq/parameters/debug_mask.&lt;br /&gt;
//这样输入完之后，如果被中断唤醒就会输出如下log&lt;br /&gt;
[ 75.0xxx] pm8xxx_show_resume_irq_chip: 479 triggered&lt;br /&gt;
[ 75.0xxx] msm_gpio_show_resume_irq: 392 triggered&lt;br /&gt;
[ 75.0xxx] gic_show_resume_irq: 48 triggered&lt;br /&gt;
[ 75.0xxx] gic_show_resume_irq: 52 triggered&lt;br /&gt;
显示整个中断设置情况&lt;/p&gt;

&lt;p&gt;#cat /proc/interrupts&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在嵌入式设备中对GPIO的操作是最基本的操作。一般的做法是写一个单独驱动程序，网上大多数的例子都是这样的。其实linux下面有一个通用的GPIO操作接口，那就是我要介绍的 “/sys/class/gpio” 方式。&lt;/p&gt;

&lt;p&gt;首先，看看系统中有没有“/sys/class/gpio”这个文件夹。如果没有请在编译内核的时候加入   Device Drivers  —&amp;gt;  GPIO Support  —&amp;gt;     /sys/class/gpio/… (sysfs interface)。&lt;/p&gt;

&lt;p&gt;/sys/class/gpio 的使用说明：&lt;/p&gt;

&lt;p&gt;gpio_operation 通过/sys/文件接口操作IO端口 GPIO到文件系统的映射&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;控制GPIO的目录位于/sys/class/gpio&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/sys/class/gpio/export文件用于通知系统需要导出控制的GPIO引脚编号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/sys/class/gpio/unexport 用于通知系统取消导出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/sys/class/gpio/gpiochipX目录保存系统中GPIO寄存器的信息，包括每个寄存器控制引脚的起始编号base，寄存器名称，引脚总数 导出一个引脚的操作步骤&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首先计算此引脚编号，引脚编号 = 控制引脚的寄存器基数 + 控制引脚寄存器位数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;向/sys/class/gpio/export写入此编号，比如12号引脚，在shell中可以通过以下命令实现，命令成功后生成/sys/class/gpio/gpio12目录，如果没有出现相应的目录，说明此引脚不可导出：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;echo 12 &amp;gt; /sys/class/gpio/export&lt;br /&gt;
* direction文件，定义输入输入方向，可以通过下面命令定义为输出&lt;/p&gt;

&lt;p&gt;echo out &amp;gt; direction&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;direction接受的参数：in, out, high, low。high/low同时设置方向为输出，并将value设置为相应的1/0。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;value文件是端口的数值，为1或0.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;echo 1 &amp;gt; value&lt;br /&gt;
下面在2440下进行一下测试&lt;/p&gt;

&lt;p&gt;1.取得GPIO信息，在终端中敲入以下命令&lt;/p&gt;

&lt;p&gt;$ cd /sys/class/gpio&lt;br /&gt;
$ for i in gpiochip* ; do echo &lt;code&gt;cat $i/label&lt;/code&gt;: &lt;code&gt;cat $i/base&lt;/code&gt; ; done&lt;br /&gt;
终端中显示如下&lt;br /&gt;
GPIOA: 0&lt;br /&gt;
GPIOE: 128&lt;br /&gt;
GPIOF: 160&lt;br /&gt;
GPIOG: 192&lt;br /&gt;
GPIOH: 224&lt;br /&gt;
GPIOB: 32&lt;br /&gt;
GPIOC: 64&lt;br /&gt;
GPIOD: 96&lt;br /&gt;
2.计算GPIO号码&lt;/p&gt;

&lt;p&gt;我们把GPE11用来控制LED。&lt;/p&gt;

&lt;p&gt;GPE0的头是128，GPE11 就是128+11 = 139.&lt;br /&gt;
$ echo 139 &amp;gt;; /sys/class/gpio/export&lt;br /&gt;
ls 一下看看有没有 gpio139 这个目录&lt;/p&gt;

&lt;p&gt;3.GPIO控制测试。&lt;/p&gt;

&lt;p&gt;控制LED所以是输出。&lt;/p&gt;

&lt;p&gt;所以我们应该执行&lt;br /&gt;
$ echo out &amp;gt; /sys/class/gpio/gpio139/direction&lt;br /&gt;
之后就可以进行输出设置了。&lt;/p&gt;

&lt;p&gt;$ echo 1 &amp;gt; /sys/class/gpio/gpio139/value&lt;br /&gt;
or&lt;br /&gt;
$ echo 0 &amp;gt; /sys/class/gpio/gpio139/value&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Linux driver中gpio_request和gpio_free的调用&lt;br /&gt;
一般来说，一个GPIO只是分配给一个设备的，所以这个设备的驱动会请求这个GPIO。这样，在其他的设备也想请求这个GPIO的时候会返回失败。事实上，gpio_request只是给这个GPIO做一个标示，并没有什么实质的作用。操作GPIO是通过gpio_set_value、gpio_direction_output之类的函数去做的，即便没有request，一样可以设置GPIO的电平。&lt;/p&gt;

&lt;p&gt;对于设备驱动来说，应该保证每一个在初始化的时候（一般是probe），对和设备有关的GPIO都进行一次gpio_request，在remove时候时候使用gpio_free。当然，如果probe失败，应该在probe里面free掉已经request过的GPIO。每次使用的时候不需要再request和free了，只需要直接gpio_set_value就可以了。&lt;/p&gt;

&lt;p&gt;可以参考下kernel里面已有的一些设备驱动，GPIO的操作还是挺基本的，那些设备驱动里都有现成的做法，可供参考。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;一 概述&lt;br /&gt;
  Linux内核中gpio是最简单，最常用的资源(和 interrupt ,dma,timer一样)驱动程序，应用程序都能够通过相应的接口使用gpio，gpio使用0～MAX_INT之间的整数标识，不能使用负数,gpio与硬件体系密切相关的,不过linux有一个框架处理gpio，能够使用统一的接口来操作gpio.在讲gpio核心(gpiolib.c)之前先来看看gpio是怎么使用的&lt;br /&gt;
二 内核中gpio的使用&lt;br /&gt;
     1 测试gpio端口是否合法 int gpio_is_valid(int number);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 2 申请某个gpio端口当然在申请之前需要显示的配置该gpio端口的pinmux  
    `int gpio_request(unsigned gpio, const char *label)`  

 3 标记gpio的使用方向包括输入还是输出  
   /*成功返回零失败返回负的错误值*/  
   int gpio_direction_input(unsigned gpio);  
   int gpio_direction_output(unsigned gpio, int value);  

 4 获得gpio引脚的值和设置gpio引脚的值(对于输出)  
    int gpio_get_value(unsigned gpio);  
    void gpio_set_value(unsigned gpio, int value);  

 5 gpio当作中断口使用  
    int gpio_to_irq(unsigned gpio);  
    返回的值即中断编号可以传给request_irq()和free_irq()  
    内核通过调用该函数将gpio端口转换为中断，在用户空间也有类似方法  

 6 导出gpio端口到用户空间  
    int gpio_export(unsigned gpio, bool direction_may_change);  
    内核可以对已经被gpio_request()申请的gpio端口的导出进行明确的管理，  
    参数direction_may_change表示用户程序是否允许修改gpio的方向，假如可以  
    则参数direction_may_change为真  
     撤销GPIO的导出  
    void gpio_unexport();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三 用户空间gpio的调用&lt;br /&gt;
          用户空间访问gpio，即通过sysfs接口访问gpio，下面是/sys/class/gpio目录下的三种文件：&lt;br /&gt;
            &amp;ndash;export/unexport文件&lt;br /&gt;
            &amp;ndash;gpioN指代具体的gpio引脚&lt;br /&gt;
            &amp;ndash;gpio_chipN指代gpio控制器&lt;br /&gt;
            必须知道以上接口没有标准device文件和它们的链接。&lt;br /&gt;
 (1) export/unexport文件接口：&lt;br /&gt;
               /sys/class/gpio/export，该接口只能写不能读&lt;br /&gt;
               用户程序通过写入gpio的编号来向内核申请将某个gpio的控制权导出到用户空间当然前提是没有内核代码申请这个gpio端口&lt;br /&gt;
               比如  echo 19 &amp;gt; export&lt;br /&gt;
               上述操作会为19号gpio创建一个节点gpio19，此时/sys/class/gpio目录下边生成一个gpio19的目录&lt;br /&gt;
               /sys/class/gpio/unexport和导出的效果相反。&lt;br /&gt;
               比如 echo 19 &amp;gt; unexport&lt;br /&gt;
               上述操作将会移除gpio19这个节点。&lt;br /&gt;
 (2) /sys/class/gpio/gpioN&lt;br /&gt;
       指代某个具体的gpio端口,里边有如下属性文件&lt;br /&gt;
      direction 表示gpio端口的方向，读取结果是in或out。该文件也可以写，写入out 时该gpio设为输出同时电平默认为低。写入low或high则不仅可以&lt;br /&gt;
                      设置为输出 还可以设置输出的电平。 当然如果内核不支持或者内核代码不愿意，将不会存在这个属性,比如内核调用了gpio_export(N,0)就&lt;br /&gt;
                       表示内核不愿意修改gpio端口方向属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  value      表示gpio引脚的电平,0(低电平)1（高电平）,如果gpio被配置为输出，这个值是可写的，记住任何非零的值都将输出高电平, 如果某个引脚  
                  能并且已经被配置为中断，则可以调用poll(2)函数监听该中断，中断触发后poll(2)函数就会返回。  

  edge      表示中断的触发方式，edge文件有如下四个值：&amp;quot;none&amp;quot;, &amp;quot;rising&amp;quot;, &amp;quot;falling&amp;quot;，&amp;quot;both&amp;quot;。  
       none表示引脚为输入，不是中断引脚  
       rising表示引脚为中断输入，上升沿触发  
       falling表示引脚为中断输入，下降沿触发  
       both表示引脚为中断输入，边沿触发  
                  这个文件节点只有在引脚被配置为输入引脚的时候才存在。 当值是none时可以通过如下方法将变为中断引脚  
                  echo &amp;quot;both&amp;quot; &amp;gt; edge;对于是both,falling还是rising依赖具体硬件的中断的触发方式。此方法即用户态gpio转换为中断引脚的方式  

  active_low 不怎么明白，也木有用过  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3)/sys/class/gpio/gpiochipN&lt;br /&gt;
      gpiochipN表示的就是一个gpio_chip,用来管理和控制一组gpio端口的控制器，该目录下存在一下属性文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  base   和N相同，表示控制器管理的最小的端口编号。  
  lable   诊断使用的标志（并不总是唯一的）  
  ngpio  表示控制器管理的gpio端口数量（端口范围是：N ~ N+ngpio-1）  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;四 用户态使用gpio监听中断&lt;br /&gt;
首先需要将该gpio配置为中断&lt;br /&gt;
echo  &amp;ldquo;rising&amp;rdquo; &amp;gt; /sys/class/gpio/gpio12/edge&lt;br /&gt;
以下是伪代码&lt;br /&gt;
int gpio_id;&lt;br /&gt;
struct pollfd fds[1];&lt;br /&gt;
gpio_fd = open(&amp;ldquo;/sys/class/gpio/gpio12/value&amp;rdquo;,O_RDONLY);&lt;br /&gt;
if( gpio_fd == -1 )&lt;br /&gt;
   err_print(&amp;ldquo;gpio open&amp;rdquo;);&lt;br /&gt;
fds[0].fd = gpio_fd;&lt;br /&gt;
fds[0].events  = POLLPRI;&lt;br /&gt;
ret = read(gpio_fd,buff,10);&lt;br /&gt;
if( ret == -1 )&lt;br /&gt;
    err_print(&amp;ldquo;read&amp;rdquo;);&lt;br /&gt;
while(1){&lt;br /&gt;
     ret = poll(fds,1,-1);&lt;br /&gt;
     if( ret == -1 )&lt;br /&gt;
         err_print(&amp;ldquo;poll&amp;rdquo;);&lt;br /&gt;
       if( fds[0].revents &amp;amp; POLLPRI){&lt;br /&gt;
           ret = lseek(gpio_fd,0,SEEK_SET);&lt;br /&gt;
           if( ret == -1 )&lt;br /&gt;
               err_print(&amp;ldquo;lseek&amp;rdquo;);&lt;br /&gt;
           ret = read(gpio_fd,buff,10);&lt;br /&gt;
           if( ret == -1 )&lt;br /&gt;
               err_print(&amp;ldquo;read&amp;rdquo;);&lt;br /&gt;
            /&lt;em&gt;此时表示已经监听到中断触发了，该干事了&lt;/em&gt;/&lt;br /&gt;
            &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&lt;br /&gt;
    }&lt;br /&gt;
}&lt;br /&gt;
记住使用poll()函数，设置事件监听类型为POLLPRI和POLLERR在poll()返回后，使用lseek()移动到文件开头读取新的值或者关闭它再重新打开读取新值。必须这样做否则poll函数会总是返回。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Android 按键输入</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-hal%E7%BC%96%E7%A8%8B/</link>
            <pubDate>Mon, 11 Jan 2016 14:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-hal%E7%BC%96%E7%A8%8B/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/mcgrady_tracy/article/details/44514057&#34; target=&#34;_blank&#34;&gt;Android HAL编程&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Android 按键输入</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-led%E5%AD%90%E7%B3%BB%E7%BB%9F/</link>
            <pubDate>Mon, 11 Jan 2016 14:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-linux-led%E5%AD%90%E7%B3%BB%E7%BB%9F/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/shiyi_2012/article/details/7456165&#34; target=&#34;_blank&#34;&gt;LED子系统剖析（一）&lt;/a&gt;
&lt;a href=&#34;http://blog.chinaunix.net/uid-23373524-id-2426965.html&#34; target=&#34;_blank&#34;&gt;Platform设备之gpio-led分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/yuanlulu/article/details/6438841&#34; target=&#34;_blank&#34;&gt;led子系统&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/wenhuisun/archive/2013/04/11/3013951.html&#34; target=&#34;_blank&#34;&gt;gpio框架及处理流程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/lagujw/p/4226424.html&#34; target=&#34;_blank&#34;&gt;OpenWRT中的按键和灯的GPIO控制实现&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/eastmoon502136/article/details/37569789&#34; target=&#34;_blank&#34;&gt;初探linux子系统集之led子系统(一)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;1.2 LED使用1.2.1前言&lt;br /&gt;
Firefly-RK3288开发板上有 2 个 LED 灯，如下表所示：&lt;br /&gt;
LED GPIO ref. GPIO number&lt;br /&gt;
Blue GPIO8_A1 257&lt;br /&gt;
Yellow GPIO8_A2 258&lt;br /&gt;
可通过使用 LED 设备子系统或者直接操作 GPIO 控制该 LED。&lt;br /&gt;
1.2.2以设备的方式控制 LED&lt;br /&gt;
标准的 Linux 专门为 LED 设备定义了 LED 子系统。 在 Firefly-RK3288 开发板中的两个 LED 均以设备的形式被定义。&lt;br /&gt;
用户可以通过 /sys/class/leds/ 目录控制这两个LED。&lt;br /&gt;
更详细的说明请参考 leds-class.txt 。&lt;br /&gt;
开发板上的 LED 的默认状态为：&lt;br /&gt;
§ Blue:系统上电时打开&lt;br /&gt;
§ Yellow：用户自定义&lt;br /&gt;
用户可以通过 echo 向其 trigger 属性输入命令控制每一个 LED：&lt;br /&gt;
root@firefly:~ # echo none &amp;gt;/sys/class/leds/firefly:blue:power/trigger&lt;br /&gt;
root@firefly:~ # echo default-on &amp;gt;/sys/class/leds/firefly:blue:power/trigger&lt;br /&gt;
用户还可以使用 cat 命令获取 trigger 的可用值：&lt;br /&gt;
root@firefly:~ # cat /sys/class/leds/firefly:blue:power/trigger&lt;br /&gt;
none [ir-power-click] test_ac-online test_battery-charging-or-full test_battery-chargingtest_battery-full test_battery-charging-blink-full-solid test_usb-online mmc0 mmc1 mmc2backlight default-on rfkill0 rfkill1 rfkill2&lt;br /&gt;
1.2.3 在内核中操作 LED&lt;br /&gt;
在内核中操作 LED 的步骤如下：&lt;br /&gt;
1、在 dts 文件中定义 LED 节点“leds”&lt;br /&gt;
在kernel/arch/arm/boot/dts/firefly-rk3288.dts 文件中定义LED节点，具体定义如下：&lt;br /&gt;
leds {&lt;br /&gt;
  compatible =&amp;ldquo;gpio-leds&amp;rdquo;;&lt;br /&gt;
  power {&lt;br /&gt;
    label =&amp;ldquo;firefly:blue:power&amp;rdquo;;&lt;br /&gt;
    linux,default-trigger =&amp;ldquo;ir-power-click&amp;rdquo;;&lt;br /&gt;
    default-state =&amp;ldquo;on&amp;rdquo;;&lt;br /&gt;
    gpios =&amp;lt;&amp;amp;gpio8 GPIO_A1 GPIO_ACTIVE_LOW&amp;gt;;&lt;br /&gt;
    };&lt;br /&gt;
  user{&lt;br /&gt;
    label =&amp;ldquo;firefly:yellow:user&amp;rdquo;;&lt;br /&gt;
    linux,default-trigger =&amp;ldquo;ir-user-click&amp;rdquo;;&lt;br /&gt;
    default-state =&amp;ldquo;off&amp;rdquo;;&lt;br /&gt;
    gpios =&amp;lt;&amp;amp;gpio8 GPIO_A2 GPIO_ACTIVE_LOW&amp;gt;;&lt;br /&gt;
    };&lt;br /&gt;
  };&lt;/p&gt;

&lt;p&gt;注意：compatible 的值要跟 drivers/leds/leds-gpio.c 中的 .compatible 的值要保持一致。&lt;br /&gt;
2、在驱动文件包含头文件&lt;br /&gt;
#include &lt;linux/leds.h&gt;&lt;br /&gt;
3、在驱动文件中控制 LED。&lt;br /&gt;
（1）、定义 LED 触发器&lt;br /&gt;
DEFINE_LED_TRIGGER(ledtrig_ir_click);&lt;br /&gt;
（2）、注册该触发器&lt;br /&gt;
led_trigger_register_simple(&amp;ldquo;ir-power-click&amp;rdquo;,&amp;amp;ledtrig_ir_click);&lt;br /&gt;
（3）、控制 LED 的亮灭。&lt;br /&gt;
led_trigger_event(ledtrig_ir_click, LED_FULL);//亮&lt;br /&gt;
led_trigger_event(ledtrig_ir_click, LED_OFF);//灭&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Android开发环境搭建</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android%E5%BA%95%E5%B1%82-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
            <pubDate>Mon, 11 Jan 2016 14:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android%E5%BA%95%E5%B1%82-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://android.cloudchou.com/&#34; target=&#34;_blank&#34;&gt;Android编译系统参考手册&lt;/a&gt;
&lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/aosp&#34; target=&#34;_blank&#34;&gt;Android 源码下载&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://source.android.com/source/initializing.html&#34; target=&#34;_blank&#34;&gt;Android 编译环境&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;常用ppa源-https-launchpad-net-ubuntu-ppas-name-filter-vim&#34;&gt;&lt;a href=&#34;https://launchpad.net/ubuntu/+ppas?name_filter=vim&#34; target=&#34;_blank&#34;&gt;常用PPA源&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;[git]   apt-add-repository ppa:git-core/ppa&lt;br /&gt;
ssh-keygen -t rsa -b 4096 -C &amp;ldquo;rinetd@163.com&amp;rdquo;&lt;br /&gt;
[java]  add-apt-repository ppa:webupd8team/java&lt;br /&gt;
[vim7.3]    add-apt-repository ppa:passy/vim&lt;br /&gt;
[python2.7] add-apt-repository ppa:fkrull/deadsnakes&lt;br /&gt;
[cmake 2.8.11] apt-add-repository ppa:roblib/ppa&lt;br /&gt;
################################################################################&lt;br /&gt;
Ubuntu 10.04 64位LTS英文版本&lt;br /&gt;
sudo apt-get install gnupg flex bison gperf build-essential \&lt;br /&gt;
  zip curl zlib1g-dev libc6-dev lib32ncurses5-dev ia32-libs \&lt;br /&gt;
  x11proto-core-dev libx11-dev lib32readline5-dev lib32z-dev \&lt;br /&gt;
  libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown \&lt;br /&gt;
  libxml2-utils xsltproc&lt;/p&gt;

&lt;h2 id=&#34;1-java-6u45&#34;&gt;1. java-6u45&lt;/h2&gt;

&lt;p&gt;sudo add-apt-repository ppa:webupd8team/java&lt;br /&gt;
apt-get remove openjdk*可以卸载openJDK&lt;br /&gt;
安装sun java6-jdk&lt;br /&gt;
sudo apt-get update&lt;br /&gt;
sudo apt-get install oracle-java6-installer&lt;br /&gt;
                    这里安装的是 JDK6, JDK7, JDK8, JDK9 也可以安装，用apt-cache search 查询&lt;/p&gt;

&lt;p&gt;sudo apt-get install oracle-java6-set-default&lt;br /&gt;
 java -version&lt;/p&gt;

&lt;p&gt;补充: 手工设置xxx 为默认的方法，以java 为例：&lt;br /&gt;
update-alternatives &amp;ndash;config java&lt;br /&gt;
update-alternatives &amp;ndash;display java&lt;br /&gt;
    为系统安装新的JAVA&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/javac javac /usr/lib/jvm/jdk-6u45-linux-x64.bin/bin/javac 1&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/java java /usr/lib/jvm/jdk-6u45-linux-x64.bin/bin/java 1&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/javaws javaws /usr/lib/jvm/jdk-6u45-linux-x64.bin/bin/javaws 1&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/javadoc javadoc /usr/lib/jvm/jdk-6u45-linux-x64.bin/bin/javadoc 1&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/javah javah /usr/lib/jvm/jdk-6u45-linux-x64.bin/bin/javah 1&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/javap javap /usr/lib/jvm/jdk-6u45-linux-x64.bin/bin/javap 1&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/jar jar /usr/lib/jvm/jdk-6u45-linux-x64.bin/bin/jar 1&lt;br /&gt;
    为系统选择新安装的JAVA版本&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;config javac&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;config java&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;config javaws&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;config javadoc&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;config javah&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;config javap&lt;br /&gt;
$ sudo update-alternatives &amp;ndash;config jar&lt;br /&gt;
6.检查JAVA版本&lt;br /&gt;
$ java -version&lt;br /&gt;
7.验证Javac, Java, Javaws, Javadoc, Javah, Javap, Jar是否都指向新的JAVA位置和版本&lt;br /&gt;
$ ls -la /etc/alternatives/java* &amp;amp;&amp;amp; ls -la /etc/alternatives/jar&lt;/p&gt;

&lt;h2 id=&#34;2-git-版本过低的错误&#34;&gt;2. git 版本过低的错误&lt;/h2&gt;

&lt;p&gt;fatal:git 1.7.2 or later required&lt;/p&gt;

&lt;p&gt;解决方法：增加ppa&lt;br /&gt;
sudo apt-add-repository ppa:git-core/ppa&lt;br /&gt;
sudo apt-get update&lt;br /&gt;
sudo apt-get install git&lt;br /&gt;
如果本地已经安装过Git，可以使用升级命令：&lt;br /&gt;
sudo apt-get dist-upgrade&lt;/p&gt;

&lt;h2 id=&#34;下载源码镜像&#34;&gt;下载源码镜像&lt;/h2&gt;

&lt;p&gt;$ curl &lt;a href=&#34;https://storage.googleapis.com/git-repo-downloads/repo&#34; target=&#34;_blank&#34;&gt;https://storage.googleapis.com/git-repo-downloads/repo&lt;/a&gt; &amp;gt; ~/repo&lt;br /&gt;
$ chmod a+x ~/repo&lt;br /&gt;
&lt;code&gt;repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest&lt;/code&gt;&lt;br /&gt;
$?=1;   while [ $? -ne 0 ] ; do  repo sync ; done&lt;/p&gt;

&lt;h2 id=&#34;repo-相关问题&#34;&gt;repo 相关问题&lt;/h2&gt;

&lt;p&gt;1.repo sync中遇到error:&amp;hellip;&amp;hellip;checkout &amp;hellip;.接一串hashnumber&lt;br /&gt;
解决方法：进到它说提示的目录中，用git status显示文件，将修改过的文件删除掉，再重新repo sync&lt;br /&gt;
2.repo sync中遇到：contains uncommitted changes&lt;br /&gt;
解决方法：进到它说提示的目录中，使用git reset &amp;ndash;hard命令&lt;br /&gt;
3. 怎么对repo下的所有project执行git命令&lt;br /&gt;
解决方法：repo forall -c git checkout -b    //该条命令会对repo下的project执行切换branch的命令&lt;br /&gt;
4. 怎么切换到你想要的branch&lt;br /&gt;
解决方法：git checkout branchName，比如 git checkout testBranch&lt;/p&gt;

&lt;p&gt;################################################################################&lt;/p&gt;

&lt;h2 id=&#34;编译内核&#34;&gt;编译内核&lt;/h2&gt;

&lt;p&gt;单独编译kernel : ./buildM120DRETAIL kernel&lt;br /&gt;
单独编译bootloader : ./buildM120DRETAIL aboot&lt;br /&gt;
编译kernel和bootloader : ./buildM120DRETAIL bootimage &amp;gt;boot.img&lt;br /&gt;
单独编译system image: ./buildM120DRETAIL systemimage&lt;br /&gt;
单独编译userdata image: ./buildM120DRETAIL userdataimage&lt;/p&gt;

&lt;p&gt;fastboot flash bootloader u-boot.bin&lt;br /&gt;
fastboot flash kernel uImage&lt;br /&gt;
fastboot flash system system.img&lt;br /&gt;
fastboot flash userdata userdata.img&lt;br /&gt;
fastboot flash ramdisk ramdisk-uboot.img&lt;br /&gt;
fastboot erase cache&lt;/p&gt;

&lt;p&gt;fastboot flash boot boot.img烧录boot分区&lt;br /&gt;
fastboot flash system system.img烧录system分区&lt;br /&gt;
fastboot flash userdata userdata.img烧录data分区&lt;br /&gt;
adb root&lt;br /&gt;
adb remount&lt;br /&gt;
adb pull &lt;remote&gt; &lt;local&gt;&lt;br /&gt;
adb push &lt;local&gt; &lt;remote&gt;&lt;br /&gt;
adb reboot recovery&lt;br /&gt;
adb reboot bootloader&lt;br /&gt;
fastboot flashall -w&lt;/p&gt;

&lt;p&gt;//烧写kernel&lt;br /&gt;
./buildM120DRETAIL kernel&lt;br /&gt;
adb reboot bootloader&lt;br /&gt;
sudo fastboot flash boot boot.img&lt;br /&gt;
sudo fastboot reboot&lt;/p&gt;

&lt;h2 id=&#34;android-mk-编译系统&#34;&gt;Android.mk 编译系统&lt;/h2&gt;

&lt;h3 id=&#34;local-path-call-my-dir&#34;&gt;LOCAL_PATH:= $(call my-dir)&lt;/h3&gt;

&lt;p&gt;build\core\definitions.mk [define my-dir]&lt;/p&gt;

&lt;h3 id=&#34;include-clear-vars-清空除local-path外的所有环境变量&#34;&gt;include $(CLEAR_VARS) #清空除LOCAL_PATH外的所有环境变量&lt;/h3&gt;

&lt;p&gt;build\core\config.mk[CLEAR_VARS:= $(BUILD_SYSTEM)/clear_vars.mk]&lt;/p&gt;

&lt;h3 id=&#34;build-system&#34;&gt;$(BUILD_SYSTEM)&lt;/h3&gt;

&lt;p&gt;build\core\main.mk[TOPDIR := , BUILD_SYSTEM := $(TOPDIR)build/core ]&lt;/p&gt;

&lt;p&gt;AP是application processor&lt;br /&gt;
CP是communication processor,modem那块。&lt;/p&gt;

&lt;h2 id=&#34;安装编译好的android镜像到模拟器上&#34;&gt;安装编译好的Android镜像到模拟器上。&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 设置环境变量：  
USER-NAME@MACHINE-NAME:~/Android$ export PATH=$PATH:~/Android/out/host/linux-x86/bin  
USER-NAME@MACHINE-NAME:~/Android$ export ANDROID_PRODUCT_OUT=~/Android/out/target/product/generic  
其中，~/Android/out/host/linux-x86/bin有我们要执行的emulator命令，而~/Android/out/target/product/generic是Android镜像存放目录，下面执行emulator命令时会用到。  
2. 运行模拟器。  
USER-NAME@MACHINE-NAME:~/Android$ emulator  
模拟器运行需要四个文件，分别是  
Linux Kernel镜像`zImage`  
Android镜像文件`system.img`、`userdata.img`和`ramdisk.img`。  
执行emulator命令时，如果不带任何参数，则Linux Kernel镜像默认使用~/Android/prebuilt/android-arm/kernel目录下的kernel-qemu文件，而Android镜像文件则默认使用ANDROID_PRODUCT_OUT目录下的system.img、userdata.img和ramdisk.img，也就是我们刚刚编译出来的镜像问题。  
当然，我们也可以以指定的镜像文件来运行模拟器，即运行emulator时，即：  

emulator -kernel ./prebuilt/android-arm/kernel/kernel-qemu -sysdir ./out/target/product/generic -system system.img -data userdata.img -ramdisk ramdisk.img  
到这里，我们就可以在模拟器上运行我们自己编译的Android镜像文件了，是不是很酷呢？但是注意，这里说的Android镜像文件，只是包括system.img、userdata.img和ramdisk.img这三个文件，而Linux Kernel镜像用的是Android为我们预编译好的kernel-qemu镜像。那么，有没有办法使用我们自己编译的Linux Kernel镜像呢？答案上肯定的，这样我们就可以完全DIY自己的Android系统了！我将在下一篇文章描述如果编译自己的Linux Kernel镜像，敬请期待~  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;搭建easydrawin-视频服务&#34;&gt;搭建easydrawin 视频服务&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://doc.easydarwin.org/&#34; target=&#34;_blank&#34;&gt;在线文档&lt;/a&gt;&lt;br /&gt;
1. git clone &lt;a href=&#34;https://github.com/EasyDarwin/EasyDarwin.git&#34; target=&#34;_blank&#34;&gt;https://github.com/EasyDarwin/EasyDarwin.git&lt;/a&gt;&lt;br /&gt;
2.&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Android自动开关机实现</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E6%9C%BA%E5%AE%9E%E7%8E%B0/</link>
            <pubDate>Mon, 11 Jan 2016 14:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-11-android-%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E6%9C%BA%E5%AE%9E%E7%8E%B0/</guid>
            <description>&lt;p&gt;Android自动开关机实现&lt;/p&gt;

&lt;p&gt;关于android自动关机，网上有很多应用程序和例子。 相对于自动开机来说，自动关机可以在应用层通过设置alarm来实现。而自动开机，网上的介绍就比较少了，因为它需要底层rtc时钟的支持。前段时间根据客户需求实现了自动开关机。在这里分享一下。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;简介&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的实现是在设置程序里面增加一个接口，让用户设置自动开关机，这个自动开关机的设置可以参照闹钟的设置。关于自动关机，考虑到关机的时候，用户可能正有一些重要的操作，那么应该给用户一个机会去取消当前的关机。&lt;/p&gt;

&lt;p&gt;1）一个BroadcastReceiver, 接收如下信息：&lt;/p&gt;

&lt;p&gt;　　a) 自定义的ACTION_REQUEST_POWER_OFF：设置auto power off时，通过AlarmManager设置的一个RTC_WAKEUP时钟。当到设置的关机时间时，之前设置到AlarmManager的这个action会被广播。我们实现的这个BroadcastReceiver接收到这个消息后，就要开始power off流程&lt;/p&gt;

&lt;p&gt;　　b) 自定义的ACTION_REQUEST_POWER_ON：设置auto power on时，通过AlarmManager设置的一个RTC_WAKEUP时钟。我们知道power on的应该设置一个rtc的alarm，那么这个RTC_WAKEUP的alarm是做什么的呢？其实当用户设置自动关机的时候，我设置了2个时钟，一个是RTC时钟，用于关机状态下开机；还有一个就是这个RTC_WAKEUP时钟。之所以设置这个时钟，其实是这样的，比如说你设置了周一到周五每天7点半自动开机，而周四早上你7点就打开了手机，这样到7点半的时候，之前设置的时钟就过期了，如果不重新设置的话，周五早上是不会自动开机的。所以这个时候，之前设置的RTC_WAKEUP就接收到了这样的信息，在重新设置下次自动开机的时钟。&lt;/p&gt;

&lt;p&gt;　　c) BOOT_COMPLETE和TIMEZONE changed, Time set等时间相关的action：当系统开机完成或时间、时区发生改变时，都需要重新设置alarm。&lt;/p&gt;

&lt;p&gt;2）一个处理power off 的Service，当BroadcastReceiver接收到ACTION_REQUEST_POWER_OFF，我们给用户一个机会去取消当前的自动关机。这个Service的作用就是启动一个无背景的页面，给用户提示。同时播放之前用户设置的提示音或振动。&lt;/p&gt;

&lt;p&gt;3）一个Activity：显示一个dialog提示用户要自动关机，并用一个计时器倒计时。当用户确认关机，或者计时器到时间的时候，就关机。否则取消当前关机，并重设下次自动关机alarm。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自动关机的实现。自动关机的实现比较简单，这里主要说一下怎么设置alarm，和实现关机：&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1） 设置自动关机的alarm：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   AlarmManager am = (AlarmManager) context  
               .getSystemService(Context.ALARM_SERVICE);  

       Intent intent = new Intent(  
               &amp;quot;com.android.settings.action.REQUEST_POWER_OFF&amp;quot;);  

       PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0,  
               intent, PendingIntent.FLAG_CANCEL_CURRENT);  
       am = (AlarmManager) context  
               .getSystemService(Context.ALARM_SERVICE);  
       am.set(AlarmManager.RTC_WAKEUP, time, pendingIntent);  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）自动关机掉的是./frameworks/base/services/java/com/android/server/ShutdownActivity.java：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Intent newIntent = new Intent(Intent.ACTION_REQUEST_SHUTDOWN);  
   newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);  
   startActivity(newIntent);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Intent.ACTION_REQUEST_SHUTDOWN是Intent里面一个隐藏的action。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自动开机的实现。一直在做上层应用和framework，对于底层不是很熟悉。正好有同事之前做过关机闹铃，所以把他之前的实现稍加改动就可以了。在系统power off的状态下自动开机，我们需要设置一个rtc时钟，当用户设置自动开机时，由AlarmManagerService将时钟设置下去。这学要底层的支持。这里的实现是定义一个我们自己的rtc alarm type：&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1） 首先要在头文件里面定义：&lt;/p&gt;

&lt;p&gt;　　a) kernel/include/linux/android_alarm.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define ANDROID_ALARM_GET_TIME(type)        ALARM_IOW(4, type, struct timespec)  
#define ANDROID_ALARM_SET_RTC               _IOW(&#39;a&#39;, 5, struct timespec)  

/* we define ANDROID_RTC_ALARM_SET for auto power off */  
#define ANDROID_RTC_ALARM_SET               _IOW(&#39;a&#39;, 7, int)  

#define ANDROID_ALARM_BASE_CMD(cmd)         (cmd &amp;amp; ~(_IOC(0, 0, 0xf0, 0)))  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　b) bionic/libc/kernel/common/linux/android_alarm.h&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#define ANDROID_RTC_ALARM_SET _IOW(&#39;a&#39;, 7, int)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2) 定义完成之后，还需要实现：在kernel/drivers/rtc/alarm-dev.c文件的alarm_ioctl方法里面，增加一个case，实现设置alarm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   case ANDROID_RTC_ALARM_SET:  
       {  
           unsigned int rtc_alarm_time;  
           struct rtc_time rtc_now;  
           if (copy_from_user(&amp;amp;rtc_alarm_time, (void __user *)arg,  
               sizeof(rtc_alarm_time))) {  
               rv = -EFAULT;  
               goto err1;  
           }  
           if (pmic_rtc_get_time(&amp;amp;rtc_now) &amp;lt; 0) {  
               rtc_now.sec = 0;  
               if (pmic_rtc_start(&amp;amp;rtc_now) &amp;lt; 0) {  
                   printk(&amp;quot;get and set rtc info failed\n&amp;quot;);  
                   break;  
               }  
           }  
           pmic_rtc_disable_alarm(PM_RTC_ALARM_1);  
           rtc_now.sec += rtc_alarm_time;  
           pmic_rtc_enable_alarm(PM_RTC_ALARM_1, &amp;amp;rtc_now);  
           break;  
       }  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然不要忘记增加一个include：&lt;/p&gt;

&lt;p&gt;#include &lt;mach/pmic.h&gt;&lt;/p&gt;

&lt;p&gt;3）在frameworks/base/services/jni/com_android_server_AlarmManagerService.cpp里面增加一个方法去设置时钟：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
static void android_server_AlarmManagerService_updateRtcAlarm(JNIEnv* env, jobject obj, jint fd, jint seconds)  
{  
#if HAVE_ANDROID_OS  
   int result = ioctl(fd, ANDROID_RTC_ALARM_SET, &amp;amp;seconds);  
   LOGE(&amp;quot;set rtc alarm to %d later: %s\n&amp;quot;, seconds, strerror(errno));  
   if (result &amp;lt; 0)  
   {  
       LOGE(&amp;quot;Unable to set rtc alarm to %d later: %s\n&amp;quot;, seconds, strerror(errno));  
   }  
#endif  
}  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有就是不要忘记定义一下接口：&lt;/p&gt;

&lt;p&gt;{&amp;ldquo;updateRtcAlarm&amp;rdquo;, &amp;ldquo;(II)V&amp;rdquo;, (void*)android_server_AlarmManagerService_updateRtcAlarm},&lt;/p&gt;

&lt;p&gt;4） 在frameworks/base/services/java/com/android/server/AlarmManagerService.java里面定义native的设置alarm的方法，然后调用就可以实现将自动关机的alarm设置下去了：&lt;/p&gt;

&lt;p&gt;定义：private native void updateRtcAlarm(int fd, int seconds);&lt;/p&gt;

&lt;p&gt;调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   public void setRepeating(int type, long triggerAtTime, long interval,  
           PendingIntent operation) {  
       if (operation == null) {  
           Slog.w(TAG, &amp;quot;set/setRepeating ignored because there is no intent&amp;quot;);  
           return;  
       }  
       synchronized (mLock) {  
           Alarm alarm = new Alarm();  
           alarm.type = type;  
           alarm.when = triggerAtTime;  
           alarm.repeatInterval = interval;  
           alarm.operation = operation;  

           // Remove this alarm if already scheduled.  
           removeLocked(operation);  

           if (localLOGV) Slog.v(TAG, &amp;quot;set: &amp;quot; + alarm);  

           int index = addAlarmLocked(alarm);  
           if (index == 0) {  
               setLocked(alarm);  
           }  

           // Start to setup auto power on alarm  
           if ((alarm.type == AlarmManager.ELAPSED_REALTIME_WAKEUP) &amp;amp;&amp;amp;  
                               alarm.operation.getTargetPackage().equals(&amp;quot;com.android.settings&amp;quot;)) {  
               updateRtcAlarm(mDescriptor, (int)((alarm.when - System.currentTimeMillis()) / 1000));  
           }  
           // End to setup auto power on alarm  
       }  
   }  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5）在应用层设置自动开机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
       AlarmManager am = (AlarmManager) context  
               .getSystemService(Context.ALARM_SERVICE);  
       Intent intent = new Intent(  
               &amp;quot;com.android.settings.action.REQUEST_POWER_ON&amp;quot;);  
       PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0,  
               intent, PendingIntent.FLAG_CANCEL_CURRENT);  
       am = (AlarmManager) context  
               .getSystemService(Context.ALARM_SERVICE);  
       am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, time, pendingIntent);  

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;总结&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1） 自动开机原理比较简单，但是需要底层的支持，所以对于做应用或者framework层的技术人员来说，实现起来稍微比较麻烦。&lt;br /&gt;
2） 在设置自动开关机的时候，需要考虑的情况很多，比如是否设置时间/时区的改变，手机当前是开机还是关机状态等。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux内核及文件系统移植</title>
            <link>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-07-linux%E5%86%85%E6%A0%B8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</link>
            <pubDate>Thu, 07 Jan 2016 16:46:14 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/hardware/android-%E5%BA%95%E5%B1%82/2016-01-07-linux%E5%86%85%E6%A0%B8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</guid>
            <description>

&lt;h1 id=&#34;linux内核及文件系统移植&#34;&gt;Linux内核及文件系统移植&lt;/h1&gt;

&lt;p&gt;嵌入式系统包含硬件子系统与软件子系统，其中软件子系统大致可分为：bootloader、Linux内核、文件系统与应用开发，这四个组成部分中前三者构建成嵌入式应用功能的基础运行环境，是进行嵌入式产品项目开发前期就需要敲定的配置环境，非常重要与关键。本课程主要对第三部分嵌入式文件系统的构建与移植进行介绍，讲解如何选择、配置、移植与制作一个可用的文件系统及其镜像，以及怎样配合Linux内核的配置调整来应用生成的文件系统，进而掌握构建完整的嵌入式软件子系统应用开发环境。&lt;/p&gt;

&lt;h1 id=&#34;开发移植环境-虚拟机ubuntu-12-04-friendlyarm-smart210sdk-windows-7-ultimate&#34;&gt;开发移植环境：虚拟机Ubuntu 12.04 + FriendlyARM Smart210SDK + Windows 7 Ultimate&lt;/h1&gt;

&lt;h2 id=&#34;lesson-1-linux内核启动参数介绍与设置&#34;&gt;Lesson 1. Linux内核启动参数介绍与设置&lt;/h2&gt;

&lt;p&gt;引导：&lt;br /&gt;
  软件子系统各组成部分之间的层次与关联，怎样相互识别、配置与加载？&lt;/p&gt;

&lt;p&gt;一、系统启动流程&lt;br /&gt;
  bootloader(uboot) ———— Linux Kernel(uImage) ———— Rootfs(Init) ———— Applications&lt;/p&gt;

&lt;p&gt;二、启动环境配置&lt;br /&gt;
  uboot环境变量: printenv  setenv  saveenv  tftpboot  nand read/write &amp;hellip;&lt;br /&gt;
    baudrate  115200&lt;br /&gt;
    bootdelay&lt;br /&gt;
    bootcmd   boot bootd运行bootcmd变量指定的命令进行启动&lt;br /&gt;
    ipaddr, serverip, ethaddr,gatewayip&lt;br /&gt;
    bootargs&lt;/p&gt;

&lt;p&gt;内核启动参数：bootargs &amp;lsquo;&lt;name&gt;=&lt;value&gt; &amp;hellip;&amp;rsquo;&lt;br /&gt;
  bootargs=root=/dev/nfs nfsroot=192.168.10.7:/home/hong/nfsroot ip=192.168.10.11 init=/linuxrc console=ttySAC0,115200&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root, rootfstype, nfsroot  
  root=/dev/nfs nfsroot=nfsserver:path  
  root=/dev/mtdblock2  
  rootfstype=jffs2/yaffs2/squashfs/ubifs/...  
mtdparts： mtdparts=mtd-id:&amp;lt;size1&amp;gt;@&amp;lt;offset1&amp;gt;(&amp;lt;name1&amp;gt;),&amp;lt;size2&amp;gt;@&amp;lt;offset2&amp;gt;(&amp;lt;name2&amp;gt;)  
  mtdparts=s5pv210-nand:1M(boot),5M(kernel),80M(rootfs),426M(usrfs)  
  要想这个参数起作用，内核中的mtd驱动必须要支持，即内核配置时需要选上  
  Device Drivers  ---&amp;gt; Memory Technology Device (MTD) support  ---&amp;gt; Command line partition table parsing  
ip: nfs必须进行设置  
   ip=ip addr  
   ip=ip addr:server ip addr:gateway:netmask::which netcard:off  
init, console  
mem 限制linux内核的使用内存 mem=128M  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、启动参数设置&lt;br /&gt;
    setenv bootargs &amp;lsquo;root=/dev/nfs nfsroot=192.168.10.7:/home/hong/nfsroot ip=192.168.10.11 init=/linuxrc console=ttySAC0,115200&amp;rsquo;&lt;br /&gt;
  setenv bootcmd &amp;lsquo;tftpboot 20008000 tiny_uImage;bootm 20008000&amp;rsquo;&lt;/p&gt;

&lt;p&gt;总结：&lt;br /&gt;
  1. 收集信息：flash类型与分区(nand/nor/spi.etc), 内存大小, 根文件系统类型,网络参数等(参考SDK开发手册)&lt;br /&gt;
  2. 配置参数：setenv bootargs &amp;lsquo;&amp;hellip;&amp;rsquo;;saveenv;&lt;br /&gt;
  3. 测试参数：确保内核镜像可以成功加载，必不可少的步骤&lt;/p&gt;

&lt;h2 id=&#34;lession-2-linux的根文件系统与基本框架&#34;&gt;Lession 2.Linux的根文件系统与基本框架&lt;/h2&gt;

&lt;p&gt;引导：&lt;br /&gt;
  Q1.什么是根文件系统，为什么需要根文件系统？&lt;br /&gt;
  Q2.根文件系统需要满足哪些要求？&lt;/p&gt;

&lt;p&gt;一、Linux文件系统&lt;br /&gt;
  目录结构&lt;br /&gt;
  树形结构：倒立 —— 根目录 /&lt;/p&gt;

&lt;p&gt;二、根文件系统概念&lt;br /&gt;
  1. 是什么&lt;br /&gt;
    内核第一个挂载的文件系统，包含Linux系统完整启动所需的目录结构和重要文件&lt;br /&gt;
    其它所有文件系统进行挂载使用的载体&lt;br /&gt;
  2. 为什么&lt;br /&gt;
    Linux完整启动的需要，进入用户态操作环境：VFS设计&lt;br /&gt;
    提供了良好强大的文件系统扩展性&lt;/p&gt;

&lt;p&gt;三、根文件系统形式&lt;br /&gt;
  1. 要求&lt;br /&gt;
    根文件系统能被内核找到并加载：存储介质驱动、存在地址问题&lt;br /&gt;
    格式能被内核识别：initrd/cramfs/&amp;hellip;&lt;br /&gt;
    包含基本的目录结构与启动程序&lt;br /&gt;
  2. 结构&lt;br /&gt;
    /bin  存放二进制可执行命令的目录&lt;br /&gt;
    /dev  存放设备文件的目录&lt;br /&gt;
    /etc  存放系统管理和配置文件的目录&lt;br /&gt;
    /home 用户主目录，比如用户user的主目录就是/home/user，可以用~user表示&lt;br /&gt;
    /lib  存放动态链接共享库的目录&lt;br /&gt;
    /sbin 存放系统管理员使用的管理程序的目录&lt;br /&gt;
    /tmp  公用的临时文件存储点&lt;br /&gt;
    /root 系统管理员的主目录&lt;br /&gt;
    /mnt  系统提供这个目录是让用户临时挂载其他的文件系统。&lt;br /&gt;
    /proc 虚拟文件系统，可直接访问这个目录来获取系统信息。&lt;br /&gt;
    /var  某些大文件的溢出区&lt;br /&gt;
    /usr  最庞大的目录，要用到的应用程序和文件几乎都在这个目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一般说来，只有/bin，/dev，/etc，/lib，/proc，/var，/usr这些需要的，而其他都是可选的。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：&lt;br /&gt;
  1.概念：根文件系统必不可少，有基本的格式与结构要求&lt;br /&gt;
  2.框架：/bin，/dev，/etc，/lib，/proc，/var，/usr&lt;/p&gt;

&lt;h2 id=&#34;lession-3-嵌入式根文件系统框架-busybox简介&#34;&gt;Lession 3.嵌入式根文件系统框架：busybox简介&lt;/h2&gt;

&lt;p&gt;引导：&lt;br /&gt;
  每次从零开始构建根文件系统框架，还是可以从一个现成的通用框架开始构建满足需求的根文件系统？&lt;/p&gt;

&lt;p&gt;一、从零开始构建最小根文件系统&lt;br /&gt;
  /bin，/dev，/etc，/lib，/proc，/var，/usr&lt;/p&gt;

&lt;p&gt;二、通用嵌入式根文件系统项目：busybox&lt;br /&gt;
  1. busybox项目： &lt;a href=&#34;http://www.busybox.net/&#34; target=&#34;_blank&#34;&gt;http://www.busybox.net/&lt;/a&gt;&lt;br /&gt;
    23 March 2015 &amp;ndash; BusyBox 1.23.2 (stable)&lt;br /&gt;
    嵌入式Linux的瑞士军刀&lt;br /&gt;
      BusyBox 将许多具有共性的小版本的UNIX工具结合到一个单一的可执行文件。这样的集合可以替代大部分常用工具比如的GNU fileutils, shellutils等工具，BusyBox提供了一个比较完善的环境，可以适用于任何小的嵌入式Linux系统。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;busybox源码&lt;br /&gt;
下载稳定的版本&lt;br /&gt;
编译构建二进制：make defconfig;make&lt;br /&gt;
  make menuconfig&lt;br /&gt;
安装得到目录结构：make CONFIG_PREFIX=../mini_rootfs/ install&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：&lt;br /&gt;
  以busybox为起点，进行项目根文件系统的裁剪定制，构建自己的根文件系统。&lt;/p&gt;

&lt;h2 id=&#34;lession-4-嵌入式根文件系统框架-启动脚本&#34;&gt;[Lession 4]. 嵌入式根文件系统框架：启动脚本&lt;/h2&gt;

&lt;p&gt;引导：&lt;br /&gt;
  前提：基于busybox的根文件系统移植与应用&lt;br /&gt;
  init程序的限制性与局限性如何实现灵活动态调整的嵌入式应用启动控制？&lt;/p&gt;

&lt;p&gt;一、init进程：linuxrc &amp;ndash;&amp;gt; ELF二进制程序&lt;br /&gt;
  /bin/busybox, 进程号1&lt;/p&gt;

&lt;p&gt;二、/etc/inittab文件: init程序的默认配置文件&lt;br /&gt;
  sysinit —— 为init提供初始化命令行的路径及脚本程序&lt;br /&gt;
  respawn —— 每当相应的进程终止执行便会重新启动&lt;br /&gt;
  askfirst —— 类似respawn，不过它的主要用途是减少系统上执行的终端应用程序的数量。它将会促使init在控制台上显示“Please press Enter to active this console”的信息，并在重新启动之前等待用户按下enter键&lt;br /&gt;
  wait —— 告诉init必须等到相应的进程完成之后才能继续执行&lt;br /&gt;
  once —— 仅执行相应的进程一次，而且不会等待它完成&lt;br /&gt;
  restart —— 当init重新启动时，执行相应的进程，通常此处所执行的进程就是init本身&lt;br /&gt;
  ctrlaltdel —— 当按下Ctrl+Alt+Delete组合键时，执行相应的进程&lt;br /&gt;
  shutdown —— 当系统关机时，执行相应的进程&lt;/p&gt;

&lt;p&gt;三、/etc/init.d/rcS文件及/etc/init.d目录&lt;br /&gt;
  初始化脚本：rcS &amp;ndash;&amp;gt; 系统环境准备与配置&lt;br /&gt;
  应用及服务脚本：S[0-9]* &amp;ndash;&amp;gt; 应用环境准备与配置&lt;/p&gt;

&lt;p&gt;四、编写并添加自定义的启动脚本&lt;br /&gt;
  S71myapp_demo S01hello&lt;/p&gt;

&lt;p&gt;总结：&lt;br /&gt;
  1.init —— inittab —— /etc/init.d/rcS —— /etc/init.d/S[0-9][0-9]* —— Applications&lt;br /&gt;
  2.用C编写一个应用程序，修改或者创建启动脚本使程序上电自动运行&lt;/p&gt;

&lt;h2 id=&#34;lession-5-嵌入式根文件系统框架-busybox编译&#34;&gt;Lession 5. 嵌入式根文件系统框架：busybox编译&lt;/h2&gt;

&lt;p&gt;怎样从源码交叉编译得到符合需求的可用busybox二进制以及根文件系统框架？&lt;/p&gt;

&lt;p&gt;一、busybox的构建流程&lt;br /&gt;
  1. make menuconfig &amp;ndash;&amp;gt; 裁剪定制构建选项: make defconfig&lt;br /&gt;
    ncurses库的支持：&lt;br /&gt;
      sudo apt-get install libncurses*&lt;br /&gt;
      aptitude search libncurses&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;make &amp;ndash;&amp;gt; 根据选项编译出二进制文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make install &amp;mdash;&amp;gt;  根据选项安装busybox&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、busybox的交叉编译&lt;br /&gt;
  1. 确认使用的交叉编译工具链以及其安装位置&lt;br /&gt;
      which arm-linux-gcc&lt;br /&gt;
  2. 配置busybox的编译工具链参数&lt;br /&gt;
    Build Options  &amp;mdash;&amp;gt;&lt;br /&gt;
      ()Cross Compiler prefix&lt;br /&gt;
      ()Path to sysroot&lt;/p&gt;

&lt;p&gt;三、busybox的裁剪定制&lt;br /&gt;
  1. 可配置选项简介： busybox settings&lt;br /&gt;
    通用配置&lt;br /&gt;
      [ ] Don&amp;rsquo;t use /usr&lt;br /&gt;
    构建选项：静态库、交叉编译&lt;br /&gt;
      [ ] Build BusyBox as a static binary (no shared libs)&lt;br /&gt;
    安装目录：./_install&lt;br /&gt;
      (./_install) BusyBox installation prefix&lt;br /&gt;
  注意：记得保存裁剪配置,可以查看.config文件进行简单的确认&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;工具应用程序定制： applets&lt;br /&gt;
对应busybox的源码目录&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;裁剪主要目标：降低busybox的文件大小，节省存储空间&lt;br /&gt;
  裁剪原则：确信你在做什么，否则就不要做&lt;/p&gt;

&lt;p&gt;总结&lt;br /&gt;
  掌握busybox的编译构建步骤和busybox的配置选项&lt;br /&gt;
  对busybox的配置选项进行各种尝试，观察构建出的busybox体积大小在去掉哪些选项时会有显著的降低&lt;/p&gt;

&lt;h2 id=&#34;lession-6-嵌入式根文件系统框架-busybox应用&#34;&gt;Lession 6. 嵌入式根文件系统框架：busybox应用&lt;/h2&gt;

&lt;p&gt;使用busybox需要确保busybox的运行，以及掌握常用的工具命令。&lt;/p&gt;

&lt;p&gt;一、补全目录与文件&lt;br /&gt;
  补全需要的目录：&lt;br /&gt;
    /proc /lib /etc /dev /usr /var&lt;/p&gt;

&lt;p&gt;动态库依赖：readelf -d busybox|grep NEEDED&lt;br /&gt;
    ld-linux.so.3  libc.so.6  libm.so.6&lt;br /&gt;
    ld-linux.so &amp;mdash;-&amp;gt; 实现动态库的链接&lt;br /&gt;
    C库的选择：glibc，还是uclibc &amp;mdash;-&amp;gt; 取决于你的交叉编译器&lt;br /&gt;
      glibc &amp;mdash;&amp;gt; 更全面完善的功能&lt;br /&gt;
      uclibc &amp;mdash;&amp;gt; 更小的体积&lt;br /&gt;
    库文件的查找：交叉编译器的安装目录 find命令&lt;/p&gt;

&lt;p&gt;设备文件：&lt;br /&gt;
    /dev/console&lt;br /&gt;
    /dev/tty1 /dev/tty2 /dev/tty3&lt;br /&gt;
  配置文件：&lt;br /&gt;
    拷贝 examples/bootfloppy/etc&lt;/p&gt;

&lt;p&gt;二、机制与使用&lt;br /&gt;
  busybox是一个二进制程序，集合大量简单常用的工具程序到单个执行文件&lt;br /&gt;
    代码共用，让busybox更小&lt;br /&gt;
    单一执行文件，让busybox更简单&lt;br /&gt;
  直接使用busybox：（二进制程序）&lt;br /&gt;
    得到可用的工具命令（applets)列表&lt;br /&gt;
  将命令名称作为参数调用busybox：等同于直接使用命令&lt;br /&gt;
    /bin/busybox ls &amp;mdash;&amp;gt; ls&lt;br /&gt;
    手动创建链接文件：ln -s /bin/busybox /bin/ls&lt;br /&gt;
    安装过程自动创建所有的链接文件 &amp;mdash;&amp;gt; make install&lt;br /&gt;
  所有工具命令的通用选项：&amp;ndash;help&lt;br /&gt;
    提供命令的简洁使用说明&lt;/p&gt;

&lt;p&gt;三、嵌入式常用的工具命令&lt;br /&gt;
  设备驱动管理:&lt;br /&gt;
    fdisk fsck  hwclock   mkdosfs&lt;br /&gt;
    insmod  rmmod lsmod   mknod     modprobe&lt;br /&gt;
    lsusb mdev  mount   umount&lt;br /&gt;
  文本编辑处理：&lt;br /&gt;
    mkdir mkfifo  ln    mv    cp    touch rm  unlink&lt;br /&gt;
    awk   cat   cut   find  vi    sed   wc  tar&lt;br /&gt;
    grep  head  tail  less  more  xargs od  stat&lt;br /&gt;
  网络信息配置：&lt;br /&gt;
    udhcpc  udhcpd  route netstat ping  ifconfig&lt;/p&gt;

&lt;p&gt;系统信息管理：&lt;br /&gt;
    chmod clear date  dd    df    echo  free&lt;br /&gt;
    ipcrm   ipcs  ls    ps    pwd   top   uptime&lt;br /&gt;
    kill  killall reboot  sleep sysctl  usleep&lt;/p&gt;

&lt;p&gt;总结：&lt;br /&gt;
  编译完成后的安装步骤是进行busybox根文件系统应用高效开始的第一步&lt;br /&gt;
  熟悉并掌握常用的工具命令是进行busybox根文件系统应用开发的第二步&lt;br /&gt;
  确保busybox的正确运行需要额外的库支持，这是进行busybox应用的前提条件&lt;/p&gt;

&lt;h2 id=&#34;lession-7-文件系统移植实践一-基于busybox制作可用根文件系统&#34;&gt;Lession 7  文件系统移植实践一：基于busybox制作可用根文件系统&lt;/h2&gt;

&lt;p&gt;一个开发中实用的根文件系统，还需要完善哪些内容，怎样来部署一个根文件系统？&lt;/p&gt;

&lt;p&gt;一、完善根文件系统&lt;br /&gt;
1. check程序运行库：/lib/&lt;br /&gt;
  从交叉编译工具目录拷贝&lt;br /&gt;
    libpthread.so   libthread_db.so&lt;br /&gt;
    libresolv.so&lt;br /&gt;
    librt.so&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;check配置文件： /etc目录&lt;br /&gt;
/etc/inittab&lt;br /&gt;
/etc/fstab: 文件内容与格式介绍, man fstab&lt;br /&gt;
 &lt;file system&gt;    &lt;dir&gt; &lt;type&gt;      &lt;options&gt; &lt;dump&gt;      &lt;pass&gt;&lt;br /&gt;
设备名称(分区)    挂载点 文件系统类型  挂载选项  备份检查[0|1] fsck优先级[0|1|2]&lt;br /&gt;
  defaults  使用默认设置，等于rw,suid,dev,exec,auto,nouser,async&lt;br /&gt;
内核文件系统挂载：proc&lt;br /&gt;
/etc/profile：环境变量的设置与导出&lt;br /&gt;
#!/bin/sh&lt;br /&gt;
PATH=/bin:/sbin:/usr/bin:/usr/sbin&lt;br /&gt;
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH&lt;br /&gt;
export PATH LD_LIBRARY_PATH&lt;br /&gt;
/etc/resolv.conf&lt;br /&gt;
DNS配置： nameserver 192.168.10.1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;check启动脚本：/etc目录&lt;br /&gt;
/etc/init.d/rcS&lt;br /&gt;
for script in /etc/init.d/S[0-9][0-9]*&lt;br /&gt;
do&lt;br /&gt;
  if [ -x $script ];then&lt;br /&gt;
    /bin/sh -c $script&lt;br /&gt;
  fi&lt;br /&gt;
done&lt;br /&gt;
/etc/init.d/S80network：网络配置&lt;br /&gt;
ifconfig eth0 hw ether 00:aa:11:cc:01:10&lt;br /&gt;
静态配置：&lt;br /&gt;
  ifconfig eth0 192.168.10.111 broadcast 255.255.255.0&lt;br /&gt;
  route add default gw 192.168.10.1&lt;br /&gt;
动态配置：&lt;br /&gt;
  udhcpc -i eth0 -t 20 -naq&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、 制作文件系统镜像&lt;br /&gt;
  二进制镜像是根文件系统的目录结构以某种数据组织格式打包成的二进制文件&lt;br /&gt;
    组织格式：文件系统格式&lt;br /&gt;
       cramfs jffs2 yaffs2 &amp;hellip;&lt;br /&gt;
  产品的生产部署阶段使用：批量烧录到产品&lt;br /&gt;
    镜像可以方便地进行存储、分发与部署&lt;/p&gt;

&lt;p&gt;总结：&lt;br /&gt;
  实践取决于应用需求，原理是相通的，但是不同的需求决定需要包含哪些内容。&lt;br /&gt;
 Lession 9  Linux内核文件系统：proc、tmpfs、devfs、sysfs&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在类Unix系统中一切都是文件，那么Linux是如何将系统的运行信息、设备信息等抽象成文件进行管理的？&lt;/p&gt;

&lt;p&gt;Linux内核实现了一套特殊的内存虚拟文件系统用于使用与文件接口统一的操作来完成系统信息管理，它们包括：&lt;br /&gt;
  procfs、devfs、sysfs。&lt;/p&gt;

&lt;p&gt;一、procfs&lt;br /&gt;
  procfs是Linux内核信息的抽象文件接口，大量内核中的信息以及可调参数都被作为常规文件映射到&lt;br /&gt;
一个目录树中/proc.这样我们就可以简单直接的通过echo或cat这样的文件操作命令对系统信息进行查取&lt;br /&gt;
和调整了。大量的系统工具也通过procfs获取内核参数，例如ps、lspci等。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;procfs的挂载：首先确定你的内核已经支持procfs，默认支持&lt;/p&gt;

&lt;h1 id=&#34;mount-t-proc-none-proc&#34;&gt;mount -t proc none /proc&lt;/h1&gt;

&lt;p&gt;使用/etc/fstab条目：none /proc proc defaults 0 0&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;procfs的内容：&lt;br /&gt;
进程信息&lt;br /&gt;
系统信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;procfs信息查看&lt;br /&gt;
cat命令： cat /proc/cmdline&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;procfs参数调整&lt;br /&gt;
echo命令&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、tmpfs&lt;br /&gt;
  tmpfs是一种虚拟内存文件系统，使用内存作为存储分区进行文件的临时性存取，掉电会丢失，创建时不需要使用mkfs等进行格式化。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;tmpfs的挂载：首先确定你的内核已经支持tmpfs&lt;/p&gt;

&lt;h1 id=&#34;mount-t-tmpfs-o-size-10m-tmpfs-tmp&#34;&gt;mount -t tmpfs -o size=10M tmpfs /tmp&lt;/h1&gt;

&lt;h1 id=&#34;df-h&#34;&gt;df -h&lt;/h1&gt;

&lt;p&gt;使用/etc/fstab条目：tmpfs /tmp tmpfs defaults 0 0&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tmpfs的使用：用来存放应用临时生成的信息，不需要持久保存&lt;br /&gt;
正常使用挂载目录：创建文件，存储信息，删除文件等&lt;br /&gt;
记住：目录下的所有信息将在系统掉电后全部丢失&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tmpfs的作用&lt;br /&gt;
提高存储效率，内存的访问速度比Flash快很多&lt;br /&gt;
避免对Flash存储设备的频繁读写，提高使用寿命&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、devfs&lt;br /&gt;
  Linux2.6内核以前设备文件的抽象机制：提供了一种类似于文件的方法来管理位于/dev目录下的所有设备。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;/dev ————— 根文件系统目录&lt;br /&gt;
设备文件创建&lt;br /&gt;
  制作根文件系统时创建基本的，比如console,tty1等&lt;br /&gt;
  设备驱动加载时创建相应的设备文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;特殊设备文件&lt;br /&gt;
/dev/console&lt;br /&gt;
/dev/null /dev/zero&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;devfs的缺点 ————&amp;gt; sysfs的设计&lt;br /&gt;
不确定的设备映射，有时一个设备映射的设备文件可能不同，例如我的U盘可能对应sda有可能对应sdb&lt;br /&gt;
没有足够的主/辅设备号，当设备过多的时候，显然这会成为一个问题&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;四、sysfs&lt;br /&gt;
  Linux2.6内核以后引入sysfs：挂载于/sys目录下，把实际连接到系统上的设备和总线组织成一个分级的文件，用户空间的程序同样可以利用这些信息以实现和内核的交互，该文件系统是当前系统上实际设备树的一个直观反应。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;sysfs的原理&lt;br /&gt;
kobject子系统：建立目录树&lt;br /&gt;
  当一个kobject被创建的时候，/sys/目录下对应的文件和目录也就被创建&lt;br /&gt;
  每个设备在sysfs中都有唯一对应的目录，可以被用户空间读写&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sysfs的挂载：首先确定你的内核已经支持sysfs，默认支持&lt;/p&gt;

&lt;h1 id=&#34;mount-t-none-sysfs-sys&#34;&gt;mount -t none sysfs /sys&lt;/h1&gt;

&lt;p&gt;使用/etc/fstab条目：none /sys sysfs defaults 0 0&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sysfs的使用&lt;br /&gt;
cat命令： 查看/sys目录下的设备信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sysfs的应用&lt;br /&gt;
用户空间的工具udev：利用了sysfs提供的信息来实现所有devfs的功能&lt;br /&gt;
  udev运行在用户空间中，而devfs却运行在内核空间&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：&lt;br /&gt;
  一切皆文件的抽象思想，使得Linux系统的管理变得简单统一，好的哲学产生好的设计。&lt;/p&gt;

&lt;h2 id=&#34;lession-10-嵌入式nfs文件系统的介绍与应用&#34;&gt;Lession 10  嵌入式NFS文件系统的介绍与应用&lt;/h2&gt;

&lt;p&gt;嵌入式是宿主机 + 开发板的开发模式，两者之间的网络通讯与文件共享是进行高效率开发调试的前提条件。&lt;br /&gt;
  NFS文件系统是嵌入式开发调试的快速高效手段，掌握与熟练使用是必备技能。&lt;/p&gt;

&lt;p&gt;一、NFS简介&lt;br /&gt;
1、NFS：Network FileSystem&lt;br /&gt;
  通过NFS挂载远程主机的目录，访问该目录就像访问本地目录一样&lt;br /&gt;
  使用NFS服务能够方便地使各unix-like系统之间实现共享&lt;br /&gt;
  Samba：在unix-like系统和windows系统之间共享&lt;/p&gt;

&lt;p&gt;2、NFS模式：C/S模式，RPC服务框架&lt;br /&gt;
  NFS Server &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-&amp;gt; NFS Client&lt;br /&gt;
  NFS运行在SUN的RPC（Remote Procedure Call，远程过程调用）基础上，RPC定义了一种与系统无关的方法来实现进程间通信&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NFS服务与安装：&lt;br /&gt;
portmap服务&lt;br /&gt;
nfs-kernel-server服务&lt;br /&gt;
安装：# sudo apt-get install nfs-kernel-server&lt;br /&gt;
启动：# sudo /etc/init.d/nfs-kernel-server start&lt;br /&gt;
停止：# sudo /etc/init.d/nfs-kernel-server stop&lt;br /&gt;
状态：# sudo /etc/init.d/nfs-kernel-server status&lt;br /&gt;
重启：# sudo /etc/init.d/nfs-kernel-server restart&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、NFS使用配置&lt;br /&gt;
  1. 配置文件： /etc/exports&lt;br /&gt;
    对NFS服务的访问是由exports来批准，它枚举了若干有权访问NFS服务器上文件系统的主机名。&lt;br /&gt;
    文件控制对目录的共享（NFS挂载目录及权限由该文件定义），书写规则是每个共享为一行）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;格式：[共享目录] [主机名或IP](参数,参数...)  
第一个参数是要让客户机访问的目录，第二个是你允许的主机IP，最后的()内是访问控制方式。  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NFS共享控制参数：man exports&lt;br /&gt;
ro 只读访问&lt;br /&gt;
rw 读写访问&lt;br /&gt;
sync 所有数据在请求时写入共享（默认）&lt;br /&gt;
async NFS在写入数据前可以相应请求&lt;br /&gt;
secure NFS通过1024以下的安全TCP/IP端口发送&lt;br /&gt;
insecure NFS通过1024以上的端口发送&lt;br /&gt;
wdelay 如果多个用户要写入NFS目录，则归组写入（默认）&lt;br /&gt;
no_wdelay 如果多个用户要写入NFS目录，则立即写入，当使用async时，无需此设置&lt;br /&gt;
hide 在NFS共享目录中不共享其子目录&lt;br /&gt;
no_hide 共享NFS目录的子目录&lt;br /&gt;
subtree_check 要求检查请求访问的目录或者文件是否在共享目录下&lt;br /&gt;
no_subtree_check 只检查请求访问的目录或文件是否在共享的文件系统中&lt;br /&gt;
all_squash 共享文件的UID和GID映射匿名用户anonymous，适合公用目录&lt;br /&gt;
no_all_squash 保留共享文件的UID和GID（默认）&lt;br /&gt;
root_squash root用户的所有请求映射成如anonymous用户一样的权限（默认）&lt;br /&gt;
no_root_squash root用户具有根目录的完全管理访问权限&lt;br /&gt;
anonuid=xxx 指定NFS服务器/etc/passwd文件中匿名用户的UID&lt;br /&gt;
anongid=xxx 指定NFS服务器/etc/passwd文件中匿名用户的GID&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置命令&lt;br /&gt;
exportfs&lt;br /&gt;
  重新加载/etc/exports的共享目录，卸载NFS Server共享的目录或者重新共享&lt;br /&gt;
  若更改了/etc/exports，运行以下命令进行更新：&lt;br /&gt;
    $ sudo exportfs -r&lt;br /&gt;
showmount&lt;br /&gt;
  用來查看NFS共享的目录资源, 查看NFS Server的export list：&lt;br /&gt;
    $ sudo showmount -e&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、NFS开发板使用&lt;/p&gt;

&lt;p&gt;1、宿主机防火墙：在挂载失败时返回来检查设置&lt;br /&gt;
  一般需要关闭防火墙服务，确保没有屏蔽NFS使用的端口和允许通信的主机&lt;/p&gt;

&lt;p&gt;2、NFS内核支持&lt;br /&gt;
  Network FileSystem &amp;ndash;&amp;gt; [] NFS Client&lt;br /&gt;
  首先查看目标板kernel自身是否支持NFS&lt;br /&gt;
    cat /proc/filesystems命令： 是否有NFS一行&lt;/p&gt;

&lt;p&gt;3、NFS目录挂载&lt;br /&gt;
  挂载格式： mount [Server IP]:/[share dir] [local mount point]&lt;br /&gt;
    # mount -t nfs -o nolock 192.168.10.11:/opt/FriendlyARM/mini2440/root_nfs /mnt/root_nfs&lt;br /&gt;
  检查挂载：挂载失败会有错误原因打印&lt;br /&gt;
    # df -h&lt;br /&gt;
  取消挂载&lt;br /&gt;
    # umount /mnt/root_nfs&lt;/p&gt;

&lt;h2 id=&#34;lession-11-ramfs文件系统-initramfs概念与使用&#34;&gt;Lession 11  Ramfs文件系统：initramfs概念与使用&lt;/h2&gt;

&lt;p&gt;Linux内核加载根文件系统执行/sbin/init程序前，需要找到根设备位置，如果根设备需要驱动的支持，&lt;br /&gt;
  内核有可能无能为力，通过提供一个过渡的临时根文件系统可以使得内核的设计更灵活简单。&lt;/p&gt;

&lt;p&gt;一、rootfs,ramfs,ramdisk与tmpfs&lt;br /&gt;
  1. rootfs&lt;br /&gt;
    内核启动的初始始根文件系统，大部分linux系统正常运行后都会安装另外的文件系统，然后忽略rootfs&lt;br /&gt;
  2. ramfs&lt;br /&gt;
    基于内存的文件系统。ramfs文件系统没有容量大小的限制，它可以根据需要动态增加容量。&lt;br /&gt;
    直接利用了内核的磁盘高速缓存&lt;br /&gt;
  3. ramdisk&lt;br /&gt;
    基于ram的块设备，占据一块固定的内存，事先要使用特定的工具比如mke2fs格式化，还需要一个文件系统驱动来读写其上的文件&lt;br /&gt;
    空间固定导致容量有限，要想装入更多的文件需要重新格式化&lt;br /&gt;
    Linux的块设备缓冲特性, ram disk上的数据被拷贝到page cache(对于文件数据)和dentry cache(对于目录项),导致内存浪费&lt;br /&gt;
  4. tmpfs&lt;br /&gt;
    ramfs的一个缺点是它可能不停的动态增长直到耗尽系统的全部内存，所以只有root或授权用户允许使用ramfs。&lt;br /&gt;
      增加了容量大小的限制  +  允许把数据写入交换分区&lt;br /&gt;
    由于增加了这两个特性，tmpfs允许普通用户使用。&lt;/p&gt;

&lt;p&gt;二、initrd与initramfs&lt;br /&gt;
  过渡根文件系统机制：将加载真正的根文件系统需要的设备驱动、工具以及初始化程序先加载到内存运行。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;initrd: initial Ramdisk&lt;br /&gt;
/linuxrc文件&lt;br /&gt;
基于ramdisk技术&lt;br /&gt;
文件系统(ext2等)镜像文件 ————&amp;gt; cpio格式镜像文件&lt;br /&gt;
在内核启动完成后把它复制到/dev/ram块设备中, 作为内核加载真正根文件系统的过渡根文件系统&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;initramfs: initial RAM file system&lt;br /&gt;
init文件&lt;br /&gt;
cpio格式镜像文件&lt;br /&gt;
在内核启动完成后把它复制到rootfs中，作为内核初始的根文件系统，完成挂载系统真正的根文件系统&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、initramfs使用&lt;br /&gt;
  1. init程序文件: hello world&lt;br /&gt;
    #include &lt;stdio.h&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(int argc, char *argv[])  
{  
  printf(&amp;quot;Hello world Initramfs!\n&amp;quot;);  
  sleep(999999999);  
}  
交叉编译：arm-linux-gcc -static hello.c -o hello  
修改命名：mv hello init  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打包initramfs镜像&lt;br /&gt;
find .|cpio -o -H newc|gzip &amp;gt; ~/myinitramfs.cpio.gz&lt;br /&gt;
在内核中选择使用: 注意选择initramfs的压缩格式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解包initramfs镜像&lt;br /&gt;
cpio -i -F myinitramfs.cpio &amp;ndash;no-absolute-filenames&lt;br /&gt;
zcat myinitramfs.cpio.gz | cpio -i -d -H newc &amp;ndash;no-absolute-filenames&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内核initramfs的构建&lt;br /&gt;
General setup  &amp;mdash;&amp;gt;&lt;br /&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support&lt;br /&gt;
  (/rootfs_dir) Initramfs source file(s)&lt;br /&gt;
   Built-in initramfs compression mode (None)  &amp;mdash;&amp;gt; [] None [] GZIP&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：&lt;br /&gt;
  Linux内核 ————&amp;gt; initrd/initramfs（包含根文件系统的设备驱动等） ————&amp;gt; Real Root Filesystem&lt;br /&gt;
  详细官方的描述文档：内核源码树下 Documentation/filesystems/ramfs-rootfs-initramfs.txt&lt;/p&gt;

&lt;h2 id=&#34;lession-13-flash文件系统-jffs-jffs2和yaffs-yaffs2&#34;&gt;Lession 13  Flash文件系统：jffs/jffs2和yaffs/yaffs2&lt;/h2&gt;

&lt;p&gt;在嵌入式系统中进行数据读写时，为了保证可靠性，我们可以选择哪些合适的文件系统？&lt;/p&gt;

&lt;p&gt;一、Flash闪存类型&lt;br /&gt;
  非易失存储器，可以对称为块的存储器单元块进行擦写和再编程&lt;br /&gt;
  任何flash器件的写入操作只能在空或已擦除的单元内进行，在进行写入操作之前必须先执行擦除&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NOR Flash: 非易失内存&lt;br /&gt;
应用：代码存储介质&lt;br /&gt;
特点：&lt;br /&gt;
  芯片内执行(XIP, eXecute In Place)&lt;br /&gt;
  低容量高成本： 1 - 16MB（常见）&lt;br /&gt;
  读写速度：读取速度快，写入速度慢&lt;br /&gt;
  块最大擦写次数：10W&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NAND Flash：类似硬盘的块设备&lt;br /&gt;
应用：数据存储介质&lt;br /&gt;
特点：&lt;br /&gt;
　极高的单元密度&lt;br /&gt;
  读写速度：写入和擦除的速度很快&lt;br /&gt;
  高容量低成本：16 - 1024MB（常见）&lt;br /&gt;
  块最大擦写次数：100W&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、JFFS2&lt;br /&gt;
  JFFS：1999&lt;br /&gt;
  Journalling Flash File System， Version 2：2001-9-23，Linux 2.4.10&lt;br /&gt;
  主要用于NOR Flash，可用于NAND Flash&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;特性：&lt;br /&gt;
掉电保护与损耗平衡&lt;br /&gt;
垃圾回收机制&lt;br /&gt;
CRC循环冗余校验机制&lt;br /&gt;
挂载时间与内存消耗跟文件系统的大小成正比：文件系统越大，越慢，消耗越多 ————&amp;gt; 很差的扩展性&lt;br /&gt;
  挂载需要进行全盘扫描，挂载一个 16M 的闪存有时需要半分钟以上的时间&lt;br /&gt;
  在实际应用中，JFFS2 最大能用在 128M 的闪存上&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、YAFFS2&lt;br /&gt;
  YAFFS：2002&lt;br /&gt;
  Yet Another Flash File System， Version 2：2003&lt;br /&gt;
  只能用于NAND Flash, YAFFS1支持512Bytes/Page的NAND Flash;YAFFS2支持2kBytes/Page的NAND Flash.&lt;/p&gt;

&lt;p&gt;1.特性：&lt;br /&gt;
    储存资料的基本单位是Chunk：Page&lt;br /&gt;
    支持YAFFS/Direct使用：可以不需要VFS，甚至操作系统支持&lt;br /&gt;
    ECC冗余校验机制&lt;br /&gt;
      纠正单比特错误和检测双比特错误，而且计算速度很快，但对1比特以上的错误无法纠正，对2比特以上的错误不保证能检测。&lt;br /&gt;
    更快的挂载速度，更少的内存使用&lt;br /&gt;
      512B/page ————&amp;gt; 4KB RAM/1MB NAND&lt;br /&gt;
      2KB/Page  ————&amp;gt; 1KB RAM/1MB NAND&lt;/p&gt;

&lt;p&gt;总结：&lt;br /&gt;
  JFFS与YAFFS都是日志结构文件系统（LFS），保障了数据的可靠性与安全性，可以恢复数据。&lt;br /&gt;
  一般来说,对于小于64MB的NAND Flash,可以选用JFFS2;如果超过64MB,用YAFFS2比较合适&lt;/p&gt;

&lt;h2 id=&#34;lesson-16-cramfs文件系统的制作与使用&#34;&gt;Lesson 16 Cramfs文件系统的制作与使用&lt;/h2&gt;

&lt;p&gt;如何来制作一个cramfs文件系统的镜像以及验证它？&lt;/p&gt;

&lt;p&gt;一、工具安装&lt;br /&gt;
  sudo apt-get install cramfsprogs&lt;/p&gt;

&lt;p&gt;命令：&lt;br /&gt;
    mkcramfs&lt;br /&gt;
    cramfsck&lt;/p&gt;

&lt;p&gt;二、镜像制作&lt;br /&gt;
  文件系统内容：mini_busybox/&lt;br /&gt;
  mkcramfs [dir] [fs-name]&lt;/p&gt;

&lt;p&gt;三、镜像使用&lt;br /&gt;
  文件系统验证：&lt;br /&gt;
    cramfsck  [fs-name]&lt;/p&gt;

&lt;p&gt;文件系统测试：losetup命令&lt;br /&gt;
    losetup [loop device] [fs-file]&lt;br /&gt;
    losetup -a&lt;br /&gt;
    losetup -d [loop device]&lt;/p&gt;

&lt;p&gt;总结：文件系统镜像制作：安装工具 &amp;mdash; 准备文件系统内容 &amp;mdash; 使用工具制作镜像 &amp;mdash; 测试镜像&lt;/p&gt;

&lt;h2 id=&#34;lesson-17-squashfs文件系统的制作与使用&#34;&gt;Lesson 17 squashfs文件系统的制作与使用&lt;/h2&gt;

&lt;p&gt;如何来制作一个squashfs件系统的镜像？&lt;/p&gt;

&lt;p&gt;一、工具安装&lt;br /&gt;
  sudo apt-get install squashfs-tools&lt;/p&gt;

&lt;p&gt;命令：dpkg -L squashfs-tools|grep bin&lt;br /&gt;
    mksquashfs&lt;br /&gt;
    unsquashfs&lt;/p&gt;

&lt;p&gt;二、镜像制作&lt;br /&gt;
  mksquashfs source1 source2 &amp;hellip;  dest [options] [-e list of exclude dirs/files]&lt;br /&gt;
  主要选项：&lt;br /&gt;
    -comp &lt;comp&gt;            指定压缩算法：gzip (default)/lzo/xz&lt;br /&gt;
    -b &lt;block_size&gt;         设置块大小，单位 Bytes，默认 131072 bytes (1MB)&lt;br /&gt;
    -no-exports             不支持NFS文件系统导出&lt;br /&gt;
    -no-sparse              不检测稀疏文件&lt;br /&gt;
    -no-xattrs              不存储扩展文件属性(XATTR)&lt;br /&gt;
    -xattrs                 存储扩展文件属性(default)&lt;br /&gt;
    -noI                    不压缩Inode节点表&lt;br /&gt;
    -noD                    不压缩数据块&lt;br /&gt;
    -noF                    不压缩片段块&lt;br /&gt;
    -noX                    不压缩扩展文件属性&lt;br /&gt;
    -no-fragments           不使用片段管理&lt;br /&gt;
    -always-use-fragments   对比块大小大的文件也是用片段块&lt;br /&gt;
    -no-duplicates          不对文件重复进行检查&lt;br /&gt;
    -all-root               修改所有的文件拥有者为root&lt;br /&gt;
    -force-uid uid          设置所有文件的uid为指定的uid&lt;br /&gt;
    -force-gid gid          设置所有文件的gid为指定的gid&lt;br /&gt;
    -nopad                  不对文件系统进行4K字节对齐&lt;br /&gt;
    -keep-as-directory      如果指定的源中有目录，在文件系统中创建根目录包含该目录，而不是包含目录内容&lt;/p&gt;

&lt;p&gt;文件系统内容：mini_busybox/&lt;br /&gt;
    mksquashfs mini_busybox rootfs.squashfs -no-exports -no-xattrs -all-root&lt;/p&gt;

&lt;p&gt;三、镜像使用&lt;br /&gt;
  内容提取：&lt;br /&gt;
    unsquashfs [options] filesystem [directories or files to extract]&lt;br /&gt;
    主要选项：&lt;br /&gt;
      -d[est] &lt;pathname&gt;      解压到指定目录，默认为&amp;rdquo;squashfs-root&amp;rdquo;&lt;br /&gt;
      -n[o-progress]          不显示进度条&lt;br /&gt;
      -no[-xattrs]            不提取xattr属性，默认提取&lt;br /&gt;
      -l[s]                   列出文件系统内容，不进行解压缩提取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  unsquashfs rootfs.squashfs  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;烧录挂载：&lt;br /&gt;
    sudo losetup /dev/loop0 rootfs.squashfs&lt;br /&gt;
    sudo mount /dev/loop0 /mnt&lt;br /&gt;
    sudo losetup -a&lt;/p&gt;

&lt;p&gt;卸载解依附：&lt;br /&gt;
    sudo umount /dev/loop0&lt;br /&gt;
    sudo losetup -d /dev/loop0&lt;/p&gt;

&lt;h2 id=&#34;lession-18-jffs2文件系统的制作与使用&#34;&gt;Lession 18  jffs2文件系统的制作与使用&lt;/h2&gt;

&lt;p&gt;如何来制作一个jffs2文件系统的镜像？&lt;/p&gt;

&lt;p&gt;一、工具安装&lt;br /&gt;
  sudo apt-get install mtd-utils&lt;/p&gt;

&lt;p&gt;命令：mkfs.jffs2&lt;/p&gt;

&lt;p&gt;二、镜像制作&lt;br /&gt;
  信息收集：&lt;br /&gt;
    Flash的页大小、擦除块大小&lt;/p&gt;

&lt;p&gt;mkfs.jffs2 [options]&lt;br /&gt;
  主要选项：&lt;br /&gt;
      -p, &amp;ndash;pad[=SIZE]        使用0xff填充文件系统到指定大小，不指定则只填充完最后一个擦除块&lt;br /&gt;
      -r, -d, &amp;ndash;root=DIR      使用指定的目录内容构建文件系统(default: cwd)&lt;br /&gt;
      -s, &amp;ndash;pagesize=SIZE     使用指定的页大小（最大数据节点大小） (default: 4KiB)&lt;br /&gt;
      -e, &amp;ndash;eraseblock=SIZE   指定擦除块的大小 (default: 64KiB)&lt;br /&gt;
      -c, &amp;ndash;cleanmarker=SIZE  擦除标记的大小 (default 12)&lt;br /&gt;
      -m, &amp;ndash;compr-mode=MODE   选择压缩模式(default: priortiry)&lt;br /&gt;
      -x, &amp;ndash;disable-compressor=COMPRESSOR_NAME  禁用指定的压缩算法&lt;br /&gt;
      -X, &amp;ndash;enable-compressor=COMPRESSOR_NAME 启用指定的压缩算法&lt;br /&gt;
      -y, &amp;ndash;compressor-priority=PRIORITY:COMPRESSOR_NAME  设置压缩算法的优先级&lt;br /&gt;
      -L, &amp;ndash;list-compressors  列出可用的压缩算法&lt;br /&gt;
      -t, &amp;ndash;test-compression  测试压缩算法&lt;br /&gt;
      -n, &amp;ndash;no-cleanmarkers   不添加擦除标记到擦除块&lt;br /&gt;
      -o, &amp;ndash;output=FILE       指定文件系统镜像名称(default: stdout)&lt;br /&gt;
      -l, &amp;ndash;little-endian     创建一个小端的文件系统&lt;br /&gt;
      -b, &amp;ndash;big-endian        创建一个大端的文件系统&lt;br /&gt;
      -q, &amp;ndash;squash            压缩权限和设置所有文件的拥有者为root&lt;br /&gt;
      -U, &amp;ndash;squash-uids       设置所有文件的拥有者为root&lt;br /&gt;
      -P, &amp;ndash;squash-perms      压缩所有文件的权限&lt;/p&gt;

&lt;p&gt;文件系统内容：mini_busybox/&lt;br /&gt;
    mkfs.jffs2 -d mini_busybox &amp;ndash;pad=0x1000000 -s 4096 -l -o rootfs.jffs2&lt;/p&gt;

&lt;p&gt;三、镜像使用&lt;br /&gt;
  MTD设备文件系统： 无法使用/dev/loop0块设备来模拟&lt;br /&gt;
    只能在Flash设备上使用&lt;/p&gt;

&lt;p&gt;应用: 烧录到Flash设备或者分区&lt;/p&gt;

&lt;p&gt;总结：mtd-utils包带有很多的工具命令可以使用，辅助管理和使用Flash设备&lt;/p&gt;

&lt;h2 id=&#34;lession-19-yaffs2文件系统的制作与使用&#34;&gt;Lession 19 yaffs2文件系统的制作与使用&lt;/h2&gt;

&lt;p&gt;如何来制作一个yaffs2文件系统的镜像？&lt;/p&gt;

&lt;p&gt;一、获取yaffs2源码&lt;br /&gt;
  git clone git://www.aleph1.co.uk/yaffs2&lt;br /&gt;
  从源码中编译制作工具：&lt;br /&gt;
    cd yaffs2/utils&lt;br /&gt;
    make&lt;br /&gt;
      error: unknown type name ‘u8’&lt;br /&gt;
      error: unknown type name ‘u32’&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  修改yportenv.h文件，增加：#define CONFIG_YAFFS_DEFINES_TYPES  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;制作工具：&lt;br /&gt;
    mkyaffs2image： YAFFS2(2KB/page)&lt;br /&gt;
    mkyaffsimage： YAFFS(512B/page)&lt;/p&gt;

&lt;p&gt;二、镜像制作&lt;br /&gt;
  文件系统内容：mini_busybox/&lt;br /&gt;
  mkyaffs2image dir image_file [convert]&lt;/p&gt;

&lt;p&gt;三、镜像使用&lt;br /&gt;
  MTD设备文件系统： 无法使用/dev/loop0块设备来模拟&lt;br /&gt;
    只能在NAND Flash设备上使用&lt;/p&gt;

&lt;p&gt;应用: 烧录到Flash设备或者分区&lt;/p&gt;

&lt;h2 id=&#34;lession-20-文件系统移植实践三-flash分区与文件系统镜像烧录&#34;&gt;Lession 20  文件系统移植实践三：Flash分区与文件系统镜像烧录&lt;/h2&gt;

&lt;p&gt;如何将文件系统镜像烧录到嵌入式Flash设备中，怎么样进行Flash的布局？&lt;/p&gt;

&lt;p&gt;一、Flash设备分区&lt;br /&gt;
  1. 嵌入式通用Flash布局&lt;br /&gt;
    bootloader + kernel + rootfs + appfs&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内核启动参数bootargs： mtparts&lt;br /&gt;
mtdparts： mtdparts=mtd-id:&lt;size1&gt;@&lt;offset1&gt;(&lt;name1&gt;),&lt;size2&gt;@&lt;offset2&gt;(&lt;name2&gt;)&lt;br /&gt;
  mtdparts=s5pv210-nand:1M(boot),5M(kernel),80M(rootfs),426M(usrfs)&lt;br /&gt;
  mtdparts=s5pv210-nand:1M(boot),5M(kernel),80M(rootfs),16M(jffs2),394M(yaffs2)&lt;br /&gt;
  要想这个参数起作用，内核中的mtd驱动必须要支持，即内核配置时需要选上&lt;br /&gt;
  Device Drivers  &amp;mdash;&amp;gt; Memory Technology Device (MTD) support  &amp;mdash;&amp;gt; Command line partition table parsing&lt;/p&gt;

&lt;p&gt;0x000000000000-0x000000100000 : &amp;ldquo;boot&amp;rdquo;&lt;br /&gt;
0x000000100000-0x000000600000 : &amp;ldquo;kernel&amp;rdquo;&lt;br /&gt;
0x000000600000-0x000005600000 : &amp;ldquo;rootfs&amp;rdquo;&lt;br /&gt;
0x000005600000-0x000006600000 : &amp;ldquo;jffs2&amp;rdquo;&lt;br /&gt;
0x000006600000-0x000020000000 : &amp;ldquo;yaffs2&amp;rdquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、uboot环境下的Flash命令&lt;br /&gt;
  nand    - NAND sub-system&lt;/p&gt;

&lt;p&gt;nand info - show available NAND devices&lt;br /&gt;
  nand device [dev] - show or set current device&lt;br /&gt;
  nand read - addr off|partition size&lt;br /&gt;
  nand write - addr off|partition size&lt;br /&gt;
    read/write &amp;lsquo;size&amp;rsquo; bytes starting at offset &amp;lsquo;off&amp;rsquo;&lt;br /&gt;
    to/from memory address &amp;lsquo;addr&amp;rsquo;, skipping bad blocks.&lt;br /&gt;
  nand write.yaffs - addr off|partition size&lt;br /&gt;
    write &amp;lsquo;size&amp;rsquo; bytes starting at offset &amp;lsquo;off&amp;rsquo; with yaffs format&lt;br /&gt;
    from memory address &amp;lsquo;addr&amp;rsquo;, skipping bad blocks.&lt;br /&gt;
  nand erase[.spread] [clean] off size - erase &amp;lsquo;size&amp;rsquo; bytes from offset &amp;lsquo;off&amp;rsquo;&lt;br /&gt;
    With &amp;lsquo;.spread&amp;rsquo;, erase enough for given file size, otherwise,&lt;br /&gt;
    &amp;lsquo;size&amp;rsquo; includes skipped bad blocks.&lt;/p&gt;

&lt;p&gt;二、文件系统镜像烧录&lt;br /&gt;
  0. 镜像制作： Flash型号的Page大小与Block大小，查看Datasheet手册&lt;br /&gt;
    K9F4G08X0B Array Organization：&lt;br /&gt;
      1 Page = (2K + 64)Bytes&lt;br /&gt;
      1 Block = 64 Pages = (128K + 4K) Bytes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs.jffs2 -d mini_busybox --pad=0x1000000 -s 2048 -e 0x20000 -l -o rootfs_128K.jffs2  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载镜像到系统内存中： 确定内存地址&lt;br /&gt;
tftp 0x20008000 &lt;image&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确定烧录要使用的分区： 确定Flash地址&lt;br /&gt;
Flash地址偏移&lt;br /&gt;
  0x000005600000-0x000006600000 : &amp;ldquo;jffs2&amp;rdquo;&lt;br /&gt;
  0x000006600000-0x000020000000 : &amp;ldquo;yaffs2&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;烧录内存中的镜像到Flash分区中&lt;br /&gt;
nand erase[.spread] &lt;flash-offset&gt; &lt;size&gt;&lt;br /&gt;
nand write &lt;memory-address&gt; &lt;flash-offset&gt; &lt;size&gt;&lt;br /&gt;
nand write.yaffs &lt;memory-address&gt; &lt;flash-offset&gt; &lt;size&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完整命令：&lt;br /&gt;
  tftp 0x20008000 rootfs.jffs2;nand erase 0x5600000 0x1000000;nand write 0x20008000 0x6600000 0x1000000&lt;br /&gt;
  tftp 0x20008000 rootfs.yaffs2;nand erase 0x6600000 0x19a00000;nand write.yaffs 0x20008000 0x6600000 0x4194c0&lt;/p&gt;

&lt;h2 id=&#34;lession-21-文件系统的挂载配置与选项&#34;&gt;Lession 21  文件系统的挂载配置与选项&lt;/h2&gt;

&lt;p&gt;将Flash设备分区挂载到根文件系统才能进行读写操作，挂载动作是系统正常运行的基础工作。&lt;/p&gt;

&lt;p&gt;一、根文件系统与应用文件系统&lt;br /&gt;
  根文件系统挂载： 内核完成&lt;br /&gt;
  应用文件系统（设备分区）挂载：mount命令&lt;br /&gt;
    Linux伪文件系统&lt;br /&gt;
    tmpfs文件系统&lt;br /&gt;
    Flash设备分区&lt;/p&gt;

&lt;p&gt;二、文件系统的挂载&lt;br /&gt;
  准备工作：&lt;br /&gt;
    设备分区：/dev/mtdblock3 /dev/mtdbock4&lt;br /&gt;
    创建挂载点：/mnt  /tmp  /apps&lt;/p&gt;

&lt;p&gt;挂载命令：&lt;br /&gt;
    mount   系统当前的文件系统挂载信息&lt;br /&gt;
    mount -a  挂载/etc/fstab文件中指定的文件系统与设备&lt;br /&gt;
    mount -t &lt;fstype&gt; [options] &lt;device name&gt; &lt;mount-point&gt; 挂载指定类型的设备到指定挂载点&lt;br /&gt;
      mount -t jffs2 /dev/mtdblock3 /appfs/jffs2    &amp;mdash;-&amp;gt; 时间比yaffs2的挂载长很多&lt;br /&gt;
      mount -t yaffs2 /dev/mtdblock4 /appfs/yaffs2&lt;/p&gt;

&lt;p&gt;启动挂载控制：启动脚本设置&lt;br /&gt;
    /etc/fstab   添加设备与文件系统的挂载配置&lt;br /&gt;
      注意：确保MTD设备分区已识别（udev/mdev的运行需要比/etc/fstab的挂载早）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/rc.S  添加具体的设备挂载命令  
  添加挂载脚本：  
  mount -t jffs2 /dev/mtdblock3 /appfs/jffs2  
  mount -t yaffs2 /dev/mtdblock4 /appfs/yaffs2  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lession-22-嵌入式开发文件系统的选择与配置原则&#34;&gt;Lession 22  嵌入式开发文件系统的选择与配置原则&lt;/h2&gt;

&lt;p&gt;构建嵌入式软件开发的基础设施环境是嵌入式应用开发的前提&lt;/p&gt;

&lt;p&gt;一、嵌入式软件开发&lt;br /&gt;
  1. uboot  ———— 提供开发控制环境&lt;br /&gt;
    基础硬件驱动移植&lt;br /&gt;
      串口控制终端&lt;br /&gt;
      Flash设备&lt;br /&gt;
      网卡识别&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;kernel(linux)  ———— 系统管理与任务调度&lt;br /&gt;
完整硬件驱动移植&lt;br /&gt;
文件系统支持移植&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FileSystem(rootfs + appfs) ———— 提供用户应用环境&lt;br /&gt;
移植构建根文件系统&lt;br /&gt;
组织应用文件系统&lt;br /&gt;
  应用开发&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分区管理控制&lt;br /&gt;
uboot + kernel + fs&lt;br /&gt;
镜像制作与烧录&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、文件系统移植应用&lt;br /&gt;
  1. 应用范畴&lt;br /&gt;
    根文件系统：建立用户空间使用环境&lt;br /&gt;
      busybox  &amp;mdash;&amp;ndash;&amp;gt; 提供系统管理等全面的用户工具集合&lt;br /&gt;
      启动脚本 &amp;mdash;&amp;ndash;&amp;gt; 配置用户空间的环境变量与提供应用开机启动机制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;应用文件系统：存放用户应用程序与数据  
  防止修改： cramfs squashfs  
  Flash设备: jffs2 yaffs2  
  SD卡等外部设备：FAT32  

临时文件系统：运行时存在的文件系统  
  系统信息管理：Linux伪文件系统  
    proc  
    sys  

  内存文件系统：临时数据的存放管理  
    tmpfs  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：内核与文件系统是嵌入式软件开发的基础设施，最重要的原则就是必须保证稳定可靠。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
