<!DOCTYPE html>
<html lang="zh-CN" class="no-js">
<head>
  <meta charset="UTF-8">
  <base href="//blog.pytool.com/">
  <script>
    document._writeOriginal = document.write;
    document.write = function(str) {
        if (str.indexOf('livereload.js') > -1) {
            document._writeOriginal(str);
        } else {
            document._writeOriginal('<!-- Be Hijack!! -->');
        }
    }
  </script>
<title>Linux命令 route - 时光小栈</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

<meta name="description" content="iproute2;高级路由;ip_route,ip_rule; - 陳聽溪 - 博客园 ip address （接口地址操作相关） ip -6 address add 2000:ff04::2&frasl;64 dev eth1.11 # 接口上添加地址 ip -6 address del">
<meta name="author" content=rinetd>
<meta name="publisher" content=rinetd@163.com>

<meta itemprop="name" content="Linux命令 route - 时光小栈">
<meta itemprop="description" content="iproute2;高级路由;ip_route,ip_rule; - 陳聽溪 - 博客园 ip address （接口地址操作相关） ip -6 address add 2000:ff04::2&frasl;64 dev eth1.11 # 接口上添加地址 ip -6 address del">
<meta itemprop="image" content="//blog.pytool.com/public/avatar.png">

<meta property="og:type" content="article" />
<meta property="og:title" content="Linux命令 route - 时光小栈" />
<meta property="og:description" content="iproute2;高级路由;ip_route,ip_rule; - 陳聽溪 - 博客园 ip address （接口地址操作相关） ip -6 address add 2000:ff04::2&frasl;64 dev eth1.11 # 接口上添加地址 ip -6 address del">
<meta property="og:image" content="//blog.pytool.com/public/avatar.png" />
<meta property="og:url" content="//blog.pytool.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2016-01-01-linux%E5%91%BD%E4%BB%A4-iproute2/" />

<meta name="baidu-site-verification" content="pCInWQYbNT" />


<script>document.documentElement.className = document.documentElement.className.replace("no-js", "js");</script>
<link rel="canonical" href="//blog.pytool.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2016-01-01-linux%E5%91%BD%E4%BB%A4-iproute2/">
<link rel='shortlink' href="//blog.pytool.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2016-01-01-linux%E5%91%BD%E4%BB%A4-iproute2/"/>
<link rel="shortcut icon" href="//blog.pytool.com/public/favicon.ico"/>

<link rel="stylesheet" id="human-style-css" href="//blog.pytool.com/wp-content/themes/hueman/style.css" type="text/css" media="all"/>
<link rel="stylesheet" id="human-style-css1" href="//blog.pytool.com/wp-content/themes/hueman/custom.css" type="text/css" media="all"/>
<link rel="stylesheet" id="human-style-css2" href="//blog.pytool.com/wp-content/themes/hueman-child/style.css" type="text/css" media="all"/>
<link rel="stylesheet" id="responsive-css" href="//blog.pytool.com/wp-content/themes/hueman/responsive.css" type="text/css" media="all"/>
<link rel="stylesheet" id="font-awesome-css" href="//blog.pytool.com/wp-content/themes/hueman/fonts/font-awesome.min.css" type="text/css" media="all"/>

<link rel="stylesheet" href="//blog.pytool.com/public/highlight/styles/github.css">
<link rel="stylesheet" id="human-style-css3" href="//blog.pytool.com/wp-content/themes/hueman-child/user.css" type="text/css" media="all"/>
<link rel="stylesheet" href="//blog.pytool.com/public/font/hack/css/hack.min.css">

</head>


<body class="single single-post single-format-standard col-3cm full-width topbar-enabled chrome">
<div id="wrapper">
  <header id="header">

  <nav class="nav-container group" id="nav-topbar">
    <div class="nav-toggle"><i class="fa fa-bars"></i></div>
    <div class="nav-text"></div>
    <div class="nav-wrap container">
      <a rel="nofollow" href="//blog.pytool.com/" class="nav-cs-icon">
        <img width="40" height="40" src="//blog.pytool.com/public/avatar.png" alt="rinetd" title="Home">
      </a>
      <ul id="menu-default-menu" class="nav container-inner group">
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a rel="nofollow" href="//blog.pytool.com/">首页</a>
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/linux%e5%9f%ba%e7%a1%80/">Linux基础</a>
          
        </li>
        
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e5%a5%87%e7%9c%9f%e5%bc%82%e5%ae%9d/">奇真异宝</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e5%b5%8c%e5%85%a5%e5%bc%8f%e5%bc%80%e5%8f%91/">嵌入式开发</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4/">常用命令</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e5%b8%b8%e7%94%a8%e5%b7%a5%e5%85%b7/">常用工具</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e6%96%87%e6%9c%ac%e7%bc%96%e8%be%91%e5%99%a8/">文本编辑器</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e7%a8%8b%e5%ba%8f%e5%91%98/">程序员</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e7%bc%96%e7%a8%8b%e5%9f%ba%e7%a1%80/">编程基础</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e8%bd%ac%e8%bd%bd/">转载</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e9%9d%99%e6%80%81%e5%8d%9a%e5%ae%a2/">静态博客</a>
          
        </li>
        
          
          <li class="menu-item menu-item-type-post_type menu-item-object-page">
            <a rel="nofollow" href="//blog.pytool.com/%e9%bb%91%e5%ae%a2%e6%8a%80%e6%9c%af/">黑客技术</a>
          
        </li>
        
        
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a rel="nofollow" href="//blog.pytool.com/post/">归档</a>
        </li>
        
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a rel="nofollow" href="//blog.pytool.com/about/">关于我</a>
        </li>
        
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a rel="nofollow" href="" type="application/rss+xml" target="_blank">订阅</a>
        </li>
        <li class="menu-item menu-item-type-post_type menu-item-text">
        
        </li>
      </ul>

    </div>

    <div class="container">
      <div class="container-inner">
        <div class="toggle-search"><i class="fa fa-search"></i></div>
        <div class="search-expand">
          <div class="search-expand-inner">
            <form method="get" class="searchform themeform" action="https://www.google.com/search">
              <div>
                <input type="text" class="search" name="q" placeholder="Press enter to start searching">
              </div>
            </form>
          </div>
        </div>
      </div>
      
    </div>
    

  </nav>
  

  <div class="container group">
    <div class="container-inner">
      <div class="group pad">
        <div class="group pad">
          <h1 class="site-title">
            <a rel="nofollow" href="//blog.pytool.com/" rel="home">
              
              
            </a>
          </h1>
          <p class="site-description"> 如果你没有感觉到时间不够用时，你多半正在虚度光阴。 </p>
        </div>

      </div>
    </div>
    
  </div>
  

</header>



  <div class="container" id="page">
    <div class="container-inner">
      <div class="main">
        <div class="main-inner group">
          <section class="content">
            <div class="page-title pad group">
              <ul class="meta-single group">
                
                <li class="category">
                  <a href="//blog.pytool.com/categories/linux%E5%91%BD%E4%BB%A4/" rel="category tag">Linux命令</a>
                </li>
                
              </ul>
            </div>

            <div class="pad group">

              <article
                  class="post type-post status-publish format-standard has-post-thumbnail hentry category-australien tag-bondi-beach tag-city2surf tag-sydney">
                <div class="post-inner group">

                  <h1 class="post-title">Linux命令 route</h1>

                  <p class="post-byline">
                    by  · 2016年01月06日 16:46:14 · 52951 Words ·
                    ~106min reading time |
                    
                    <a href="https://coding.net/u/rinetd/p/blog/git/edit/master/content/%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4/2016-01-01%20Linux%e5%91%bd%e4%bb%a4%20iproute2.md" target="_blank">Improve on <i class="fa fa-github"></i></a>
                  </p>

                  <div class="clear"></div>

                  <div class="entry">
                    <div class="entry-inner">
                      
                      

<p><a href="http://www.cnblogs.com/taosim/articles/4444887.html">iproute2;高级路由;ip_route,ip_rule; - 陳聽溪 - 博客园</a></p>

<p>ip address （接口地址操作相关）</p>

<p>ip -6 address add 2000:ff04::<sup>2</sup>&frasl;<sub>64</sub> dev eth1.11       # 接口上添加地址
ip -6 address del 2000:ff04::<sup>2</sup>&frasl;<sub>64</sub> dev eth1.11       # 删除接口上指定地址
ip -6 address flush dev eth1.11                     # 删除接口上所有地址
ip -6 address show <interface name>                 # 查看接口 ipv6 地址
ip address show <interface name>                    # 查看接口 IP 地址，包括 <sup>4</sup>&frasl;<sub>6</sub> 2个版本的
ip address add 192.168.1.1 broadcast +              # 设置接口地址和广播地址，+ 表示让系统自动计算
ip address add 192.68.1.1 dev eth1 label eth1.1     # 设置接口别名，注意别和 ip link set &hellip; name 命令混淆
ip address add 192.68.1.1 dev eth1 scope global     # 设置接口领域，也就是可以接受的包的范围，有下面几种：
                                                    #   global  允许所有
                                                    #   site    仅允许 ipv6 和本机连接
                                                    #   link    仅允许本机连接
                                                    #   host    仅允许内部连接（和 link 的区别还不确定有哪些）
ip route 命令组 （路由表相关）</p>

<p>ip -6 route add 2000:ff::/80 via 2000:ff04::1 dev eth1.11   # 添加一条路由
ip -6 route add default via 2000:ff04::1 dev eth1.11        # 添加默认路由
ip -6 route show                                            # 查看完整路由表
ip -6 route show dev eth1.11                                # 查看指定接口路由项
ip -6 route del 2000:ff04::/64                              # 删除所有相关路由表
ip -6 route del 2000:ff04::/64 dev eth1.11                  # 删除相关接口上的路由表
ip -6 route change 2000:ff04::/64 dev eth1.12               # 修改路由表项
ip route add nat 192.168.10.100 via 202.6.10.1              # 添加 NAT 路由项，将 192 地址转换成 202 地址
ip route replace default equalize nexthop via 211.139.218.145 dev eth0 weight 1 nexthop via 211.139.218.145 dev eth1 weight 1   # 添加负载均衡路由
ip neighbor 命令组 （ARP地址表相关）</p>

<p>ip neighbor show                                                # 查看 ARP 表
ip neighbor add 10.1.1.1 lladdr 0:0:0:0:0:1 dev eth0 nud permit # 添加一条 ARP 相关表项
ip neighbor change 10.1.1.1 dev eth0 nud reachable              # 修改相关表项
ip neighbor del 10.1.1.1 dev eth0                               # 删除一条表项
ip neighbor flush                                               # 清除整个 ARP 表
ip link set 命令组 （接口硬件操作相关）</p>

<p>ip -s -s link show                                  # 显示所有接口详细信息
ip -s -s link show eth1.11                          # 显示单独接口信息
ip link set dev eth1 up                             # 启动设备，相当于 ifconfig eth1 up
ip link set dev eth1 down                           # 停止设备，相当于 ifconfig eth1 down
ip link set dev eth1 txqueuelen 100                 # 改变设备传输队列长度
ip link set dev eth1 mtu 1200                       # 改变 MTU 长度
ip link set dev eth1 address 00:00:00:AA:BB:CC      # 改变 MAC 地址
ip link set dev eth1 name myeth                     # 接口名变更</p>

<p>添加一条网关路由
route add -net 192.168.0.0/24 gw 10.0.0.253 dev eth1
################################################################################
ip addr
#设置和删除 ip地址
ip addr show enp3s0                             # 查看指定网卡
ip addr flush enp3s0                            # 清空配置
sudo ip addr add 192.168.0.<sup>100</sup>&frasl;<sub>24</sub> dev enp3s0    # 添加ip地址
sudo ip addr del 192.168.0.<sup>193</sup>&frasl;<sub>24</sub> dev enp3s0    # 删除 ip地址
sudo ip link set enp3s0 up                      # 启动
sudo ip link set enp3s0 down                    # 停止</p>

<p>#路由
route
netstat -rn
ip route list # 显示核心路由表
ip route show
假设现在你有一个IP地址，你需要知道路由包从哪里来,列出了路由所使用的接口
ip route get 10.42.0.47
要更改默认路由
sudo ip route add default via 192.168.0.196 $gateway
配置一条路由: 发到 10.0.0.0/24 的数据包通过 192.168.0.19 (gw)转发
ip route add 10.0.0.0/24 via 192.168.0.19
#ARP
ip neighbour
ip neigh list # 显示邻居表
#监控netlink消息
sudo ip monitor all</p>

<h1 id="重启网卡">重启网卡</h1>

<ol>
<li><p>sudo service network-manager restart</p></li>

<li><p>/etc/init.d/network restart
3.
ifdown eth0
ifup eth0
4.
ifconfig eth0 down
ifconfig eth0 up</p></li>
</ol>

<h1 id="linux-网桥配置命令-brctl">&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; Linux 网桥配置命令:brctl</h1>

<h2 id="首先-我们先增加一个网桥lxcbr0-模仿docker0">首先，我们先增加一个网桥lxcbr0，模仿docker0</h2>

<p>brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.<sup>1</sup>&frasl;<sub>24</sub> up #为网桥设置IP地址</p>

<h2 id="接下来-我们要创建一个network-namespace-ns1">接下来，我们要创建一个network namespace - ns1</h2>

<h1 id="增加一个namesapce-命令为-ns1-使用ip-netns-add命令">增加一个namesapce 命令为 ns1 （使用ip netns add命令）</h1>

<p>ip netns add ns1</p>

<h1 id="激活namespace中的loopback-即127-0-0-1-使用ip-netns-exec-ns1来操作ns1中的命令">激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</h1>

<p>ip netns exec ns1   ip link set dev lo up</p>

<h2 id="然后-我们需要增加一对虚拟网卡">然后，我们需要增加一对虚拟网卡</h2>

<h1 id="增加一个pair虚拟网卡-注意其中的veth类型-其中一个网卡要按进容器中">增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</h1>

<p>ip link add veth-ns1 type veth peer name lxcbr0.1</p>

<h1 id="把-veth-ns1-按到namespace-ns1中-这样容器中就会有一个新的网卡了">把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</h1>

<p>ip link set veth-ns1 netns ns1</p>

<h1 id="把容器里的-veth-ns1改名为-eth0-容器外会冲突-容器内就不会了">把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</h1>

<p>ip netns exec ns1  ip link set dev veth-ns1 name eth0</p>

<h1 id="为容器中的网卡分配一个ip地址-并激活它">为容器中的网卡分配一个IP地址，并激活它</h1>

<p>ip netns exec ns1 ifconfig eth0 192.168.10.<sup>11</sup>&frasl;<sub>24</sub> up</p>

<h1 id="上面我们把veth-ns1这个网卡按到了容器中-然后我们要把lxcbr0-1添加上网桥上">上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</h1>

<p>brctl addif lxcbr0 lxcbr0.1</p>

<h1 id="为容器增加一个路由规则-让容器可以访问外面的网络">为容器增加一个路由规则，让容器可以访问外面的网络</h1>

<p>ip netns exec ns1     ip route add default via 192.168.10.1</p>

<h1 id="在-etc-netns下创建network-namespce名称为ns1的目录">在/etc/netns下创建network namespce名称为ns1的目录，</h1>

<h1 id="然后为这个namespace设置resolv-conf-这样-容器内就可以访问域名了">然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</h1>

<p>mkdir -p /etc/netns/ns1
echo &ldquo;nameserver 8.8.8.8&rdquo; &gt; /etc/netns/ns1/resolv.conf</p>

<p>####### 静态路由表</p>

<h1 id="linux下静态路由修改命令route">linux下静态路由修改命令route:</h1>

<p>add 增加路由
del 删除路由
-net 设置到某个网段的路由
-host 设置到某台主机的路由
gw 出口网关 IP地址
dev 出口网关 物理设备名</p>

<p>增加默认路由
route add default gw 192.168.0.1</p>

<p>查看路由表
route -n
netstat -rn</p>

<p>方法一：
添加路由
route add -net 192.168.0.0/24 gw 192.168.0.1
route add -host 192.168.1.1 dev 192.168.0.1
删除路由
route del -net 192.168.0.0/24 gw 192.168.0.1</p>

<p>方法二：
添加路由
ip route add 192.168.0.0/24 via 192.168.0.1
ip route add 192.168.1.1 dev 192.168.0.1
删除路由
ip route del 192.168.0.0/24 via 192.168.0.1</p>

<p>add 增加路由
del 删除路由
via 网关出口 IP地址
dev 网关出口 物理设备名</p>

<p>增加默认路由
ip route add default via 192.168.0.1 dev eth0
via 192.168.0.1 是我的默认路由器</p>

<p>查看路由信息</p>

<h2 id="ip-route">ip route</h2>

<p>保存路由设置，使其在网络重启后任然有效
在/etc/sysconfig/network-script/目录下创建名为route- eth0的文件
vi /etc/sysconfig/network-script/route-eth0
在此文件添加如下格式的内容</p>

<p>192.168.1.0/24 via 192.168.0.1</p>

<p>重启网络验证</p>

<p>/etc/rc.d/init.d/network中有这么几行：</p>

<h1 id="add-non-interface-specific-static-routes">Add non interface-specific static-routes.</h1>

<p>if [ -f /etc/sysconfig/static-routes ]; then
grep &ldquo;^any&rdquo; /etc/sysconfig/static-routes | while read ignore args ; do
/sbin/route add -$args
done
fi</p>

<p>也就是说，将静态路由加到/etc/sysconfig/static-routes 文件中就行了。</p>

<p>如加入：
route add -net 11.1.1.0 netmask 255.255.255.0 gw 11.1.1.1</p>

<p>则static-routes的格式为
any net 11.1.1.0 netmask 255.255.255.0 gw 11.1.1.1</p>

<p>iproute2 对决 net-tools</p>

<p>2014-11-27 21:04| 查看: 1943| 评论: 12| 收藏: 4| 分享: 24</p>

<p>原文：<a href="http://xmodulo.com/2014/09/linux-tcpip-networking-net-tools-iproute2.html作者：">http://xmodulo.com/2014/09/linux-tcpip-networking-net-tools-iproute2.html作者：</a> Dan Nanni
译文：LCTT  <a href="http://linux.cn/article-4326-1.html译者：">http://linux.cn/article-4326-1.html译者：</a> KayGuoWhu</p>

<p>如今很多系统管理员依然通过组合使用诸如ifconfig、route、arp和netstat等命令行工具（统称为net-tools）来配置网络功能，解决网络故障。net-tools起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持iproute2。</p>

<p>作为网络配置工具的一份子，iproute2的出现旨在从功能上取代net-tools。net-tools通过procfs(/proc)和ioctl系统调用去访问和改变内核网络配置，而iproute2则通过netlink套接字接口与内核通讯。抛开性能而言，iproute2的用户接口比net-tools显得更加直观。比如，各种网络资源（如link、IP地址、路由和隧道等）均使用合适的对象抽象去定义，使得用户可使用一致的语法去管理不同的对象。更重要的是，到目前为止，iproute2仍处在持续开发中。</p>

<p>如果你仍在使用net-tools，而且尤其需要跟上新版Linux内核中的最新最重要的网络特性的话，那么是时候转到iproute2的阵营了。原因就在于使用iproute2可以做很多net-tools无法做到的事情。</p>

<p>对于那些想要转到使用iproute2的用户，有必要了解下面有关net-tools和iproute2的众多对比。</p>

<p>显示所有已连接的网络接口</p>

<p>下面的命令显示出所有可用网络接口的列表（无论接口是否激活）。</p>

<p>使用net-tools：</p>

<pre><code>$ ifconfig -a
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ ip link show
</code></pre>

<p>激活或停用网络接口</p>

<p>使用这些命令来激活或停用某个指定的网络接口。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo ifconfig eth1 up
$ sudo ifconfig eth1 down
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip link set down eth1
$ sudo ip link set up eth1
</code></pre>

<p>为网络接口分配IPv4地址</p>

<p>使用这些命令配置网络接口的IPv4地址。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo ifconfig eth1 10.0.0.1/24
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip addr add 10.0.0.1/24 dev eth1
</code></pre>

<p>值得注意的是，可以使用iproute2给同一个接口分配多个IP地址，ifconfig则无法这么做。使用ifconfig的变通方案是使用IP别名。</p>

<pre><code>$ sudo ip addr add 10.0.0.1/24 broadcast 10.0.0.255 dev eth1
$ sudo ip addr add 10.0.0.2/24 broadcast 10.0.0.255 dev eth1
$ sudo ip addr add 10.0.0.3/24 broadcast 10.0.0.255 dev eth1
</code></pre>

<p>移除网络接口的IPv4地址</p>

<p>就IP地址的移除而言，除了给接口分配全0地址外，net-tools没有提供任何合适的方法来移除网络接口的IPv4地址。相反，iproute2则能很好地完全。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo ifconfig eth1 0
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip addr del 10.0.0.1/24 dev eth1
</code></pre>

<p>显示网络接口的IPv4地址</p>

<p>按照如下操作可查看某个指定网络接口的IPv4地址。</p>

<p>使用net-tools：</p>

<pre><code>$ ifconfig eth1
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ ip addr show dev eth1
</code></pre>

<p>同样，如果接口分配了多个IP地址，iproute2会显示出所有地址，而net-tools只能显示一个IP地址。</p>

<p>为网络接口分配IPv6地址</p>

<p>使用这些命令为网络接口添加IPv6地址。net-tools和iproute2都允许用户为一个接口添加多个IPv6地址。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo ifconfig eth1 inet6 add 2002:0db5:0:f102::1/64
$ sudo ifconfig eth1 inet6 add 2003:0db5:0:f102::1/64
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip -6 addr add 2002:0db5:0:f102::1/64 dev eth1
$ sudo ip -6 addr add 2003:0db5:0:f102::1/64 dev eth1
</code></pre>

<p>显示网络接口的IPv6地址</p>

<p>按照如下操作可显示某个指定网络接口的IPv6地址。net-tools和iproute2都可以显示出所有已分配的IPv6地址。</p>

<p>使用net-tools：</p>

<pre><code>$ ifconfig eth1
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ ip -6 addr show dev eth1
</code></pre>

<p>移除网络设备的IPv6地址</p>

<p>使用这些命令可移除接口中不必要的IPv6地址。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo ifconfig eth1 inet6 del 2002:0db5:0:f102::1/64
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip -6 addr del 2002:0db5:0:f102::1/64 dev eth1
</code></pre>

<p>改变网络接口的MAC地址</p>

<p>使用下面的命令可篡改网络接口的MAC地址，请注意在更改MAC地址前，需要停用接口。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo ifconfig eth1 hw ether 08:00:27:75:2a:66
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip link set dev eth1 address 08:00:27:75:2a:67
</code></pre>

<p>查看IP路由表</p>

<p>net-tools中有两个选择来显示内核的IP路由表：route和netstat。在iproute2中，使用命令ip route。</p>

<p>使用net-tools：</p>

<pre><code>$ route -n

$ netstat -rn
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ ip route show
</code></pre>

<p>添加和修改默认路由</p>

<p>这里的命令用来添加或修改内核IP路由表中的默认路由规则。请注意在net-tools中可通过添加新的默认路由、删除旧的默认路由来实现修改默认路由。在iproute2使用ip route命令来代替。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo route add default gw 192.168.1.2 eth0
$ sudo route del default gw 192.168.1.1 eth0
</code></pre>

<p>使用iproute2:</p>

<pre><code>$ sudo ip route add default via 192.168.1.2 dev eth0
$ sudo ip route replace default via 192.168.1.2 dev eth0
</code></pre>

<p>添加和移除静态路由</p>

<p>使用下面命令添加或移除一个静态路由。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo route add -net 172.16.32.0/24 gw 192.168.1.1 dev eth0
$ sudo route del -net 172.16.32.0/24
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip route add 172.16.32.0/24 via 192.168.1.1 dev eth0
$ sudo ip route del 172.16.32.0/24
</code></pre>

<p>查看套接字统计信息</p>

<p>这里的命令用来查看套接字统计信息（比如活跃或监听状态的TCP/UDP套接字）。</p>

<p>使用net-tools：</p>

<pre><code>$ netstat
$ netstat -l
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ ss
$ ss -l
</code></pre>

<p>查看ARP表</p>

<p>使用这些命令显示内核的ARP表。</p>

<p>使用net-tools:</p>

<pre><code>$ arp -an
</code></pre>

<p>使用iproute2:</p>

<pre><code>$ ip neigh
</code></pre>

<p>添加或删除静态ARP项</p>

<p>按照如下操作在本地ARP表中添加或删除一个静态ARP项。</p>

<p>使用net-tools：</p>

<pre><code>$ sudo arp -s 192.168.1.100 00:0c:29:c0:5a:ef
$ sudo arp -d 192.168.1.100
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip neigh add 192.168.1.100 lladdr 00:0c:29:c0:5a:ef dev eth0
$ sudo ip neigh del 192.168.1.100 dev eth0
</code></pre>

<p>添加、删除或查看多播地址</p>

<p>使用下面的命令配置或查看网络接口上的多播地址。</p>

<p>使用net-tools:</p>

<pre><code>$ sudo ipmaddr add 33:44:00:00:00:01 dev eth0
$ sudo ipmaddr del 33:44:00:00:00:01 dev eth0
$ ipmaddr show dev eth0
$ netstat -g
</code></pre>

<p>使用iproute2：</p>

<pre><code>$ sudo ip maddr add 33:44:00:00:00:01 dev eth0
$ sudo ip maddr del 33:44:00:00:00:01 dev eth0
$ ip maddr list dev eth0
</code></pre>

<p>via: <a href="http://xmodulo.com/2014/09/linux-tcpip-networking-net-tools-iproute2.html">http://xmodulo.com/2014/09/linux-tcpip-networking-net-tools-iproute2.html</a></p>

<p>作者：Dan Nanni 译者：KayGuoWhu 校对：wxy</p>

<p>本文由 LCTT 原创翻译，Linux中国 荣誉推出</p>

<p>原文：<a href="http://xmodulo.com/2014/09/linux-tcpip-networking-net-tools-iproute2.html作者：">http://xmodulo.com/2014/09/linux-tcpip-networking-net-tools-iproute2.html作者：</a> Dan Nanni
译文：LCTT  <a href="http://linux.cn/article-4326-1.html译者：">http://linux.cn/article-4326-1.html译者：</a> KayGuoWhu</p>

<p>本文由 LCTT 原创翻译，Linux中国首发。也想加入译者行列，为开源做一些自己的贡献么？欢迎加入 LCTT！
翻译工作和译文发表仅用于学习和交流目的，翻译工作遵照CC 协议规定，如果我们的工作有侵犯到您的权益，请及时联系我们。
欢迎遵照CC 协议规定转载，敬请在正文中标注并保留原文/译文链接和作者/译者等信息。
文章仅代表作者的知识和看法，如有不同观点，请楼下排队吐槽 :D</p>

<p><a href="http://www.txdy8.com/linux-%E9%AB%98%E7%BA%A7%E8%B7%AF%E7%94%B1/">http://www.txdy8.com/linux-%E9%AB%98%E7%BA%A7%E8%B7%AF%E7%94%B1/</a>
linux 高级路由
2014年07月13日 ⁄ Linux ⁄ 共 11389字 ⁄ 字号 小 中 大 ⁄ 暂无评论 ⁄ 阅读 366 views 次</p>

<ol>
<li>什么是高级路由？
是把信息从源穿过网络到达目的地的行为. 有两个动作：确定最佳路径，传输信息
确定最佳路径：手工指定，自动学习。
传输信息：隧道传输，流量整形
高级路由（策略路由）是根据一定的需要定下一些策略为依据。
rpdb(routing policy data base)通过一定的规则进行路由</li>
</ol>

<p>2.什么是多路由表及规则？
 （1） 多路由表用来等待匹配，默认有四张路由表
 255 是本地路由表
 254 主路由表 没有指明表所属位置 都放在这里
 253 默认路由表
 0 系统保留的表
（2）规则
 rpdb可以匹配数据包的源地址 目的地址 进入接口
 每一个路由
 动作 选择下一跳地址， 产生通讯时被</p>

<p>3.ip
 ip link show 显示所有的网络设备
 ip address show
 ip route show table 255 显示指定编号的表
 ip rule 定义规则
 ip rule add from 192.168.2.1／32 table 1 从192.168.2.1的包按照1的表进行匹配
 ip rule show 显示规则
 ip rule add from 192.168.2.1／24 pref 1000 prohibit 从192.168.2.1的包返回不可达
 ip rule del pref 32764 删除规则
 ip route add 192.168.2.0／24 via 202.96.156.111 table 1 访问外网
例如
 ip rule add 192.168.2.1 table 1 pref 1000
 ip rule add 192.168.2.2 table 1 pref 1005
 ip rule add 192.168.2.3 table 1 pref 1010
 ip rule add 192.168.2.0/24 table 2 pref 1015
 ip route add 192.168.2.0/24 via 2M table 1
 ip route add 192.168.2.0/24 via 1M table 2</p>

<p>ip route add default via 192.168.1.1 table 2 proto statc 设置默认网关 （ip route flush cache 刷新表1的缓存）
 ip route flush table 1 清空表
负载均衡
 1M 2M
 ip route add default scope global nexthop via ip1 dev eth0 weight 1 nexthop via ip2 dev eth1 weight 1
 第一跳eth0 第二跳eth1 第三跳 eth0 。。。。。。。。
 ip route add default scope global nexthop via ip1 dev eth0 weight 2 nexthop via ip2 dev eth1 weight 1
 第一跳eth0分2／3 第二条eth1 1／3
 实验
 有三种人老板 美眉 我 员工</p>

<p>4.IP 隧道 （ip-ip）
 一层 ip－ip
 二层 GRE
 三层 ipsec ｛加密（ESP），认证（AH），协商（IKE）｝
 隧道模式 主机包头－－AH－－ESP－－数据
 传输模式 安全网关头部－－AH－－ESP－－主机头｜数据 （VPN）
 NtoN 虚拟处于一个局域网中</p>

<p>解释
1.qdisc 队列
2.pfifo_fast (先进先出)有3个频道
 priomap:
3.（1）令牌桶过滤器 （tbf）
 数据流＝令牌流 无延迟的通过队列
 数据流&lt;令牌流 消耗一部分令牌 剩下的在桶里积累，直到桶被填满，剩下的会在令牌&gt;数据的时候消耗掉
 数据流&gt;令牌流 导致tbf中断一断时间 发生丢包现象
 （2）使用
 limit/latency 最多有多少数据在队列中等待可用的令牌／确定了一个包在tbf中等待传输的最长等待时间
 burst／buffer／maxburst 桶的大小 （字节） 10M bit/s的速率－－－10k字节
 mpu 令牌的最低消耗 （0长度的包需要消耗64字节的带宽）
 rate 速度操纵
4.实验
 tc qdisc add dev eth0 root tbf rate 220kbit latency 50ms burst 1540
 将网卡设备eth0加入队列中，以root为根的令牌桶，数据不超过220k速率通过，当数据包等待50ms没有拿到令牌 则丢弃，定义桶的大小为1540字节
5.随机公平队列 （sfq）
 解释：将流量分为相当多的FIFO队列中 每个队列对应一个会话数据按照简单轮转方式发送，每个会话都按顺序得到发送机会
 解决问题：网络阻塞
 参数：1.perturb 多少秒重新配置一次散列算法，一般为10m
 2.quantum 一个流要传输多少字节后才切换到下个队列 一般设为一个包的最大长度
6.tc qdisc add dev ppp0 root sfq perturb 10
7.队列的选取
 降低出口速率 令牌桶过滤器
 链路已经塞满，想保证不会有某一个会话独占出口带宽， 使用随机公平队列
 有一个很大的骨干带宽， 随机丢包
 希望对入口流量整形 入口流量整形
8.分类的队列规定 cbq</p>

<p>实验
 要求：总体的网络布局，有三种人 学生 教师 教职员工，
1.学生：每栋宿舍分10m带宽 需要流量整形，学生不和教职员工的网络连接，不可以访问外部网络，可以访问学校内部的FTP 和视频点播服务器
2.教师：共享10m带宽，教师的网络和教职员工的网络连通 可以访问学校的FTP 视频点播 web服务器
3.教职员工：共享1 0m带宽，可以访问学校内部的web服务器 不能访问FTP 和视频点播
服务器：web服务器用来提供erp 有一个站点 用来提供资料下载，ftp服务器 保存各种视频资料，视频课件 ，视频点播服务器：提供教师学生视频 娱乐 外部的web服务器。学校的主站 学校内部有四个网络机房，平时上课用来做实验 晚上用来上网，四个机房共享100m带宽。网络安全，外部不能访问内部的视频 ftp服务器。注意防止改变ip地址获得其他角色的服务。希望有一套机制监控全校的网络使用状况</p>

<p>~new~ppp的包
rp-pppoe-3.5-32.1
ppp-2.4.4-1.el5
/etc/ppp/pppoe-server-options (options)
验证方式
pap pap-secrets（不可用）
chap chap-secrets
 man pppd
vim pppoe-server-options</p>

<h1 id="ppp-options-for-the-pppoe-server">PPP options for the PPPoE server</h1>

<h1 id="lic-gpl">LIC: GPL</h1>

<p>require-chap
login
lcp-echo-interval 10
lcp-echo-failure 2
ms-dns 192.168.0.22 给客户端
logfile /var/log/pppoe.log</p>

<p>vim chap-secrets</p>

<h1 id="secrets-for-authentication-using-chap">Secrets for authentication using CHAP</h1>

<h1 id="client-server-secret-ip-addresses">client server secret IP addresses</h1>

<p>####### redhat-config-network will overwrite this part!!! (begin) ##########
joker * 123456 *
tom * 123456 *
jerry * 123456 *
shrek * 123456 *
####### redhat-config-network will overwrite this part!!! (end) ############</p>

<p>uname -r rhel5 u1 u2
service syslog stop 有bug,u3没有bug
pppoe-service -I eth0 -L 172.16.0.1 -R 10.0.0.1 -N 100
 服务器地址 客户端地址池
客户端adsl-setup
adsl-start
adsl-stop</p>

<p>tc 流量控制 sfq tbf</p>

<p>CLASSFUL QDISCS
HTB 分层令牌桶
PRIO tc class ls dev eth0
tc qd add dev eth0 root prio
tc qd add dev eth0 parent 8016:1 tbf rate 10kbit limit 5k burst 5k
tc qd add dev eth0 parent 8016:2 sfq
tc qd add dev eth0 parent 8016:3 sfq</p>

<p>tc qd ls
qdisc pfifo_fast 0: dev eth1 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1</p>

<p>tc qd add dev eth0 root sfq
tc qd del dev eth0 root sfq
tc qd add dev eth0 root pfifo
tc qd add dev eth0 root tbf rate 256kbit limit 10k burst 10k
tc qd add dev eth0 root handle 1: tbf rate 256kbit limit 10k burst 10k
1:0 1:2 &hellip;&hellip;
高级路由
pppoe点到点协议
利用pppoe可防止arp欺骗
adsl-setup这是拨号上网的命令
radius的记帐服务器 AAA协议
安装包：
rpm -ivh pp-2.4.4&hellip;.
 rp-pppoe-3.5-32.1
cd /etc/ppp
vim pppoe-servar
身份验证方式：
chap-secrets
pap-secrets不能用</p>

<h2 id="修改">修改</h2>

<p>require-chap
login
lcp-echo-interval 10密码身份验证
lcp-echo-railure 2
以下为添加：
ms-dns 192.168.0.254此处为dns地址</p>

<h2 id="logfile-var-log-pppo-log日志路径">logfile /var/log/pppo.log日志路径</h2>

<p>man pppd
查看可添加的配置参数
－－－－－－－－－－－－－－－－－
创建帐户和密码
vim chap-secrets
zorro * 123456（密码明文） *(可分配的ip，要在地址段内）
－－－－－－－－－－－－－－－－
查版本：
uname -r
rhel5 u1 u2之间是冲突的</p>

<h2 id="service-syslog-stop-关闭日志-这是必需的">service syslog stop 关闭日志：这是必需的</h2>

<p>设置网卡监听
pppoe-server -I eht0 -L(指定虚ip.登录后可见到的ip）172.16.0.1－R（分给客户端的ip）10.0.0.1－N 100(个数是100个）
－－－－－－－－－－－－－－－－－－－－－－
客户端拨号
adsl-setup
1eth0(哪个网卡连接的就用哪个网卡建）
2name：aorro
3网卡：eth0
4dns：
5passwd:
6是否允许一般用户启动：
7防火墙规则：0
9是否保存设置：
－－－－－－－－－
启动拨号：
adsl-start
中断拨号：</p>

<h2 id="adsl-stop">adsl-stop</h2>

<p>客户间通信是要通过服务器的＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
－－－－－－－－－－－－－－－－－－－
查看日志：
tail -f /var/log/pppoe.log
记录登录目录
服务器设置的用户名才能能真正登录的
－－－－－－－－－－－－－－－－－－－－－－－
设置记帐：
时间记帐：的对话叫：aaloth-up；实际的ip连接：ip-up;退出过程：aloth-down;(这个时间是记帐的最好时间）
数据包量查看：（流量记帐）
netstat -i
－－－－－－－－－－－－
为记帐建立脚本：
vim /auth-up
#!/bin/bash
export LANG=C</p>

<p>echo $PEERNAME login at &lsquo;date&rsquo; &gt;&gt; /tmp/pppd-login.log这是帐户登录的时间
－－－－－
vim /auth-down
#!/bin/bash
LANG=C</p>

<h2 id="echo-peername-logout-in-date-tmp-pppd-loging-log这是帐户登出的时间">echo $PEERNAME logout in &lsquo;date&rsquo; &gt;&gt; /tmp/pppd-loging.log这是帐户登出的时间</h2>

<p>kilkall -9</p>

<h2 id="cat-tmp-pppd-login-log">cat /tmp/pppd-login.log</h2>

<p>怎样限制客户端的速度：客户端下行速度，在服务器端限制是上行速度。
tc命令：
网卡：
tc
ssh 10.0.0.93
服务器端限制上行速度：
tc qdisc add dev ppp1 root tbf rate 256kbit limit 10k burst 10k 这是对ppp1的上行速度做的限制
重启服务：
service httpd restart</p>

<h2 id="去掉限速-add-del">去掉限速：add＞＞del</h2>

<p>自动设置限速：
vim /etc/ppp/ip-up
[ -x /etc/ppp/ip-up.local ] &amp;&amp; /etc/ppp/ip-up.local &ldquo;$@&ldquo;下面加入：
设置vip同帐户
if [ $PEERNAME = &ldquo; zorro&rdquo;]
then
 tc qdisc add dev $IFNAME root tbf rate 512kbit limit 10k burst 10k
 exit 0
fi
tc qdisc add dev $IFNAME root tbf rate 512kbit limit 10k burst 10k</p>

<p>查看：
tc qdisc list
kailkill -9 pppd</p>

<p>ip ad sh************************
－－－－－－－－－－－－－－－－－－－－－－－－－－－
tc交通控制：
OBJECT:1 qdisc:队列规则；队列的优先级依次排列，前面比后面的高［0.1.2共计16个，不同的位标记为不同的队列：一般服务排在中间队列。］。
2class：
3filter：
4action：
5monitor：
tc qd 显示当前所有队列规则：
qdisc pfifo_fast 0: dev eth0 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
0000：1 0001：20010：2 0011：2这个队列规则为pfifo_fast
man tc
两大类：
不可分类;CLASSLESS QDISCS
1 [p|b]fifo
2 pfifo_fast
3 red随机优先
4 sfq完全公平
5 tbf没有所谓的队列，相当只有一个队列，令牌总队列。
每一个会话连接称为：session 完全公平
默认是tc qd
tc qd add dev eth0 root sfq修改默认队列规则
tcqd del dev etho root sfq 删除队列规则
tc qd add dev eth0 root pfifo添加规则
tc qd add dev eth0 root tbf rate 256kbit （limit 10 ＜burst 10令牌总的参数＞） 附属参数［添加规则时必须加参数，不然会报错］
8015：此外为编号，可指定加
tc qd add dev eth0 root handle 1: (不加数字，默认为0）tbf rate 256kbit limit 10 burst 10
网卡上行限速 tbf
－－－－－－－－－－－－－－
分分类队列规则：
CBQ：在高端应用广，软件上做即时限速是不准确的。软件上不适用。
HTB：分层令牌总
PRIO:
tc qd add dev eth0 root prio区别是分类了
tc class ls dev eth0 查验，默认产生3个类，还是以tos值分。8016：1、2、3，各有不同的优先级，类下可再加队列规则：要指定具体父类
tc qd add dev eth0 parent 8016:1 tbf rate 10kbit limit 5k burst 5k
tc qd add dev eth0 parent 8016:2 sfq
tc qd add dev eth0 parent 8016:3 sfq
－－－－－－－－－－－－－－－－
人为方式指定，而不是tos值。
tc qd del dev etho root
tc qd add dev eth0 root handle 1:prio
tc cl ls dev eth0查看
tc qd add dev eth0 parent 1:1 tbf rate 256kbit burst 200k(字节）limit 10k
tc qd add dev eth0 parent 1:2 tbf rate 5mbit burst 3m limit 10k
tc qd add dev eth0 parent 1:3 tbf rate 1mbit burst 1mlimit 10k
tc qd add dev eth0 parent 1:protocol ip prio 1001 (优先级）u32(过滤器类型） match ip(报头）dst 192.168.0.120 flowid 1:1
tc qd add dev eth0 parent 1:protocol ip prio 1001 (优先级）u32(过滤器类型） match ip(报头）dst 192.168.0.128 flowid 1:2
tc qd add dev eth0 parent 1:protocol ip prio 1001 (优先级）u32(过滤器类型） match ip(报头）dst 192.168.0.0／24 flowid 1:3其他人共享1m带宽｛这就是分组处理｝这是ip限制。
环境：
10m带宽，scp ssh smtp http 规定流量:scp10k；http5m，无其他人时10m；smtp5m
man tc8</p>

<h2 id="pro实现">pro实现</h2>

<p>history
删除数字：</p>

<h2 id="1-s-tc-1-g">：1，＄s/^ &hellip;. <em>(tc.</em>$)/\1/g</h2>

<p>脚本1
vim
#!/bin/bash</p>

<p>wget <a href="http://192.168.0.254:/var/ftp/ki...">http://192.168.0.254:/var/ftp/ki...</a>.</p>

<p>＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
建立文件：
dd it=/dev/zer of=/varftp/bigfile
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
tc qd ls</p>

<p>查看路径：
man pppd
在SCRIPTS中可看到相应的参数提示</p>

<p>#双线路由切换</p>

<p>rpm -q iproute iproute-2.6.18-4.el5
ip address show dev eth0
ip ad sh dev eth1</p>

<p>[root@localhost ~]# ip
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }
 ip [ -force ] [-batch filename
where OBJECT := { link | addr | route | rule | neigh | ntable | tunnel |
 maddr | mroute | monitor | xfrm }
 OPTIONS := { -V[ersion] | -s[tatistics] | -r[esolve] |
 -f[amily] { inet | inet6 | ipx | dnet | link } |
 -o[neline] | -t[imestamp] }
ip link ,ip li sh,ip li help,
[root@localhost ~]# ip ad add dev eth1 192.168.5.<sup>3</sup>&frasl;<sub>24</sub>
[root@localhost ~]# ip ad sh dev eth1
[root@localhost ~]# ip ad del dev eth1 192.168.5.<sup>3</sup>&frasl;<sub>24</sub>
[root@localhost ~]# ip ne sh //看arp，
[root@localhost ~]# ip ne help
Usage: ip neigh { add | del | change | replace } { ADDR [ lladdr LLADDR ]
 [ nud { permanent | noarp | stale | reachable } ]
 | proxy ADDR } [ dev DEV ]
 ip neigh {show|flush} [ to PREFIX ] [ dev DEV ] [ nud STATE ]
[root@localhost ~]# ip route sh ,ip ro sh
ip ro add 10.0.0.<sup>1</sup>&frasl;<sub>32</sub> dev eth1 ,route add -host 10.0.0.1 dev eth1
ip ro del 10.0.0.<sup>1</sup>&frasl;<sub>32</sub> dev eth1
ip ro sh
ip ro add default dev eth0 via 192.168.0.1
ss -antp
*ip ro del default
ip ro default dev nexthop dev eth0 via 211.0.0.1 weight 10 nexthop dev eth1 via 123.112.0.1 weight 5
ip ro sh</p>

<p>如果通过服务器上网，服务器做的是默认路由。
vim root
#!/bin/bash
IFNAME1＝eth0
IFNAME2=ETH1
IP1=211.0.01
IP2=123.112.0.1</p>

<p>while :
do
 route del default
 route add default dev $IFNAME1 gw $IP1</p>

<p>while ping -c 1 211.0.0.1 &amp; /dev/null
 do
 sleep 1
 done</p>

<p>route del default
 route add default dev $IFNAME2 gw $IP2</p>

<p>until ping -c 1 211.0.0.1 &amp; /dev/null
 do
 sleep 1
 done
done</p>

<h2 id="这是互备的内容">这是互备的内容</h2>

<p>改变需求：两条线同时上网，
默认路由是支持一条路由的，不能同时支持二条
cd /usr/src/linux-2.6..
make menuconfig
IP：equal cost multipath选中
－－－－－－－－－－－－－－－－－－以上为填加高级路由必须操作的
 rpm -q iproute 这是支持高级路由的包
ifconfig
route -n
netstat
ip address show dev eth0显示eth0的网卡地址
ip ad sh dev eth0同上命令，这是简写命令
&mdash;&mdash;-一定要查看以上命令
ip 回车是命令参数
ip link只针对三层
ip ad 所有网卡显示
ip ad add dev eth0 192.168.1.254/24这是填加ip
ip ad sh dev etho这是立即生效的ipconfig是看不见的
ip ad del dev eth0 192.168.0.254/24这是删除
编辑ip ad sh dev eth0
显示链路层ip li</p>

<h2 id="ip-li-help帮助">ip li help帮助</h2>

<p>查看arp协议ip ne sh
相当于：arp －n
ip ne help帮助
ip rout sh 查看路由
ip ro sh同上
ip ro add 10.0.0.<sup>1</sup>&frasl;<sub>32</sub> dev eth1添加路由 发往ip的包由eth1发出
route add -host 10.0.0.1 dev eth1
ip ro del 10.0.0.<sup>1</sup>&frasl;<sub>32</sub> dev eth1
ip ro add 100.0.0/8 dev eth0
ip ro sh
ip ro del 10.0.0.0/8 dev eth0
ip ro del default
ip ro add default dev eth0 via 192.168.0.1
ip ro sh
ss -antp</p>

<h2 id="ip-ro-add-default-dev-eth0-via-192-168-0-1">ip ro add default dev eth0 via 192.168.0.1</h2>

<p>添加ecmp
ip ro del default
ip ro add default dev eth0 via 211.0.0.1这是加一个
加二个，后面加：
ip ro add default nexthop dev eth0 via 211.0.0.1 nexthop dev eth1 via 123.112.0.1注意参数
加权重：
ip ro add default nexthop dev eth0 via 211.0.0.1 weight 10 nexthop dev eth1 via 123.112.0.1 weight5
ip ro add default nexthop dev eth0 via 192.168.0.1 weight 10 nexthop dev eth1 via 192.168.1.2 weight 5
ip ro sh 这是查看
－－－－－－－－－－－－
ecmp支持的问题
脚本：
vim ar_ecmp.sh
#!/bin/bash</p>

<p>IFNAME=eth0
IPNAME=eth1
IFNAME=eth2
#&hellip;&hellip;..
#IFNAME=ethn</p>

<p>IP1＝192.168.1.1
IP2＝192.168.1.2
IP3＝192.168.1.3
#&hellip;&hellip;.
#IPn=xxx.xxx.xxx.xxx</p>

<p>ip ro del default
ip ro add default nexthop dev $IFNAME1 via $IP1 seight 1 <br />
 nexthop dev $IFNAME2 via $IP2 seight 1 <br />
 nexthop dev $IFNAME3 via $IP3 seight 1 #</p>

<h1 id="toc_34">&hellip;&hellip;.</h1>

<p>&mdash;&mdash;&mdash;&mdash;-以上为ecmp
高级路由：
部分上网走10m，部分走1m
ip ro sh table local这是所有经过本机的路由表
ip ro sh table all 这是本机所有的路由表
策略表：rule表，指定如何查其他表，匹配规则，这是路由的策略机制。可在策略这查ip经过的路由表
可在策略表中指定ip范围所经过的带宽
ip ro sh显示当前；默认路由
cd /etc/
vim rt_tables
#reserved values
255 local
254 main
253 unspec
111 ta2
101 ta1 添加时要按顺序
#
#local
ip ro sh ta 254
ip ro sh ta ta1
ip ro sh ta ta2
以上两表添加相应的路由
ip ro add 192.168.0.0/24 dev eth1 ta ta1
ip ro add 192.168.1.0/24 dev eth1 ta ta1
ip ro sh ta ta1
ip ro del 192.168.0.0/24 dev eth1 ta ta1
ip ro add 192.168.0.0/24 dev eth0 ta ta1
ip ro sh ta ta1
ip ro add default dev eth0 via 192.168.0.1 ta ta1
ip ro sh ta ta1
ip ro add 192.168.0.0/24 dev eth0 ta ta2
ip ro add 192.168.1.0/24 dev eth1 ta ta2
ip ro add default dev eth1 via 192.168.1.1 ta ta2
ip ro sh ta ta2
ip ro sh ta ta1
设置策略，如何查表
ip rule show
[root@www ~]# ip rule show
0: from all lookup 255
32766: from all lookup main
32767: from all lookup default
You have new mail in /var/spool/mail/root
顺序从上至下查表
加规则：不同网段查不同表1～100查1表，101～253查2表
ip ru(route) help帮助
ip ru add from 192.168.0.1 ta ta1
for i in &lsquo;seq 2 100&rsquo;;do ip ru add from 192.168.0.$i ta t1;done
for i in &lsquo;seq 2 253&rsquo;;do ip ru add from 192.168.0.$i ta t2;done
ip ru show
删除：
for in in &lsquo;seq 1 253&rsquo;;do ip rou del from 192.168.0.$i;done
ip ru sh
_____________更换查找方式
防火墙和高级路由联用：
iptables -t mangle -A PREROUTING -m iprange &ndash;src-range 192.168.0.1-192.168.0.100 -j MARK &ndash;set-mark 1
iptables -t mangle -A PREROUTING -m iprange &ndash;src-range 192.168.0.101-192.168.0.253 -j MARK &ndash;set-mark 2
ip ru help
ip ru add fwmark 1 ta ta1
ip ru add rwmark 2 ta ta2</p>

<h2 id="ip-ru-sh">ip ru sh</h2>

<p>TC联用
－－－－－－－－－
这是不同原地址发的带宽不一样
－－－－－－－－－－－－－－－
定义默认规则：
ip ro sh 默认def表：
ip ro sh
ip ro sh ta ta1
vim /etc/iproute2/rt_
ip ro sh ta ta1
ip ru sh
ip ru del fwmark 2
ip ru del fwmark 1
ip ru sh
ip ru add to 211.0.0.1 ta ta1
ip ru sh
根据目标地址指定以上
防火墙添加标记</p>

<h2 id="ip-ru-help">ip ru help</h2>

<p>要掌握结构
ab测试
ab -c 100 -n 1000 <a href="http://192.168.0.254">http://192.168.0.254</a>
vmstat 1
renice -20 ?
ps ax |grep httpd
ps ax |grep /usr/sbin/bttp |sed &ldquo;$d&rsquo; |awk ‘｛print $1}&lsquo;;do renice -20 $i;done
for i in &lsquo;ps ax|grep /usr/sbin/httpd |sed &lsquo;</p>

<hr />

<p>vim
#!/bin/bash</p>

<p>count=&ldquo;&rdquo;
ret=0</p>

<p>for ((count=1000;count&lt;=3000;count++))
do
 for ((i=2;i&lt;count;i++)
 do
 if ［ $[$count%$i] = 0]
 then
 rte=0
 break
 fi
 ret=1
 confinue
 done
 if [ $ret = 1 ]
 then
 echo $count
 fi
done</p>

<p><a href="http://wdicc.com/linux-bridge-script/">http://wdicc.com/linux-bridge-script/</a></p>

<p>Linux下双网接入高级路由配置脚本zz
<a href="http://lwfs.net/2005/11/28/10/">http://lwfs.net/2005/11/28/10/</a></p>

<pre><code>#!/bin/bash

IP0=
IP1=
GW0=
GW1=
NET0=
NET1=
DEV0=eth0
DEV1=eth1

# comment the next two line after first run this script.
echo 200 cernet &gt;&gt;/etc/iproute2/rt_tables
echo 210 chinanet &gt;&gt;/etc/iproute2/rt_tables

ip route add ${NET0} dev ${DEV0} src ${IP0} table cernet
ip route add default via ${GW0} table cernet
ip route add ${NET1} dev ${DEV1} src ${IP1} table chinanet
ip route add default via ${GW1} table chinanet
ip route add ${NET0} dev ${DEV0} src ${IP0}
ip route add ${NET1} dev ${DEV1} src ${IP1}

# delete old rule
ip rule del from ${IP0}
ip rule del from ${IP1}
# setup new rule
ip rule add from ${IP0} table cernet
ip rule add from ${IP1} table chinanet
</code></pre>

<p><a href="http://jpuyy.com/2014/01/ip-rule-and-ip-route.html">http://jpuyy.com/2014/01/ip-rule-and-ip-route.html</a></p>

<p>ip rule和 ip route
发表于2014 年 1 月 13 日</p>

<p>相对ip route ，ip rule是高级路由，能实现不同条件路由的转发。</p>

<p>linux系统维护了路由表，用ip rule show可以查看路由表。</p>

<h1 id="ip-rule-show">ip rule show</h1>

<p>0: from all lookup local
32766: from all lookup main
32767: from all lookup default</p>

<p>路由表记录在/etc/iproute2/rt_tables文件中，默认里面会用这么几行，在这个文件里添加的路由表即时生效</p>

<p>255 local
254 main
253 default
0 unspec</p>

<p>所以自定义一个路由表的时候，序号要在1-252之间，路由选择的优先级也与数字的大小有关，越小的优先级越高，先匹配。
数字后面要规定一个别名，方便使用和辨认。</p>

<p>这样路由表的查看可有以下两种方法：</p>

<p>ip route list table table_number
ip route list table table_name</p>

<p>如查看默认路由表可用如下命令</p>

<p>ip route list table main
ip route list table 254</p>

<p>路由表添加完之后，接下来就是对路由表的操作，如果我有</p>

<p>eth1 配置ip 192.168.1.<sup>8</sup>&frasl;<sub>24</sub> 路由表 101 mytable1</p>

<p>eth2 配置ip  192.168.2.<sup>8</sup>&frasl;<sub>24</sub> 路由表 102 mytable2</p>

<p>不同段的从不同的网卡走。</p>

<p>ip route add 192.168.1.0 dev eth1 src 192.168.1.8 table mytable1
ip route add default via 192.168.1.1 table mytable1
ip rule add from 192.168.1.8 table mytable1</p>

<p>ip route add 192.168.2.0 dev eth2 src 192.168.2.8 table mytable2
ip route add default via 192.168.2.1 table mytable2
ip rule add from 192.168.2.8 table mytable2</p>

<p>现在使用ip rule show查看</p>

<h1 id="ip-rule-show-1">ip rule show</h1>

<p>0: from all lookup local
 32764: from 192.168.2.8 lookup mytable2
 32765: from 192.168.1.8 lookup mytable1
 32766: from all lookup main
 32767: from all lookup default</p>

<p>这时要删除rule可使用</p>

<p>ip rule del prio 32764</p>

<p>ip rule还可以实现更高级的功能，比如根据ip目的地址，包大小来进行转发。</p>

<p>查看route -n flag</p>

<p>The flags</p>

<p>Following is the list of flags and their significance in the routing table :</p>

<p>U : This flag signifies that the route is up
G : This flag signifies that the route is to a gateway. If this flag is not present then we can say that the route is to a directly connected destination
H : This flag signifies that the route is to a host which means that the destination is a complete host address. If this flag is not present then it can be assumed that the route is to a network and destination would be a network address.
D : This flag signifies that this route is created by a redirect.
M : This flag signifies that this route is modified by a redirect.</p>

<p><a href="http://blog.csdn.net/bytxl/article/details/9850803">http://blog.csdn.net/bytxl/article/details/9850803</a>
策略路由以及使用 ip route ， ip rule ， iptables 配置策略路由实例
分类： 网络 linux 命令2013-08-09 10:36 560人阅读 评论(0) 收藏 举报</p>

<p>目录(?)[+]</p>

<p><a href="http://blog.sina.com.cn/s/blog_659b48590100n2q6.html">http://blog.sina.com.cn/s/blog_659b48590100n2q6.html</a></p>

<p>例：</p>

<p>公司内网要求192.168.0.100以内的使用 10.0.0.1 网关上网（电信），其他IP使用 20.0.0.1 （网通）上网。</p>

<p>首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关。</p>

<h1 id="ip-route-add-default-gw-20-0-0-1">ip route add default gw 20.0.0.1</h1>

<p>之后通过 ip route 添加一个路由表</p>

<h1 id="ip-route-add-table-3-via-10-0-0-1-dev-ethx">ip route add table 3 via 10.0.0.1 dev ethX</h1>

<p>(ethX是10.0.0.1所在的网卡，3 是路由表的编号)</p>

<p>之后添加 ip  rule 规则</p>

<h1 id="ip-rule-add-fwmark-3-table-3">ip rule add fwmark 3  table 3</h1>

<p>（fwmark 3是标记，table 3 是路由表3 上边。 意思就是凡是标记了 3 的数据使用table3 路由表）</p>

<p>之后使用iptables给相应的数据打上标记：</p>

<h1 id="iptables-a-prerouting-t-mangle-i-eth0-s-192-168-0-1-192-168-0-100-j-mark-set-mark-3">iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 -192.168.0.100 -j MARK &ndash;set-mark 3</h1>

<p>因为mangle的处理是优先于 nat 和fiter表的，所以相应数据包到达之后先打上标记，之后再通过ip rule规则。对应的数据包使用相应的路由表进行路由，最后读取路由表信息，将数据包送出网关。</p>

<hr />

<p>ip rule 命令</p>

<p>linux 高级路由即基于策略的路由，比传统路由在功能上更强大，使用也更灵活，它不仅能够像传统路由一样，根据目的地址来转发数据，而且也能够根据报文大小、应用，协议或ip源地址来选择路由转发路径从而让系统管理员能轻松做到：
1、 管制某台计算机的带宽。
2、 管制通向某台计算机的带宽
3、 帮助你公平地共享带宽
4、 保护你的网络不受DOS的攻击
5、 保护你的Internet不受到你的客户的攻击
6、 把多台服务器虚拟成一台，并进行负载均衡或者提高可用性
7、 限制你的用户访问某些计算机
8、 限制对你的计算机的访问
9、 基于用户帐号、MAC地址、源IP地址、端口、QOS《TOS》、时间或者content等进行路由</p>

<p>一、高级路由的基础IP ROUTE2
基本命令：
ip link list 显示ip链路状态信息
ip address show 除显示所有网络地址
ip route show 显示主路由表信息
ip neigh show 显示邻居表
linux系统路由表
linux可以自定义从1－252个路由表，
linux系统维护了4个路由表：
0表 系统保留表</p>

<p>255  local 本地路由表，存有本地接口地址，广播地址，以及NAT地址。
     local表由系统自动维护，管理员不能操作此表。
254  main 主路由表，传统路由表,ip route若没指定表即操作表254。
     注:平时用route查看的亦是此表设置的路由。
253  default  默认路由表一般存放默认路由。
     注：rt_tables文件中表以数字来区分表，保留最多支持255张表。</p>

<p>路由表的查看可有以下二种方法：
      ip route list table table_number
      ip route list table table_name</p>

<p>路由表序号和表名的对应关系在/etc/iproute2/rt_tables中，可手动编辑。
路由表添加完毕即时生效，下面为实例：</p>

<h1 id="ip-route-add-default-via-192-168-1-1-table-1-在1表中添加默认路由为192-168-1-1">ip route add default via 192.168.1.1 table 1                       在1表中添加默认路由为192.168.1.1</h1>

<h1 id="ip-route-add-192-168-0-0-24-via-192-168-1-2-添加一条到192-168-0-0网段的路由为192-168-1-2">ip route add 192.168.0.0/24 via 192.168.1.2                     添加一条到192.168.0.0网段的路由为192.168.1.2</h1>

<p>注:各路由表中应当指明默认路由，尽量不回查路由表。路由添加完毕，即可在路由规则中应用。
高级路由重点之一路由规则 ip rule
进行路由时，根据路由规则来进行匹配，按优先级（pref）从低到高匹配，直到找到合适的规则，所以在应用中配置默认路由是必要的。
ip rule show 显示路由规则。
路由规则的添加：</p>

<h1 id="ip-rule-add-from-192-168-1-10-32-table-1-pref-100">ip rule add from 192.168.1.<sup>10</sup>&frasl;<sub>32</sub> table 1 pref 100</h1>

<p>如果pref值不指定，则将在已有规则最小序号前插入
注：创建完路由规则若需立即生效须执行
#ip route flush cache
刷新路由缓冲。</p>

<p>命令格式如下：
        Usage: ip rule [ list | add | del ] SELECTOR ACTION
        SELECTOR := [ from PREFIX ] [ to PREFIX ] [ tos TOS ][ dev STRING ] [ pref NUMBER ]
        ACTION := [ table TABLE_ID ] [ nat ADDRESS ][ prohibit | reject | unreachable ]
                  [ flowid CLASSID ]
        TABLE_ID := [ local | main | default | new | NUMBER ]</p>

<pre><code>参数解析如下：
    From -- 源地址
    To -- 目的地址（这里是选择规则时使用，查找路由表时也使用）
</code></pre>

<p>　　Tos &ndash; IP包头的TOS（type of sevice）域Linux高级路由-
　　Dev &ndash; 物理接口
　    Fwmark &ndash; iptables标签
    采取的动作除了指定路由表外，还可以指定下面的动作：
        Table 指明所使用的表
  　   Nat 透明网关
　　 Prohibit 丢弃该包，并发送 COMM.ADM.PROHIITED的ICMP信息
　　 Reject 单纯丢弃该包
　　 Unreachable丢弃该包， 并发送 NET UNREACHABLE的ICMP信息</p>

<pre><code>路由表添加完毕,即可在策略路由表内添加路由。
</code></pre>

<p>例:
      #ip route add 192.168.1.0/24 dev eth0 via 192.168.1.66 realm 4
        注:发往子网192.168.1.0/24的数据包通过分类4转发配合tc使用,后文有介绍讲解&hellip;
      #ip route add default via 192.168.1.1 table int1
      #ip route add 192.168.1.0/24 via 192.168.1.1 table int2
      #ip route add 172.16.0.<sup>2</sup>&frasl;<sub>16</sub> via 172.16.0.1 table int3
        注:各路由表中应当指明默认路由,尽量不回查路由表.路由添加完毕,即可在路由规则中应用。
    #ip rule sh 显示路由规则
      0:      from all lookup local
      32766:  from all lookup main
      32767:  from all lookup default
    进行路由时，正是根据路由规则来进行匹配，按优先级(pref后数值)从高到低匹配,直到找到合适的规则.所以在应用中配置默认路由是必要的。
    策略路由一般手工添加路由表，路由表的添加只需编辑rt_tables文件，规定表序号，表名即可。
    ip rule规则添加示例：
      #ip rule add from 192.168.1.<sup>112</sup>&frasl;<sub>32</sub> [tos 0x10] table test2 pref 999 prohibit
      #ip rule add to 192.168.1.2 pref 1000 table test1
      #ip rule add from 192.168.1.0/24 pref 1001 table test1
      #ip rule add [from 0/0] table test1 pref 1003
      #ip rule add fwmark 1 pref 1002 table test2<br />
（此句型配合iptables -t mangle应用。如先对数据包作标记:
      #iptables -t mangle -A PREROUTING -p tcp -m multiport &ndash;dports 80,8080,20,21 -s 192.168.1.0/24 -j MARK &ndash;set-mark 1  ）</p>

<p>Linux高级路由需结合iptables才能充分体现其功能的强大,实际工作中的应用多半基于此,当然要熟练掌握Linux高级路由+iptables 还需进一步的加强学习和实践的应用。</p>

<p>route 命令</p>

<p>使用 Route 命令行工具查看并编辑计算机的 IP 路由表。Route 命令和语法如下所示：
route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]]
-f 清除所有网关入口的路由表。<br />
-p 与 add 命令一起使用时使路由具有永久性。
Command 指定您想运行的命令 (Add/Change/Delete/Print)。
Destination 指定该路由的网络目标。<br />
mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。<br />
Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。<br />
metric Metric 为路由指定一个整数成本值标（从 1 至 ArrayArrayArrayArray），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。<br />
if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。
/?  在命令提示符处显示帮助。<br />
示例:</p>

<p>使用route 命令添加的路由，机器重启或者网卡重启后路由就失效了，方法：</p>

<p>　　//添加到主机的路由</p>

<p>　　# route add –host 192.168.168.110 dev eth0</p>

<p>　　# route add –host 192.168.168.119 gw 192.168.168.1</p>

<p>　　//添加到网络的路由</p>

<p>　　# route add –net IP netmask MASK eth0</p>

<p>　　# route add –net IP netmask MASK gw IP</p>

<p>　　# route add –net IP/24 eth1</p>

<p>　　//添加默认网关</p>

<p>　　# route add default gw IP</p>

<p>　　//删除路由</p>

<p>　　# route del –host 192.168.168.110 dev eth0</p>

<p>添加一条路由(发往192.168.62这个网段的全部要经过网关192.168.1.1：
　　route add -net 192.168.62.0 netmask 255.255.255.0 gw 192.168.1.1</p>

<p>　　删除一条路由
　　route del -net 192.168.122.0 netmask 255.255.255.0
　　删除的时候不用写网关。</p>

<p>若要显示 IP 路由表的全部内容，请键入：</p>

<h1 id="route-print">route print</h1>

<p>Kernel IP routing table</p>

<p>　　Destination Gateway Genmask Flags Metric Ref Use Iface</p>

<p>　　10.147.9.0 * 255.255.255.0 U 1 0 0 eth0</p>

<p>　　192.168.1.0 * 255.255.255.0 U 2 0 0 wlan0</p>

<p>　　192.168.122.0 * 255.255.255.0 U 0 0 0 virbr0</p>

<p>　　link-local * 255.255.0.0 U 1000 0 0 eth0</p>

<p>　　192.168.0.0 192.168.1.1 255.255.0.0 UG 0 0 0 wlan0</p>

<p>　　default 10.147.9.1 0.0.0.0 UG 0 0 0 eth0</p>

<p>　　root@Ubuntu:~#</p>

<p>　　结果是自上而下， 就是说， 哪条在前面， 哪条就有优先， 前面都没有， 就用最后一条default。</p>

<p>若要显示以 10. 起始的 IP 路由表中的路由，请键入：
route print 10.*
若要添加带有 1Array2.168.12.1 默认网关地址的默认路由，请键入：
route add 0.0.0.0 mask 0.0.0.0 1Array2.168.12.1
若要向带有 255.255.0.0 子网掩码和 10.27.0.1 下一跃点地址的 10.41.0.0 目标中添加一个路由，请键入：
route add 10.41.0.0 mask 255.255.0.0 10.27.0.1
若要向带有 255.255.0.0 子网掩码和 10.27.0.1 下一跃点地址的 10.41.0.0 目标中添加一个永久路由，请键入：
route -p add 10.41.0.0 mask 255.255.0.0 10.27.0.1
若要向带有 255.255.0.0 子网掩码、10.27.0.1 下一跃点地址且其成本值标为 7 的 10.41.0.0 目标中添加一个路由，请键入：
route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 metric 7
若要向带有 255.255.0.0 子网掩码、10.27.0.1 下一跃点地址且使用 0x3 接口索引的 10.41.0.0 目标中添加一个路由，请键入：
route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 if 0x3
若要删除到带有 255.255.0.0 子网掩码的 10.41.0.0 目标的路由，请键入：
route delete 10.41.0.0 mask 255.255.0.0
若要删除以 10. 起始的 IP 路由表中的所有路由，请键入：
route delete 10.*
若要将带有 10.41.0.0 目标和 255.255.0.0 子网掩码的下一跃点地址从 10.27.0.1 修改为 10.27.0.25，请键入：
route change 10.41.0.0 mask 255.255.0.0 10.27.0.25</p>

<p>ip命令的语法
　　ip命令的用法如下：
　　ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]
　　4.1 ip link set&ndash;改变设备的属性. 缩写：set、s
　　示例1：up/down 起动／关闭设备。
　　# ip link set dev eth0 up
　　这个等于传统的 # ifconfig eth0 up(down)
　　示例2：改变设备传输队列的长度。
　　参数:txqueuelen NUMBER或者txqlen NUMBER
　　# ip link set dev eth0 txqueuelen 100
　　示例3：改变网络设备MTU(最大传输单元)的值。
　　# ip link set dev eth0 mtu 1500
　　示例4： 修改网络设备的MAC地址。
　　参数: address LLADDRESS
　　# ip link set dev eth0 address 00:01:4f:00:15:f1
　　4.2 ip link show&ndash;显示设备属性. 缩写：show、list、lst、sh、ls、l
　　-s选项出现两次或者更多次，ip会输出更为详细的错误信息统计。
　　示例:
　　# ip -s -s link ls eth0
　　eth0: mtu 1500 qdisc cbq qlen 100
　　link/ether 00:a0:cc:66:18:78 brd ff:ff:ff:ff:ff:ff
　　RX: bytes packets errors dropped overrun mcast
　　2449949362 2786187 0 0 0 0
　　RX errors: length crc fifo missed
　　0 0 0 0 0
　　TX: bytes packets errors dropped carrier collsns
　　178558497 1783946 332 0 332 35172
　　TX errors: aborted fifo window heartbeat
　　0 0 0 332
　　这个命令等于传统的 ifconfig eth0
　　5.1 ip address add&ndash;添加一个新的协议地址. 缩写：add、a
　　示例1：为每个地址设置一个字符串作为标签。为了和Linux-2.0的网络别名兼容，这个字符串必须以设备名开头，接着一个冒号，
　　# ip addr add local 192.168.4.<sup>1</sup>&frasl;<sub>28</sub> brd + label eth0:1 dev eth0
　　示例2: 在以太网接口eth0上增加一个地址192.168.20.0，掩码长度为24位(155.155.155.0)，标准广播地址，标签为eth0:Alias：
　　# ip addr add 192.168.4.<sup>2</sup>&frasl;<sub>24</sub> brd + dev eth1 label eth1:1
　　这个命令等于传统的: ifconfig eth1:1 192.168.4.2
　　5.2 ip address delete&ndash;删除一个协议地址. 缩写：delete、del、d
　　# ip addr del 192.168.4.<sup>1</sup>&frasl;<sub>24</sub> brd + dev eth0 label eth0:Alias1
　　5.3 ip address show&ndash;显示协议地址. 缩写：show、list、lst、sh、ls、l
　　# ip addr ls eth0
　　5.4.ip address flush&ndash;清除协议地址. 缩写：flush、f
　　示例1 : 删除属于私网10.0.0.0/8的所有地址：
　　# ip -s -s a f to <sup>10</sup>&frasl;<sub>8</sub>
　　示例2 : 取消所有以太网卡的IP地址
　　# ip -4 addr flush label &ldquo;eth0&rdquo;
　　6. ip neighbour&ndash;neighbour/arp表管理命令
　　缩写 neighbour、neighbor、neigh、n
　　命令 add、change、replace、delete、fulsh、show(或者list)
　　6.1 ip neighbour add &ndash; 添加一个新的邻接条目
　　ip neighbour change&ndash;修改一个现有的条目
　　ip neighbour replace&ndash;替换一个已有的条目
　　缩写：add、a；change、chg；replace、repl
　　示例1: 在设备eth0上，为地址10.0.0.3添加一个permanent ARP条目：
　　# ip neigh add 10.0.0.3 lladdr 0:0:0:0:0:1 dev eth0 nud perm
　　示例2:把状态改为reachable
　　# ip neigh chg 10.0.0.3 dev eth0 nud reachable
　　6.2.ip neighbour delete&ndash;删除一个邻接条目
　　示例1:删除设备eth0上的一个ARP条目10.0.0.3
　　# ip neigh del 10.0.0.3 dev eth0
　　6.3.ip neighbour show&ndash;显示网络邻居的信息. 缩写：show、list、sh、ls
　　示例1: # ip -s n ls 193.233.7.254
　　193.233.7.254. dev eth0 lladdr 00:00:0c:76:3f:85 ref 5 used 12/13/20 nud reachable
　　6.4.ip neighbour flush&ndash;清除邻接条目. 缩写：flush、f
　　示例1: (-s 可以显示详细信息)
　　# ip -s -s n f 193.233.7.254
　　7. 路由表管理
　　7.1.缩写 route、ro、r
　　7.2.路由表
　　从Linux-2.2开始，内核把路由归纳到许多路由表中，这些表都进行了编号，编号数字的范围是1到255。另外，
　　为了方便，还可以在/etc/iproute2/rt_tables中为路由表命名。
　　默认情况下，所有的路由都会被插入到表main(编号254)中。在进行路由查询时，内核只使用路由表main。
　　7.3.ip route add &ndash; 添加新路由
　　ip route change &ndash; 修改路由
　　ip route replace &ndash; 替换已有的路由
　　缩写：add、a；change、chg；replace、repl
　　示例1: 设置到网络10.0.0/24的路由经过网关193.233.7.65
　　# ip route add 10.0.0/24 via 193.233.7.65
　　示例2: 修改到网络10.0.0/24的直接路由，使其经过设备dummy
　　# ip route chg 10.0.0/24 dev dummy
　　示例3: 实现链路负载平衡.加入缺省多路径路由，让ppp0和ppp1分担负载(注意：scope值并非必需，它只不过是告诉内核，
　　这个路由要经过网关而不是直连的。实际上，如果你知道远程端点的地址，使用via参数来设置就更好了)。
　　# ip route add default scope global nexthop dev ppp0 nexthop dev ppp1
　　# ip route replace default scope global nexthop dev ppp0 nexthop dev ppp1
　　示例4: 设置NAT路由。在转发来自192.203.80.144的数据包之前，先进行网络地址转换，把这个地址转换为193.233.7.83
　　# ip route add nat 192.203.80.142 via 193.233.7.83
　　示例5: 实现数据包级负载平衡,允许把数据包随机从多个路由发出。weight 可以设置权重.
　　# ip route replace default equalize nexthop via 211.139.218.145 dev eth0 weight 1 nexthop via 211.139.218.145 dev eth1 weight 1
　　7.4.ip route delete&ndash; 删除路由
　　缩写：delete、del、d
　　示例1:删除上一节命令加入的多路径路由
　　# ip route del default scope global nexthop dev ppp0 nexthop dev ppp1
　　7.5.ip route show &ndash; 列出路由
　　缩写：show、list、sh、ls、l
　　示例1: 计算使用gated/bgp协议的路由个数
　　# ip route ls proto gated/bgp |wc
　　1413 9891 79010
　　示例2: 计算路由缓存里面的条数，由于被缓存路由的属性可能大于一行，以此需要使用-o选项
　　# ip -o route ls cloned |wc
　　159 2543 18707
　　示例3: 列出路由表TABLEID里面的路由。缺省设置是table main。TABLEID或者是一个真正的路由表ID或者是/etc/iproute2/rt_tables文件定义的字符串，
　　或者是以下的特殊值：
　　all &ndash; 列出所有表的路由；
　　cache &ndash; 列出路由缓存的内容。
　　ip ro ls 193.233.7.82 tab cache
　　示例4: 列出某个路由表的内容
　　# ip route ls table fddi153
　　示例5: 列出默认路由表的内容
　　# ip route ls
　　这个命令等于传统的: route
　　7.6.ip route flush &ndash; 擦除路由表
　　示例1: 删除路由表main中的所有网关路由（示例：在路由监控程序挂掉之后）：
　　# ip -4 ro flush scope global type unicast
　　示例2:清除所有被克隆出来的IPv6路由：
　　# ip -6 -s -s ro flush cache
　　示例3: 在gated程序挂掉之后，清除所有的BGP路由：
　　# ip -s ro f proto gated/bgp
　　示例4: 清除所有ipv4路由cache
　　# ip route flush cache
　　*** IPv4 routing cache is flushed.
　　7.7 ip route get &ndash; 获得单个路由 .缩写：get、g
　　使用这个命令可以获得到达目的地址的一个路由以及它的确切内容。
　　ip route get命令和ip route show命令执行的操作是不同的。ip route show命令只是显示现有的路由，而ip route get命令在必要时会派生出新的路由。
　　示例1: 搜索到193.233.7.82的路由
　　# ip route get 193.233.7.82
　　193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac cache mtu 1500 rtt 300
　　示例2: 搜索目的地址是193.233.7.82，来自193.233.7.82，从eth0设备到达的路由（这条命令会产生一条非常有意思的路由，这是一条到193.233.7.82的回环路由）
　　# ip r g 193.233.7.82 from 193.233.7.82 iif eth0
　　193.233.7.82 from 193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac/inr.ac
　　cache
 mtu 1500 rtt 300 iif eth0
　　8. ip route &ndash; 路由策略数据库管理命令
　　命令
　　add、delete、show(或者list)
　　注意：策略路由(policy routing)不等于路由策略(rouing policy)。
　　在某些情况下，我们不只是需要通过数据包的目的地址决定路由，可能还需要通过其他一些域：源地址、IP协议、传输层端口甚至数据包的负载。
　　这就叫做：策略路由(policy routing)。
　　8.1. ip rule add &ndash; 插入新的规则
　　ip rule delete &ndash; 删除规则
　　缩写：add、a；delete、del、d
　　示例1: 通过路由表inr.ruhep路由来自源地址为192.203.80/24的数据包
　　ip ru add from 192.203.<sup>80</sup>&frasl;<sub>24</sub> table inr.ruhep prio 220
　　示例2:把源地址为193.233.7.83的数据报的源地址转换为192.203.80.144，并通过表1进行路由
　　ip ru add from 193.233.7.83 nat 192.203.80.144 table 1 prio 320
　　示例3:删除无用的缺省规则
　　ip ru del prio 32767
　　8.2. ip rule show &ndash; 列出路由规则
　　缩写：show、list、sh、ls、l
　　示例1: # ip ru ls
　　0: from all lookup local
　　32762: from 192.168.4.89 lookup fddi153
　　32764: from 192.168.4.88 lookup fddi153
　　32766: from all lookup main
　　32767: from all lookup 253
　　9. ip maddress &ndash; 多播地址管理
　　缩写：show、list、sh、ls、l
　　9.1.ip maddress show &ndash; 列出多播地址
　　示例1: # ip maddr ls dummy
　　9.2. ip maddress add &ndash; 加入多播地址
　　ip maddress delete &ndash; 删除多播地址
　　缩写：add、a；delete、del、d
　　使用这两个命令，我们可以添加／删除在网络接口上监听的链路层多播地址。这个命令只能管理链路层地址。
　　示例1: 增加 # ip maddr add 33:33:00:00:00:01 dev dummy
　　示例2: 查看 # ip -O maddr ls dummy
　　2: dummy
　　link 33:33:00:00:00:01 users 2 static
　　link 01:00:5e:00:00:01
　　示例3: 删除 # ip maddr del 33:33:00:00:00:01 dev dummy
　　10.ip mroute &ndash; 多播路由缓存管理
　　10.1. ip mroute show &ndash; 列出多播路由缓存条目
　　缩写：show、list、sh、ls、l
　　示例1:查看 # ip mroute ls
　　(193.232.127.6, 224.0.1.39) Iif: unresolved
　　(193.232.244.34, 224.0.1.40) Iif: unresolved
　　(193.233.7.65, 224.66.66.66) Iif: eth0 Oifs: pimreg
　　示例2:查看 # ip -s mr ls 224.<sup>66</sup>&frasl;<sub>16</sub>
　　(193.233.7.65, 224.66.66.66) Iif: eth0 Oifs: pimreg
　　9383 packets, 300256 bytes
　　11. ip tunnel &ndash; 通道配置
　　缩写
　　tunnel、tunl
　　11.1.ip tunnel add &ndash; 添加新的通道
　　ip tunnel change &ndash; 修改现有的通道
　　ip tunnel delete &ndash; 删除一个通道
　　缩写：add、a；change、chg；delete、del、d
　　示例1:建立一个点对点通道，最大TTL是32
　　# ip tunnel add Cisco mode sit remote 192.31.7.104 local 192.203.80.1 ttl 32
　　11.2.ip tunnel show &ndash; 列出现有的通道
　　缩写：show、list、sh、ls、l
　　示例1: # ip -s tunl ls Cisco
　　12. ip monitor和rtmon &ndash; 状态监视
　　ip命令可以用于连续地监视设备、地址和路由的状态。这个命令选项的格式有点不同，命令选项的名字叫做monitor，接着是操作对象：
　　ip monitor [ file FILE ] [ all | OBJECT-LIST ]
　　示例1: # rtmon file /var/log/rtmon.log
　　示例2: # ip monitor file /var/log/rtmon.log r</p>

<p>转自：<a href="http://www.unixnotes.net/ip-rule.html?replytocom=25">http://www.unixnotes.net/ip-rule.html?replytocom=25</a>
相关资料：</p>

<pre><code>linux｜tasklet机制
linux｜Struts学习笔记：Struts Framework工作原理
linux｜iReport-4.7.0转pdf中文字符集问题
linux｜ip rule 命令
linux｜shell编程下的AWK语法小结
linux｜ioremap函数解析
linux｜ioremap原理及意义
</code></pre>

<p><a href="http://www.cppblog.com/isware/archive/2011/06/01/147825.html">http://www.cppblog.com/isware/archive/2011/06/01/147825.html</a></p>

<p><a href="http://www.aliyun.com/zixun/content/3_12_519324.html">http://www.aliyun.com/zixun/content/3_12_519324.html</a>
Linux的高级路由和流量控制：介绍iproute2
发布时间：2014-12-19 更新时间：2014-12-26 来源：网络
作者：水笔思思</p>

<p>关键词： Linux 流量控制 iproute2 高级路由</p>

<p>希望这篇文档能对你更好地理解Linxs2.<sup>2</sup>&frasl;<sub>2</sub>.4的路由有所帮助和启发。不被大多数使用者所知道的是，你所使用工具，其实能够完成相当规模工作。比如route 和ifconfig，实际上暗中调用了非常强大的iproute 2的底层基本功能。</p>

<p>Linux能为你做什么</p>

<p>一个小列表：</p>

<p>• 管制某台计算机的带宽
• 管制通向某台计算机的带宽
• 帮助你公平地共享带宽
• 保护你的网络不受DoS攻击
• 保护Internet不受到你的客户的攻击
• 把多台服务器虚拟成一台，进行<a href="http://www.aliyun.com/zixun/aggregation/13996.html&quot;&gt;负载均衡或者提高可用性">http://www.aliyun.com/zixun/aggregation/13996.html&quot;&gt;负载均衡或者提高可用性</a>
• 限制对你的计算机的访问
• 限制你的用户访问某些主机
• 基于用户账号(没错！)、MAC地址、源IP地址、端口、服务类型、时间或者内容等条件进行路由。</p>

<p>现在，很多人都没有用到这些高级功能。这有很多原因。比如提供的文档过于冗长而且不容易上手，而且流量控制甚至根本就没有归档。</p>

<p>1 为什么使用 iproute2?</p>

<p>现在，绝大多数 Linux 发行版和绝大多数 UNIX都使用古老的arp, ifconfig和route命令。虽然这些工具能够工作，但它们在Linux2.2和更高版本的内核上显得有一些落伍。比如，现在GRE隧道已经成为了路由的一个主要概念，但却不能通过上述工具来配置。
使用了iproute2，隧道的配置与其他部分完全集成了。</p>

<p>2.2 和更高版本的Linux 内核包含了一个经过彻底重新设计的网络子系统。这些新的代码让Linux在操作系统的竞争中取得了功能和性能上的优势。实际上，Linux新的路由、过滤和分类代码，从功能和性能上都不弱于现有的那些专业的路由器、防火墙和流量整形产品。</p>

<p>随着新的网络概念的提出，人们在现有操作系统的现有体系上修修补补来实现他们。这种固执的行为导致了网络代码中充斥着怪异的行为，这有点像人类的语言。过去，Linux模仿了SunOS的许多处理方式，并不理想。</p>

<p>这个新的体系则有可能比以往任何一个版本的Linux都更善于清晰地进行功能表达。</p>

<p>2 iproute2 概览</p>

<p>Linux有一个成熟的带宽供给系统，称为Traffic Control（流量控制）。这个系统支持各种方式进行分类、排序、共享和限制出入流量。</p>

<p>我们将从 iproute2 各种可能性的一个简要概览开始。</p>

<p>3 先决条件</p>

<p>你应该确认已经安装了用户级配置工具。这个包的名字在RedHat和Debian中都叫作“iproute”，也可以在这个地方找到：</p>

<p><a href="ftp://ftp.inr.ac.ru/ip-routing/iproute2-2.2.4-now-ss??????.tar.gz">ftp://ftp.inr.ac.ru/ip-routing/iproute2-2.2.4-now-ss??????.tar.gz</a></p>

<p>你也可以试试在这里(<a href="ftp://ftp.inr.ac.ru/ip-routing/iproute2-current.tar.gz)找找最新版本。">ftp://ftp.inr.ac.ru/ip-routing/iproute2-current.tar.gz)找找最新版本。</a></p>

<p>iproute 的某些部分需要你打开一些特定的内核选项。应该指出的是，RedHat6.2及其以前的所有发行版中所带的缺省内核都不带有流量控制所需要的绝大多数功能。</p>

<p>而RedHat 7.2在缺省情况下能满足所有要求。</p>

<p>另外，确认一下你的内核支持netlink ，Iproute2需要它.</p>

<p>本站所有文章全部来源于互联网，版权归属于原作者。本站所有转载文章言论不代表本站观点，如是侵犯了原作者的权利请发邮件联系站长（yanjing@alibaba-inc.com），我们收到后立即删除。</p>

<p><a href="http://man.chinaunix.net/linux/lfs/LFS-6.1.1/chapter06/iproute2.html">http://man.chinaunix.net/linux/lfs/LFS-6.1.1/chapter06/iproute2.html</a>
6.32. IPRoute2-2.6.11-050330</p>

<p>IPRoute2 包含了基本的和高级的基于 IPv4 网络的程序。
预计编译时间：0.1 SBU
所需磁盘空间：4.3 MB
安装依赖于：GCC, Glibc, Make, Linux-Headers, Sed
6.32.1. 安装 IPRoute2</p>

<p>这个程序包中的二进制文件 arpd 依赖于 Berkeley DB 。因为 arpd 对于一个基本 Linux 系统基本上没有用处，所以我们要使用下面的补丁去除对 Berkeley DB 的依赖。如果你需要使用 arpd 你可以参考 BLFS-Book 中的这个页面来了解如何编译与安装 Berkeley DB ：<a href="http://www.linuxfromscratch.org/blfs/view/svn/server/databases.html#db">http://www.linuxfromscratch.org/blfs/view/svn/server/databases.html#db</a> 。</p>

<p>sed -i &lsquo;/^TARGETS/s@arpd@@g&rsquo; misc/Makefile</p>

<p>为编译 IPRoute2 做准备：</p>

<p>./configure</p>

<p>编译软件包：</p>

<p>make SBINDIR=/sbin</p>

<p>make 选项的含义：</p>

<p>SBINDIR=/sbin</p>

<pre><code>确保将 IPRoute2 包中的二进制文件安装到 /sbin 目录中以符合 FHS 标准，因为一些 IPRoute2 二进制文件将会被 LFS-Bootscripts 使用。
</code></pre>

<p>安装软件包：</p>

<p>make SBINDIR=/sbin install</p>

<p>6.32.2. IPRoute2 的内容
安装的程序：ctstat (链接到 lnstat), ifcfg, ifstat, ip, lnstat, nstat, routef, routel, rtacct, rtmon, rtpr, rtstat (链接到 lnstat), ss, tc
简要描述
ctstat</p>

<p>连接状态工具
ifcfg</p>

<p>ip 命令的shell脚本包装
ifstat</p>

<p>显示网络接口的统计信息，包括接口发送和接收到的包数量。
ip</p>

<p>主可执行程序，它包含以下几个功能：</p>

<p>ip link [device] 查看和修改设备状态</p>

<p>ip addr 查看地址的特性，添加新地址、删除旧地址。</p>

<p>ip neighbor 查看邻居的特性，添加新邻居、删除旧邻居。</p>

<p>ip rule 查看和修改路由规则</p>

<p>ip route 查看路由表和修改路由表规则</p>

<p>ip tunnel 查看和修改 IP 隧道及其特性</p>

<p>ip maddr 查看和修改多播地址及其特性</p>

<p>ip mroute 设置、修改、删除多播路由</p>

<p>ip monitor 不间断的监视设备状态、地址、路由
lnstat</p>

<p>提供 Linux 网络统计信息，用于替代旧的 rtstat 程序。
nstat</p>

<p>显示网络统计信息
routef</p>

<p>ip route 的一个组件，用于刷新路由表。
routel</p>

<p>ip route 的一个组件，用于列出路由表。
rtacct</p>

<p>显示 /proc/net/rt_acct 文件的内容
rtmon</p>

<p>路由监视工具
rtpr</p>

<p>将 ip -o 的输出转换为可读的格式
rtstat</p>

<p>路由状态工具
ss</p>

<p>类似于 netstat 命令，显示活动的连接。
tc</p>

<p>流量控制，用于实现服务质量(QOS)和服务级别(COS)：</p>

<p>tc qdisc 建立排队规则</p>

<p>tc class 建立基于级别的队列调度</p>

<p>tc estimator 估算网络流量</p>

<p>tc filter 设置 QOS/COS 包过滤器</p>

<p>tc policy 设置 QOS/COS 规则</p>

<p><a href="http://blog.csdn.net/dog250/article/details/6685633">http://blog.csdn.net/dog250/article/details/6685633</a></p>

<p>Linux路由应用-使用策略路由实现访问控制
2011-08-14 10:51 5239人阅读 评论(2) 收藏 举报
linuxtablesocketfilter防火墙网络</p>

<p>目录(?)[+]</p>

<p>引：
一般而言，访问控制并不是路由模块完成的，而是防火墙的职责，如果你使用Linux的，这是iptables的职责。然而有时候，特别是在策略很多的情况下，使用iptables会极大降低网络性能，这是Netfilter的filter表的本质决定的，具体的优化参见《Linux的Netfilter框架深度思考-对比Cisco的ACL》。
     Linux有一个很实用的特性可以在某些情形下代替iptables，从而实现访问控制。本文给出一个方法，说明如何使用策略路由来控制数据访问的入口网卡，具体来讲就是：只有通过特定的网卡才能访问机器上的某一个地址。具体来讲，Linux服务器有如下配置：
eth0:192.168.1.<sup>1</sup>&frasl;<sub>24</sub>
eth1:192.168.2.<sup>1</sup>&frasl;<sub>24</sub>
eth2:172.16.1.<sup>1</sup>&frasl;<sub>24</sub>
lo:127.0.0.1
只能通过eth0访问192.168.1.1这个地址，而不能通过eth1或者eth2访问，甚至本机都不能访问192.168.1.1。
     但是在探讨如何做之前，首先要明白一些理论知识，这样才能知其然且知其所以然。
1.完成这个需求必须要明白的背景知识
1.1.Linux路由查找流程
所有的路由器设计都要遵循以下规则：
IF 目的地址配置在本机
    THEN 本机接收
ELSE
    查找路由表并在找到路由的情况下转发
END
当然Linux也不能例外，但是Linux并没有将这这两种情况进行区分，而是使用“多张路由表”将二者统一了起来。在Linux中，内置了三张路由表：
local，main，default，其中local路由表的优先级最高，并且不能被替换，在有数据包进来的时候，首先无条件的查找local路由表，如果找到了路由，则数据包就是发往本机的，如果找不到，则接着在其它的路由表中进行查找。使用ip route ls table local命令可以看到local表的内容，比如机器的eth0网卡上配有192.168.0.7，则在local表中会有如下的路由：
local 192.168.0.7 dev eth0  proto kernel  scope host  src 192.168.0.7
值得注意的是，local表中的路由是可以删除的。路由的src项指的是当数据包从本机发出时，在local表中找到了源地址的路由，首选的源ip地址
     在local表和main表之间，可以插入251张策略路由表，因此如果有策略路由表的话，如果local表中没有找到路由，则会查找策略路由表。
     总结一下本节的内容，Linux内置了三张路由表，其中local路由表优先级最高且不可替换，它完成“IF 目的地址配置在本机 THEN 本机接收”这个逻辑，在local表之后，可以配置多张策略路由表，策略路由的知识本文不谈，但是基本就是根据源地址，目的地址，出接口，入接口等元素来决定数据包在路由前是否进入该张策略路由表，本质上是一种过滤行为(然则结果是可以缓存的，其要点就在于此！)。
1.2.bind地址/no-bind地址
有一个问题，那就是如果一个数据包从本机发出，如何确定其源地址，这个问题如果搞不明白，就可能面临很多奇怪的现象而无法解释，在这个问题上，TCP和UDP的行为是不同的，TCP比较简单，因为一个TCP连接是四元素决定的(源IP地址，目的IP地址，源端口，目的端口)，因此在建立连接后，源/目的IP地址是确定的。对于UDP而言，情况就复杂了，下节详述。但是不管什么协议，在API接口层次上，一个socket分为bind地址的和不bind地址的。
     如果是bind地址，那么源地址就是bind的那个地址，如果没有bind，那么源地址在路由之后根据路由的结果确定。这就意味着，策略路由的from关键字将无法匹配到所有没有bind地址的应用程序从本地发出的包-原因是策略路由匹配是在路由前做的，而此时还没有源IP地址。
     想明白协议栈如何这么设计，还是要从IP路由的本质以及传输层语义来分析。IP路由的职责就是能将IP数据报送到目的地，在路由之后选择源IP地址可以使返回的IP数据报在完全逆向路径上返回。考虑传输层的语义，对于TCP而言，其源地址的确定性是TCP做的，而不是IP层做的，这一点一定要清楚。对于不bind地址的情况，应用程序在数据包到达网络层之前不需要考虑网络层协议头的内容，这个工作完全有网络层的IP路由模块来完成，应用程序只需要指出目的IP即可，完全由协议栈负责网络层协议头的添加。
     想明白协议栈如何实现这个逻辑，最好的办法是看Linux的源代码，方法是跟踪一个数据包发送的全过程源码，具体看ip_route_output_slow。
1.3.UDP踢皮球
讨论TCP的文章很多，TCP也有很多复杂的特性值得去深究，然而UDP也不是吃素的，有一种现象就是UDP连接会踢皮球，最终用TCPDUMP抓取的数据包结果会让人焦头烂额。其实只要明白1.2节的内容，本节的内容就很简单了。
     UDP无连接，不可靠，只负责将数据尽力而为传到目的主机，它对源和目的IP地址的管理很松散，UDP数据流(更确切的并不能称为数据流)是单包的。在两端都没有显式bind到具体的IP地址的情况下，最终的数据包可以使用任意的本机地址，关键看路由的结果。数据到达对端之后，如果对端也没有显示bind到具体的IP地址，那么回复包的源地址也可能不再是初始包的目的地址。我们还是用实例来说明吧，先看网络拓扑：</p>

<p>路由配置如下：
host1：default 192.168.0.2
host2：default 172.16.0.2
host1上运行一个UDP服务器，绑到0.0.0.0这个地址，也就是不绑定地址，host2向host1 192.168.1.1的UDP端口8888发送数据，抓包发现其源地址是172.16.0.1，目的地址是192.168.1.1，而返回包却抓不到了，意外抓取到一个源地址是192.168.0.1，目的地址是172.16.0.1的数据包。这是正常的，因为数据包到达host1时，查找返回路由时，会查到下一跳192.168.0.2，进而根据这个下一跳选择同一网段的192.168.0.1这个地址，此时如果添加一条路由：172.16.0.1 gw 192.168.1.2，那么就会看到返回数据包源地址为192.168.1.1了。
     还有更奇怪的现象，那就是，初始时从host2向host1发送数据，源和目的分别是172.16.0.1和192.168.1.1，可是后来，在没有断开UDP客户端和服务器的情况下(host2更改了路由)，源和目的分别成了172.16.1.1和192.168.0.1，这也是正常的，因为UDP本来就是无连接的，在不bind地址的情况下，关键是根据路由来选择源地址，选择源地址原则是：优先选择路由结果接口上和下一跳地址为同一网段的第一个primary地址，否则选择其它网卡上的primary地址，在选择过程中，有三个scope会影响选择结果，一个是下一跳地址scope，它表示该地址到达本地的“距离”，另一个是路由scope，它表示到达该路由的“距离”，还有一个是本地地址的scope，它限制了该地址的使用范围，路由模块保证下一跳的scope要小于路由的scope-背后的思想就是下一跳一定距离目的地比本机更近，而选择的本地地址的scope必须小于等于给定的scope(作为一个参数存在)。
     UDP踢皮球有一个后果就是会影响Netfilter的ip_conntrack，我们知道，ip_conntrack是基于五元素来跟踪连接的，UDP的混乱情况可能使一个UDP数据流被跟踪好几次，从而使得后续的NAT规则(如果有的话)很复杂，NAT配置必须考虑到皮球的每一个方向，否则就会漏掉本来应该被NAT的数据包。
     总之，网络是很复杂的，千万不要觉得就是配置几个IP地址以及几条路由那么简单的事。
1.4.路由前对本机出发数据包的源地址的检查
如果是本机发出数据包，最终要进入路由模块的ip_route_output_slow函数来查找路由，该函数对bind地址的源地址进行了检查，它保证到该本地地址的路由必须在local路由表中被找到。</p>

<pre><code>static int ip_route_output_slow(...)  
{  
    if (oldflp-&gt;fl4_src) {  
        ...  
        if (!(oldflp-&gt;flags &amp; FLOWI_FLAG_ANYSRC)) {  
            /* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */  
            dev_out = ip_dev_find(net, oldflp-&gt;fl4_src);  
            if (dev_out == NULL)  
                goto out;  
            ...  
        }  
    }  
}  
</code></pre>

<p>ip_dev_find的实现中，有以下逻辑：</p>

<pre><code>local_table = fib_get_table(net, RT_TABLE_LOCAL);  
    if (!local_table || local_table-&gt;tb_lookup(local_table, &amp;fl, &amp;res))  
        return NULL;  
</code></pre>

<p>这意味着本机出发的数据包的源地址如果有的话，必须要在local表中找到一条local路由，否则则返回EINVAL错误。然而可以取消这一限制，具体见1.6节。总而言之，FLOWI_FLAG_ANYSRC这个标志是基于socket，通过setsockopt可以设置socket，使与之相关的oldflp的flags中有FLOWI_FLAG_ANYSRC标志。
1.5.Linux的IP地址属于主机而不属于网卡
在Linux中，不要以为IP地址是属于网卡的，它是属于主机的，实际上就算是UNIX或者其它的OS，IP地址都不应该是网卡的，IP地址是三层概念，网卡是二层设备。很多人都认为IP地址是属于网卡的是因为在Linux中配置IP地址时都要给定一个网卡参数，比如ip address add dev ethX XXX/YY。
     IP地址是属于主机的，这就意味着，只要IP数据报到达本机，没有常规的方式使用路由限制该IP数据报不到达本地应用程序(local表是无条件最先被查询的，除非在local表中将该地址对应的local路由删除)。在procfs中使用sysctl能通过配置网卡参数达到限制数据包的目的吗？比如什么“关闭eth0的forwarding，这样数据包就不能从eth0 forward到eth2了”，根本不是那回事。
1.6.取消本地地址必须存在于local路由表的限制
2.6.27以上内核的socket选项IP_TRANSPARENT可以影响本机出发数据包路由查找时的源地址检测，具体做法是在应用程序中使用下列代码段：
int value = 1;
setsockopt(fd, SOL_IP, IP_TRANSPARENT, &amp;value, sizeof(value));
设置后，服务器回包的源地址不再限制在local表内，而是可以使用任何地址，包括非本机地址，这个技术一般用于透明代理。因此可以用这一特性来利用策略路由表完成本应该由防火墙完成的功能，不损耗性能。这样可以做到在local表中将eth0上的local路由删除，将该local路由加到策略路由中，本地应用程序将不能访问配置在eth0上地址。
     在2.6.27之前，协议栈在添加源地址（或者用户指定了侦听地址）时，要确保local路由表中拥有该地址，否则会报错，而我们就是想把该地址的本机local路由移出local表，因此此功能不可实现。在2.6.27之后，增加了FLOWI_FLAG_ANYSRC标志，可以通过设置该标志做到限制的取消，具体做法有两种，一种是全局的，那就是将ip_route_output_slow中的if (!(oldflp-&gt;flags &amp; FLOWI_FLAG_ANYSRC))判断取消掉，改为if (0)；第二种改法是基于socket的，实际上FLOWI_FLAG_ANYSRC是基于单个socket设置的。完成此功能的前提：
1).内核编译了CONFIG_IP_MULTIPLE_TABLES
2).修改管理服务程序，为其socket增加IP_TRANSPARENT选项
2.具体操作
为了很简单的几步操作，前面啰里啰嗦说了那么多，实际上做技术本来就应该这样，必须挖掘深层次的原理，否则就只能算个IT工人。
配置：
eth0:192.168.0.<sup>1</sup>&frasl;<sub>24</sub>
eth1:172.16.0.<sup>1</sup>&frasl;<sub>24</sub>
eth2:10.0.0.<sup>1</sup>&frasl;<sub>24</sub>
lo:127.0.0.1
2.1.限制从其它网卡接口访问特定网卡接口上配置的IP地址(这个说法不准确，具体见1.5节)对应的服务
2.1.1.添加一个策略路由表
echo &ldquo;100 my&rdquo; &gt;&gt; /etc/iproute2/rt_tables
这样可以在local和main表之间增加一个路由表my，内核路由模块的查找顺序是：local-&gt;my-&gt;main&hellip;
2.1.2.增加一条策略
ip rule add from 192.168.0.1 table my
2.1.3.在策略路由表中增加所有从eth0出去的路由
ip route add 12.34.0.0/16 via 192.168.0.2 dev eth0 table my
ip route add &hellip; table my
&hellip;
ip route add default dev eth0 table my
所有匹配到my这个策略路由表的数据包，将从上述的路由项中查询结果。注意，最后一条默认路由是必须要的，且一定要从eth0出去，否则根据Linux策略路由查找原则，如果在my表中没有找到路由的话，还是会继续往下进行的，所谓的策略路由表只是一个优先级问题，而不是强制的查找约束。
2.1.4.结论和问题
通过以上的配置，所有从eth0进来的数据包才能安全返回，否则，比如从eth1进来一个访问192.168.0.1的数据包，由于它只有从eth1返回才可以(不考虑多径路由)，然而返回包的源地址却是192.168.0.1(对应的服务不管是TCP的还是UDP必须显式bind到192.168.0.1这个地址，否则对于UDP就会有踢皮球的现象)，这样路由查找就会进入my表(对于踢皮球的情况，就可能不进入my表)，然则my表中没有一个从eth1出去的路由，且该包起码会匹配到my表的默认路由，数据包因此无法返回。
     现在考虑一下一个问题，如果是bind到192.168.0.1这个地址的服务主动访问外部，是不是也一定要从eth0出去呢？答案是肯定的，因为它bind了一个明确的地址，而源地址是该地址的数据包一定会匹配到my，最终起码会匹配到my的默认路由&hellip;
2.1.5.进一步的问题
现在已经实现了不能从除eth0之外的其它接口进入访问bind到eth0上地址的服务，然而如果希望做到连本地都不能访问该服务，那才是名副其实的“除eth0之外的&hellip;都不能&hellip;”，无疑本地出发的访问192.168.0.1的数据包肯定不是从eth0进入的。
     有一个办法可以解决这个问题，那就是禁用掉lo，因为在Linux中，所有从本地到本地的包都会被定向掉lo，禁掉lo后，所有本地到本地的包就都无法到达目的地。但是这种方法并不好，管不着人家就把人家关起来，非真的猛士！下一节我们就看看怎么做到本地不能访问本地eth0上的192.168.0.1这个地址，做到名副其实的“只有eth0进入的数据包才能访问”
2.2.限制本地访问本地bind到eth0上192.168.0.1这个地址的服务
想理解这个配置原理，还要回顾一下1.4节和1.6节，当理解了这两节之后，这里的配置就手到擒来了
2.2.0.前提：两种方式
之一：直接将内核中的检查取消掉，见1.6节
之二：改写bind到192.168.0.1地址服务程序，为其socket增加IP_TRANSPARENT选项，
2.2.1.添加一个新路由表
echo “100  my_rule” &gt;&gt; /etc/iproute2/rt_tables
2.2.2.增加一条策略：从eth0到来的数据包，开放my_rule路由表
ip rule add iif eth0 table my_rule
所有从eth0进来的数据包，查找my_rule表中的路由
2.2.3.为新增策略增加190.7 local路由
ip route add local 192.168.0.<sup>1</sup>&frasl;<sub>32</sub> dev lo table my_rule
由于到达本地的数据包要想成功到达，必须要找到一条local路由(类型对即可，无需非要在local表)，因此在my_rule中增加一条到达192.168.0.1的local路由
2.2.4.删除原有的local表中的192.168.0.1路由
ip route del local 192.168.0.<sup>1</sup>&frasl;<sub>32</sub> table local
由于2.2.0中的两种前提，对源地址的检测已经取消了，到达源地址的路由现在没有必要非要在local表中了，因此即使删除了local中到达192.168.0.1的路由，也无所谓，返回包会直接使用源地址192.168.0.1而不被检查。
2.2.5.结论和问题
2.2.1-2.2.4的结果就是：访问192.168.0.1的数据包从eth0而来，查找my_rule表，找到，对于返回包，由于IP_TRANSPARENT取消了限制，可以正常返回；对于从非eth0到来的访问192.168.0.1的包，由于192.168.0.1的local路由已然被删，my_rule由于只匹配入口为eth0的数据包因而不对其开放，将无法访问。
     这个配置在2.1节的基础上做了增强，然而由于要修改bind到192.168.0.1地址的服务程序，对于既有的闭源程序的类似的访问控制将没有用武之地(这些程序没有源码，不能修改)。
3.总的结论
本文给出了一种使用路由进行访问控制的方式，对于规则比较简单，且访问控制都在第三层的场景中，路由的方式要比用防火墙更好，不会影响性能。然而本文的讨论完全是基于Linux的，对于非Linux的系统，比如Cisco，可能人家的ACL防火墙实现得比较高效，比iptables配置的更好，也就不需要用路由的方式进行访问控制了，就算对于Linux本身，nf-HiPAC对filter表做了优化之后，路由的方式进行访问控制的优势也减少了。</p>

<pre><code> 总之，Linux网络或者说网络本身是一个超级复杂的系统，不同的实现对于配置方式的选型影响巨大，然而有一个问题，比如像Windows这样的系统，你还不知道它的网络协议栈实现的内幕，那么它的配置肯定也就比较固定，那就是Microsoft的建议配置。
 实际上，由于增加了策略路由表，查表的过程也是遍历，并且根据策略路由表的match一个一个比较，这个过程和filter表的查询过程几乎是一样的，则策略路由的优势体现在何方？实际上，路由和filter有一个区别，那就是路由是可以缓存的，而filter则是每包匹配的，有一种基于状态的防火墙可以“缓存”过滤结果，但是由于需要维护连接状态，这笔开销也是不可小觑的。路由缓存是完全独立的，路由完全缓存在一个hash表当中。
 但是，如果路由缓存hash表的冲突链表过长(缓存太大了)，或者hash算法太菜，在配置大量策略路由和配置iptables之间权衡的话，后者也不是总是处于劣势，孰是孰非，只有具体情况具体分析，只有分析了具体的性能数据才能有结论，否则只是纸上谈兵一纸空文。
</code></pre>

<p>4.两篇文档
linux-source/Documentation/networking/tproxy.txt
linux-source/Documentation/networking/policy-routing.txt</p>

<p><a href="http://linux.sheup.com/linux/38/linux23335.htm">http://linux.sheup.com/linux/38/linux23335.htm</a></p>

<p>懂得网络配置命令是一般技术人员必备的技术,经过一段时间的研究和学习,总结了一些常用的命令和示例以便日后查阅.
传统的在1&ndash;3点,ip高级路由命令在4&ndash;12点,两者部分可以通用,并达到同样的目的,但ip的功能更强大,可以实现更多的配置目的。
首先,先了解传统的网络配置命令:
1. 使用ifconfig命令配置并查看网络接口情况
示例1: 配置eth0的IP，同时激活设备:</p>

<h1 id="ifconfig-eth0-192-168-4-1-netmask-255-255-255-0-up">ifconfig eth0 192.168.4.1 netmask 255.255.255.0 up</h1>

<p>示例2: 配置eth0别名设备 eth0:1 的IP，并添加路由</p>

<h1 id="ifconfig-eth0-1-192-168-4-2">ifconfig eth0:1 192.168.4.2</h1>

<h1 id="route-add-host-192-168-4-2-dev-eth0-1">route add –host 192.168.4.2 dev eth0:1</h1>

<p>示例3:激活（禁用）设备</p>

<h1 id="ifconfig-eth0-1-up-down">ifconfig eth0:1 up(down)</h1>

<p>示例4:查看所有（指定）网络接口配置</p>

<h1 id="ifconfig-eth0">ifconfig (eth0)</h1>

<ol>
<li><p>使用route 命令配置路由表
示例1:添加到主机路由</p>

<h1 id="route-add-host-192-168-4-2-dev-eth0-1-1">route add –host 192.168.4.2 dev eth0:1</h1>

<h1 id="route-add-host-192-168-4-1-gw-192-168-4-250">route add –host 192.168.4.1 gw 192.168.4.250</h1>

<p>示例2:添加到网络的路由</p>

<h1 id="route-add-net-ip-netmask-mask-eth0">route add –net IP netmask MASK eth0</h1>

<h1 id="route-add-net-ip-netmask-mask-gw-ip">route add –net IP netmask MASK gw IP</h1>

<h1 id="route-add-net-ip-24-eth1">route add –net IP/24 eth1</h1>

<p>示例3:添加默认网关</p>

<h1 id="route-add-default-gw-ip">route add default gw IP</h1>

<p>示例4:删除路由</p>

<h1 id="route-del-host-192-168-4-1-dev-eth0-1">route del –host 192.168.4.1 dev eth0:1</h1>

<p>示例5:查看路由信息</p>

<h1 id="route-或-route-n-n-表示不解析名字-列出速度会比route-快">route 或 route -n (-n 表示不解析名字,列出速度会比route 快)</h1>

<p>3.ARP 管理命令
示例1:查看ARP缓存</p>

<h1 id="arp">arp</h1>

<p>示例2: 添加</p>

<h1 id="arp-s-ip-mac">arp –s IP MAC</h1>

<p>示例3: 删除</p>

<h1 id="arp-d-ip">arp –d IP</h1></li>

<li><p>ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具。例如：ifconfig、route等,
上面的示例完全可以用下面的ip命令实现,而且ip命令可以实现更多的功能.下面介绍一些示例:
4.0 ip命令的语法
ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]
4.1 ip link set&ndash;改变设备的属性. 缩写：set、s
示例1：up/down 起动／关闭设备。</p>

<h1 id="ip-link-set-dev-eth0-up">ip link set dev eth0 up</h1>

<p>这个等于传统的 # ifconfig eth0 up(down)
示例2：改变设备传输队列的长度。
参数:txqueuelen NUMBER或者txqlen NUMBER</p>

<h1 id="ip-link-set-dev-eth0-txqueuelen-100">ip link set dev eth0 txqueuelen 100</h1>

<p>示例3：改变网络设备MTU(最大传输单元)的值。</p>

<h1 id="ip-link-set-dev-eth0-mtu-1500">ip link set dev eth0 mtu 1500</h1>

<p>示例4： 修改网络设备的MAC地址。
参数: address LLADDRESS</p>

<h1 id="ip-link-set-dev-eth0-address-00-01-4f-00-15-f1">ip link set dev eth0 address 00:01:4f:00:15:f1</h1>

<p>4.2 ip link show&ndash;显示设备属性. 缩写：show、list、lst、sh、ls、l
-s选项出现两次或者更多次，ip会输出更为详细的错误信息统计。
示例:</p>

<h1 id="ip-s-s-link-ls-eth0-eth0-mtu-1500-qdisc-cbq-qlen-100-link-ether-00-a0-cc-66-18-78-brd-ff-ff-ff-ff-ff-ff-rx-bytes-packets-errors-dropped-overrun-mcast-2449949362-2786187-0-0-0-0-rx-errors-length-crc-frame-fifo-missed-0-0-0-0-0-tx-bytes-packets-errors-dropped-carrier-collsns-178558497-1783946-332-0-332-35172-tx-errors-aborted-fifo-window-heartbeat-0-0-0-332-这个命令等于传统的-ifconfig-eth0-5-1-ip-address-add-添加一个新的协议地址-缩写-add-a">ip -s -s link ls eth0 eth0: mtu 1500 qdisc cbq qlen 100 link/ether 00:a0:cc:66:18:78 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 2449949362 2786187 0 0 0 0 RX errors: length crc frame fifo missed 0 0 0 0 0 TX: bytes packets errors dropped carrier collsns 178558497 1783946 332 0 332 35172 TX errors: aborted fifo window heartbeat 0 0 0 332 这个命令等于传统的 ifconfig eth0 5.1 ip address add&ndash;添加一个新的协议地址. 缩写：add、a</h1>

<p>示例1：为每个地址设置一个字符串作为标签。为了和Linux-2.0的网络别名兼容，这个字符串必须以设备名开头，接着一个冒号，</p>

<h1 id="ip-addr-add-local-192-168-4-1-28-brd-label-eth0-1-dev-eth0">ip addr add local 192.168.4.<sup>1</sup>&frasl;<sub>28</sub> brd + label eth0:1 dev eth0</h1>

<p>示例2: 在以太网接口eth0上增加一个地址192.168.20.0，掩码长度为24位(155.155.155.0)，标准广播地址，标签为eth0:Alias：</p>

<h1 id="ip-addr-add-192-168-4-2-24-brd-dev-eth1-label-eth1-1">ip addr add 192.168.4.<sup>2</sup>&frasl;<sub>24</sub> brd + dev eth1 label eth1:1</h1>

<p>这个命令等于传统的: ifconfig eth1:1 192.168.4.2
5.2 ip address delete&ndash;删除一个协议地址. 缩写：delete、del、d</p>

<h1 id="ip-addr-del-192-168-4-1-24-brd-dev-eth0-label-eth0-alias1">ip addr del 192.168.4.<sup>1</sup>&frasl;<sub>24</sub> brd + dev eth0 label eth0:Alias1</h1>

<p>5.3 ip address show&ndash;显示协议地址. 缩写：show、list、lst、sh、ls、l</p>

<h1 id="ip-addr-ls-eth0">ip addr ls eth0</h1>

<p>5.4.ip address flush&ndash;清除协议地址. 缩写：flush、f
示例1 : 删除属于私网10.0.0.0/8的所有地址：</p>

<h1 id="ip-s-s-a-f-to-10-8">ip -s -s a f to <sup>10</sup>&frasl;<sub>8</sub></h1>

<p>示例2 : 取消所有以太网卡的IP地址</p>

<h1 id="ip-4-addr-flush-label-eth0">ip -4 addr flush label &ldquo;eth0&rdquo;</h1></li>

<li><p>ip neighbour&ndash;neighbour/arp表管理命令
缩写 neighbour、neighbor、neigh、n
命令 add、change、replace、delete、fulsh、show(或者list)
6.1 ip neighbour add &ndash; 添加一个新的邻接条目
ip neighbour change&ndash;修改一个现有的条目
ip neighbour replace&ndash;替换一个已有的条目
缩写：add、a；change、chg；replace、repl
示例1: 在设备eth0上，为地址10.0.0.3添加一个permanent ARP条目：</p>

<h1 id="ip-neigh-add-10-0-0-3-lladdr-0-0-0-0-0-1-dev-eth0-nud-perm">ip neigh add 10.0.0.3 lladdr 0:0:0:0:0:1 dev eth0 nud perm</h1>

<p>示例2:把状态改为reachable</p>

<h1 id="ip-neigh-chg-10-0-0-3-dev-eth0-nud-reachable">ip neigh chg 10.0.0.3 dev eth0 nud reachable</h1>

<p>6.2.ip neighbour delete&ndash;删除一个邻接条目
示例1:删除设备eth0上的一个ARP条目10.0.0.3</p>

<h1 id="ip-neigh-del-10-0-0-3-dev-eth0">ip neigh del 10.0.0.3 dev eth0</h1>

<p>6.3.ip neighbour show&ndash;显示网络邻居的信息. 缩写：show、list、sh、ls
示例1: # ip -s n ls 193.233.7.254
193.233.7.254. dev eth0 lladdr 00:00:0c:76:3f:85 ref 5 used 12/13/20 nud reachable
6.4.ip neighbour flush&ndash;清除邻接条目. 缩写：flush、f
示例1: (-s 可以显示详细信息)</p>

<h1 id="ip-s-s-n-f-193-233-7-254">ip -s -s n f 193.233.7.254</h1></li>

<li><p>路由表管理
7.1.缩写 route、ro、r
7.5.路由表
从Linux-2.2开始，内核把路由归纳到许多路由表中，这些表都进行了编号，编号数字的范围是1到255。另外，
为了方便，还可以在/etc/iproute2/rt_tables中为路由表命名。
默认情况下，所有的路由都会被插入到表main(编号254)中。在进行路由查询时，内核只使用路由表main。
7.6.ip route add &ndash; 添加新路由
ip route change &ndash; 修改路由
ip route replace &ndash; 替换已有的路由
缩写：add、a；change、chg；replace、repl
示例1: 设置到网络10.0.0/24的路由经过网关193.233.7.65</p>

<h1 id="ip-route-add-10-0-0-24-via-193-233-7-65">ip route add 10.0.0/24 via 193.233.7.65</h1>

<p>示例2: 修改到网络10.0.0/24的直接路由，使其经过设备dummy</p>

<h1 id="ip-route-chg-10-0-0-24-dev-dummy">ip route chg 10.0.0/24 dev dummy</h1>

<p>示例3: 实现链路负载平衡.加入缺省多路径路由，让ppp0和ppp1分担负载(注意：scope值并非必需，它只不过是告诉内核，这个路由要经过网关而不是直连的。实际上，如果你知道远程端点的地址，使用via参数来设置就更好了)。</p>

<h1 id="ip-route-add-default-scope-global-nexthop-dev-ppp0-nexthop-dev-ppp1">ip route add default scope global nexthop dev ppp0 nexthop dev ppp1</h1>

<h1 id="ip-route-replace-default-scope-global-nexthop-dev-ppp0-nexthop-dev-ppp1">ip route replace default scope global nexthop dev ppp0 nexthop dev ppp1</h1>

<p>示例4: 设置NAT路由。在转发来自192.203.80.144的数据包之前，先进行网络地址转换，把这个地址转换为193.233.7.83</p>

<h1 id="ip-route-add-nat-192-203-80-142-via-193-233-7-83">ip route add nat 192.203.80.142 via 193.233.7.83</h1>

<p>示例5: 实现数据包级负载平衡,允许把数据包随机从多个路由发出。weight 可以设置权重.</p>

<h1 id="ip-route-replace-default-equalize-nexthop-via-211-139-218-145-dev-eth0-weight-1-nexthop-via-211-139-218-145-dev-eth1-weight-1">ip route replace default equalize nexthop via 211.139.218.145 dev eth0 weight 1 nexthop via 211.139.218.145 dev eth1 weight 1</h1>

<p>7.7.ip route delete&ndash; 删除路由
缩写：delete、del、d
示例1:删除上一节命令加入的多路径路由</p>

<h1 id="ip-route-del-default-scope-global-nexthop-dev-ppp0-nexthop-dev-ppp1">ip route del default scope global nexthop dev ppp0 nexthop dev ppp1</h1>

<p>7.8.ip route show &ndash; 列出路由
缩写：show、list、sh、ls、l
示例1: 计算使用gated/bgp协议的路由个数</p>

<h1 id="ip-route-ls-proto-gated-bgp-wc">ip route ls proto gated/bgp |wc</h1>

<p>1413 9891 79010
示例2: 计算路由缓存里面的条数，由于被缓存路由的属性可能大于一行，以此需要使用-o选项</p>

<h1 id="ip-o-route-ls-cloned-wc">ip -o route ls cloned |wc</h1>

<p>159 2543 18707
示例3: 列出路由表TABLEID里面的路由。缺省设置是table main。TABLEID或者是一个真正的路由表ID或者是/etc/iproute2/rt_tables文件定义的字符串，
或者是以下的特殊值：
all &ndash; 列出所有表的路由；
cache &ndash; 列出路由缓存的内容。
ip ro ls 193.233.7.82 tab cache
示例4: 列出某个路由表的内容</p>

<h1 id="ip-route-ls-table-fddi153">ip route ls table fddi153</h1>

<p>示例5: 列出默认路由表的内容</p>

<h1 id="ip-route-ls">ip route ls</h1>

<p>这个命令等于传统的: route
7.9.ip route flush &ndash; 擦除路由表
示例1: 删除路由表main中的所有网关路由（示例：在路由监控程序挂掉之后）：</p>

<h1 id="ip-4-ro-flush-scope-global-type-unicast">ip -4 ro flush scope global type unicast</h1>

<p>示例2:清除所有被克隆出来的IPv6路由：</p>

<h1 id="ip-6-s-s-ro-flush-cache">ip -6 -s -s ro flush cache</h1>

<p>示例3: 在gated程序挂掉之后，清除所有的BGP路由：</p>

<h1 id="ip-s-ro-f-proto-gated-bgp">ip -s ro f proto gated/bgp</h1>

<p>示例4: 清除所有ipv4路由cache</p>

<h1 id="ip-route-flush-cache">ip route flush cache</h1>

<p>*** IPv4 routing cache is flushed.
7.10 ip route get &ndash; 获得单个路由 .缩写：get、g
使用这个命令可以获得到达目的地址的一个路由以及它的确切内容。
ip route get命令和ip route show命令执行的操作是不同的。ip route show命令只是显示现有的路由，而ip route get命令在必要时会派生出新的路由。
示例1: 搜索到193.233.7.82的路由</p>

<h1 id="ip-route-get-193-233-7-82">ip route get 193.233.7.82</h1>

<p>193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac cache mtu 1500 rtt 300
示例2: 搜索目的地址是193.233.7.82，来自193.233.7.82，从eth0设备到达的路由（这条命令会产生一条非常有意思的路由，这是一条到193.233.7.82的回环路由）</p>

<h1 id="ip-r-g-193-233-7-82-from-193-233-7-82-iif-eth0">ip r g 193.233.7.82 from 193.233.7.82 iif eth0</h1>

<p>193.233.7.82 from 193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac/inr.ac
cache ; mtu 1500 rtt 300 iif eth0</p></li>

<li><p>ip route &ndash; 路由策略数据库管理命令
命令　　add、delete、show(或者list)
注意：策略路由(policy routing)不等于路由策略(rouing policy)。
在某些情况下，我们不只是需要通过数据包的目的地址决定路由，可能还需要通过其他一些域：源地址、IP协议、传输层端口甚至数据包的负载。
这就叫做：策略路由(policy routing)。
8.5. ip rule add &ndash; 插入新的规则
ip rule delete &ndash; 删除规则
缩写：add、a；delete、del、d
示例1: 通过路由表inr.ruhep路由来自源地址为192.203.80/24的数据包
ip ru add from 192.203.<sup>80</sup>&frasl;<sub>24</sub> table inr.ruhep prio 220
示例2:把源地址为193.233.7.83的数据报的源地址转换为192.203.80.144，并通过表1进行路由
ip ru add from 193.233.7.83 nat 192.203.80.144 table 1 prio 320
示例3:删除无用的缺省规则
ip ru del prio 32767
8.7. ip rule show &ndash; 列出路由规则
缩写：show、list、sh、ls、l
示例1: # ip ru ls
0: from all lookup local
32762: from 192.168.4.89 lookup fddi153
32764: from 192.168.4.88 lookup fddi153
32766: from all lookup main
32767: from all lookup 253</p></li>

<li><p>ip maddress &ndash; 多播地址管理
缩写：show、list、sh、ls、l
9.3.ip maddress show &ndash; 列出多播地址
示例1: # ip maddr ls dummy
9.4. ip maddress add &ndash; 加入多播地址
ip maddress delete &ndash; 删除多播地址
缩写：add、a；delete、del、d
使用这两个命令，我们可以添加／删除在网络接口上监听的链路层多播地址。这个命令只能管理链路层地址。
示例1: 增加 # ip maddr add 33:33:00:00:00:01 dev dummy
示例2: 查看 # ip -O maddr ls dummy
2: dummy
link 33:33:00:00:00:01 users 2 static
link 01:00:5e:00:00:01
示例3: 删除 # ip maddr del 33:33:00:00:00:01 dev dummy
10.ip mroute &ndash; 多播路由缓存管理
10.4. ip mroute show &ndash; 列出多播路由缓存条目
缩写：show、list、sh、ls、l
示例1:查看 # ip mroute ls
(193.232.127.6, 224.0.1.39) Iif: unresolved
(193.232.244.34, 224.0.1.40) Iif: unresolved
(193.233.7.65, 224.66.66.66) Iif: eth0 Oifs: pimreg
示例2:查看 # ip -s mr ls 224.<sup>66</sup>&frasl;<sub>16</sub>
(193.233.7.65, 224.66.66.66) Iif: eth0 Oifs: pimreg
9383 packets, 300256 bytes</p></li>

<li><p>ip tunnel &ndash; 通道配置
缩写　tunnel、tunl
11.4.ip tunnel add &ndash; 添加新的通道
ip tunnel change &ndash; 修改现有的通道
ip tunnel delete &ndash; 删除一个通道
缩写：add、a；change、chg；delete、del、d
示例1:建立一个点对点通道，最大TTL是32</p>

<h1 id="ip-tunnel-add-cisco-mode-sit-remote-192-31-7-104-local-192-203-80-1-ttl-32">ip tunnel add Cisco mode sit remote 192.31.7.104 local 192.203.80.1 ttl 32</h1>

<p>11.4.ip tunnel show &ndash; 列出现有的通道
缩写：show、list、sh、ls、l
示例1: # ip -s tunl ls Cisco</p></li>

<li><p>ip monitor和rtmon &ndash; 状态监视
ip命令可以用于连续地监视设备、地址和路由的状态。这个命令选项的格式有点不同，命令选项的名字叫做monitor，接着是操作对象：
ip monitor [ file FILE ] [ all | OBJECT-LIST ]
示例1: # rtmon file /var/log/rtmon.log
示例2: # ip monitor file /var/log/rtmon.log r</p></li>
</ol>

<p><a href="http://zhoulifa.bokee.com/6192551.html">http://zhoulifa.bokee.com/6192551.html</a></p>

<p>高级网络工具iproute
作者： 周立发2007-03-29 18:52分类：默认分类标签：</p>

<p>IPRoute 的内容
安装的程序： ctstat (链接到 lnstat), ifcfg, ifstat, ip, lnstat, nstat, routef, routel, rtacct, rtmon, rtpr, rtstat (链接到 lnstat), ss, tc
简要描述
ctstat</p>

<p>连接状态工具
ifcfg</p>

<p>ip 命令的shell脚本包装
ifstat</p>

<p>显示网络接口的统计信息，包括接口发送和接收到的包数量。
ip</p>

<p>主可执行程序，它包含以下几个功能：</p>

<p>ip link [device] 查看和修改设备状态</p>

<p>ip addr 查看地址的特性，添加新地址、删除旧地址。</p>

<p>ip neighbor 查看邻居的特性，添加新邻居、删除旧邻居。</p>

<p>ip rule 查看和修改路由规则</p>

<p>ip route 查看路由表和修改路由表规则</p>

<p>ip tunnel 查看和修改 IP 隧道及其特性</p>

<p>ip maddr 查看和修改多播地址及其特性</p>

<p>ip mroute 设置、修改、删除多播路由</p>

<p>ip monitor 不间断的监视设备状态、地址、路由
lnstat</p>

<p>提供 Linux 网络统计信息，用于替代旧的 rtstat 程序。
nstat</p>

<p>显示网络统计信息
routef</p>

<p>ip route 的一个组件，用于刷新路由表。
routel</p>

<p>ip route 的一个组件，用于列出路由表。
rtacct</p>

<p>显示 /proc/net/rt_acct 文件的内容
rtmon</p>

<p>路由监视工具
rtpr</p>

<p>将 ip -o 的输出转换为可读的格式
rtstat</p>

<p>路由状态工具
ss</p>

<p>类似于 netstat 命令，显示活动的连接。
tc</p>

<p>流量控制，用于实现服务质量(QOS)和服务级别(COS)：</p>

<p>tc qdisc 建立排队规则</p>

<p>tc class 建立基于级别的队列调度</p>

<p>tc estimator 估算网络流量</p>

<p>tc filter 设置 QOS/COS 包过滤器</p>

<p>tc policy 设置 QOS/COS 规则</p>

<p>其中ss命令用法如下：</p>

<p>Usage: ss [ OPTIONS ]
       ss [ OPTIONS ] [ FILTER ]
   -h, &ndash;help           this message
   -V, &ndash;version        output version information
   -n, &ndash;numeric        don&rsquo;t resolve service names
   -r, &ndash;resolve       resolve host names
   -a, &ndash;all            display all sockets
   -l, &ndash;listening      display listening sockets
   -o, &ndash;options       show timer information
   -e, &ndash;extended      show detailed socket information
   -m, &ndash;memory        show socket memory usage
   -p, &ndash;processes      show process using socket
   -i, &ndash;info           show internal TCP information
   -s, &ndash;summary        show socket usage summary</p>

<p>-4, &ndash;ipv4          display only IP version 4 sockets
   -6, &ndash;ipv6          display only IP version 6 sockets
   -0, &ndash;packet display PACKET sockets
   -t, &ndash;tcp            display only TCP sockets
   -u, &ndash;udp            display only UDP sockets
   -d, &ndash;dccp           display only DCCP sockets
   -w, &ndash;raw            display only RAW sockets
   -x, &ndash;unix           display only Unix domain sockets
   -f, &ndash;family=FAMILY display sockets of type FAMILY</p>

<p>-A, &ndash;query=QUERY
       QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]</p>

<p>-F, &ndash;filter=FILE   read filter information from FILE
       FILTER := [ state TCP-STATE ] [ EXPRESSION ]</p>

<p><a href="http://m.oschina.net/blog/3046">http://m.oschina.net/blog/3046</a>
Linux高级路由&mdash;策略路由/捆绑/网桥</p>

<p>企图穿越 发布于 5年前，共有 0 条评论</p>

<p>1.策略路由
    基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小、应用或IP源地址来选择转发路 径&hellip;<br />
    #/etc/iproute2/rt_tables 此文件存有linux 系统路由表默认表有255 254 253三张表
      255  local 本地路由表 存有本地接口地址，广播地址，已及NAT地址.
           local表由系统自动维护..管理员不能操作此表&hellip;
      254  main 主路由表 传统路由表,ip route若没指定表亦操作表254.一般存所有的路由..
           注:平时用ip ro sh查看的亦是此表设置的路由.
      253  default  默认路由表一般存放默认路由&hellip;
           注：rt_tables文件中表以数字来区分表0保留最多支持255张表
    路由表的查看可有以下二种方法：
      #ip route list table table_number
      #ip route list table table_name
    路由表添加完毕,即可在策略路由表内添加路由例:
      #ip route add 192.168.1.0/24 dev eth0 via 192.168.1.66 realm 4
        注:发往子网192.168.1.0/24的数据包通过分类4转发配合tc使用,后文有介绍讲解&hellip;
      #ip route add default via 192.168.1.1 table int1
      #ip route add 192.168.1.0/24 via 192.168.1.1 table int2
      #ip route add 172.16.0.<sup>2</sup>&frasl;<sub>16</sub> via 172.16.0.1 table int3
        注:各路由表中应当指明默认路由,尽量不回查路由表.路由添加完毕,即可在路由规则中应用..
    #ip rule sh 显示路由规则
      0:      from all lookup local
      32766:  from all lookup main
      32767:  from all lookup default
    进行路由时，正是根据路由规则来进行匹配，按优先级(pref后数值)从高到低匹配,直到找到合适的规则.所以在应用中配置默认路由是必要的..<br />
    策略路由一般手工添加路由表，路由表的添加只需编辑rt_tables文件，规定表序号，表名即可..
    ip rule规则添加示例：
      #ip rule add from 192.168.1.<sup>112</sup>&frasl;<sub>32</sub> [tos 0x10] table test2 pref 999 prohibit
      #ip rule add to 192.168.1.2 pref 1000 table test1
      #ip rule add from 192.168.1.0/24 pref 1001 table test1
      #ip rule add [from 0/0] table test1 pref 1003
      #ip rule add fwmark 1 pref 1002 table test2  此句型配合iptables -t mangle应用.如先对数据
  包作标记:
      #iptables -t mangle -A PREROUTING -p tcp -m multiport
                             &ndash;dports 80,8080,20,21 -s 192.168.1.0/24 -j MARK &ndash;set-mark 1<br />
        注：创建完路由规则若需立即生效须执行#ip route flush cache;刷新路由缓冲
    可参数解析如下：
        From &ndash; 源地址
        To &ndash; 目的地址（这里是选择规则时使用，查找路由表时也使用）
    Tos &ndash; IP包头的TOS（type of sevice）域
    Dev &ndash; 物理接口
    　Fwmark &ndash; 防火墙参数
    采取的动作除了指定路由表外，还可以指定下面的动作：
        Table 指明所使用的表
  　    Nat 透明网关
    Prohibit 丢弃该包，并发送 COMM.ADM.PROHIITED的ICMP信息
    Reject 单纯丢弃该包
    Unreachable丢弃该包， 并发送 NET UNREACHABLE的ICMP信息
    具体格式如下：
        Usage: ip rule [ list | add | del ] SELECTOR ACTION
        SELECTOR := [ from PREFIX ] [ to PREFIX ] [ tos TOS ][ dev STRING ] [ pref NUMBER ]
        ACTION := [ table TABLE_ID ] [ nat ADDRESS ][ prohibit | reject | unreachable ]
                  [ flowid CLASSID ]
        TABLE_ID := [ local | main | default | new | NUMBER ]</p>

<p>2.网卡捆绑(网关linux+多网卡)
    #modprobe bonding mod=1 miimon=200 primary=eth1 创建bond0,模式为1,主网卡eth1..
    #ip addr add dev bond$ 10.0.0.<sup>1</sup>&frasl;<sub>24</sub> 设置bond0的IP
    #ifenslave bond0 eth1 eth2 添加绑定的dev
      注:mode=0 轮转均衡(默认模式),此模式MAC频繁切换导致交换机负载大..
         mode=1 主备模式 用primary指定网卡
         mode=4 常用 802.3ad模式,动态链路采集模式.此模式要求SWITCH捆绑..
         miimon=ms 每隔多少毫秒查询链路是否有效.
      其它参数如:
         arp_interval=ms
         arp_ip_target=<em>.</em>.<em>.</em></p>

<pre><code>另一种网卡捆绑固化方式:
  #vi /etc/modules.conf 加入以下行
　　alias bond0 bonding
    系统在启动时加载bonding模块，对外虚拟网络接口设备为 bond0..
  #cd /etc/sysconfig/network-scripts
  #vi ifcfg-bond0
    DEVICE=bond0
    IPADDR=11.0.0.1
    NETMASK=255.0.0.0
    NETWORK=192.168.1.0
    BROADCAST=192.168.1.255
    ONBOOT=yes
    BOOTPROTO=none
    USERCTL=no
  #vi ifcfg-eth0  
    DEVICE=eth0
    USERCTL=no
    ONBOOT=yes
    MASTER=bond0
    SLAVE=yes
    BOOTPROTO=none
  #vi ifcfg-eth1
    DEVICE=eth0
    USERCTL=no
    ONBOOT=yes
    MASTER=bond0
    SLAVE=yes
    BOOTPROTO=none
 #/etc/init.d/network restart 重启网络服务验证网卡的配置信息备份网卡被加上了NOARP标记
 #cat /proc/net/bond0/info 查看bond信息
</code></pre>

<p>3.网桥(Linux+多网卡)
    配置工具 brctl <a href="http://bridge.sourceforge.net/">http://bridge.sourceforge.net/</a>  源码包名:bridge-utils-*形式
    安装第一步:autoconf 后类同于源码包安装..
    例.linu+二网卡eth0 eth1 配置成网桥
      配置前去除加入网桥的eth0 eth1的IP
      #ifconfig eth0/eth1 down
      #ifconfig eth0/eth1 0.0.0.0 up
      #brctl addbr br0
      #brctl addif br0 eth0 eth1
      #ip li set dev br0 up
      #brctl showmacs br0 显示网桥MAC
    撤网桥:
      #ip li set dev br0 down
      #brctl delif br0 eth0 eth1
      #brctl delbr br0
    网桥接口处亦可进行流量控制,无Ip的linux网桥可有效防御外界的功击,对linux网桥机的总控安全性高&hellip;</p>

<pre><code>贴上一篇网桥应用实例,此实例是网桥的一种扩张应用...
  脚本名:start_bridge.sh
  #!/bin/sh
  brctl addbr net1
  brctl addif net1 eth0
  ifconfig eth0 down
  ifconfig eth0 0.0.0.0 up
  ifconfig net1 192.168.5.1 up
  #ip ro del 192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.28
  ip ro del 192.168.1.0/24
  #route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.5.2
  ip route add default via 192.168.5.2
  echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward
</code></pre>

<p>Linux高级路由需结合iptables才能充分体现其功能的强大,实际工作中的应用多半基于此,当然要熟练掌握Linux高级路由+iptables 还需进一步的加强学习和实践的应用&hellip;
#################################################################################################################################</p>

<p>传统路由器在网络和需求变得复杂时将无法满足需要，而一种基于策略的路由给了我们更好的选择。本文给出一个Linux下的配置实例，它在2.4G奔 腾4处理器、256M内存的计算机上运行通过，并在160多台电脑的网络环境下运转正常。</p>

<p>基于策略的路由比传统路由更强大，使用更灵活，它使网络管理者不仅能够根据目的地址而且能够根据报文大小、应用或IP源地址来选择转发路 径。在现实的网络应用中，这种选择的自由性还是很需要的。而Linux从2.1版本的内核开始就实现了对策略路由的支持，下面就介绍一个配置实例，以期对 读者有所帮助。</p>

<p>实例背景</p>

<p>如图所示，两个内部网通过远端路由器1与因特网相联，通过远端路由器2与上级网相联， Linux服务器做策略路由器，内有4块网卡。IP地址的分配情况如表所示。</p>

<p>在应用需求方面，内网1允许通过远端路由器1（172.22.254.254）连接因特网，但只允许Http协议、FTP协议经常性通过， 其他协议分时间段开放（这样做是为了避免员工在上班时间打网络游戏和聊天），例如在上班时间（7:30～16:30）封闭，在下班时间 （16:30～7:30）和周六、日全天开放。而且，内网1无权访问内网2及上级网，但可以访问内网2上的服务器。而允许内网2访问外网，上级网则只能访 问内网2上的192.168.1.2服务器。而防火墙主要用来阻止外网主动访问内网，防止网络攻击。</p>

<p>实现过程</p>

<p>这里我们选择Red Hat Enterprise Linux WS 3操作系统，其内核版本是2.4.21，对策略路由已经有了很好的支持，下面的配置也以此为基础。</p>

<p>1．设置IP地址</p>

<p>首先，执行如下命令：</p>

<p>ifconfig eth0 10.89.9.1 netmask 255.255.255.0</p>

<p>ifconfig eth1 192.168.1.1 netmask 255.255.255.0</p>

<p>ifconfig eth2 172.22.254.14 netmask 255.255.255.0</p>

<p>ifconfig eth3 10.140.133.14 netmask 255.255.255.0</p>

<p>为了让计算机启动时自动设置IP地址，还需要分别修改/etc/sysconfig/network-scripts/下的四个文 件：ifcfg-eth0、ifcfg-eth1、ifcfg-eth2、ifcfg-eth3，将ONBOOT属性设为yes，即 “ONBOOT=yes”，文件格式如下：</p>

<h1 id="intel-corp-82545em-gigabit-ethernet-controller-copper">Intel Corp.82545EM Gigabit Ethernet Controller (Copper)</h1>

<p>DEVICE=eth0</p>

<p>BOOTPROTO=none</p>

<p>HWADDR=00:0c:76:20:54:71</p>

<p>ONBOOT=yes</p>

<p>TYPE=Ethernet</p>

<p>USERCTL=yes</p>

<p>PEERDNS=no</p>

<p>NETMASK=255.255.255.0</p>

<p>IPADDR=10.89.9.1</p>

<p>如果你不喜欢命令行模式，也可以在图形模式下进行以上操作：主菜单→系统设置→网络,设好IP地址并激活，并且选中“当计算机启动时激活设 备”选项。</p>

<p>2．打开转发功能</p>

<p>执行命令“echo “1” &gt; /proc/sys/net/ipv4/ip_forward”，或者在/etc/sysconfig/network文件中添加 “FORWARD_IPV4=yes”。</p>

<p>3．创建路由表</p>

<p>编辑 /etc/iproute2/rt_tables 文件，执行如下命令。在这里新添加了4个路由表，分别为int1 、int2、int3、int4。</p>

<h1 id="reserved-values">reserved values</h1>

<p>#255 local</p>

<p>#254 main</p>

<p>#253 default</p>

<p>#0 unspec</p>

<h1 id="local">local</h1>

<p>#1 inr.ruhep</p>

<p>1 int1</p>

<p>2 int2</p>

<p>3 int3</p>

<p>4 int4</p>

<p>4．添加路由</p>

<p>执行如下命令：</p>

<p>ip route add default via 10.89.9.1 table int1</p>

<p>ip route add default via 192.168.1.1 table int2</p>

<p>ip route add default via 172.22.254.254 table int3</p>

<p>ip route add 192.168.0.0/16 via 10.140.133.254 table int4</p>

<p>ip route add default via 172.22.254.254 table int4</p>

<p>这里在int4路由表中添加了两条路由，当进入到该路由表之后，要到192.168.0.0/16的数据包则路由到 10.140.133.254，其他数据包则路由到172.22.254.254。</p>

<p>5．标记（MARK）特殊包</p>

<p>执行如下两条命令：</p>

<p>iptables -t mangle -A PREROUTING -p tcp -m multiport &ndash;dports 80,8080,20,21 -s 10.89.9.0/24 -j MARK &ndash;set-mark 1</p>

<p>iptables -t mangle -A PREROUTING -p udp &ndash;dport 53 -s 10.89.9.0/24 -j MARK &ndash;set-mark 2</p>

<p>这两条命令是将来自10.89.9.0/24的目的端口是80、8080、20或21的数据包和UDP端口是53的数据包分别标记为1或 2，然后就可以针对这些标记过的数据包制定相应的规则了。（对外发出的DNS请求用的是UDP 53端口）</p>

<p>为了实现防火墙的功能，只允许已经建立联机的数据包进入内网，就要把进入两个内网的已经建立联机的数据包进行标记。执行如下命令：</p>

<p>iptables -t mangle -A PREROUTING -p ALL -d 10.89.9.0/24 -m state &ndash;state ESTABLISHED,RELATED -j MARK &ndash;set-mark 3</p>

<p>iptables -t mangle -A PREROUTING -p ALL -d 192.168.1.0/24 -m state &ndash;state ESTABLISHED,RELATED -j MARK &ndash;set-mark 4</p>

<p>6．创建路由规则</p>

<p>执行如下命令：</p>

<p>ip rule add from 192.168.1.0/24 pref 11 table int4</p>

<p>ip rule add to 192.168.1.2 pref 21 table int2</p>

<p>ip rule add fwmark 4 pref 31 table int2</p>

<p>ip rule add fwmark 1 pref 41 table int3</p>

<p>ip rule add fwmark 2 pref 42 table int3</p>

<p>ip rule add fwmark 3 pref 51 table int1</p>

<p>接着执行命令“ip route flush cache”，刷新路由缓冲，让以上的这些命令立刻生效，否则需要等上一段时间。</p>

<p>7．实现分时间段控制</p>

<p>若是按照以上的配置，内网1的用户只能上网浏览网页和下载，为了对其他功能实现分时间段开放，需要做以下工作：</p>

<p>首先编辑命令脚本文件ropen (开放)和rclose (限制)。执行命令“vi /bin/ropen”，ropen文件内容如下：</p>

<p>/sbin/ip rule add from 10.89.9.0/24 pref 40 table int3</p>

<p>/sbin/ip route flush cache</p>

<p>执行命令“vi /bin/rclose”，rclose文件内容如下：</p>

<p>/sbin/ip rule del from 10.89.9.0/24 pref 40</p>

<p>/sbin/ip route flush cache</p>

<p>如果不习惯命令行方式，也可以在图形界面下生成这两个文件，生成文件之后，需要增加可执行属性方可执行：分别执行命令“chmod +x ropen”和“chmod +x rclose”。</p>

<p>接着，利用crontab命令实现自动运行。这里需要编辑一个文本文件，格式如下：</p>

<p>minute hour dayofmonth monthofyear dayofweek “命令”</p>

<p>其中每部分名称及取值范围是：minute代表分钟，取值范围是00～59；hour代表小时，取值范围是 00～23；dayofmonth代表某天，取值范围是01～31；monthofyear代表月份，取值范围是01～12；dayofweek代表星 期，取值范围是01～07。若需要忽略其中某一部分就用星号（*）代替。例如，文件名设为mycron，内容可编辑如下：</p>

<p>30 07 * * 01,02,03,04,05 &ldquo;/bin/ropen&rdquo;</p>

<p>30 16 * * 01,02,03,04,05 &ldquo;/bin/rclose&rdquo;</p>

<p>最后执行crontab命令，将所编辑的文件mycron装载并启动，命令为“crontab mycron”。</p>

<p><a href="http://rhcss.blog.51cto.com/672018/133812">http://rhcss.blog.51cto.com/672018/133812</a>
linux 高级路由及流量控制总结
2009-02-28 22:40:27
标签：高级路由 休闲 流量控制 linux 职场
版权声明：原创作品，如需转载，请与作者联系。否则将追究法律责任。
看了这么多天的关于流量控制的资料后，现在大脑里还是很乱，理不清晰，只好将目前所能够理理的暂时总结一下。
在Linux系统中，有一个非常重要的路由的包文件&mdash;&ndash;iproute，其中包含了两个最重要的工具ip和tc。
iproute的程序站点为：<a href="http://www.linuxfoundation.org/en/Net:Iproute2">http://www.linuxfoundation.org/en/Net:Iproute2</a>
iproute的文档站点为：<a href="http://lartc.org/">http://lartc.org/</a>
ip命令主要用于配置接口，ARP，tunnel（隧道）以及策略路由等等。
tc命令主要用于配置流量控制和策略管理，两者可以单独使用，也可以相互结合使用。
二、ip命令的使用
root@router:~# ip help
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }
where OBJECT := { link | addr | route | rule | neigh | tunnel |
maddr | mroute | monitor | xfrm }
OPTIONS := { -V[ersion] | -s[tatistics] | -r[esolve] |
-f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] }</p>

<p>ip link 命令主要用于显示网络配置信息，ip link set 主要用于配置网络信息。
例：显示当前接口配置信息。
route@linux#  ip  link  list</p>

<p>ip addr 命令用于配置IP地址信息，其能够使用ip addr add为网络设备添加主或从IP地址，ip addr show用于显示每个网络设备的IP地址，ip addr del用于删除接口的IP地址，可以通过不同的命令清空相关的IP地址信息，例如：ip addr flush dynamic可以删除所有通过动态路由协议加入至linux内核中的路由条目。
例：显示IP地址信息。
route@linux# ip  address  show</p>

<p>ip neighbor用于管理neighbor/arp表，下列的一些命令将会被用到：add, change, replace, delete, and flush。
例：显示ARP缓存信息以及删除ARP缓存信息。
route@linux# ip neigh  show
route@linux# ip neigh  delete  10.10.10.1  dev eth0</p>

<p>ip tunnel命令用于管理隧道连接，隧道协议有gre,ipip,sit等，在后面的章节中将会介绍如何建立IP 隧道的实例。</p>

<p>ip route命令是一个非常重要并最常使用的命令，它几乎可以在内核路由表上执行任何操作，主要的命令有：add, change, replace, delete, show, flush, and get routes
例：显示IP路由表。
route@linux# ip  route show</p>

<p>ip monitor:监控路由， rtmon：监控地址， rtacct：实时监控网络设备。</p>

<p>关于IP命令的详细使用请参考：<a href="http://www.policyrouting.org/iproute2.doc.html#ss9.1.1">http://www.policyrouting.org/iproute2.doc.html#ss9.1.1</a></p>

<p>此外，在iproute2中最重要的功能就是通过ip rule和ip route来实现linux的策略路由功能。</p>

<p>三、策略路由的实现
在实现策略路由的内核上必须支持IP: advanced router&rdquo;  和 &ldquo;IP: policy routing&rdquo;  两项</p>

<p>实现方法：在Linux中可以设置多张路由表，并为不同的表设置不同的出口（即网关），当内核在实现路由选择时，可以让其平均的通过几张路由表将数据发送出去或者将不同的数据通过不同的路由表发送出去。</p>

<p>默认情况下，Linux内核自带了三张路由表，可以通过route@linux# ip rule list进行查看，三张表分另为local对就编号为0，main对应编号为32766，default对应编号为32766，用户在正常创建创建条目时如果没有指定加入哪一个表时，数据通通加入至main表，所以当用户使用route  -n看到的信息全部来自于main表中。
例：显示当前内核的路由表。
kuznet@amber~ $ ip rule list
0 from all lookup local
32766 from all lookup main
32767 from all lookup default</p>

<p>用户可以通过 ip route list table 表名 的方法来查看表中的具体路由条目，如下所示：
router@linux#  ip route list table main
&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>/etc/iproute2/rt_tables 文件用于保存表名和编号的对应关系。这里需要添加T1和T2两个表，编号为200和300，具体操作如下：
echo 200 T1 &gt;&gt; /etc/iproute2/rt_tables
echo 300 T2 &gt;&gt; /etc/iproute2/rt_tables</p>

<p>接下来，使用ip rule add命令来创建具体的表，并可以在表中添加源地址或目标地址等参数。如下实例，创建表T1和T2。
例：route@linux# ip rule add from 1.1.1.1 table T1
       route@linux# ip rule add from 192.203.80.0/24 table T1
       route@linux# ip rule add to 192.203.80.0/24 table T2
       route@linux# ip rule add  table T2
上述内容表示这些源地址/目的地址/所有地址将应用于T1/T2表中的路由规则。</p>

<p>在使用ip rule add创建表时，可以指定的参数有：type TYPE (default)，from PREFIX，to PREFIX，iif NAME，tos TOS or dsfield TOS，fwmark MARK，priority PREFERENCE，table TABLEID，realms FROM/TO，nat ADDRESS。</p>

<p>最后，创建具体的路由条目至指定的表中（默认为main表），如下所示：
route@linux# ip route add default via 192.168.0.1 dev eth0 table T1
route@linux# ip route add default via 192.168.1.1 dev eth1 table T2</p>

<p>四、策略路由配置实例</p>

<p>实验拓扑如下：</p>

<p>1、创建两个表，分别为dianxin，wangtong，编辑为300和400.
route@linux#echo  300  dianxin  &gt;&gt;/etc/iproute/rt_tables
route@linux# echo  400  wangtong  &gt;&gt;/etc/iproute/rt_tables
route@linux#ip rule add from $IP1 table dianxing
route@linux#ip rule add from $IP2 table wangtong</p>

<p>2、添加相关路由至两个表中。</p>

<p>3、实现负载均衡。</p>

<p>策略路由总结：
1、添加路由表，编号至系统中。
2、添加具体的路由条目并指向用户自定义的路由表中（如默认路由）。
3、添加具体的规则至路由表中，如什么样的源地址以及对应的优先级。
4、在路由表中通过nexthop参数实现负载均衡，或者可以为数据打mask，然后设置标记1的数据从哪个表走，标记2的数据从哪个表。</p>

<p>Linux下网通、电信、教育多出口策略路由配置详解
一、处理流量分割的问题；二、解决双线负载均衡的问题。原文如下：
1、流量分割
首先是如何保证：回应来自某一个ISP的数据包时，仍然使用相同的ISP。
让我们先定义一些符号。令第一块网卡的名字叫eth1，而第二块网卡叫做eth2；然后设置网卡1的IP地址为221.200.0.2（CNC分配网址），网卡2 的IP地址为58.56.0.2（CTC分配网址）；ISP1（联通）网关地址为221.200.0.1，ISP2（电信）网关地址为58.56.0.1；最后，ISP1（联通）的网络地址为211.200.0.0/30，ISP2（电信）的网络地址为58.56.0.0/30。
额外创建两个路由表，T1 和T2 ，加入到/etc//iproute2/rt_tables中。然后如下设置两个路由表中的路由：
ip route add 211.200.0.0/30 dev eth1 src 221.200.0.2 table T1
ip route add default via 221.200.0.1 table T1</p>

<p>ip route add 58.56.0.0/30 dev eth2 src 58.56.0.2 table T2
ip route add default via 58.56.0.1 table T2
没什么大不了的，不过是建立了通向该网关的一台路由，并使之成为默认网关，分别负责一个单独的上行流，并且为这两个ISP都作这样的配置。要指出的是，那条网络路由是必要条件，因为它能让我们找到那个子网内的主机，也包括上述的那台网关。
下一步，我们设置“main”路由表，把包通过网卡直接路由到与网卡相连的局域网上不失为一个好办法。要注意“src”参数，他们能够保证选择正确的出口IP地址。
ip route add 211.200.0.0/30 dev eth1 src 221.200.0.2 table main</p>

<p>ip route add 58.56.0.0/30 dev eth2 src 58.56.0.2 table main
然后，设置你的缺省路由：
ip route add default via 221.200.0.1
接着，设置路由规则。这实际上在选择用什么路由表进行路由。你需要确认当你从一个给定接口路由出数据包时，是否已经有了相应的源地址：你需要保证的就是如果你已经有了相应的源地址，就应该把数据包从相应的网卡路由出去：
ip rule add from 221.200.0.2 table T1
ip rule add from 58.56.0.2 table T2
以上命令保证了所有的回应数据都会从他们来的那块网卡原路返回。
现在，完成了非常基本的配置。这将对于所有运行在路由器上的所有进程起作用，实现IP伪装后，对本地局域网也将起作用。如果不进行伪装，那么你要么拥有两个ISP的地址空间，要么你想对两个ISP中的一个进行伪装。无论哪种情况，你都要添加规则，基于发包的主机在局域网内的IP地址，选择从哪个ISP路由出去。
2、负载均衡
第二个问题就是如何对通过两个ISP流出的数据进行负责均衡。如果你已经成功地实现了流量分割。这件事不难。
与选择两个ISP中的一个作为缺省路由不同，这次是设置缺省路由为多线路路由。在缺省内核中，这会均衡两个ISP的路由。像下面这样做（基于前面的流量分割实验）：
ip route add default scope global nexthop via 221.200.0.1 dev eth1 weight 30 <br />
nexthop via 58.56.0.1 dev eth2 weight 70 （注意：与上面为同一行命令）
这样可以均衡两个ISP的路由。通过调整“weight”参数我们可以指定其中的一个ISP的优先权高于另一个。（具体：线路1的流量约占30％，线路1占70％）
应该指出，由于均衡是基于路由进行的，而路由是经过缓冲的，所以这样的均衡并不是100％精确。也就是说，对于一个经常访问的站点，总是会使用同一个ISP。
中国的现状这样设置是有缺陷的：因为网通和电信等的线路在沟通上存在问题，就是说从网通线路访问电信的网址不如直接从电信访问快，从电信访问网通也是如此。因此对于拥有不同种线路的路由器我们需要做基于目标地址的策略路由，同种线路的可以做上面的策略路由。如果你拥有多个ISP且某个ISP有多条线路，则可以把负载均衡与基于目标的策略路由结合起来。</p>

<p>做这样的策略路由来自于《QEL4.1 网吧版》，其相关说明部分如下：</p>

<p>从QEL4.1 版本开始，我们增加了多线路策略路由的功能。用户只需要简单地填写几个配置文件即可完成。
策略路由功能由qlcm 程序实现。这个程序在QEL4.0 上为1.0，包含了内核智能优化、抗DDOS、SYN 洪水攻击等功能。在4.1 版上，qlcm 版本为2.0，增加了arp 绑定，多线路策略路由功能。
qlcm 服务是QEL 服务器的核心服务，您可以restart qlcm 服务，但在任何情况下您都不应该停止它。关闭它会造成无法预料的后果，比如出现大量丢包，某些服务停止等。这样的故障不在我们技术支持的范围内。
qlcm 2.0 支持最大8 路外网线路，根据用户定义的配置文件自动判断工作模式，可以为每个外网出口单独定义路由表，也可以实现实现多条线路的负载均衡(即多链路带宽捆绑)。一般的硬件路由器只能支持23路外网线路，而且价格不菲。硬件路由器使用嵌入式CPU 和少量内存，处理性能有限，在处理过多路由时会超出处理能力。而使用PC做路由则不受此限制。
QEL4.1 内核最大可以支持到255 路外线，我们随时可以修改qlcm，支持32 路或者更多的外线。</p>

<p>我们再来看一个具体例子的实现：</p>

<p>3．我们有三条固定IP 线路，一条是eth0(电信)，网关为202.102.14.1，一条eth1(网通)，网关为60.12.5.1，一条是教育网线路，网关为125.216.44.1，将etho(电信线路)作为默认网关，访问网通的数据走eth1，访问教育网的走eth2，
配置如下：
wan1.conf:
interface=eth0
gateway=202.102.14.1
defaultgw=yes
wan2.conf:
interface=eth1
gateway= 60.12.5.1
routefile=/etc/quick/IP_CNC.list
wan3.conf:
interface=eth2
gateway=125.216.44.1
routefile=/etc/quick/IP_EDU.list
这样就OK 了。新建一个IP_EDU.list 文本文件，其中定义了教育网的IP 段。
在这样的环境下，defaultgw=yes 只设定在某个网卡接口上。当访问已定义的路由时，走指定的网卡出去，否则走默认网关。</p>

<p>routefile= 后面填该线路对应的路由表文件。在安装时我们已经为您默认安装了两个文件:IP_CNC.list 和IP_CTC.list，这两个文件都在/etc/quick 目录下，其中IP_CNC.list 文件是网通路由表文件，IP_CTC.list 为电信路由表文件。
这两个文件的格式也很简单，每行一个IP 段，示例如下：
58.16.0.0/16
58.17.0.0/17
58.17.128.0/17</p>

<p>qlcm只能运行在《QEL4.1 网吧版》上，如果移植到其它Linux下会因为版本的不同而造成系统的崩溃。在不想更换系统的前提下，我们可以自己用IP命令来实现qlcm的功能模拟。
我们仍然以文章开始的实例来进行说明基于目的的策略路由设置。
1、首先建立通向不同ISP的路由表
ip route add 211.200.0.0/30 dev eth1 src 221.200.0.2 table 50
ip route add default via 221.200.0.1 table 50</p>

<p>ip route add 58.56.0.0/30 dev eth2 src 58.56.0.2 table 51
ip route add default via 58.56.0.1 table 51
没什么可说的，与前面相同，只是仅用数字表示路由表。
2、针对我们要访问的目标地址，选择不同的路由表，进行路由
因为有大量的网络地址需要设置不同的规则，采用命令模式不便于修改，所以做了一个简单的脚本文件，配置文件与qlcm采用相同的结构。</p>

<p>关于策略路由的详细使用，可以参考书籍：Policy Routing Using Linux</p>

<p>本文出自 “RHCSS系统安全架构师” 博客，转载请与作者联系！</p>

<p><a href="http://xjsunjie.blog.51cto.com/999372/1583522">http://xjsunjie.blog.51cto.com/999372/1583522</a>
iproute2 策略路由与流量控制笔记
2014-11-27 22:48:47
标签：流量控制 iproute2 策略路由</p>

<p>&ndash; 前提知识: &ndash;
如果需要使用策略路由需确认编译内核时配置中带有IP:advanced route和IP:policy routing</p>

<p>iproute匹配条件:from源地址,to目的地址，Tos域,Dev物理接口,Fwmark防火墙标记  这些做为匹配条件</p>

<p>iproute动作：可以以table指明所用的表,nat网络地址转换,prohibit丢弃并发送icmp信息,reject单纯丢弃,unreachable丢弃并发送icmp信息.</p>

<p>ip rule首先程序从优先级高到低扫描所有的规则，如果规则匹配，处理该规则的动作。如果是普通的路由寻址或者是nat地址转换的换，首先从规则得到路由表，然后对该路由表进行操作。这样RPDB(routing policy database)终于清晰的显现出来了。</p>

<p>iproute相关的内核编译选项:CONFIG_IP_ADVANCED_ROUTER=y CONFIG_IP_MULTIPLE_TABLES=y CONFIG_IP_ROUTE_FWMARK=y</p>

<p>/etc/iproute2/rt_tables 保存规则的名字与数字的关联</p>

<p>iptables -A FORWARD -p tcp -m tcp &ndash;tcp-flags SYN,RST SYN -j TCPMSS &ndash;clamp-mss-to-pmtu 允许调整tcp syn包里的MSS域，用于控制连接包的最大长度。一些防火墙或主机会很不适当的过滤掉type 3、code 4（需要分片）的icmp包。目前发行的linux的内核从2.4.7开始已经包含了这个补丁。</p>

<p>IMQ 中介队列设备
被打了特定标记的数据包在netfilter的NF_IP_PRE_ROUTING和NF_IP_POST_ROUTING两个钩子函数处被拦截，并被送到一个队列规定中,该队列规定附加到一个IMQ设备上。可以实现对入口流量整形，而且可以把网卡当成一个个的类来看待而进行全局整形设置。</p>

<p>&ndash;应用案例1 &ndash;</p>

<p>通过iptables与iproute2协同实现根据 应用 的策略路由
实现要点： iptables根据端口将服务类的数据包打上标示，iptables -t mangle -A PREROUTING -p tcp &ndash;dport 80 -j MARK &ndash;set-mark 100 （用这些标记我们可以做带宽限制和基于请求的分类）
根据情况做nat iptables -t nat -A POSTROUTING -o eth2 -j MASQUERADE
然后设置路由策略ip rule add fwmark 100 table 100</p>

<p>&ndash; 应用案例2 &ndash;</p>

<p>普通双ISP的设置 外网接口$IF1 IF1接口地址$IP1 ISP1网关地址$P1 ISP1的网络地址P1_NET
#分别指定两条默认网关负责单独的上行流
ip route add $P1_NET dev $IF1 src $IP1 table T1 源地址为IP1且目的为ISP1网段从IF1接口发出(必需的,它能够让我们找到该子网内的主机及本网关) 将这条路由加入表T1
ip route add default via $P1 table T1
ip route add $P2_NET dev $IF2 src $IP2 table T2 源地址为IP2且目的为ISP2网段从IF2接口发出((必需的,它能够让我们找到该子网内的主机及本网关) 将这条路由加入表T2
ip route add default via $P2 table T2</p>

<p>#也加入到main路由表
ip route add $P1_NET dev $IF1 src $IP1
ip route add $P2_NET dev $IF2 src $IP2
  main缺省走ISP1
ip route add default via $P1</p>

<p>#设置路由规则
ip rule add from $IP1 table T1
ip rule add from $IP2 table T2
#设置负载均衡
ip route add default scope global nexthop via $P1 dev $IF1 weight 1 <br />
nexthop via $P2 dev $IF2 weight 1</p>

<p>均衡是基于路由进行的，而路由是经过缓冲的,所以这样的均衡并不是100%精确.</p>

<p>&ndash; 应用案例3 &ndash;
 TC带宽管理的主要实现步骤 主要是在输出端口处建立一个队列进行流量控制，控制的方式是基于路由，亦即基于目的IP地址或目的子网的网络号的流量控制。
1 编译内核时注意事项
以下实例:发往A主机8M带宽 发往B主机1M带宽 发往C主机1M带宽
2 　1) 针对网络物理设备(如以太网卡eth0)绑定一个CBQ队列；
 tc qdisc add dev eth0 root handle 1: cbq bandwidth 10Mbit avpkt 1000 cell 8 mpu 64
　　2) 在该队列上建立分类；
 tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 10Mbit rate 10Mbit maxburst 20 allot \ 1514 prio 8 avpkt 1000 cell 8 weight 1Mbit
 tc class add dev eth0 parent 1:1 classid 1:2 cbq bandwidth 10Mbit rate 8Mbit maxburst 20 allot \ 1514 prio 2 avpkt 1000 cell 8 weight 800Kbit split 1:0 bounded
 tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 10Mbit rate 1Mbit maxburst 20 allot \ 1514 prio 1 avpkt 1000 cell 8 weight 100Kbit split 1:0
 tc class add dev eth0 parent 1:1 classid 1:4 cbq bandwidth 10Mbit rate 1Mbit maxburst 20 allot \ 1514 prio 6 avpkt 1000 cell 8 weight 100Kbit split 1:0
　　3) 为每一分类建立一个基于路由的过滤器；
tc filter add dev eth0 parent 1:0 protocol ip prio 100 route
tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 2 flowid 1:2
tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 3 flowid 1:3
tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 4 flowid 1:4
　　4) 最后与过滤器相配合，建立特定的路由表。
ip route add 192.168.1.24 dev eth0 via 192.168.1.66 realm 2
ip route add 192.168.1.30 dev eth0 via 192.168.1.66 realm 3
ip route add 192.168.1.0/24 dev eth0 via 192.168.1.66 realm 4
3 应用,监控</p>

<p>&ndash;关于负载平衡&ndash;
关于负载平衡 CONFIG_IP_ROUTE_MULTIPATH内核选项将把所有这些路径(缺省路由)等同看待，然后再根据/usr/src/linux /Documentation/Configure.help来选择其特定的方式。Ip route命令的equalize选项，会让Linux内核基于IP地址平衡外部连接。对于一个特定的IP地址，内核会选择一个接口用于传输流出的数据包，然后内核会为该IP地址在路由缓冲中建一个记录。这样，其它到达的有相同IP地址的数据包就会使用同一个接口，直到该记录从路由缓冲中删除。我们可以使用ip route list cache命令来查看路由缓冲。</p>

<p>通过DNS循环来实现的服务的负载平衡
各种不同的服务(DNS、SMTP、HTTP、LDAP、SSH等) 可以通过DNS循环来实现。
循环复用DNS还有太多的限制(DNS缓存,忽略TTL值，修改后的刷新时间,不能意识到服务器的可用性)，只能算是一种勉强可接受的负载平衡方案</p>

<p>&ndash;相关命令 &ndash;
ip link list 显示链路
ip address show 显示IP地址 对于PPP0接口还会告诉我们链路另一端的地址
ip route show 输出结果之一default via x.x.x.x dev x</p>

<p>ip neigh show 查看缓存的ARP表
ip neigh delete x.x.x.x dev x</p>

<p>&ndash;TC流量控制：&ndash;
我们只能对发送数据进行整形
默认整形方式是Pfifo_fast队列规定。特点为先进先出。只看数据包的TOS字节节来判断应该放到哪个频道(优先).一般的应用程序会如何设置他们的TOS值。
HTB分层的令牌桶
HTB 可以保障提供给每个类带宽的数量是它所需求的最小需求或者等于分配给它的数量.当一个类需要的带宽少于分配的带宽时,剩余的带宽被分配给其他需要服务的类.</p>

<p>SFQ随机公平队列
简单轮转。使用一个散列算法，把所有的会话映射到有限的几个队列中去。(只有当你的出口网卡确实已经挤满了的时候,SFQ才会起作用)</p>

<p>（如果你并不希望进行流量整形，只是想看看你的网卡是否有比较高的负载而需要使用队列，可使用pfifo队列。它缺乏内部频道但是可以统计backlog）</p>

<p>&ndash;HTB应用案例4&ndash;
1)
tc qdisc add dev eth0 root handle 1: htb default 12
2)
tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps
tc class add dev eth0 parent 1:1 classid 1:10 htb rate 30kbps ceil 100kbps
tc class add dev eth0 parent 1:1 classid 1:11 htb rate 10kbps ceil 100kbps
tc class add dev eth0 parent 1:1 classid 1:12 htb rate 60kbps ceil 100kbps
3)为队列规定分配子类, 如果没有指定缺省是pfifo
tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5
tc qdisc add dev eth0 parent 1:11 handle 30: pfifo limit 5
tc qdisc add dev eth0 parent 1:12 handle 40: sfq perturb 10
1:12队列的类不定义时，即所有不匹配其它类规则的数据包。</p>

<p>&ndash;流量分析与故障诊断&ndash;
tc -s -d qdisc show dev eth0 队列状态
tc -s class show dev eth0 类状态
tc filter show dev eth0 过滤器状态</p>

<p><a href="http://xjsunjie.blog.51cto.com/999372/1575090">http://xjsunjie.blog.51cto.com/999372/1575090</a>
linux策略路由iproute2
2014-11-10 17:17:20
标签：linux策略路由 iproute2
策略性路由</p>

<p>　　策略性是指对于IP包的路由是以网络管理员根据需要定下的一些策略为主要依据进行路由的。例如我们可以有这样的策略：“所有来直自网A的包，选择X路径；其他选择Y路径”，或者是“所有TOS为A的包选择路径F；其他选者路径K”。
　　Cisco 的网络操作系统 (Cisco IOS) 从11.0开始就采用新的策略性路由机制。而Linux是在内核2.1开始采用策略性路由机制的。策略性路由机制与传统的路由算法相比主要是引入了多路由表以及规则的概念。
多路由表（multiple Routing Tables）</p>

<p>　　传统的路由算法是仅使用一张路由表的。但是在有些情形底下，我们是需要使用多路由表的。例如一个子网通过一个路由器与外界相连，路由器与外界有两条线路相连，其中一条的速度比较快，一条的速度比较慢。对于子网内的大多数用户来说对速度并没有特殊的要求，所以可以让他们用比较慢的路由；但是子网内有一些特殊的用户却是对速度的要求比较苛刻，所以他们需要使用速度比较快的路由。如果使用一张路由表上述要求是无法实现的，而如果根据源地址或其它参数，对不同的用户使用不同的路由表，这样就可以大大提高路由器的性能。
规则（rule）</p>

<p>　　规则是策略性的关键性的新的概念。我们可以用自然语言这样描述规则，例如我门可以指定这样的规则：
　　规则一：“所有来自192.16.152.24的IP包，使用路由表10， 本规则的优先级别是1500”
　　规则二：“所有的包，使用路由表253，本规则的优先级别是32767”</p>

<p>　　我们可以看到，规则包含3个要素：
　　什么样的包，将应用本规则（所谓的SELECTOR，可能是filter更能反映其作用）；
　　符合本规则的包将对其采取什么动作（ACTION），例如用那个表；
　　本规则的优先级别。优先级别越高的规则越先匹配（数值越小优先级别越高）。
策略性路由的配置方法</p>

<p>　　传统的linux下配置路由的工具是route，而实现策略性路由配置的工具是iproute2工具包。这个软件包是由Alexey Kuznetsov开发的，软件包所在的主要网址为<a href="ftp://ftp.inr.ac.ru/ip-routing/。">ftp://ftp.inr.ac.ru/ip-routing/。</a>
这里简单介绍策略性路由的配置方法，以便能更好理解第二部分的内容。详细的使用方法请参考Alexey Kuznetsov写的 ip-cfref文档。策略性路由的配置主要包括接口地址的配置、路由的配置、规则的配置。
接口地址的配置IP Addr</p>

<p>对于接口的配置可以用下面的命令进行：</p>

<p>Usage: ip addr [ add | del ] IFADDR dev STRING</p>

<p>　　例如：</p>

<p>router&gt;# ip addr add 192.168.0.<sup>1</sup>&frasl;<sub>24</sub> broadcast 192.168.0.255 label eth0 dev eth0</p>

<p>　　上面表示，给接口eth0赋予地址192.168.0.1 掩码是255.255.255.0(24代表掩码中1的个数)，广播地址是192.168.0.255</p>

<p>路由的配置IP Route</p>

<p>　　Linux最多可以支持255张路由表，其中有3张表是内置的：
　　表255 本地路由表（Local table） 本地接口地址，广播地址，已及NAT地址都放在这个表。该路由表由系统自动维护，管理员不能直接修改。
　　表254 主路由表（Main table） 如果没有指明路由所属的表，所有的路由都默认都放在这个表里，一般来说，旧的路由工具（如route）所添加的路由都会加到这个表。一般是普通的路由。
　　表253 默认路由表 （Default table） 一般来说默认的路由都放在这张表，但是如果特别指明放的也可以是所有的网关路由。
　　表 0 保留</p>

<p>　　路由配置命令的格式如下：</p>

<p>Usage: ip route list SELECTOR
ip route { change | del | add | append | replace | monitor } ROUTE</p>

<p>　　如果想查看路由表的内容，可以通过命令：</p>

<p>　　ip route list table table_number</p>

<p>　　对于路由的操作包括change、del、add 、append 、replace 、 monitor这些。例如添加路由可以用：</p>

<p>router&gt;# ip route add 0/0 via 192.168.0.4 table main
router&gt;# ip route add 192.168.3.0/24 via 192.168.0.3 table 1</p>

<p>　　第一条命令是向主路由表（main table）即表254添加一条路由，路由的内容是设置192.168.0.4成为网关。
　　第二条命令代表向路由表1添加一条路由，子网192.168.3.0（子网掩码是255.255.255.0）的网关是192.168.0.3。</p>

<p>　　在多路由表的路由体系里，所有的路由的操作，例如网路由表添加路由，或者在路由表里寻找特定的路由，需要指明要操作的路由表，所有没有指明路由表，默认是对主路由表（表254）进行操作。而在单表体系里，路由的操作是不用指明路由表的。
规则的配置IP Rule</p>

<p>　　在Linux里，总共可以定义 个优先级的规则，一个优先级别只能有一条规则，即理论上总共可以有 条规则。其中有3个规则是默认的。命令用法如下：</p>

<p>Usage: ip rule [ list | add | del ] SELECTOR ACTION
SELECTOR := [ from PREFIX ] [ to PREFIX ] [ tos TOS ]
[ dev STRING ] [ pref NUMBER ]
ACTION := [ table TABLE_ID ] [ nat ADDRESS ]
[ prohibit | reject | unreachable ]
[ flowid CLASSID ]
TABLE_ID := [ local | main | default | new | NUMBER</p>

<p>　　首先我们可以看看路由表默认的所有规则：</p>

<p>root@netmonster# ip rule list
0: from all lookup local
32766: from all lookup main
32767: from all lookup default
<code>
　　规则0，它是优先级别最高的规则，规则规定，所有的包，都必须首先使用local表（254）进行路由。本规则不能被更改和删除。
　　规则32766，规定所有的包，使用表main进行路由。本规则可以被更改和删除。
　　规则32767，规定所有的包，使用表default进行路由。本规则可以被更改和删除。</p>

<p>　　在默认情况下进行路由时，首先会根据规则0在本地路由表里寻找路由，如果目的地址是本网络，或是广播地址的话，在这里就可以找到合适的路由；如果路由失败，就会匹配下一个不空的规则，在这里只有32766规则，在这里将会在主路由表里寻找路由;如果失败，就会匹配32767规则，即寻找默认路由表。如果失败，路由将失败。重这里可以看出，策略性路由是往前兼容的。</p>

<p>　　还可以添加规则：
<code>
router&gt;# ip rule add [from 0/0] table 1 pref 32800
router &gt;#ip rule add from 192.168.3.<sup>112</sup>&frasl;<sub>32</sub> [tos 0x10] table 2 pref 1500 prohibit</p>

<p>　　第一条命令将向规则链增加一条规则，规则匹配的对象是所有的数据包，动作是选用路由表1的路由，这条规则的优先级是32800。
　　第二条命令将向规则链增加一条规则，规则匹配的对象是IP为192.168.3.112，tos等于0x10的包，使用路由表2，这条规则的优先级是1500，动作是prohibit。添加以后，我们可以看看系统规则的变化。</p>

<p>router&gt;# ip rule
0: from all lookup local
1500 from 192.168.3.<sup>112</sup>&frasl;<sub>32</sub> [tos 0x10] lookup 2
32766: from all lookup main
32767: from all lookup default
32800: from all lookup 1</p>

<p>　　上面的规则是以源地址为关键字，作为是否匹配的依据的。除了源地址外，还可以用以下的信息：
　　From &ndash; 源地址
　　To &ndash; 目的地址（这里是选择规则时使用，查找路由表时也使用）
　　Tos &ndash; IP包头的TOS（type of sevice）域
　　Dev &ndash; 物理接口
　　Fwmark &ndash; 防火墙参数</p>

<p>　　采取的动作除了指定表，还可以指定下面的动作：
　　　Table 指明所使用的表
　　　Nat 透明网关
　　　Action prohibit 丢弃该包，并发送 COMM.ADM.PROHIITED的ICMP信息
　　　Reject 单纯丢弃该包
　　　Unreachable丢弃该包， 并发送 NET UNREACHABLE的ICMP信息
策略性路由的应用</p>

<p>　　基于源地址选路（ Source-Sensitive Routing）
　　如果一个网络通过两条线路接入互联网，一条是比较快的ADSL，另外一条是比较慢的普通的调制解调器。这样的话，网络管理员既可以提供无差别的路由服务，也可以根据源地址的不同，使一些特定的地址使用较快的线路，而普通用户则使用较慢的线路，即基于源址的选路。</p>

<p>　　根据服务级别选路（Quality of Service）
　　网络管理员可以根据IP报头的服务级别域，对于不同的服务要求可以分别对待对于传送速率、吞吐量以及可靠性的有不同要求的数据报根据网络的状况进行不同的路由。</p>

<p>　　节省费用的应用
　　网络管理员可以根据通信的状况，让一些比较大的阵发性通信使用一些带宽比较高但是比较贵的路径一段短的时间，然后让基本的通信继续使用原来比较便宜的基本线路。例如，管理员知道，某一台主机与一个特定的地址通信通常是伴随着大量的阵发性通信的，那么网络管理员可以安排一些策略，使得这些主机使用特别的路由，这些路由是按需拨号，带宽比较高的线路，通信完成以后就停止使用，而普通的通信则不受影响。这样既提高网络的性能，又能节省费用。</p>

<p>　　负载平衡（Load Sharing）
　　根据网络交通的特征，网络管理员可以在不同的路径之间分配负荷实现负载平衡。
Linux下策略性路由的实现&ndash;RPDB（Routing　Policy DataBase）</p>

<p>　　在Linux下，策略性路由是由RPDB实现的。对于RPDB的内部机制的理解，可以加深对于策略性路由使用的理解。这里分析的是linux 2.4.18的RPDB实现的细节。主要的实现文件包括：</p>

<p>fib_hash.c
fib_rules.c
fib_sematic
fib_frontend.c
route.c</p>

<p>　　RDPB主要由多路由表和规则组成。路由表以及对其的操作和其对外的接口是整个RPDB的核心部分。路由表主要由table，zone，node这些主要的数据结构构成。对路由表的操作主要包含物理的操作以及语义的操作。路由表除了向IP层提供路由寻找的接口以外还必须与几个元素提供接口：与用户的接口（即更改路由）、proc的接口、IP层控制接口、以及和硬件的接口（网络接口的改变会导致路由表内容的改变）。处在RDPB的中心的规则，由规则选取表。IP层并不直接使用路由表，而是通过一个路由适配层,路由适配层提供为IP层提供高性能的路由服务。</p>

<p>路由表（Fib Table）</p>

<p>　　数据结构：
　　在整个策略性路由的框架里，路由表是最重要的的数据结构，我们在上面以及对路由表的概念和结构进行了清楚的说明。Linux里通过下面这些主要的数据结构进行实现的。</p>

<p>主要的数据结构 作用 位置
struct fib_table 路由表 ip_fib.h 116
struct fn_hash 路由表的哈希数据 fib_hash.c 104
struct fn_zone zone域 fib_hash.c 85
struct fib_node 路由节点 fib_hash.c 68
struct fib_info 路由信息 ip_fib.h 57
struct fib_result 路由结果 ip_fib.h 86</p>

<p>数据结构之间的主要关系如下。路由表由路由表号以及路由表的操作函数指针还有表数据组成。这里需要注意的是，路由表结构里并不直接定义zone域，而是通过一个数据指针指向fn_hash。只有当zone里有数据才会连接到fn_zone_list里。（如图）
系统的所有的路由表由数组变量*fib_tables[RT_TABLE_MAX+1]维护，其中系统定义RT_TABLE_MAX为254，也就是说系统最大的路由表为255张，所有的路由表的操作都是对这个数组进行的。。同时系统还定义了三长路由表*local_table; *main_table。</p>

<p>路由表的操作：</p>

<p>　　Linux策略路由代码的主要部分是对路由表的操作。对于路由表的操作，物理操作是直观的和易于理解的。对于表的操作不外乎就是添加、删除、更新等的操作。还有一种操作，是所谓的语义操作，语义操作主要是指诸如计算下一条的地址，把节点转换为路由项，寻找指定信息的路由等。</p>

<p>　　1、物理操作(operation)：
　　路由表的物理操作主要包括如下这些函数：</p>

<p>路由标操作 实现函数 位置
新建路由表
删除路由表
搜索路由 fn_hash_lookup fib_hash.c 269
插入路由到路由表 fn_hash_insert fib_hash.c 341
删除路由表的路由 fn_hash_delete
fn_hash_dump
fib_hash.c 433
fib_hash.c 614
更新路由表的路由 fn_hash_flush fib_hash.c 729
显示路由表的路由信息 fn_hash_get_info fib_hash.c 750
选择默认路由 fn_hash_select_default fib_hash.c 842</p>

<p>　　2、语义操作(semantics operation)：
　　语义操作并不涉及路由表整体框架的理解，而且，函数名也是不言自明的，所以请大家参考fib_semantics.c。</p>

<p>　　3、接口(front end)
　　对于路由表接口的理解，关键在于理解那里有</p>

<p>　　IP
　　首先是路由表于IP层的接口。路由在目前linux的意义上来说，最主要的还是IP层的路由，所以和IP层的的接口是最主要的接口。和ip层的衔接主要是向IP层提供寻找路由、路由控制、寻找指定ip的接口。</p>

<p>Fil_lookup
ip_rt_ioctl fib_frontend.c 286;&rdquo; f
ip_dev_find 145</p>

<p>　　Inet
　　路由表还必须提供配置接口，即用户直接操作路由的接口，例如增加和删除一条路由。当然在策略性路由里，还有规则的添加和删除。</p>

<p>inet_rtm_delroute 351
inet_rtm_newroute 366
inet_check_attr 335</p>

<p>　　proc
　　在/proc/net/route里显示路由信息。
　　fib_get_procinfo</p>

<p>　　4、网络设备（net dev event）
　　路由是和硬件关联的，当网络设备启动或关闭的时候，必须通知路由表的管理程序，更新路由表的信息。</p>

<p>fib_disable_ip 567
fib_inetaddr_event 575
fib_netdev_event</p>

<p>　　5、内部维护（ magic）
　　上面我们提到，本地路由表（local table）的维护是由系统自动进行的。也就是说当用户为硬件设置IP地址等的时候，系统自动在本地路由表里添加本地接口地址以及广播地址。</p>

<p>fib_magic 417
fib_add_ifaddr 459
fib_del_ifaddr 498</p>

<p>Rule</p>

<p>　　1、数据结构
　　规则在fib_rules.c的52行里定义为 struct fib_rule。而RPDB里所有的路由是保存在101行的变量fib_rules里的，注意这个变量很关键，它掌管着所有的规则，规则的添加和删除都是对这个变量进行的。</p>

<p>　　2、系统定义规则：
　　fib_rules被定义以后被赋予了三条默认的规则：默认规则，本地规则以及主规则。</p>

<p>u 本地规则local_rule
94 static struct fib_rule local_rule = {
r_next: &amp;main_rule, /<em>下一条规则是主规则</em>/
r_clntref: ATOMIC_INIT(2),
r_table: RT_TABLE_LOCAL, /<em>指向本地路由表</em>/
r_action: RTN_UNICAST, /<em>动作是返回路由</em>/
};</p>

<p>u 主规则main_rule
86 static struct fib_rule main_rule = {
r_next: &amp;default_rule,/<em>下一条规则是默认规则</em>/
r_clntref: ATOMIC_INIT(2),
r_preference: 0x7FFE, /<em>默认规则的优先级32766</em>/
r_table: RT_TABLE_MAIN, /<em>指向主路由表</em>/
r_action: RTN_UNICAST, /<em>动作是返回路由</em>/
};</p>

<p>u 默认规则default rule
79 static struct fib_rule default_rule = {
r_clntref: ATOMIC_INIT(2),
r_preference: 0x7FFF,/<em>默认规则的优先级32767</em>/
r_table: RT_TABLE_DEFAULT,/<em>指默认路由表</em>/
r_action: RTN_UNICAST,/<em>动作是返回路由</em>/
};</p>

<p>　　规则链的链头指向本地规则。</p>

<p>RPDB的中心函数fib_lookup</p>

<p>　　现在到了讨论RPDB的实现的的中心函数fib_lookup了。RPDB通过提供接口函数fib_lookup，作为寻找路由的入口点，在这里有必要详细讨论这个函数，下面是源代码：</p>

<p>310 int fib_lookup(const struct rt_key *key, struct fib_result *res)
311 {
312 int err;
313 struct fib_rule *r, *policy;
314 struct fib_table *tb;
315
316 u32 daddr = key-&gt;dst;
317 u32 saddr = key-&gt;src;
318
321 read_lock(&amp;fib_rules_lock);
322 for (r = fib_rules; r; r=r-&gt;r_next) {/<em>扫描规则链fib_rules里的每一条规则直到匹配为止</em>/
323 if (((saddr^r-&gt;r_src) &amp; r-&gt;r_srcmask) ||
324 ((daddr^r-&gt;r_dst) &amp; r-&gt;r_dstmask) ||
325 #ifdef CONFIG_IP_ROUTE_TOS
326 (r-&gt;r_tos &amp;&amp; r-&gt;r_tos != key-&gt;tos) ||
327 #endif
328 #ifdef CONFIG_IP_ROUTE_FWMARK
329 (r-&gt;r_fwmark &amp;&amp; r-&gt;r_fwmark != key-&gt;fwmark) ||
330 #endif
331 (r-&gt;r_ifindex &amp;&amp; r-&gt;r_ifindex != key-&gt;iif))
332 continue;/<em>以上为判断规则是否匹配，如果不匹配则扫描下一条规则，否则继续</em>/</p>

<p>335 switch (r-&gt;r_action) {/<em>好了，开始处理动作了</em>/
336 case RTN_UNICAST:/<em>没有设置动作</em>/
337 case RTN_NAT: /<em>动作nat ADDRESS</em>/
338 policy = r;
339 break;
340 case RTN_UNREACHABLE: /<em>动作unreachable</em>/
341 read_unlock(&amp;fib_rules_lock);
342 return -ENETUNREACH;
343 default:
344 case RTN_BLACKHOLE:/* 动作reject <em>/
345 read_unlock(&amp;fib_rules_lock);
346 return -EINVAL;
347 case RTN_PROHIBIT:/</em> 动作prohibit */
348 read_unlock(&amp;fib_rules_lock);
349 return -EACCES;
350 }
351 /<em>选择路由表</em>/
352 if ((tb = fib_get_table(r-&gt;r_table)) == NULL)
353 continue;
/<em>在路由表里寻找指定的路由</em>/
354 err = tb-&gt;tb_lookup(tb, key, res);
355 if (err == 0) {/<em>命中目标</em>/
356 res-&gt;r = policy;
357 if (policy)
358 atomic_inc(&amp;policy-&gt;r_clntref);
359 read_unlock(&amp;fib_rules_lock);
360 return 0;
361 }
362 if (err &lt; 0 &amp;&amp; err != -EAGAIN) {/<em>路由失败</em>/
363 read_unlock(&amp;fib_rules_lock);
364 return err;
365 }
366 }
368 read_unlock(&amp;fib_rules_lock);
369 return -ENETUNREACH;
370 }</p>

<p>　　上面的这段代码的思路是非常的清晰的。首先程序从优先级高到低扫描所有的规则，如果规则匹配，处理该规则的动作。如果是普通的路由寻址或者是nat地址转换的换，首先从规则得到路由表，然后对该路由表进行操作。这样RPDB终于清晰的显现出来了。</p>

<p>IP层路由适配（IP route）</p>

<p>　　路由表以及规则组成的系统，可以完成路由的管理以及查找的工作，但是为了使得IP层的路由工作更加的高效，linux的路由体系里，route.c里完成大多数IP层与RPDB的适配工作，以及路由缓冲（route cache）的功能。
调用接口</p>

<p>　　IP层的路由接口分为发送路由接口以及接收路由接口：
发送路由接口</p>

<p>　　IP层在发送数据时如果需要进行路由工作的时候，就会调用ip_route_out函数。这个函数在完成一些键值的简单转换以后，就会调用 ip_route_output_key函数，这个函数首先在缓存里寻找路由，如果失败就会调用 ip_route_output_slow，ip_route_output_slow里调用fib_lookup在路由表里寻找路由，如果命中，首先在缓存里添加这个路由，然后返回结果。</p>

<p>ip_route_out route.h
ip_route_output_key route.c 1984;
ip_route_output_slow route.c 1690;&rdquo;</p>

<p>接收路由接口</p>

<p>　　IP层接到一个数据包以后，如果需要进行路由，就调用函数ip_route_input，ip_route_input现在缓存里寻找，如果失败则 ip_route_inpu调用ip_route_input_slow， ip_route_input_slow里调用fib_lookup在路由表里寻找路由，如果命中，首先在缓存里添加这个路由，然后返回结果。</p>

<p>ip_route_input_slow route.c 1312;&rdquo; f
ip_route_input route.c 1622;&rdquo; f</p>

<p>cache</p>

<p>　　路由缓存保存的是最近使用的路由。当IP在路由表进行路由以后，如果命中就会在路由缓存里增加该路由。同时系统还会定时检查路由缓存里的项目是否失效，如果失效则清除。</p>

<p><a href="http://www.tanpao.com/archives/26">http://www.tanpao.com/archives/26</a>
Linux高级路由技术-实现双线服务器
三19
Linux运维</p>

<p>背景：两个网卡，两条线路：电信和网通</p>

<p>以前：
         /eth0 3.3.3.2  ——&gt; 3.3.3.1 router1
server
        \eth1 4.4.4.2  ——&gt; 4.4.4.1 router2
 eth0 3.3.3.2
 eth1 4.4.4.2
 共用一个网关： 3.3.3.1
 缺点：只能有一个网关，无法智能判断线路来源。</p>

<p>实验拓扑图
 /eth0 —– eth0[Router_1]eth1 —– eth0<br />
Client                                                                       Server
 \eth1 —– eth0[Router_2]eth1 —– eth1/
Client
 eth0 1.1.1.2  vmnet1
 eth1 2.2.2.2  vmnet2</p>

<p>Router_1
 eth0 1.1.1.1  vmnet1
 eth1 3.3.3.1  vmnet3</p>

<p>Router_2
 eth0 2.2.2.1  vmnet2
 eth1 4.4.4.1  vmnet4</p>

<p>Server
 eth0 3.3.3.2  vmnet3
 eth1 4.4.4.2  vmnet4
需要运行vmware-config.pl增加这些虚拟网卡，类型为hostonly
一、Server配置:</p>

<h1 id="ifconfig-eth0-3-3-3-2-netmask-255-255-255-0">ifconfig eth0 3.3.3.2 netmask 255.255.255.0</h1>

<h1 id="ifconfig-eth1-4-4-4-2-netmask-255-255-255-0">ifconfig eth1 4.4.4.2 netmask 255.255.255.0</h1>

<p>设定前路由表</p>

<h1 id="ip-route-1">ip route</h1>

<p>4.4.4.0/24 dev eth1  proto kernel  scope link  src 4.4.4.2
3.3.3.0/24 dev eth0  proto kernel  scope link  src 3.3.3.2
10.1.1.0/24 dev eth2  proto kernel  scope link  src 10.1.1.138
169.254.0.0/16 dev eth2  scope link
default via 10.1.1.1 dev eth2  &lt;—所有网卡公用一个网关</p>

<p>思路：是为两个网卡建立独立的路由表，他们有自己的网关
1、额外添加两个路由表</p>

<h1 id="ip-route-add-3-3-3-0-dev-eth0-src-3-3-3-2-table-1">ip route add 3.3.3.0 dev eth0 src 3.3.3.2  table 1</h1>

<p>&lt;—新建路由条目，关于3.3.3.0网络的，放到一个编号为1的路由表</p>

<h1 id="ip-route-add-default-via-3-3-3-1-table-1">ip route add default via 3.3.3.1 table 1</h1>

<p>&lt;—为路由表 1 增加一个默认网关</p>

<h1 id="ip-route-list-table-1">ip route list table 1</h1>

<p>3.3.3.0 dev eth0  scope link  src 3.3.3.2
default via 3.3.3.1 dev eth0</p>

<h1 id="ip-route-add-4-4-4-0-dev-eth1-src-4-4-4-2-table-2">ip route add 4.4.4.0 dev eth1 src 4.4.4.2  table 2</h1>

<h1 id="ip-route-add-default-via-4-4-4-1-table-2">ip route add default via 4.4.4.1 table 2</h1>

<h1 id="ip-route-list-table-2">ip route list table 2</h1>

<p>4.4.4.0 dev eth1  scope link  src 4.4.4.2
default via 4.4.4.1 dev eth1</p>

<p>2、设定main主路由表（ip route 看到的路由表）</p>

<h1 id="ip-route-add-3-3-3-0-dev-eth0-src-3-3-3-2">ip route add 3.3.3.0 dev eth0 src 3.3.3.2</h1>

<h1 id="ip-route-add-4-4-4-0-dev-eth1-src-4-4-4-2">ip route add 4.4.4.0 dev eth1 src 4.4.4.2</h1>

<p>3、设定默认路由
作用：给自己主动发数据包的时候选择一个默认的网关</p>

<p>如果原来存在默认网关，而不是你想设定的那个，那么先删除</p>

<h1 id="ip-route-del-default-via-10-1-1-1">ip route del default via 10.1.1.1</h1>

<h1 id="ip-route-add-default-via-3-3-3-1">ip route add default via 3.3.3.1</h1>

<p>4、设定路由规则，保证数据包从原网卡回去</p>

<h1 id="ip-rule-add-from-3-3-3-2-table-1">ip rule add from 3.3.3.2 table 1</h1>

<p>&lt;— from 指定数据包的源IP
 &lt;— 如果数据包的源IP是3.3.3.2，那么就使用路由表1里路由条目对数据包进行路由</p>

<h1 id="ip-rule-add-from-4-4-4-2-table-2">ip rule add from 4.4.4.2 table 2</h1>

<p>路由器的配置：
 1、打开路由转发
 2、配置IP</p>

<p>客户端配置：
 1、配置IP
 2、网关根据实验改变
验证：
A:
1、把客户端的默认网关设置为1.1.1.1 ,模拟电信线路
2、ping 3.3.3.2 &lt;–Server电信线路的IP
3、捉包
在router_1： tcpdump icmp -n -i eth1
在router_2:  tcpdump icmp -n -i eth1</p>

<p>B:
1、把客户端的默认网关设置为2.2.2.1 ,模拟电信线路
2、ping 4.4.4.2 &lt;–Server网通线路的IP
3、捉包
在router_1： tcpdump icmp -n -i eth1
在router_2:  tcpdump icmp -n -i eth1</p>

<p><a href="http://itoedr.blog.163.com/blog/static/12028429720135237643677/">http://itoedr.blog.163.com/blog/static/12028429720135237643677/</a>
linux路由工具：iproute2/iptables（路由配置实例）</p>

<p>2013-06-23 19:07:01|  分类： 路由负载均衡 |  标签：路由方案  linuxk路由技术  |举报|字号 订阅</p>

<p>下载LOFTER客户端</p>

<p>1、ip route add 和 ip rule add to之间的区别</p>

<p>ip route add 是往main表中增加目的地址路由表项.ip route add*****此处只能以源地址来区分路由；</p>

<p>ip rule add to,往指定表增加目的地址路由表项. 我们可以建多个表，可以以目标地址区分路由；
ip rule add from,往指定表中增加源地址路由表项 ；
２、Linux下基于路由策略的IP地址控制实例</p>

<p>一、背景描述</p>

<p>LINUX是一台网关服务器，内有3块网卡。</p>

<p>eth1绑定172.17.0.0/16的IP，该网段IP可以通过172.17.1.1上网。</p>

<p>eth0绑定192.168.10.0/24的IP，该网段IP可以通过192.168.10.1上网。</p>

<p>eth2绑定192.168.1.1，是内网用户的网关。</p>

<p>二、需求分析</p>

<p>内网用户应该走172.17.1.1这个路由上网。</p>

<p>但由于工作需要，部分用户应该有访问图中“专用网络”的权限。</p>

<p>也就是说，应该走192.168.10.1这个路由。</p>

<p>另外一点，所有人应该可以访问FTP服务器，这个服务器的IP是192.168.10.96</p>

<p>也就是说，走172.17.1.1路由的人，也应该能访问192.168.10.96，且可以上网。</p>

<p>三、解决方案</p>

<p>要解决这个问题，用到了一下几个命令，具体使用方法需要另查资料。</p>

<p>ip route</p>

<p>ip rule</p>

<p>arp</p>

<p>注：关于ip命令的用法，请查阅ip中文手册。</p>

<p>1、绑定IP</p>

<p>ifconfig eth1 172.17.3.x netmask 255.255.0.0</p>

<p>ifconfig eth0 192.168.10.2 netmask 255.255.255.0</p>

<p>ifconfig eth2 192.168.1.1 netmask 255.255.255.0</p>

<p>然后分别修改/etc/sysconfig/network-script/ifcfg-ethx文件，以使计算机启动自动设置IP地址。</p>

<p>在ubuntu下，使用interfaces来定义；</p>

<p>2、创建特殊路由表（手中创建）</p>

<p>vi /etc/iproute2/rt_table</p>

<p>代码:</p>

<p>#</p>

<h1 id="reserved-values-1">reserved values</h1>

<p>#</p>

<p>255 local</p>

<p>254 main</p>

<p>253 default</p>

<p>0 unspec</p>

<p>200 NET10</p>

<p>#</p>

<h1 id="local-1">local</h1>

<p>#</p>

<p>#1 inr.ruhep</p>

<p>上面那个200 NET10为新添加，自定义编号为200，名字为NET10</p>

<p>3、向NET10路由中添加它自己的默认路由。</p>

<p>代码:</p>

<p>ip route add default via 192.168.10.1 table NET10</p>

<p>注意，这个table NET10一定不要忘了写，否则写到了主路由表中。</p>

<p>4、创建特殊路由规则</p>

<p>用ip rule可以看到计算机当前的路由规则。</p>

<p>引用:</p>

<p>0: from all lookup local</p>

<p>32766: from all lookup main</p>

<p>32767: from all lookup default</p>

<p>可以看到，规则中走了3个路由表，local、main、default</p>

<p>我们平常用route看到的，实际是路由表main</p>

<p>这些规则是按序号大小顺序走的，一个不同，则走下一个，知道通路或走完为止。</p>

<p>开始添加我们自己的路由NET10到路由表中。</p>

<p>代码:</p>

<p>ip rule add from 192.168.1.222 pref 10000 table NET10</p>

<p>这个意思是说，如果来自IP地址为192.168.1.222的访问，则启用NET10的路由表中的路由规则。</p>

<p>而NET10的路由规则是什么呢？上面已经设置了，走的是192.168.10.1的网段。</p>

<p>接下来，使LINUX可以NAT（这里不再细说HOW TO了）</p>

<p>5、让所有人可以访问192.168.10.xx（这个IP不便说出来）</p>

<p>因为其余人都走了172.17.1.1这个路由，所以他们是无法访问192.168.10.xx的 。</p>

<p>怎么才能实现呢？再添加个策略就可以了！</p>

<p>代码:</p>

<p>ip rule add to 192.168.10.xx pref 10001 table NET10</p>

<p>这句话的意思是说，所有人，如果目的IP是192.168.10.xx，则临时使用NET10的路由表。</p>

<p>这样做，安全会不会有安全问题呢？路由变了，他们会不会访问到专用网络呢？</p>

<p>不会的，因为路由规则是to 192.168.10.xx，也就是目标是96时，才该路由的，访问别的网站还是走原来的路由。</p>

<p>如果说访问到专用网络的机器，也就只有10.xx这一台而已。</p>

<p>这里，我们还可以做一个小技巧，不告诉别人192.168.10.xx的地址，只告诉他们网关192.168.1.1上有这个服务</p>

<p>iptables -t nat -A PREROUTING -d 192.168.1.<sup>1</sup>&frasl;<sub>32</sub> &ndash;dport 21 -j DNAT &ndash;to 192.168.10.xx:21</p>

<p>6、防止其他人篡改IP地址而获得特殊权限</p>

<p>arp有个静态功能CM，不是C，大家可能知道。</p>

<p>如果给一个IP地址强行绑定一个非他自己的MAC，会怎么样呢？双方会话将会失败！</p>

<p>好，我们来利用这一点！</p>

<p>首先，我写了一个文件iproute.c</p>

<p>代码:</p>

<p>#include</p>

<p>#include</p>

<p>main ()</p>

<p>{</p>

<p>int i;</p>

<p>for(i=2;i&lt;255;i++)</p>

<p>printf(&ldquo;192.168.1.%d\t\t00:00:00:00:00:00\n&rdquo;,i);</p>

<p>}</p>

<p>gcc iproute.c -o iproute</p>

<p>将编译出一个可执行文件</p>

<p>注：不应该包括主机IP地址本身，所以从2循环到254（255是广播）</p>

<p>其次，生成一个C的IP地址和全为00的MAC地址。</p>

<p>代码:</p>

<p>./iproute &gt; /etc/ethers</p>

<p>再次，修改IP－MAC匹配列表。</p>

<p>vi /etc/ethers</p>

<p>具体怎么该我就不用细说了，相信大家都会。</p>

<p>最后，做静态IP-MAC绑定。</p>

<p>arp -f</p>

<p>7、为了安全，建立防火墙，修改main路由表</p>

<p>默认的路由表应该有192.168.10.0/24和172.17.0.0/16网段的内容，为了安全，可以去掉。</p>

<p>参考实例：</p>

<p>ip route add 58.14.0.0/15 via 192.168.33.1 table cnline</p>

<p>此处会新建路由表cnline;
ip route add 58.16.0.0/16 via 192.168.33.1 table cnline</p>

<p>ip route del default #操作的是路由表main；
ip route add default via 192.168.33.1　＃也给主路由表main加上了cnline相同的网关，单网卡情况，只能如此，多网卡即可出于不同网卡了，使用ebtables也可以实现类似功能；
ip rule add from 192.168.2.6 pref 1000 lookup cnline　＃表示主机源192.168.2.6的请求都去cnline表的规定路由；
ip rule add from 192.168.2.4 pref 1000 lookup cnline
ip rule add from 192.168.2.32 pref 1000 lookup cnline
ip rule add to 10.10.10.189 pref 1000 lookup cnline      ＃即去目标地址为10.10.10.189的数据包也在cnline中找出路；其中lookup可以省去，不过笔者喜欢写着，意义更明确。</p>

                      
                    </div>
                    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
    <div style="float:left;margin-top:0px;">
    <img src="//blog.pytool.com/public/qrcode.jpg" width="129px" height="129px"/>
    <div style="text-align:center;">微信扫一扫交流</div>
    </div>
    <div>
        <p style="margin-top:0px;">作者：<a target="_blank" href="http://blog.pytool.com/">rinetd</a>
        
        <br />本文出处：<a target="_blank" href="//blog.pytool.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2016-01-01-linux%E5%91%BD%E4%BB%A4-iproute2/">//blog.pytool.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2016-01-01-linux%E5%91%BD%E4%BB%A4-iproute2/</a>
        <br />
        文章版权归本人所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 </p>
    </div>
</div>

                    <div class="clear"></div>
                  </div>
                  

                </div>
                
              </article>
              
              <div class="clear"></div>
              

              
<section id="comments" class="themeform">
  <div id="SOHUCS"></div>
	<script type="text/javascript">
	(function(){
		if (window.location.hostname === 'localhost') return;
		if (window.location.hostname === '127.0.0.1') return;

		var appid = 'cytgPrsTW';
		var conf = 'prod_a8b514a0c64b034bba38e466be98c266';
		var width = window.innerWidth || document.documentElement.clientWidth;
		if (width < 960) {window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); }
	})();
	</script>

  

  

<div id="disqus_thread"></div>
  <script type="text/javascript">
  (function() {
      
      
      if (window.location.hostname === 'localhost') return;
  		if (window.location.hostname === '127.0.0.1') return;
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'rinetd';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  


</section>

            </div>
          </section>
          <div class="sidebar s1">
  <a class="sidebar-toggle" title="Expand Sidebar"><i class="fa icon-sidebar-toggle"></i></a>
  <div class="sidebar-content">
    <div class="sidebar-top group">
      <p>Follow:</p>
      <ul class="social-links">
    <li>
    <a class="social-tooltip" title="On WeiBo"
        href="http://weibo.com/rinetd" target="_blank">
        <i class="fa fa-weibo"></i>
    </a>
    </li>
    <li>
    <a class="social-tooltip" title="On Twitter" rel="nofollow"
        href="https://twitter.com/rinetd" target="_blank">
        <i class="fa fa-twitter"></i>
    </a>
    </li>
    <li>
    <a class="social-tooltip" title="On GitHub"
        href="https://github.com/rinetd" target="_blank">
        <i class="fa fa-github"></i>
    </a>
    </li>
</ul>

    </div>

    <ul class="post-nav group">
    <li class="previous">
      
      <a href="//blog.pytool.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2016-01-01-linux%E5%91%BD%E4%BB%A4-repo/" rel="prev">
        <i class="fa fa-chevron-left"></i>
        <strong>Previous Post</strong>
        <span>Linux命令 repo</span>
      </a>
      
  </li>
</ul>

    <div id="categories-2" class="widget widget_categories"><h3>分类</h3>
  <ul>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/android/">Android</a>
        <small>(16)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/android%E5%BA%95%E5%B1%82/">Android底层</a>
        <small>(7)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/english/">English</a>
        <small>(1)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/golang/">Golang</a>
        <small>(56)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/lessons/">Lessons</a>
        <small>(17)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/linux%E5%86%85%E6%A0%B8/">Linux内核</a>
        <small>(4)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/linux%E5%91%BD%E4%BB%A4/">Linux命令</a>
        <small>(88)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/linux%E5%9F%BA%E7%A1%80/">Linux基础</a>
        <small>(89)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/stm32/">Stm32</a>
        <small>(5)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E4%B8%AD%E5%8C%BB/">中医</a>
        <small>(1)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a>
        <small>(3)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E5%A5%87%E7%9C%9F%E5%BC%82%E5%AE%9D/">奇真异宝</a>
        <small>(10)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8Flinux/">嵌入式linux</a>
        <small>(1)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
        <small>(9)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/">数据算法</a>
        <small>(1)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/">文本编辑</a>
        <small>(20)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
        <small>(2)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
        <small>(3)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a>
        <small>(8)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/">端口转发</a>
        <small>(1)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a>
        <small>(44)</small>
      </li>
    
      <li class="cat-item cat-item-1">
        <a rel="nofollow" href="//blog.pytool.com/categories/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/">静态博客</a>
        <small>(10)</small>
      </li>
    
  </ul>
</div>

    
    
     
  <div id="search-2" class="widget widget_search"><h3>Search</h3>
      <form method="get" class="searchform themeform" action="https://www.google.com/search">
        <div>
          <input type="text" class="search" name="q" placeholder="Press enter to start searching">
        </div>
      </form>
    </div>
  </div>
  
</div>

          <div class="sidebar s2">
  <a class="sidebar-toggle" title="Expand Sidebar"><i class="fa icon-sidebar-toggle"></i></a>
  <div class="sidebar-content">
    <div class="sidebar-top group">
      <p>More</p>
    </div>

    
    <ul class="post-nav group">
    <li class="next">
      
      <a href="//blog.pytool.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2016-01-01-linux%E5%91%BD%E4%BB%A4-rsync/" rel="next">
        <i class="fa fa-chevron-right"></i>
        <strong>Next post</strong>
        <span>Linux命令 rsync</span>
      </a>
      
  </li>
</ul>

    <div id="tag_cloud-2" class="widget widget_tag_cloud"><h3>标签云</h3>
  <div class="tagcloud post-tags">
      
         <a rel="tag" href="//blog.pytool.com/tags/ack/" class="tag-link-8" title="1 Posts">ack<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/activity/" class="tag-link-3" title="1 Posts">activity<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/adb/" class="tag-link-8" title="1 Posts">adb<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ansible/" class="tag-link-4" title="1 Posts">ansible<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/apt/" class="tag-link-8" title="1 Posts">apt<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/aria2/" class="tag-link-6" title="1 Posts">aria2<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/arp/" class="tag-link-8" title="1 Posts">arp<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/atom/" class="tag-link-7" title="1 Posts">atom<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/autohotkey/" class="tag-link-1" title="1 Posts">autohotkey<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/awesome/" class="tag-link-4" title="1 Posts">awesome<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/awk/" class="tag-link-8" title="1 Posts">awk<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/bash/" class="tag-link-7" title="1 Posts">bash<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/bat/" class="tag-link-8" title="1 Posts">bat<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/bc/" class="tag-link-9" title="1 Posts">bc<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/bower/" class="tag-link-6" title="1 Posts">bower<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/burpssuite/" class="tag-link-1" title="1 Posts">burpssuite<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/burpsuite/" class="tag-link-2" title="1 Posts">burpsuite<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/capistrano/" class="tag-link-1" title="1 Posts">capistrano<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/cash/" class="tag-link-7" title="1 Posts">cash<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/centos7/" class="tag-link-4" title="1 Posts">centos7<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/coffeescript/" class="tag-link--1" title="1 Posts">coffeescript<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/composer/" class="tag-link-3" title="1 Posts">composer<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/coreos/" class="tag-link-5" title="1 Posts">coreos<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/crontab/" class="tag-link-4" title="1 Posts">crontab<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/cryptsetup/" class="tag-link-1" title="1 Posts">cryptsetup<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/css/" class="tag-link-8" title="1 Posts">css<small>(12)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/css3/" class="tag-link-7" title="1 Posts">css3<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ctags/" class="tag-link-6" title="1 Posts">ctags<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/curl/" class="tag-link-7" title="1 Posts">curl<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/date/" class="tag-link-7" title="1 Posts">date<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/dd/" class="tag-link-9" title="1 Posts">dd<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/debug/" class="tag-link-6" title="1 Posts">debug<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/devops/" class="tag-link-5" title="1 Posts">devops<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/discourse/" class="tag-link-2" title="1 Posts">discourse<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/dnsmasq/" class="tag-link-4" title="1 Posts">dnsmasq<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/docker/" class="tag-link-5" title="1 Posts">docker<small>(7)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/dpkg/" class="tag-link-7" title="1 Posts">dpkg<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/editorconfig/" class="tag-link--1" title="1 Posts">editorconfig<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/emacs/" class="tag-link-6" title="1 Posts">emacs<small>(11)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/enca/" class="tag-link-7" title="1 Posts">enca<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/encode/" class="tag-link-5" title="1 Posts">encode<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/expect/" class="tag-link-5" title="1 Posts">expect<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ffmpeg/" class="tag-link-5" title="1 Posts">ffmpeg<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/find/" class="tag-link-7" title="1 Posts">find<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/firewall/" class="tag-link-3" title="1 Posts">firewall<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/fonts/" class="tag-link-6" title="1 Posts">fonts<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/fstab/" class="tag-link-6" title="1 Posts">fstab<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/git/" class="tag-link-8" title="1 Posts">git<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/glang/" class="tag-link-6" title="1 Posts">glang<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/go/" class="tag-link-9" title="1 Posts">go<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/go-shadowsocks2/" class="tag-link--4" title="1 Posts">go-shadowsocks2<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/golang/" class="tag-link-5" title="1 Posts">golang<small>(56)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/gpg/" class="tag-link-8" title="1 Posts">gpg<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/gpio/" class="tag-link-7" title="1 Posts">gpio<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/grep/" class="tag-link-7" title="1 Posts">grep<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/hexdump/" class="tag-link-4" title="1 Posts">hexdump<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/hexo/" class="tag-link-7" title="1 Posts">hexo<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/hmac/" class="tag-link-7" title="1 Posts">hmac<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/html/" class="tag-link-7" title="1 Posts">html<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/html5/" class="tag-link-6" title="1 Posts">html5<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/http/" class="tag-link-7" title="1 Posts">http<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/httperf/" class="tag-link-4" title="1 Posts">httperf<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/hugo/" class="tag-link-7" title="1 Posts">hugo<small>(7)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/hydra/" class="tag-link-6" title="1 Posts">hydra<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/i18n/" class="tag-link-7" title="1 Posts">i18n<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ifttt/" class="tag-link-6" title="1 Posts">ifttt<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/imagemagick/" class="tag-link-0" title="1 Posts">imagemagick<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/insomnia/" class="tag-link-3" title="1 Posts">insomnia<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/intent/" class="tag-link-5" title="1 Posts">intent<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ios/" class="tag-link-8" title="1 Posts">ios<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/iotop/" class="tag-link-6" title="1 Posts">iotop<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ip/" class="tag-link-9" title="1 Posts">ip<small>(10)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/iproute2/" class="tag-link-3" title="1 Posts">iproute2<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/iptables/" class="tag-link-3" title="1 Posts">iptables<small>(4)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/irc/" class="tag-link-8" title="1 Posts">irc<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/javascript/" class="tag-link-1" title="1 Posts">javascript<small>(6)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/linux/" class="tag-link-6" title="1 Posts">linux<small>(4)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/linux%E5%91%BD%E4%BB%A4/" class="tag-link-0" title="1 Posts">linux命令<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/locale/" class="tag-link-5" title="1 Posts">locale<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/losetup/" class="tag-link-4" title="1 Posts">losetup<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/lsof/" class="tag-link-7" title="1 Posts">lsof<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/lvm2/" class="tag-link-7" title="1 Posts">lvm2<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/makefile/" class="tag-link-3" title="1 Posts">makefile<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/mariadb/" class="tag-link-4" title="1 Posts">mariadb<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/mathjax/" class="tag-link-4" title="1 Posts">mathjax<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/mbr/" class="tag-link-8" title="1 Posts">mbr<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/md5/" class="tag-link-8" title="1 Posts">md5<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/md5sum/" class="tag-link-5" title="1 Posts">md5sum<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/meteor/" class="tag-link-5" title="1 Posts">meteor<small>(7)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/mongodb/" class="tag-link-4" title="1 Posts">mongodb<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/mtr/" class="tag-link-8" title="1 Posts">mtr<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/mysql/" class="tag-link-6" title="1 Posts">mysql<small>(4)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/nessus/" class="tag-link-5" title="1 Posts">nessus<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/netcat/" class="tag-link-5" title="1 Posts">netcat<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/netsh/" class="tag-link-6" title="1 Posts">netsh<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/nexpose/" class="tag-link-4" title="1 Posts">nexpose<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/nginx/" class="tag-link-6" title="1 Posts">nginx<small>(26)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/nmap/" class="tag-link-7" title="1 Posts">nmap<small>(3)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/nodejs/" class="tag-link-5" title="1 Posts">nodejs<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/npm/" class="tag-link-8" title="1 Posts">npm<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/nvic/" class="tag-link-7" title="1 Posts">nvic<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/oauth2/" class="tag-link-5" title="1 Posts">oauth2<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/objdump/" class="tag-link-4" title="1 Posts">objdump<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/openssl/" class="tag-link-4" title="1 Posts">openssl<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/pandoc/" class="tag-link-5" title="1 Posts">pandoc<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/php/" class="tag-link-8" title="1 Posts">php<small>(3)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/postgresql/" class="tag-link-1" title="1 Posts">postgresql<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/powershell/" class="tag-link-1" title="1 Posts">powershell<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/proxy/" class="tag-link-6" title="1 Posts">proxy<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/python/" class="tag-link-5" title="1 Posts">python<small>(5)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/redis/" class="tag-link-6" title="1 Posts">redis<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/rename/" class="tag-link-5" title="1 Posts">rename<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/repo/" class="tag-link-7" title="1 Posts">repo<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/resin/" class="tag-link-6" title="1 Posts">resin<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/responsive/" class="tag-link-1" title="1 Posts">responsive<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/restful/" class="tag-link-4" title="1 Posts">restful<small>(4)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/rethinkdb/" class="tag-link-2" title="1 Posts">rethinkdb<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/retina/" class="tag-link-5" title="1 Posts">retina<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/root/" class="tag-link-7" title="1 Posts">root<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/route/" class="tag-link-6" title="1 Posts">route<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/rsync/" class="tag-link-6" title="1 Posts">rsync<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/rtsp/" class="tag-link-7" title="1 Posts">rtsp<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ruby/" class="tag-link-7" title="1 Posts">ruby<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/samba/" class="tag-link-6" title="1 Posts">samba<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/sar/" class="tag-link-8" title="1 Posts">sar<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/scp/" class="tag-link-8" title="1 Posts">scp<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/scrapy/" class="tag-link-5" title="1 Posts">scrapy<small>(8)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/sed/" class="tag-link-8" title="1 Posts">sed<small>(3)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/selenium/" class="tag-link-3" title="1 Posts">selenium<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/sftp/" class="tag-link-7" title="1 Posts">sftp<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/shell/" class="tag-link-6" title="1 Posts">shell<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/snap/" class="tag-link-7" title="1 Posts">snap<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/sort/" class="tag-link-7" title="1 Posts">sort<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ssh/" class="tag-link-8" title="1 Posts">ssh<small>(3)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ssl/" class="tag-link-8" title="1 Posts">ssl<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/sso/" class="tag-link-8" title="1 Posts">sso<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ssrf/" class="tag-link-7" title="1 Posts">ssrf<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/stm32/" class="tag-link-6" title="1 Posts">stm32<small>(5)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/sublime/" class="tag-link-4" title="1 Posts">sublime<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/sudo/" class="tag-link-7" title="1 Posts">sudo<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/svg/" class="tag-link-8" title="1 Posts">svg<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/swagger/" class="tag-link-4" title="1 Posts">swagger<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/swarm/" class="tag-link-6" title="1 Posts">swarm<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/systemctl/" class="tag-link-2" title="1 Posts">systemctl<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/tc/" class="tag-link-9" title="1 Posts">tc<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/tcpdump/" class="tag-link-4" title="1 Posts">tcpdump<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/tim/" class="tag-link-8" title="1 Posts">tim<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/time/" class="tag-link-7" title="1 Posts">time<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/timezone/" class="tag-link-3" title="1 Posts">timezone<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/tmux/" class="tag-link-7" title="1 Posts">tmux<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/top/" class="tag-link-8" title="1 Posts">top<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/tr/" class="tag-link-9" title="1 Posts">tr<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/tshark/" class="tag-link-5" title="1 Posts">tshark<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ubuntu/" class="tag-link-5" title="1 Posts">ubuntu<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/ulimit/" class="tag-link-5" title="1 Posts">ulimit<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/underscore/" class="tag-link-1" title="1 Posts">underscore<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/unpack/" class="tag-link-5" title="1 Posts">unpack<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/update-alternatives/" class="tag-link--8" title="1 Posts">update-alternatives<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/useradd/" class="tag-link-4" title="1 Posts">useradd<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/vim/" class="tag-link-8" title="1 Posts">vim<small>(5)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/visualstudiocode/" class="tag-link--5" title="1 Posts">visualstudiocode<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/vlc/" class="tag-link-8" title="1 Posts">vlc<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/webpack3/" class="tag-link-3" title="1 Posts">webpack3<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/wget/" class="tag-link-7" title="1 Posts">wget<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/windows10/" class="tag-link-2" title="1 Posts">windows10<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/windump/" class="tag-link-4" title="1 Posts">windump<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/wireshark/" class="tag-link-2" title="1 Posts">wireshark<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/xidel/" class="tag-link-6" title="1 Posts">xidel<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/xml/" class="tag-link-8" title="1 Posts">xml<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/xmllint/" class="tag-link-4" title="1 Posts">xmllint<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/xpath/" class="tag-link-6" title="1 Posts">xpath<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/yaml/" class="tag-link-7" title="1 Posts">yaml<small>(2)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" class="tag-link-2" title="1 Posts">响应式<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" class="tag-link--4" title="1 Posts">自动化测试<small>(1)</small></a>
      
         <a rel="tag" href="//blog.pytool.com/tags/%E8%B4%A6%E6%88%B7%E7%B3%BB%E7%BB%9F/" class="tag-link--1" title="1 Posts">账户系统<small>(1)</small></a>
      
  </div>
</div>

    

    
  </div>
</div>

        </div>
      </div>
    </div>
  </div>
</div>
<footer id="footer">
  <section class="container" id="footer-bottom">
    <div class="container-inner">
      <a id="back-to-top" href="#"><i class="fa fa-angle-up"></i></a>
      <div class="pad group">
        <div class="grid one-half">
          <div id="copyright">
              <p>Copyright (c) 2017. All rights reserved. (版权所有) <a href='http://www.miitbeian.gov.cn/'>鲁ICP备17074587号-1</a></p>
              
          </div>
          
        </div>
        
        <div class="grid one-half last">
          <ul class="social-links">
    <li>
    <a class="social-tooltip" title="On WeiBo"
        href="http://weibo.com/rinetd" target="_blank">
        <i class="fa fa-weibo"></i>
    </a>
    </li>
    <li>
    <a class="social-tooltip" title="On Twitter" rel="nofollow"
        href="https://twitter.com/rinetd" target="_blank">
        <i class="fa fa-twitter"></i>
    </a>
    </li>
    <li>
    <a class="social-tooltip" title="On GitHub"
        href="https://github.com/rinetd" target="_blank">
        <i class="fa fa-github"></i>
    </a>
    </li>
</ul>

        </div>
      </div>

    </div>
    
  </section>
  
</footer>



<script src="//blog.pytool.com/public/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
<script type="text/javascript" src="//blog.pytool.com/wp-content/themes/hueman/js/jquery.jplayer.min.js"></script>
<script type="text/javascript" src="//blog.pytool.com/wp-content/themes/hueman/js/scripts.js"></script>
<script type="text/javascript" src="//blog.pytool.com/assets/picturefill/picturefill.min.js"></script>
<script type="text/javascript" src="//blog.pytool.com/assets/js/jquery.matchHeight-min.js"></script>
<script type="text/javascript" async defer src="//blog.pytool.com/assets/js/myblog.js"></script>



<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-106129999-2', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?e2103759b6030b3c4ac84c63c542e493";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>

</body>
</html>

