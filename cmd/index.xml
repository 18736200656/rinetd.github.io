<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Cmds on 时光小栈</title>
        <link>//blog.pytool.com/cmd/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Fri, 06 Jan 2017 16:46:14 CST</updated>
        
        <item>
            <title>Linux命令 extundelete</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-extundelete/</link>
            <pubDate>Fri, 06 Jan 2017 16:46:14 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-extundelete/</guid>
            <description>

&lt;p&gt;参阅博文《使用 Linux 文件恢复工具》&lt;a href=&#34;http://www.ibm.com/developerworks/cn/linux/1312_caoyq_linuxrestore/&#34; target=&#34;_blank&#34;&gt;http://www.ibm.com/developerworks/cn/linux/1312_caoyq_linuxrestore/&lt;/a&gt;&lt;br /&gt;
使用&lt;/p&gt;

&lt;p&gt;inode 和 block&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linux 文件系统的最基本单元：inode。inode 译成中文就是索引节点，每个存储设备（例如硬盘）或存储设备的分区被格式化为文件系统后，应该有两部份，一部份是 inode，另一部份是 block，block 是用来存储数据用的。而 inode 呢，就是用来存储这些数据的信息，这些信息包括文件大小、属主、归属的用户组、读写权限等。inode 为每个文件进行信息索引，所以就有了 inode 的数值。linux 操作系统下可以使用 ls –id 命令来查看文件或者目录的 inode 值，一般”root”目录的 inode 值为 2,一个分区挂载到一个目录下时，这个”root”目录的 inode 值为 2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件恢复的原理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;本文要介绍的命令是通过文件系统的 inode 值（一般是 2 ）来获取文件系统信息。在 ext3 和 ext4 文件系统中，每个文件都是通过 inode 来描述其数据存放的具体位置，当文件被删除以后，inode 的数据指针部分被清零，文件目录区没有太多变化。文件的读写都是通过 inode 来实现，当 inode 数据指针被清零以后，即便文件内容还在，也没有办法把文件内容组合出来。当 ext3 和 ext4 文件系统中的元数据 metadata 发生变化时，相应的元数据 metadata 在日志文件会有一份拷贝。比如一个文件被删除了，它的 inode 信息会在日志文件中先保存一份，然后把要删除文件 inode 相关信息清零。这个日志文件是循环使用的，当操作过多时，删除的文件的 inode 日志记录会被新的数据替换，这就彻底丧失了根据 inode 找回数据的机会了。如果是大量文件的删除，这个日志文件会被反复循环利用多次，只留给最后删除的那些文件的恢复机会。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;工具名称    工作界面    功能简介&lt;br /&gt;
foremost      命令行     formost 是一个基于文件头和尾部信息以及文件的内建数据结构恢复文件的命令行工具&lt;br /&gt;
extundelete 命令行   Extundelete 是 ext3、ext4 文件系统的恢复工具&lt;br /&gt;
scalpel     命令行   scalpel 是一种快速文件恢复工具，它通过读取文件系统的数据库来恢复文件。它是独立于文件系统的&lt;br /&gt;
testdisk      字符终端  Testdisk 支持分区表恢复、raid 恢复、分区恢复&lt;br /&gt;
phtorec 字符终端 photorec 用来恢复硬盘、光盘中丢失的视频、文档、压缩包等文件，或从数码相机存储卡中恢复丢失的图片&lt;/p&gt;

&lt;p&gt;第一种情况&lt;/p&gt;

&lt;p&gt;当前系统有多个用户,其中一个用户对文件进行修改,则另一个用户对文件进行删除操作,那么这时候该如何操作? 解决方法: 通过文件打开的PID及打开的文件句柄&lt;/p&gt;

&lt;p&gt;lsof | grep -i delete&lt;br /&gt;
cp /proc/file_PID/fd/# /path/file_name&lt;/p&gt;

&lt;p&gt;-i 不区分大小写搜索 #为标志1的文件&lt;/p&gt;

&lt;p&gt;第二种情况&lt;/p&gt;

&lt;p&gt;当前系统只有一个用户在登录,对文件进行了误删除操作,那么这个时候如何操作呢? 注意事项及解决思路:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;停止对当前分区进行修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过dd命令进行对分区备份,防止通过第三方软件恢复失败,造成对数据的丢失&lt;/p&gt;

&lt;p&gt;dd if=/path/filename of /dev/sdb1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过umount命令将当前设备分区基于卸载 umount /dev/sda或者umount /mount_poit&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;卸载分区(防止继续写入)&lt;br /&gt;
extundelete /dev/sda4 &amp;ndash;inode 2 （查看节点深度文件）&lt;br /&gt;
extundelete  /dev/sda4 &amp;ndash;restore-inode  12（根据inode 恢复）&lt;br /&gt;
extundelete /dev/sda4 &amp;ndash;restore-file  passwd（根据文件名）&lt;br /&gt;
extundelete  /dev/sda4 &amp;ndash;restore-all （恢复所有文件）&lt;/p&gt;

&lt;h2 id=&#34;恢复单个文件&#34;&gt;恢复单个文件&lt;/h2&gt;

&lt;p&gt;sudo extundelete /dev/sda7 &amp;ndash;restore-file /home/dg/c/sort_binary.c&lt;/p&gt;

&lt;p&gt;extundelete-【工具下载】&lt;/p&gt;

&lt;p&gt;除了PhotoRec之外，我们也可以选择使用extundelete来完成数据恢复工作。extundelete针对的是ext3和ext4文件系统，所以相较于TestDisk而言，extundelete的使用范围就有一定的限制了。&lt;/p&gt;

&lt;p&gt;通常情况下，在进行文件恢复工作的时候，我们要先将文件系统重新挂载，然后给它分配只读权限。完成之后，再将恢复的文件写入另外一个文件系统中，这样可以避免原始数据所在的存储区域被覆盖。使用extundelete来恢复文件的操作步骤非常的简单，我们只需要选择相应的文件系统，然后运行下面这条命令即可：&lt;/p&gt;

&lt;p&gt;extundelete /dev/sda1 &amp;ndash;restore-all&lt;/p&gt;

&lt;p&gt;apt-get install extundelete&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;搜索 extundelete &amp;ndash;inode 1 /dev/dm-0&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;恢复 extundelete &amp;ndash;restore-inode inode /dev/dm-0&lt;br /&gt;
    extundelete &amp;ndash;restore-all /dev/dm-0&lt;br /&gt;
3.文件,目录,时间 extundelete &amp;ndash;help&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 gpg openssl</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-gpg/</link>
            <pubDate>Fri, 06 Jan 2017 16:46:14 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-gpg/</guid>
            <description>

&lt;p&gt;计算机技术发展这么多年，安全验证的技术也是很多种，大家熟悉有： BaseAuth, Oauth, Oauth2，基于Token的认证等机制。现在比较流行，大家常用的就是token认证的方式。&lt;br /&gt;
   token的生成一般是采用uuid保证唯一性，当用户登录时为其生成唯一的token，存储一般保存在数据库中。token过期时间采用把token二次保存在cookie或session里面，根据cookie和session的过期时间去维护token的过期时间。至于采用那种存储一般需要根据应用程序部署的环境，如果你的应用部署在多台机器上，使用nginx进行负载均衡，那么需要把token二次保存在cookie中。&lt;br /&gt;
   怎么保证用户使用状态下token持续时间的一直有效？这需要依赖框架的一种机制，大家应该都挺熟悉的，那就是aop技术（面向切面编程），在Yii2框架里面一般采用behavior来实现，主要内容就是在给用户行为的api controller添加一个before action。在action里面，从cookie中获取token,拿取用户信息，如果用户有操作的权限，就根据当前时间去更新cookie的过期时间，从而维护token的持续时间，使得token在给定时间内不会过期，这样可以使用户的操作体验达到最佳，又能起到保护程序安全的作用。&lt;/p&gt;

&lt;p&gt;支持方式    支持内容&lt;br /&gt;
公钥      RSA,RSA-E,RSA-S,ELG-E,DSA&lt;br /&gt;
对称加密   3DES,CAST5,BLOWFISH,AES,AES192,AES256,TWOFISH&lt;br /&gt;
散列0     MD5,SHA1,SHA160,SHA256,SHA384,SHA512&lt;br /&gt;
压缩     不压缩，ZIP,ZLIB,BZIP2&lt;/p&gt;

&lt;h1 id=&#34;gpg-对称加密-密码&#34;&gt;gpg 对称加密 密码&lt;/h1&gt;

&lt;p&gt;gpg -c test.cpp         #加密&lt;br /&gt;
gpg -o output.cpp test.cpp.gpg 解密&lt;/p&gt;

&lt;h1 id=&#34;gpg-非对称加密-公钥-私钥&#34;&gt;GPG 非对称加密 公钥+私钥&lt;/h1&gt;

&lt;p&gt;在 Unix 上密钥存储在 ~/.gnupg/ 中&lt;br /&gt;
~/.gnupg/pubring.gpg                 # 包含你的公钥和所有其他导入的信息&lt;br /&gt;
~/.gnupg/secring.gpg                 # 可包含多个私钥&lt;/p&gt;

&lt;h1 id=&#34;配置文件介绍&#34;&gt;配置文件介绍&lt;/h1&gt;

&lt;p&gt;GPG 配置文件目录:~/.gnupg&lt;br /&gt;
~/.gnupg/gpg.conf – 配置文件&lt;br /&gt;
~/.gnupg/trustdb.gpg – 信任库&lt;br /&gt;
~/.gnupg/pubring.gpg – 公钥库&lt;br /&gt;
~/.gnupg/secring.gpg – 私钥库&lt;/p&gt;

&lt;p&gt;常用选项的简短描述：&lt;/p&gt;

&lt;p&gt;-e 加密数据&lt;br /&gt;
-d 解密数据&lt;br /&gt;
-r 为某个收件者加密(&amp;lsquo;全名&amp;rsquo; 或者 &amp;lsquo;email@domain&amp;rsquo;)&lt;br /&gt;
-a 输出经过 ascii 封装的密钥&lt;br /&gt;
-o 指定输出文件&lt;/p&gt;

&lt;p&gt;-o, &amp;ndash;output&lt;br /&gt;
-r, &amp;ndash;recipient NAME&lt;br /&gt;
-a, &amp;ndash;armor   ascii  表示加内容转换成可见的 ASCII 码输出&lt;br /&gt;
-e, &amp;ndash;encrypt&lt;br /&gt;
-s, &amp;ndash;sign [file]&lt;br /&gt;
-d, &amp;ndash;decrypt&lt;br /&gt;
-se -r Bob [file]          sign and encrypt for user Bob&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看本机钥匙信息&lt;br /&gt;
&lt;code&gt;gpg --list-keys&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成钥匙对&lt;br /&gt;
&lt;code&gt;gpg --gen-key&lt;/code&gt;&lt;br /&gt;
输入 name email passwd&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了将自己的公钥发送给他人，你需要把公钥导出成为一个文件：&lt;br /&gt;
&lt;code&gt;gpg  -a --export [UID|name|email] --output key.pub&lt;/code&gt;&lt;br /&gt;
  -a 表示输出文本文件格式。默认输出是二进制格式，因为二进制格式不太方便在网络（比如论坛或者博客）上展示，所以推荐文本格式。&lt;br /&gt;
  &amp;ndash;output 指定输出文件的名字，你可以更改为其他名字。&lt;br /&gt;
  &amp;ndash;export 表示执行输出公钥操作，后面的 UID 为你要输出的公钥的标识。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私钥导出：&lt;br /&gt;
  &lt;code&gt;gpg -ao seckey.asc --export-secret-keys mykeyID&lt;/code&gt;&lt;br /&gt;
4. 把公钥发布到公钥服务器&lt;br /&gt;
$ &lt;code&gt;gpg --keyserver keys.gnupg.net --send-key [公钥的标识（id）]&lt;/code&gt;&lt;br /&gt;
注： &amp;ndash;keyserver 可以不加，默认为 keys.gnupg.net&lt;br /&gt;
5. 在公钥服务器搜索公钥&lt;br /&gt;
$ &lt;code&gt;gpg --keyserver keys.gnupg.net --search-key [UID|name|email]&lt;/code&gt;&lt;br /&gt;
6. 公钥并导入到本机&lt;br /&gt;
$ &lt;code&gt;gpg --keyserver keys.gnupg.net --recv-key 72E75B05&lt;/code&gt;&lt;br /&gt;
        72E75B05 是这个公钥的id，这个id跟uid都是用于标识这个公钥的，因为uid是用户随便输入的所以会有重复的情况，因此在某些需要明确指定公钥的命令，需要用id而不能用uid表示这个公钥。&lt;br /&gt;
$ &lt;code&gt;gpg --import key.public&lt;/code&gt;&lt;br /&gt;
7. 核对公钥的指纹值并签收公钥&lt;br /&gt;
$ &lt;code&gt;gpg --fingerprint&lt;/code&gt;&lt;br /&gt;
8. 公钥进行签收（sign key）：&lt;br /&gt;
$ &lt;code&gt;gpg --sign-key [UID|name|email]&lt;/code&gt;&lt;br /&gt;
  把对方的公钥导入到本机后，就已经可以用它来加密信息或者用于校验我的数字签名。不过这样每次操作时都会提示公钥不可信，因为虽然你导入了我的公钥，但存在导入冒充者的公钥的可能性。所以你需要进一步跟我核对公钥是否正确，然后签收（sign key）它&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;密钥的回收&lt;br /&gt;
&lt;code&gt;gpg -o revoke.asc –gen-revoke jianxiangqiao&lt;/code&gt;&lt;br /&gt;
选择吊销的原因：0=未指定原因，1=密钥已泄露，2=密钥被替换，3=密钥不再使用，Q=取消。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;密钥回收:当您的密钥对生成之后，您应该立即做一个公钥回收证书，如果您忘记了您的私钥的口令或者您的私钥丢失或者被盗窃，您可以发布这个证书来声明以前的公钥不再有效。 生成回收证书&lt;/p&gt;

&lt;p&gt;gpg &amp;ndash;output revoke.asc &amp;ndash;gen-revoke mykeyID&lt;/p&gt;

&lt;p&gt;导入回收证书&lt;br /&gt;
 gpg &amp;ndash;import revoke.asc&lt;br /&gt;
 发送回收证书到服务器，声明原 GPG Key 作废&lt;br /&gt;
 gpg &amp;ndash;keyserver keyserverAddress &amp;ndash;send mykeyID&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;删除密钥&lt;br /&gt;
先删除私钥&lt;br /&gt;
&lt;code&gt;gpg --delete-secret-keys jianxiangqiao&lt;/code&gt;&lt;br /&gt;
再删除公钥&lt;br /&gt;
&lt;code&gt;gpg --delete-keys jianxiangqiao&lt;/code&gt;&lt;br /&gt;
############################&lt;/p&gt;

&lt;h1 id=&#34;加密一个文件-默认&#34;&gt;加密一个文件 默认：&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;加密一个文件&lt;br /&gt;
$ &lt;code&gt;gpg -a --output message-ciper.txt -r ivarptr@126.com -e message.txt&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;-a 表示输出文本文件格式。&lt;br /&gt;
  &amp;ndash;output 指定输出（即加密后）的文件名。&lt;br /&gt;
  -r 指定信息的接收者（recipient）公钥的uid，可以是名字也可以是email地址。&lt;br /&gt;
  -e 表示这次要执行的是加密（encrypt）操作&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解密一个文件&lt;br /&gt;
现在假设我已经收到你寄过来的加密文件 message-ciper.txt，使用如下的命令解密：&lt;br /&gt;
$ &lt;code&gt;gpg --output message-plain.txt -d message-ciper.txt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;ndash;output 指定输出（即解密后）的文件名。&lt;br /&gt;
  -d 表示这次要执行的是解密（decrypt）操作&lt;br /&gt;
####################################################################&lt;/p&gt;

&lt;h1 id=&#34;gpg数字签名-用来检验一个文件是否被修改-默认-sha256&#34;&gt;GPG数字签名：用来检验一个文件是否被修改 默认:SHA256&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成独立的签名文件 abc.txt + abc.txt.asc&lt;br /&gt;
  $ &lt;code&gt;gpg -a -b abc.txt&lt;/code&gt;&lt;br /&gt;
-a 表示输出文本文件格式。&lt;br /&gt;
-b 表示以生成独立的签名文件的方式进行签名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字签名一个文件的方法B abc.txt.asc&lt;br /&gt;
如果不想生成一个独立的签名文件，则还可以用如下的命令进行签名：&lt;br /&gt;
&lt;code&gt;$ gpg -a --clearsign abc.txt&lt;/code&gt;&lt;br /&gt;
跟方法A不同的地方是用参数 –clearsign 替代了参数 -b参数 clearsign 表示将签名和原信息合并在一起，并生成一个新文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后使用如下命令进行检验：&lt;br /&gt;
$ &lt;code&gt;gpg --verify abc.txt.asc&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用如下命令可以把原始信息提取出来：&lt;br /&gt;
$ &lt;code&gt;gpg --output message-original.txt -d abc.txt.asc&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;gpg常用参数&#34;&gt;GPG常用参数:&lt;/h2&gt;

&lt;p&gt;-s, &amp;ndash;sign [文件名]        生成一份签字&lt;br /&gt;
&amp;ndash;clearsign [文件名]       生成一份明文签字&lt;br /&gt;
-b, &amp;ndash;detach-sign         生成一份分离的签字&lt;br /&gt;
-e, &amp;ndash;encrypt             加密数据&lt;br /&gt;
-c, &amp;ndash;symmetric           仅使用对称加密&lt;br /&gt;
-d, &amp;ndash;decrypt             解密数据(默认)&lt;br /&gt;
&amp;ndash;verify                  验证签字&lt;br /&gt;
&amp;ndash;list-keys               列出密钥&lt;br /&gt;
&amp;ndash;list-sigs               列出密钥和签字&lt;br /&gt;
&amp;ndash;check-sigs              列出并检查密钥签字&lt;br /&gt;
&amp;ndash;fingerprint             列出密钥和指纹&lt;br /&gt;
-K, &amp;ndash;list-secret-keys    列出私钥&lt;br /&gt;
&amp;ndash;gen-key                 生成一副新的密钥对&lt;br /&gt;
&amp;ndash;delete-keys             从公钥钥匙环里删除密钥&lt;br /&gt;
&amp;ndash;delete-secret-keys      从私钥钥匙环里删除密钥&lt;br /&gt;
&amp;ndash;sign-key                为某把密钥添加签字&lt;br /&gt;
&amp;ndash;lsign-key               为某把密钥添加本地签字&lt;br /&gt;
&amp;ndash;edit-key                编辑某把密钥或为其添加签字&lt;br /&gt;
&amp;ndash;gen-revoke              生成一份吊销证书&lt;br /&gt;
&amp;ndash;export                  导出密钥&lt;br /&gt;
&amp;ndash;send-keys               把密钥导出到某个公钥服务器上&lt;br /&gt;
&amp;ndash;recv-keys               从公钥服务器上导入密钥&lt;br /&gt;
&amp;ndash;search-keys             在公钥服务器上搜寻密钥&lt;br /&gt;
&amp;ndash;refresh-keys            从公钥服务器更新所有的本地密钥&lt;br /&gt;
&amp;ndash;import                  导入/合并密钥&lt;br /&gt;
&amp;ndash;card-status             打印卡状态&lt;br /&gt;
&amp;ndash;card-edit               更改卡上的数据&lt;br /&gt;
&amp;ndash;change-pin              更改卡的 PIN&lt;br /&gt;
&amp;ndash;update-trustdb          更新信任度数据库&lt;br /&gt;
&amp;ndash;print-md 算法 [文件]     使用指定的散列算法打印报文散列值&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;p&gt;-a, &amp;ndash;armor               输出 ASCII 文本文件&lt;br /&gt;
-r, &amp;ndash;recipient           为收件者“UID”加密&lt;br /&gt;
-u, &amp;ndash;local-user          使用这个用户标识来签字或解密&lt;br /&gt;
-z N                      设定压缩等级为 N (0 表示不压缩)&lt;br /&gt;
&amp;ndash;textmode                使用标准的文本模式&lt;br /&gt;
-o, &amp;ndash;output              指定输出文件&lt;br /&gt;
-v, &amp;ndash;verbose             详细模式&lt;br /&gt;
-n, &amp;ndash;dry-run             不做任何改变&lt;br /&gt;
-i, &amp;ndash;interactive         覆盖前先询问&lt;br /&gt;
&amp;ndash;openpgp                 行为严格遵循 OpenPGP 定义&lt;br /&gt;
&amp;ndash;pgp2                    生成与 PGP 2.x 兼容的报文&lt;/p&gt;

&lt;p&gt;(请参考在线说明以获得所有命令和选项的完整清单)&lt;/p&gt;

&lt;p&gt;范例：&lt;br /&gt;
-se -r Bob [文件名]          为 Bob 这个收件人签字及加密&lt;br /&gt;
&amp;ndash;clearsign [文件名]         做出明文签字&lt;br /&gt;
&amp;ndash;detach-sign [文件名]       做出分离式签字&lt;/p&gt;

&lt;h3 id=&#34;gpg-加密解密简明教程&#34;&gt;GPG 加密解密简明教程&lt;/h3&gt;

&lt;p&gt;大家都知道，互联网上充斥着大量的明文传输方式，可以说绝对是不安全地带。那么，我们如何保证在不安全的互联网中更可靠的传输重要数据呢？个人认为最好的方式之一就是使用 GPG 工具进行加密。此文只是简单介绍了 GPG 的常规用法，重在推广和普及 GPG 加密工具，详细的使用请参见 GPG 手册。&lt;/p&gt;

&lt;h4 id=&#34;名词解释&#34;&gt;名词解释&lt;/h4&gt;

&lt;p&gt;RSA / DSA / ElGamal : 是指加密算法&lt;/p&gt;

&lt;p&gt;GPG :（全称 GnuPG ) 是一款非对称加密(PGP)的免费软件，非对称加密方式简单讲就是指用公钥加密文件，用私钥解密文件。如果你想给谁发送加密信息，首先你要得到他的公钥，然后通过该公钥加密后传给他，对方利用自已的私钥就可解密并读取文件了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 配置文件介绍  
GPG 配置文件目录:~/.gnupg  
~/.gnupg/gpg.conf – 配置文件  
~/.gnupg/trustdb.gpg – 信任库  
~/.gnupg/pubring.gpg – 公钥库  
~/.gnupg/secring.gpg – 私钥库  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;基本操作&#34;&gt;基本操作&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;生成密钥对&lt;br /&gt;
&lt;code&gt;gpg --gen-key&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成过程中会让你选择加密方式，一般选 (1) RSA and RSA (default) 就可以了，然后还需要选择加密位数、过期日期及输入姓名，邮件地址，备注，Passphrase(访问密码）等信息。最后你就可以干点别的事，比如上上网，玩玩游戏什么的，以便让机器生成一些随机数，回头你就可以看到密钥对已经生成完毕。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;传播公钥：&lt;br /&gt;
导出公钥:生成后你可以把公钥中公钥库中导出来，以便传播给你的朋友。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gpg --export --armor mykeyID &amp;gt; gpgkey.pub.asc&lt;/code&gt; # mykeyID 部分可以用 name 或 mail 地址代替&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注： - -armor 表示加内容转换成可见的 ASCII 码输出,否则是二进制不可见内容。&lt;br /&gt;
现在你可以把导出的公钥通过 Email 等途径发送给你的朋友了，或者你也可以不导出公钥直接上传公钥到密钥服务器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`gpg --keyserver keyserverAddress --send mykeyID`  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注： &amp;ndash;keyserver 可以不加，默认为 keys.gnupg.net&lt;br /&gt;
然后只要把公钥 ID 和服务器地址告诉给朋友就可以了，朋友可以通过搜索你的 公钥 ID ，Email 地址或名字来获取并导入你的公钥，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`gpg --keyserver keyserverAddress --search-keys keyid/name/Email`  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如搜索我的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`gpg --keyserver keyserver.ubuntu.com --search-keys rikulu`  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;导入朋友的公钥&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当你获得朋友的公钥文件后，你首先需要导入公钥到公钥库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`gpg --import gpgkey.pub.asc`  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或直接从公钥服务器导入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gpg --keyserver keyserverAddress --recv-keys pubkeyID&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;私钥备份与密钥回收&#34;&gt;私钥备份与密钥回收&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;密钥的导出和导入:以便用来备份密钥或导入到其它机器上。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;导出私钥&lt;br /&gt;
&lt;code&gt;gpg -oa seckey.asc --export-secret-keys mykeyID&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入私钥&lt;br /&gt;
&lt;code&gt;gpg --import seckey.asc&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;密钥回收:当您的密钥对生成之后，您应该立即做一个公钥回收证书，如果您忘记了您的私钥的口令或者您的私钥丢失或者被盗窃，您可以发布这个证书来声明以前的公钥不再有效。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成回收证书&lt;br /&gt;
&lt;code&gt;gpg --output revoke.asc --gen-revoke mykeyID&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入回收证书&lt;br /&gt;
&lt;code&gt;gpg --import revoke.asc&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发送回收证书到服务器，声明原 GPG Key 作废&lt;br /&gt;
&lt;code&gt;gpg --keyserver keyserverAddress --send mykeyID&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;列出机器中保存的所有密钥&#34;&gt;列出机器中保存的所有密钥&lt;/h4&gt;

&lt;p&gt;列出所有公钥&lt;br /&gt;
    gpg -k&lt;/p&gt;

&lt;p&gt;列出所有私钥&lt;br /&gt;
    gpg -K&lt;/p&gt;

&lt;h4 id=&#34;常规使用&#34;&gt;常规使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对称加密与解密： 有时候没有得到对方的公钥，而且资料不是太重要，此时还可以使用简单的对称加密方式(加密及解密都使用相同的密钥/密码)，加密过程中提示输出对称密钥/密码，注意:此密码是临时用的密码,不要设置和自己的私钥保护密码一样，以防别人猜测及盗用!&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;密码加密&lt;br /&gt;
    &lt;code&gt;gpg -c filename&lt;/code&gt;&lt;br /&gt;
         -c, &amp;ndash;symmetric               仅使用对称加密&lt;/p&gt;

&lt;p&gt;密码解密&lt;br /&gt;
    &lt;code&gt;gpg -d filename.gpg&lt;/code&gt;&lt;br /&gt;
         -d, &amp;ndash;decrypt                 解密数据(默认)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非对称文件加密与解密：&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公钥加密：当你导入完好友的公钥后，就可以用朋友的公钥加密文件了，&lt;br /&gt;
    &lt;code&gt;gpg -e -r username filename (-r 表示指定用户)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;私钥解密：上面的操作会生成 filename.gpg 加密文件，之后你可以把此文件发送给好友了，对方就可以用自已的密钥来解密文件了。&lt;br /&gt;
    &lt;code&gt;gpg -d filename.gpg&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对文件签名&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;数字签名 二进制&lt;br /&gt;
&lt;code&gt;gpg -o doc.sig -s doc&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;gpg --sign test.txt&lt;/code&gt; &amp;gt;&amp;gt; test.txt.gpg&lt;br /&gt;
其中doc是原文件，doc.sig包含了原文件和签名，是二进制的。这个命令会要求你输入你的私钥的密码句。&lt;br /&gt;
&lt;code&gt;gpg -o doc.sig -ser name doc&lt;/code&gt; 既签名又加密&lt;br /&gt;
&lt;code&gt;gpg -o doc -d doc.sig&lt;/code&gt;        解密时自动校验签名&lt;br /&gt;
&lt;code&gt;gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt test.txt&lt;/code&gt;&lt;br /&gt;
-u, &amp;ndash;local-user 参数指定用发信者的私钥签名，&lt;br /&gt;
-r, &amp;ndash;recipient  参数指定用接收者的公钥加密，&lt;br /&gt;
-a, &amp;ndash;armor      参数表示采用ASCII码形式显示，&lt;br /&gt;
-s, &amp;ndash;sign       signature参数表示需要签名，&lt;br /&gt;
-e, &amp;ndash;encrypt    encrypt参数表示加密源文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;文本签名 ANSCII&lt;br /&gt;
&lt;code&gt;gpg -o doc.sig --clearsign doc&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样产生的doc.sig同样包含原文件和签名，其中签名是文本的，而原文件不变。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;分离式签名&lt;br /&gt;
&lt;code&gt;gpg -o doc.sig -ab doc&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;doc.sig仅包括签名，分离式签名的意思是原文件和签名是分开的。&lt;br /&gt;
b 表示分离式签名detach-sign&lt;/p&gt;

&lt;p&gt;如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gpg --detach-sign test.txt&lt;/code&gt;&lt;br /&gt;
  是一个二进制的数据，如果想采用ASCII码形式，要加上armor参数&lt;br /&gt;
  &lt;code&gt;gpg --armor --detach-sign test.txt&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证签名&lt;br /&gt;
&lt;code&gt;gpg --verify doc.sig [doc]&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;gpg --verify test.txt.asc test.txt&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;修改信任等级&lt;br /&gt;
&lt;code&gt;gpg --edit-key &amp;quot;rinetd&amp;quot; trust quit&lt;/code&gt;&lt;br /&gt;
请选择您要使用的密钥种类：&lt;br /&gt;
(1) DSA 和 ElGamal (默认)&lt;br /&gt;
(2) DSA (仅用于签名)&lt;br /&gt;
(5) RSA (仅用于签名)&lt;br /&gt;
您的选择？ 1  ←只有1可以用于加密，其他种类只能用于签名&lt;br /&gt;
DSA 密钥对会有 1024 位。&lt;br /&gt;
ELG-E 密钥长度应在 1024 位与 4096 位之间。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;您想要用多大的密钥尺寸？(2048)  ←选择密码的位数，位数越大，越安全，但速度越慢&lt;br /&gt;
您所要求的密钥尺寸是 2048 位&lt;/p&gt;

&lt;p&gt;请设定这把密钥的有效期限。&lt;br /&gt;
0 = 密钥永不过期&lt;br /&gt;
&lt;n&gt;  = 密钥在 n 天后过期&lt;br /&gt;
&lt;n&gt;w = 密钥在 n 周后过期&lt;br /&gt;
&lt;n&gt;m = 密钥在 n 月后过期&lt;br /&gt;
&lt;n&gt;y = 密钥在 n 年后过期&lt;br /&gt;
密钥的有效期限是？(0) 0  ←根据实际情况选择密钥期限&lt;br /&gt;
密钥永远不会过期&lt;br /&gt;
以上正确吗？(y/n)y  ←确认&lt;/p&gt;

&lt;p&gt;您需要一个用户标识来辨识您的密钥；本软件会用真实姓名、注释和电子邮件地址组合&lt;br /&gt;
成用户标识，如下所示：&lt;br /&gt;
“Heinrich Heine (Der Dichter) &lt;a href=&#34;mailto:heinrichh@duesseldorf.de&#34; target=&#34;_blank&#34;&gt;heinrichh@duesseldorf.de&lt;/a&gt;”&lt;/p&gt;

&lt;p&gt;真实姓名：Hyphen Wang  ←请填入真实姓名，后面会用到&lt;br /&gt;
电子邮件地址：gpgencrypt@linuxfly.org  ←邮件作为标记之一，不能重复&lt;br /&gt;
注释：Use for GPG Encrypt  ←仅是注释而已&lt;br /&gt;
您选定了这个用户标识：&lt;br /&gt;
“Hyphen Wang (Use for GPG Encrypt) &lt;a href=&#34;mailto:gpgencrypt@linuxfly.org&#34; target=&#34;_blank&#34;&gt;gpgencrypt@linuxfly.org&lt;/a&gt;”&lt;/p&gt;

&lt;p&gt;更改姓名(N)、注释&amp;copy;、电子邮件地址(E)或确定(O)/退出(Q)？O  ←输入“O”确认&lt;br /&gt;
您需要一个密码来保护您的私钥。  ←输入两次用于访问私钥的密码，紧记，不能公开或丢失&lt;/p&gt;

&lt;p&gt;我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动&lt;br /&gt;
鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。&lt;br /&gt;
++++++++++&amp;hellip;++++++++++..++++++++&lt;/p&gt;

&lt;p&gt;随机字节不够多。请再做一些其他的琐事，以使操作系统能搜集到更多的熵数！&lt;br /&gt;
(还需要274字节)  ←运行一些的程序，以便在内存中获得更多随机数&lt;br /&gt;
我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动&lt;br /&gt;
鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。&lt;br /&gt;
+++++++++++++++++++++++++.+++++.+++++.++++++++++.+++&amp;lt;+++++..+++++^^^&lt;br /&gt;
gpg: 密钥 A3942296 被标记为绝对信任  ←密钥ID&lt;br /&gt;
公钥和私钥已经生成并经签名。&lt;/p&gt;

&lt;p&gt;gpg: 正在检查信任度数据库&lt;br /&gt;
gpg: 需要 3 份勉强信任和 1 份完全信任，PGP 信任模型&lt;br /&gt;
gpg: 深度：0 有效性：  2 已签名：  0 信任度：0-，0q，0n，0m，0f，2u&lt;br /&gt;
pub   1024D/A3942296 2008-12-19&lt;br /&gt;
密钥指纹 = E95E 1F77 6C4E 33BD 740C  19AB EEF9 A67E A394 2296&lt;br /&gt;
uid                  Hyphen Wang (Use for GPG Encrypt) &lt;a href=&#34;mailto:gpgencrypt@linuxfly.org&#34; target=&#34;_blank&#34;&gt;gpgencrypt@linuxfly.org&lt;/a&gt;&lt;br /&gt;
sub   2048g/911E677B 2008-12-19&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;密钥的回收&lt;br /&gt;
当您的密钥对生成之后，您应该立即做一个公钥回收证书，如果您忘记了您的私钥的口令或者您的私钥丢失或者被盗窃，您可以发布这个证书来声明以前的公钥不再有效。生成回收证书的选项是&amp;rdquo;&amp;ndash;gen-revoke&amp;rdquo;。&lt;br /&gt;
&lt;code&gt;gpg --output revoke.asc --gen-revoke mykeyID&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中mykey 参数是可以表示的密钥标识，产生的回收证书放在revoke.asc文件里，一旦回收证书被发放，以前的证书就不能再被其他用户访问，因此以前的公钥也就失效了。&lt;/p&gt;

&lt;p&gt;PS:如果一旦决定撤销已经上传的公钥，就需要将该密钥的回收证书上传至密钥服务器完成回收工作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gpg --keyserver Server Address --send-keys mykeyID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.密钥的上传&lt;/p&gt;

&lt;p&gt;当上述工作完成以后，为了让尽可能多的人获取您的公钥，您可以将公钥邮寄出去，或者贴在自己的个人主页上，当然还有一种更好的方法就是上传到全球性的密钥服务器，其他用户可以通过您提供的公钥ID来搜索并获得您的公钥。&lt;/p&gt;

&lt;p&gt;通过如下命令可以将你的key发布到服务器上：&lt;/p&gt;

&lt;p&gt;gpg &amp;ndash;keyserver Server Address &amp;ndash;send-keys mykeyID&lt;br /&gt;
PS:当然您也可以定义默认的服务器key server，一般安装好后的默认key server都是subkeys.pgp.net。你也可以通过修改.gnupg/gpg.conf中的keyserver信息来改变你的key server。&lt;br /&gt;
4.密钥的导出／导入&lt;/p&gt;

&lt;p&gt;我们通常需要导出公钥和私钥保存起来，当然公钥是可以满世界的泼洒，但是私钥请务必保存好，否则你的密钥对将会永久性的失去威力。&lt;br /&gt;
公钥的导出：&lt;br /&gt;
gpg -o keyfilename &amp;ndash;export mykeyID&lt;/p&gt;

&lt;p&gt;如果没有mykeyID则是备份所有的公钥，-o表示输出到文件keyfilename中，如果加上-a的参数则输出文本格式( ASCII )的信息，否则输出的是二进制格式信息。&lt;/p&gt;

&lt;p&gt;私钥的导出：&lt;br /&gt;
gpg -o keyfilename &amp;ndash;export-secret-keys mykeyID&lt;/p&gt;

&lt;p&gt;如果没有mykeyID则是备份所有的私钥，-o表示输出到文件keyfilename中，如果加上-a的参数则输出文本格式的信息，否则输出的是二进制格式信息。&lt;/p&gt;

&lt;p&gt;密钥的导入：&lt;br /&gt;
gpg &amp;ndash;import filename&lt;/p&gt;

&lt;p&gt;PS:用户可以使用gpg &amp;ndash;list-keys命令查看是否成功导入了密钥。&lt;/p&gt;

&lt;p&gt;5.加密解密和数字签名&lt;/p&gt;

&lt;p&gt;通过上述的密钥生成以及公钥分发后，加密和解密数据变得非常容易，用户可以通过使用该功能来达到安全地在网络上传输自己的隐密数据的目的。&lt;/p&gt;

&lt;p&gt;如果用户patterson要给用户liyang发送一个加密文件，则他可以使用liyang的公钥加密这个文件，并且这个文件也只有liyang使用自己的密钥才可以解密查看。下面给出加解密的步骤：&lt;/p&gt;

&lt;p&gt;用户patterson使用liyang的公钥加密文件test，使用下面的指令：&lt;/p&gt;

&lt;h1 id=&#34;gpg-e-test&#34;&gt;gpg -e test&lt;/h1&gt;

&lt;p&gt;You did not specify a user ID. (you may use &amp;ldquo;-r&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;Enter the user ID. End with an empty line: liyang&lt;/p&gt;

&lt;p&gt;Added 1024g/C50E455A 2006-01-02 &amp;ldquo;liyang (hello) &amp;lt; liyang@sina.com&amp;gt;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;这样，就可以将gpg.conf文件加密成test.gpg，一般用户是无法阅读的&lt;/p&gt;

&lt;p&gt;PS:当然你也可以直接指定使用哪个用户的公钥进行加密:&lt;/p&gt;

&lt;p&gt;gpg -e -r liyang test  (-r 表示指定用户)&lt;/p&gt;

&lt;p&gt;还可以加上参数 -a 来输出ASCII编码的文件test.asc(test.gpg是二进制编码的，不可用文本读)&lt;/p&gt;

&lt;p&gt;gpg -ea -r liyang test&lt;/p&gt;

&lt;p&gt;用户liyang 使用自己的私钥来解密该文件，如下所示：&lt;/p&gt;

&lt;h1 id=&#34;gpg-d-test-gpg&#34;&gt;gpg -d test.gpg&lt;/h1&gt;

&lt;p&gt;You need a passphrase to unlock the secret key for&lt;/p&gt;

&lt;p&gt;user: &amp;ldquo;liyang (hello) &amp;lt; liyang@sina.com&amp;gt;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;1024-bit ELG-E key, ID C50E455A, created 2006-01-02 (main key ID 378D11AF)&lt;/p&gt;

&lt;p&gt;GnuPG提示用户，需要输入生成私钥使用的密码：&lt;/p&gt;

&lt;p&gt;Enter passphrase:&lt;/p&gt;

&lt;p&gt;gpg: encrypted with 1024-bit ELG-E key, ID C50E455A, created 2006-01-02&lt;/p&gt;

&lt;p&gt;&amp;ldquo;liyang (hello) &amp;lt; liyang@sina.com&amp;gt;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;PS:无论加密解密，都可以加上-o参数来指定加密和解密后的输出文件，例如&lt;/p&gt;

&lt;p&gt;#gpg -o doc.gpg -er name doc&lt;br /&gt;
其中name是选择谁的公钥加密，即谁是文件的接收者。&lt;br /&gt;
doc为要加密的文件，即原文件&lt;br /&gt;
doc.gpg为命令执行后生成的加密的文件，这里要先指定好文件名&lt;/p&gt;

&lt;p&gt;对文件进行签名&lt;br /&gt;
1、数字签名&lt;br /&gt;
命令格式：&lt;br /&gt;
#gpg -o doc.sig -s doc&lt;br /&gt;
其中doc是原文件，doc.sig包含了原文件和签名，是二进制的。这个命令会要求你输入你的私钥的密码句。&lt;br /&gt;
#gpg -o doc.sig -ser name doc&lt;br /&gt;
既签名又加密&lt;/p&gt;

&lt;p&gt;2、文本签名&lt;br /&gt;
#gpg -o doc.sig &amp;ndash;clearsign doc&lt;br /&gt;
这样产生的doc.sig同样包含原文件和签名，其中签名是文本的，而原文件不变。&lt;/p&gt;

&lt;p&gt;3、分离式签名&lt;br /&gt;
#gpg -o doc.sig -ab doc&lt;br /&gt;
doc.sig仅包括签名，分离式签名的意思是原文件和签名是分开的。&lt;br /&gt;
b 表示分离式签名detach-sign&lt;/p&gt;

&lt;p&gt;4、验证签名&lt;br /&gt;
#gpg &amp;ndash;verify doc.sig [doc]&lt;br /&gt;
验证之前必须导入文件作者的公钥，对于分离式签名，最后还要加上原文件，即后面的doc。&lt;/p&gt;

&lt;p&gt;密匙签名和用户信任(进阶功能)&lt;br /&gt;
尽管在理论上讲，具备了公匙和私匙就可以实现安全的信息通讯，但是在实际应用中，还必须对公匙进行有效确认。因为，确实存在伪造公匙信息的可能。&lt;/p&gt;

&lt;p&gt;由此，在GPG中引入了一个复杂的信任系统，以帮助我们区分哪些密匙是真的，哪些密匙是假的。这个信任系统是基于密匙的，主要包括密匙签名。&lt;/p&gt;

&lt;p&gt;当收到熟人的公匙并且GPG告知不存在任何实体可信信息附加于这个公匙后，首要的事情就是对这个密匙进行“指纹采样”（fingerprint）。例如，我们对来自mike的公匙进行了导入操作，并且GPG告知我们不存在这个密匙的附加可信信息，这时候，我们首先要做的工作就是对这个新密匙进行“指纹采样 ”，相关命令及执行情况如下：&lt;/p&gt;

&lt;p&gt;$ gpg &amp;ndash;fingerprint mike@hairnet.orgpub 1024D/4F03BD39 2001-01-15 Mike Socks (I&amp;rsquo;m WIRED) Key fingerprint = B121 5431 8DE4 E3A8 4AA7 737D 20BE 0DB8 4F03 BD39sub 1024g/FDBB477D 2001-01-15$&lt;/p&gt;

&lt;p&gt;这样，就从密匙数据中生成了其指纹信息，并且应该是唯一的。然后，我们打电话给mike，确认两件事情。首先，他是否发送给我们了密匙；其次，他的公匙的指纹信息是什么。如果Mike确认了这两件事情，我们就可以确信这个密匙是合法的。接下来，我们对密匙进行签名操作，以表示这个密匙来自Mike而且我们对密匙的信任，相关命令及执行情况如下：&lt;/p&gt;

&lt;p&gt;$ gpg &amp;ndash;sign-key mike@hairnet.orgpub 1024D/4F03BD39 created: 2001-01-15 expires: neversub 1024g/FDBB477D created: 2001-01-15 expires: never(1) Mike Socks (I&amp;rsquo;m WIRED) pub 1024D/4F03BD39 created: 2001-01-15 expires: neverFingerprint = B121 5431 8DE4 E3A8 4AA7 737D 20BE 0DB8 4F03 BD39Mike Socks (I&amp;rsquo;m WIRED) Are you really sure that you want to sign this keywith your key: Ima User (I&amp;rsquo;m just ME) Really sign? yYou need a passphrase to unlock the secret key foruser: Ima User (I&amp;rsquo;m just ME) 1024-bit DSA key, ID D9BAC463, created 2001-01-03Enter passphrase:$&lt;/p&gt;

&lt;p&gt;执行到此，使用我们的私匙完成了对Mike的公匙的签名操作，任何持有我们的公匙的人都可以查证签名确实属于我们自己。这个附加到Mike的公匙上的签名信息将随它环游Internet世界，我们使用个人信誉，也就是我们自己的私匙，保证了那个密匙确实属于Mike。这是一个多么感人的充满诚信的故事啊 :-) 现实世界的人们是否应该从这严格的技术标准中反思些什么呢？&lt;/p&gt;

&lt;p&gt;还是回到这里。获取附加于一个公匙上的签名信息列表的命令是：&lt;/p&gt;

&lt;p&gt;gpg &amp;ndash;check-sigs mike@hairnet.org&lt;/p&gt;

&lt;p&gt;签名列表越长，密匙的可信度越大。其实，正是签名系统本身提供了密匙查证功能。假设我们接收到一个签名为Mike的密匙，通过Mike的公匙，我们验证出签名确实属于Mike，那么我们就信任了这个密匙。推而广之，我们就可以信任Mike签名的任何密匙。&lt;/p&gt;

&lt;p&gt;为了更加稳妥，GPG还引入了另一个附加功能：可信级别（trust level）。使用它，我们可以为我们拥有的任何密匙的所有者指定可信级别。例如，即使我们知道Mike的公匙是可信的，但是事实上我们不能信任Mike在对其他密匙签名时的判断；我们会想，Mike也许只对少数密匙进行了签名，但却没有好好地检查一遍。&lt;/p&gt;

&lt;p&gt;设置可信级别的命令及执行情况如下：&lt;/p&gt;

&lt;p&gt;$ gpg &amp;ndash;edit-key mike@hairnet.orgpub 1024D/4F03BD39 created: 2001-01-15 expires: never trust: -/fsub 1024g/FDBB477D created: 2001-01-15 expires: never(1) Mike Socks (I&amp;rsquo;m WIRED) Command&amp;gt; trust 1 = Don&amp;rsquo;t know 2 = I do NOT trust 3 = I trust marginally 4 = I trust fully s = please show me more information m = back to the main menuYour decision? 2Command&amp;gt; quit$&lt;/p&gt;

&lt;p&gt;在命令编辑环境中执行trust，然后选择级别2（I do NOT trust），这样我们割断了任何信任链，使每个密匙都必须经过Mike的签名。&lt;/p&gt;

&lt;p&gt;6.删除密钥&lt;/p&gt;

&lt;p&gt;从私钥钥匙环里删除密钥：&lt;/p&gt;

&lt;h1 id=&#34;gpg-delete-secret-keys-hyphenwang-redflag-linux-com&#34;&gt;gpg &amp;ndash;delete-secret-keys hyphenwang@redflag-linux.com&lt;/h1&gt;

&lt;p&gt;gpg (GnuPG) 1.4.5; Copyright &amp;copy; 2006 Free Software Foundation, Inc.&lt;br /&gt;
This program comes with ABSOLUTELY NO WARRANTY.&lt;br /&gt;
This is free software, and you are welcome to redistribute it&lt;br /&gt;
under certain conditions. See the file COPYING for details.&lt;br /&gt;
sec  1024D/A3942296 2008-12-19 Hyphen Wang (Use for GPG Encrypt) &lt;a href=&#34;mailto:gpgencrypt@linuxfly.org&#34; target=&#34;_blank&#34;&gt;gpgencrypt@linuxfly.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要从钥匙环里删除这把密钥吗？(y/N)y&lt;br /&gt;
这是一把私钥！――真的要删除吗？(y/N)y&lt;/p&gt;

&lt;p&gt;必须先删除私钥，然后才能删除公钥。&lt;br /&gt;
从公钥钥匙环里删除密钥：&lt;/p&gt;

&lt;h1 id=&#34;gpg-delete-keys-hyphenwang-redflag-linux-com&#34;&gt;gpg &amp;ndash;delete-keys hyphenwang@redflag-linux.com&lt;/h1&gt;

&lt;p&gt;gpg (GnuPG) 1.4.5; Copyright &amp;copy; 2006 Free Software Foundation, Inc.&lt;br /&gt;
This program comes with ABSOLUTELY NO WARRANTY.&lt;br /&gt;
This is free software, and you are welcome to redistribute it&lt;br /&gt;
under certain conditions. See the file COPYING for details.&lt;br /&gt;
sec  1024D/A3942296 2008-12-19 Hyphen Wang (Use for GPG Encrypt) &lt;a href=&#34;mailto:gpgencrypt@linuxfly.org&#34; target=&#34;_blank&#34;&gt;gpgencrypt@linuxfly.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要从钥匙环里删除这把密钥吗？(y/N)y&lt;/p&gt;

&lt;p&gt;三.对称加密:&lt;br /&gt;
当然GPG同样具备普通的对称加密功能，这时候就不需要密钥，直接用密码加密即可（注意，这里的密码不一定是你私钥的密码，您大可以随意设定）&lt;/p&gt;

&lt;p&gt;gpg -o doc.gpg -c doc&lt;/p&gt;

&lt;p&gt;－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－&lt;/p&gt;

&lt;p&gt;四.GPG常用参数:&lt;br /&gt;
语法：gpg [选项] [文件名]&lt;br /&gt;
签字、检查、加密或解密&lt;br /&gt;
默认的操作依输入数据而定&lt;br /&gt;
指令：&lt;/p&gt;

&lt;p&gt;-s, &amp;ndash;sign [文件名]           生成一份签字&lt;br /&gt;
&amp;ndash;clearsign [文件名]      生成一份明文签字&lt;br /&gt;
-b, &amp;ndash;detach-sign             生成一份分离的签字&lt;br /&gt;
-e, &amp;ndash;encrypt                 加密数据&lt;br /&gt;
-c, &amp;ndash;symmetric               仅使用对称加密&lt;br /&gt;
-d, &amp;ndash;decrypt                 解密数据(默认)&lt;br /&gt;
&amp;ndash;verify                  验证签字&lt;br /&gt;
&amp;ndash;list-keys               列出密钥&lt;br /&gt;
&amp;ndash;list-sigs               列出密钥和签字&lt;br /&gt;
&amp;ndash;check-sigs              列出并检查密钥签字&lt;br /&gt;
&amp;ndash;fingerprint             列出密钥和指纹&lt;br /&gt;
-K, &amp;ndash;list-secret-keys        列出私钥&lt;br /&gt;
&amp;ndash;gen-key                 生成一副新的密钥对&lt;br /&gt;
&amp;ndash;delete-keys             从公钥钥匙环里删除密钥&lt;br /&gt;
&amp;ndash;delete-secret-keys      从私钥钥匙环里删除密钥&lt;br /&gt;
&amp;ndash;sign-key                为某把密钥添加签字&lt;br /&gt;
&amp;ndash;lsign-key               为某把密钥添加本地签字&lt;br /&gt;
&amp;ndash;edit-key                编辑某把密钥或为其添加签字&lt;br /&gt;
&amp;ndash;gen-revoke              生成一份吊销证书&lt;br /&gt;
&amp;ndash;export                  导出密钥&lt;br /&gt;
&amp;ndash;send-keys               把密钥导出到某个公钥服务器上&lt;br /&gt;
&amp;ndash;recv-keys               从公钥服务器上导入密钥&lt;br /&gt;
&amp;ndash;search-keys             在公钥服务器上搜寻密钥&lt;br /&gt;
&amp;ndash;refresh-keys            从公钥服务器更新所有的本地密钥&lt;br /&gt;
&amp;ndash;import                  导入/合并密钥&lt;br /&gt;
&amp;ndash;card-status             打印卡状态&lt;br /&gt;
&amp;ndash;card-edit               更改卡上的数据&lt;br /&gt;
&amp;ndash;change-pin              更改卡的 PIN&lt;br /&gt;
&amp;ndash;update-trustdb          更新信任度数据库&lt;br /&gt;
&amp;ndash;print-md 算法 [文件]    使用指定的散列算法打印报文散列值&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;p&gt;-a, &amp;ndash;armor                   输出 ASCII 文本文件&lt;br /&gt;
-r, &amp;ndash;recipient               为收件者“UID”加密&lt;br /&gt;
-u, &amp;ndash;local-user              使用这个用户标识来签字或解密&lt;br /&gt;
-z N                          设定压缩等级为 N (0 表示不压缩)&lt;br /&gt;
&amp;ndash;textmode                    使用标准的文本模式&lt;br /&gt;
-o, &amp;ndash;output                  指定输出文件&lt;br /&gt;
-v, &amp;ndash;verbose                 详细模式&lt;br /&gt;
-n, &amp;ndash;dry-run                 不做任何改变&lt;br /&gt;
-i, &amp;ndash;interactive             覆盖前先询问&lt;br /&gt;
&amp;ndash;openpgp                 行为严格遵循 OpenPGP 定义&lt;br /&gt;
&amp;ndash;pgp2                    生成与 PGP 2.x 兼容的报文&lt;/p&gt;

&lt;p&gt;(请参考在线说明以获得所有命令和选项的完整清单)&lt;/p&gt;

&lt;p&gt;范例：&lt;/p&gt;

&lt;p&gt;-se -r Bob [文件名]          为 Bob 这个收件人签字及加密&lt;br /&gt;
&amp;ndash;clearsign [文件名]         做出明文签字&lt;br /&gt;
&amp;ndash;detach-sign [文件名]       做出分离式签字&lt;br /&gt;
&amp;ndash;list-keys [某甲]           显示密钥&lt;br /&gt;
&amp;ndash;fingerprint [某甲]         显示指纹&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 Aria2</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-aria2/</link>
            <pubDate>Sat, 08 Oct 2016 16:46:14 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-aria2/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/aria2/aria2&#34; target=&#34;_blank&#34;&gt;aria2/aria2: aria2 is a lightweight multi-protocol &amp;amp; multi-source, cross platform download utility operated in command-line. It supports HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://binux.blog/2012/12/aria2-examples/&#34; target=&#34;_blank&#34;&gt;aria2配置示例 | Binuxの杂货铺&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://sydi.org/posts/linux/aria2c-usage-sample-cns.html&#34; target=&#34;_blank&#34;&gt;Aria2c 使用举例&lt;/a&gt;&lt;br /&gt;
##多线程下载axel&lt;br /&gt;
axel -q -n 10 -o /tmp/ &lt;a href=&#34;http://soft.vpser.net/lnmp/lnmp0.7-full.tar.gz&#34; target=&#34;_blank&#34;&gt;http://soft.vpser.net/lnmp/lnmp0.7-full.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aria2c -c -x5 https://atlas.hashicorp.com/hashicorp/boxes/precise64/versions/1.1.0/providers/virtualbox.box&lt;/code&gt;&lt;br /&gt;
 -c  断点续传&lt;br /&gt;
 -x2 多线程 同一host建立多个连接&lt;br /&gt;
 -s2 大文件分段下载&lt;br /&gt;
 &amp;ndash;max-upload-limit=100K 调节上传速度（Throttle upload speed）&lt;/p&gt;

&lt;p&gt;Aria2 是一个轻量级多协议和多源 命令行 下载实用工具。它支持 HTTP / HTTPS, FTP, SFTP, bt 和 Metalink。通过内置 Aria2 可以操作 json - rpc 和 xml - rpc。对，Aria2 没有 GUI 图形界面，只有粗糙的命令行界面！但这也正是 Aria2 之轻快好省所在。&lt;/p&gt;

&lt;p&gt;#命令行模式&lt;/p&gt;

&lt;p&gt;我们可以在命令行中非常简单地调用 aria2 进行多种协议的下载操作。例如：&lt;/p&gt;

&lt;p&gt;普通下载：&lt;br /&gt;
&lt;code&gt;aria2c http://example.org/mylinux.iso&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;多个源下载文件：同时使用两个连接&lt;br /&gt;
&lt;code&gt;aria2c http://a/f.iso ftp://b/f.iso&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;多线程下载&lt;br /&gt;
&lt;code&gt;aria2c -x2 http://a/f.iso&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;断点续传&lt;br /&gt;
&lt;code&gt;aria2c -c http://host/partiallydownloadedfile.zip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;从 txt 文本文档中获取下载链接下载文件：&lt;br /&gt;
&lt;code&gt;aria2c -i http://www.url.com/url.txt&lt;/code&gt;&lt;br /&gt;
  -j5 用于指定同时下载的文件的数量&lt;/p&gt;

&lt;p&gt;写入到 /dev/null （Writing to /dev/null）&lt;br /&gt;
&lt;code&gt;aria2c -d /dev -o null --allow-overwrite=true http://example.org/file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为所有的连接设置代理服务器（Set proxy server to use all protocols(HTTP(S)/FTP)）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aria2c --all-proxy=&#39;http://proxy:8080&#39; http://host/file&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;aria2c --http-proxy=&#39;http://proxy:8080&#39; --http-proxy-user=&#39;username&#39; --http-proxy-passwd=&#39;password&#39; http://host/file&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;aria2c --http-proxy=&#39;http://username:password@proxy:8080&#39; http://host/file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用 BitTorrent 协议下载：&lt;br /&gt;
$ &lt;code&gt;aria2c http://example.org/mylinux.torrent&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用磁力链接（Magnet URI）进行下载：&lt;br /&gt;
$ &lt;code&gt;aria2c &#39;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Metalink：&lt;br /&gt;
$ &lt;code&gt;aria2c http://example.org/mylinux.metalink&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下载 text 文本文件中的链接：&lt;br /&gt;
$ &lt;code&gt;aria2c -i uris.txt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;简易版的 Aria2 至此就部署完毕，你可以在 Web 控制前段方便地添加下载链接/bt种子了。如要想要进一步使用 Aria2，往下读吧。&lt;br /&gt;
进阶 Aria2&lt;/p&gt;

&lt;p&gt;配置文件 aria2.conf 详解&lt;/p&gt;

&lt;p&gt;更多参数请参考官方说明文档： &lt;a href=&#34;http://aria2.sourceforge.net/manual/en/html/aria2c.html&#34; target=&#34;_blank&#34;&gt;http://aria2.sourceforge.net/manual/en/html/aria2c.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;网友翻译的部分内容：   &lt;a href=&#34;http://sydi.org/posts/linux/aria2c-usage-sample-cns.html#fn.1&#34; target=&#34;_blank&#34;&gt;http://sydi.org/posts/linux/aria2c-usage-sample-cns.html#fn.1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;开头为注释内容-选项都有相应的注释说明-根据需要修改&#34;&gt;&amp;rsquo;#&amp;lsquo;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##&lt;/h2&gt;

&lt;h2 id=&#34;被注释的选项填写的是默认值-建议在需要修改时再取消注释&#34;&gt;被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##&lt;/h2&gt;

&lt;h2 id=&#34;基本选项&#34;&gt;基本选项 ##&lt;/h2&gt;

&lt;h1 id=&#34;文件的保存路径-可使用绝对路径或相对路径-默认-当前启动位置&#34;&gt;文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置&lt;/h1&gt;

&lt;p&gt;dir=~/downloads&lt;/p&gt;

&lt;h1 id=&#34;启用磁盘缓存-0为禁用缓存-需1-16以上版本-默认-16m&#34;&gt;启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M&lt;/h1&gt;

&lt;p&gt;disk-cache=32M&lt;/p&gt;

&lt;h1 id=&#34;文件预分配方式-能有效降低磁盘碎片-默认-prealloc&#34;&gt;文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc&lt;/h1&gt;

&lt;h1 id=&#34;预分配所需时间-none-falloc-trunc-prealloc&#34;&gt;预分配所需时间: none &amp;lt; falloc ? trunc &amp;lt; prealloc&lt;/h1&gt;

&lt;h1 id=&#34;falloc和trunc则需要文件系统和内核支持&#34;&gt;falloc和trunc则需要文件系统和内核支持&lt;/h1&gt;

&lt;h1 id=&#34;ntfs建议使用falloc-ext3-4建议trunc-mac-下需要注释此项&#34;&gt;NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项&lt;/h1&gt;

&lt;p&gt;file-allocation=none&lt;/p&gt;

&lt;h1 id=&#34;断点续传-目前只支持-http-https-ftp-协议&#34;&gt;断点续传，目前只支持 HTTP/HTTPS/FTP 协议&lt;/h1&gt;

&lt;p&gt;continue=true&lt;br /&gt;
#检查文件完整性，默认：false&lt;br /&gt;
check-intergrity=false&lt;br /&gt;
#帮助信息分类&lt;br /&gt;
#一个标签以#开头&lt;br /&gt;
#可用标签: #basic, #advanced, #http, #https, #ftp, #metalink, #bittorrent, #cookie, #hook, #file, #rpc, #checksum, #experimental, #deprecated, #help, #all Default: #basic&lt;br /&gt;
#默认为#basic&lt;br /&gt;
help=#basic&lt;/p&gt;

&lt;h2 id=&#34;下载连接相关&#34;&gt;下载连接相关 ##&lt;/h2&gt;

&lt;h1 id=&#34;最大同时下载任务数-运行时可修改-默认-5&#34;&gt;最大同时下载任务数, 运行时可修改, 默认:5&lt;/h1&gt;

&lt;p&gt;max-concurrent-downloads=1&lt;/p&gt;

&lt;h1 id=&#34;同一服务器连接数-添加时可指定-默认-1&#34;&gt;同一服务器连接数, 添加时可指定, 默认:1&lt;/h1&gt;

&lt;p&gt;max-connection-per-server=5&lt;/p&gt;

&lt;h1 id=&#34;最小文件分片大小-添加时可指定-取值范围1m-1024m-默认-20m&#34;&gt;最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M&lt;/h1&gt;

&lt;h1 id=&#34;假定size-10m-文件为20mib-则使用两个来源下载-文件为15mib-则使用一个来源下载&#34;&gt;假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载&lt;/h1&gt;

&lt;p&gt;min-split-size=10M&lt;/p&gt;

&lt;h1 id=&#34;单个任务最大线程数-添加时可指定-默认-5&#34;&gt;单个任务最大线程数, 添加时可指定, 默认:5&lt;/h1&gt;

&lt;p&gt;split=5&lt;/p&gt;

&lt;h1 id=&#34;整体下载速度限制-运行时可修改-默认-0&#34;&gt;整体下载速度限制, 运行时可修改, 默认:0&lt;/h1&gt;

&lt;p&gt;#max-overall-download-limit=0&lt;/p&gt;

&lt;h1 id=&#34;单个任务下载速度限制-默认-0&#34;&gt;单个任务下载速度限制, 默认:0&lt;/h1&gt;

&lt;p&gt;#max-download-limit=0&lt;/p&gt;

&lt;h1 id=&#34;整体上传速度限制-运行时可修改-默认-0&#34;&gt;整体上传速度限制, 运行时可修改, 默认:0&lt;/h1&gt;

&lt;p&gt;#max-overall-upload-limit=0&lt;/p&gt;

&lt;h1 id=&#34;单个任务上传速度限制-默认-0&#34;&gt;单个任务上传速度限制, 默认:0&lt;/h1&gt;

&lt;p&gt;#max-upload-limit=0&lt;/p&gt;

&lt;h1 id=&#34;禁用ipv6-默认-false&#34;&gt;禁用IPv6, 默认:false&lt;/h1&gt;

&lt;p&gt;disable-ipv6=true&lt;/p&gt;

&lt;h2 id=&#34;进度保存相关&#34;&gt;进度保存相关 ##&lt;/h2&gt;

&lt;h1 id=&#34;从会话文件中读取下载任务&#34;&gt;从会话文件中读取下载任务&lt;/h1&gt;

&lt;p&gt;input-file=/etc/aria2/aria2.session&lt;/p&gt;

&lt;h1 id=&#34;在aria2退出时保存-错误-未完成-的下载任务到会话文件&#34;&gt;在Aria2退出时保存&lt;code&gt;错误/未完成&lt;/code&gt;的下载任务到会话文件&lt;/h1&gt;

&lt;p&gt;save-session=/etc/aria2/aria2.session&lt;/p&gt;

&lt;h1 id=&#34;定时保存会话-0为退出时才保存-需1-16-1以上版本-默认-0&#34;&gt;定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0&lt;/h1&gt;

&lt;p&gt;#save-session-interval=60&lt;/p&gt;

&lt;h2 id=&#34;rpc相关设置&#34;&gt;RPC相关设置 ##&lt;/h2&gt;

&lt;h1 id=&#34;启用rpc-默认-false&#34;&gt;启用RPC, 默认:false&lt;/h1&gt;

&lt;p&gt;enable-rpc=true&lt;/p&gt;

&lt;h1 id=&#34;允许所有来源-默认-false&#34;&gt;允许所有来源, 默认:false&lt;/h1&gt;

&lt;p&gt;rpc-allow-origin-all=true&lt;/p&gt;

&lt;h1 id=&#34;允许非外部访问-默认-false&#34;&gt;允许非外部访问, 默认:false&lt;/h1&gt;

&lt;p&gt;rpc-listen-all=true&lt;/p&gt;

&lt;h1 id=&#34;事件轮询方式-取值-epoll-kqueue-port-poll-select-不同系统默认值不同&#34;&gt;事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同&lt;/h1&gt;

&lt;p&gt;#event-poll=select&lt;/p&gt;

&lt;h1 id=&#34;rpc监听端口-端口被占用时可以修改-默认-6800&#34;&gt;RPC监听端口, 端口被占用时可以修改, 默认:6800&lt;/h1&gt;

&lt;p&gt;#rpc-listen-port=6800&lt;/p&gt;

&lt;h1 id=&#34;设置的rpc授权令牌-v1-18-4新增功能-取代-rpc-user-和-rpc-passwd-选项&#34;&gt;设置的RPC授权令牌, v1.18.4新增功能, 取代 &amp;ndash;rpc-user 和 &amp;ndash;rpc-passwd 选项&lt;/h1&gt;

&lt;p&gt;#rpc-secret=&lt;TOKEN&gt;&lt;/p&gt;

&lt;h1 id=&#34;设置的rpc访问用户名-此选项新版已废弃-建议改用-rpc-secret-选项&#34;&gt;设置的RPC访问用户名, 此选项新版已废弃, 建议改用 &amp;ndash;rpc-secret 选项&lt;/h1&gt;

&lt;p&gt;#rpc-user=&lt;USER&gt;&lt;/p&gt;

&lt;h1 id=&#34;设置的rpc访问密码-此选项新版已废弃-建议改用-rpc-secret-选项&#34;&gt;设置的RPC访问密码, 此选项新版已废弃, 建议改用 &amp;ndash;rpc-secret 选项&lt;/h1&gt;

&lt;p&gt;#rpc-passwd=&lt;PASSWD&gt;&lt;/p&gt;

&lt;h2 id=&#34;bt-pt下载相关&#34;&gt;BT/PT下载相关 ##&lt;/h2&gt;

&lt;h1 id=&#34;当下载的是一个种子-以-torrent结尾-时-自动开始bt任务-默认-true&#34;&gt;当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true&lt;/h1&gt;

&lt;p&gt;#follow-torrent=true&lt;/p&gt;

&lt;h1 id=&#34;bt监听端口-当端口被屏蔽时使用-默认-6881-6999&#34;&gt;BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999&lt;/h1&gt;

&lt;p&gt;listen-port=51413&lt;/p&gt;

&lt;h1 id=&#34;单个种子最大连接数-默认-55&#34;&gt;单个种子最大连接数, 默认:55&lt;/h1&gt;

&lt;p&gt;#bt-max-peers=55&lt;/p&gt;

&lt;h1 id=&#34;打开dht功能-pt需要禁用-默认-true&#34;&gt;打开DHT功能, PT需要禁用, 默认:true&lt;/h1&gt;

&lt;p&gt;enable-dht=false&lt;/p&gt;

&lt;h1 id=&#34;打开ipv6-dht功能-pt需要禁用&#34;&gt;打开IPv6 DHT功能, PT需要禁用&lt;/h1&gt;

&lt;p&gt;#enable-dht6=false&lt;/p&gt;

&lt;h1 id=&#34;dht网络监听端口-默认-6881-6999&#34;&gt;DHT网络监听端口, 默认:6881-6999&lt;/h1&gt;

&lt;p&gt;#dht-listen-port=6881-6999&lt;/p&gt;

&lt;h1 id=&#34;本地节点查找-pt需要禁用-默认-false&#34;&gt;本地节点查找, PT需要禁用, 默认:false&lt;/h1&gt;

&lt;p&gt;#bt-enable-lpd=false&lt;/p&gt;

&lt;h1 id=&#34;种子交换-pt需要禁用-默认-true&#34;&gt;种子交换, PT需要禁用, 默认:true&lt;/h1&gt;

&lt;p&gt;enable-peer-exchange=false&lt;/p&gt;

&lt;h1 id=&#34;每个种子限速-对少种的pt很有用-默认-50k&#34;&gt;每个种子限速, 对少种的PT很有用, 默认:50K&lt;/h1&gt;

&lt;p&gt;#bt-request-peer-speed-limit=50K&lt;/p&gt;

&lt;h1 id=&#34;客户端伪装-pt需要&#34;&gt;客户端伪装, PT需要&lt;/h1&gt;

&lt;p&gt;peer-id-prefix=-TR2770-&lt;br /&gt;
user-agent=Transmission/2.77&lt;/p&gt;

&lt;h1 id=&#34;当种子的分享率达到这个数时-自动停止做种-0为一直做种-默认-1-0&#34;&gt;当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0&lt;/h1&gt;

&lt;p&gt;seed-ratio=0&lt;/p&gt;

&lt;h1 id=&#34;强制保存会话-话即使任务已经完成-默认-false&#34;&gt;强制保存会话, 话即使任务已经完成, 默认:false&lt;/h1&gt;

&lt;h1 id=&#34;较新的版本开启后会在任务完成后依然保留-aria2文件&#34;&gt;较新的版本开启后会在任务完成后依然保留.aria2文件&lt;/h1&gt;

&lt;p&gt;#force-save=false&lt;/p&gt;

&lt;h1 id=&#34;bt校验相关-默认-true&#34;&gt;BT校验相关, 默认:true&lt;/h1&gt;

&lt;p&gt;#bt-hash-check-seed=true&lt;/p&gt;

&lt;h1 id=&#34;继续之前的bt任务时-无需再次校验-默认-false&#34;&gt;继续之前的BT任务时, 无需再次校验, 默认:false&lt;/h1&gt;

&lt;p&gt;bt-seed-unverified=true&lt;/p&gt;

&lt;h1 id=&#34;保存磁力链接元数据为种子文件-torrent文件-默认-false&#34;&gt;保存磁力链接元数据为种子文件(.torrent文件), 默认:false&lt;/h1&gt;

&lt;p&gt;bt-save-metadata=true&lt;/p&gt;

&lt;p&gt;新建链接任务进阶&lt;/p&gt;

&lt;p&gt;直接添加链接下载文件：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.url.com/file.zip&#34; target=&#34;_blank&#34;&gt;http://www.url.com/file.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从多个地址源下载同一个文件（用空格隔开）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.url1.com/file.zip&#34; target=&#34;_blank&#34;&gt;http://www.url1.com/file.zip&lt;/a&gt; www.url2.com/file.zip&lt;/p&gt;

&lt;p&gt;使用 n 个线程下载文件（&amp;rdquo;x2&amp;rdquo; 就是 2 个线程）：&lt;/p&gt;

&lt;p&gt;-x2 &lt;a href=&#34;http://www.url.com/file.zip&#34; target=&#34;_blank&#34;&gt;http://www.url.com/file.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本使用&lt;br /&gt;
下载一个文件（Download a file）：&lt;/p&gt;

&lt;p&gt;aria2c &lt;a href=&#34;http://host/image.iso&#34; target=&#34;_blank&#34;&gt;http://host/image.iso&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明：1.10.0以后的版本默认对每个 host 使用 1 个连接，你可以使用 –max-connection-per-server 或者 -x 选项进行改变。&lt;br /&gt;
用每个 host 两个连接从一个 host 下载一个文件（To download a file using 2 connections from single host）：&lt;/p&gt;

&lt;p&gt;aria2c -x2 &lt;a href=&#34;http://host/image.iso&#34; target=&#34;_blank&#34;&gt;http://host/image.iso&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。&lt;br /&gt;
同时使用两个连接下载同一文件（Download a file using 2 connections）：&lt;/p&gt;

&lt;p&gt;aria2c -s2 &lt;a href=&#34;http://host/image.iso&#34; target=&#34;_blank&#34;&gt;http://host/image.iso&lt;/a&gt; &lt;a href=&#34;http://mirror1/image.iso&#34; target=&#34;_blank&#34;&gt;http://mirror1/image.iso&lt;/a&gt; &lt;a href=&#34;http://mirror2/image.iso&#34; target=&#34;_blank&#34;&gt;http://mirror2/image.iso&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明：你可以指定URIs的数量多余 -s 选项设定的数。在这个例子中，前两个URL会被用于下载，而第三个URL作为备用（如果前面两个有个挂了，第三个顶上）。&lt;br /&gt;
同时从FTP和HTTP源下载一个文件（Download a file from HTTP and FTP servers）：&lt;/p&gt;

&lt;p&gt;aria2c &lt;a href=&#34;http://host1/file.zip&#34; target=&#34;_blank&#34;&gt;http://host1/file.zip&lt;/a&gt; &lt;a href=&#34;ftp://host2/file.zip&#34; target=&#34;_blank&#34;&gt;ftp://host2/file.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;并行下载任意数目的URI, metalink, torrent（Parallel downloads of arbitrary number of URI, metalink, torrent）：&lt;/p&gt;

&lt;p&gt;aria2c -Z &lt;a href=&#34;http://host/file1&#34; target=&#34;_blank&#34;&gt;http://host/file1&lt;/a&gt; file2.torrent file3.metalink&lt;/p&gt;

&lt;p&gt;说明：如果你只是下载 torrent 和 metalink 的文件，那么选项 -Z 将不是必须的。所以你可以使用以下这个命令同时下载bt文件。&lt;/p&gt;

&lt;p&gt;aria2c file1.torrent file2.torrent&lt;/p&gt;

&lt;p&gt;并发下载一个文件中的URI（Download files listed in a file concurrently）：&lt;/p&gt;

&lt;p&gt;aria2c -ifiles.txt -j5&lt;/p&gt;

&lt;p&gt;说明：选项 -j 用于指定同时下载的文件的数量。你可以在文件中指定本地的 torrent 和 metalink 文件。&lt;/p&gt;

&lt;p&gt;说明：你可以指定一些 选项 在下载文件（input list file）中。&lt;br /&gt;
在退出时保存错误/未完成的下载（Save error/unfinished downloads on exit）：&lt;/p&gt;

&lt;p&gt;aria2c -ifiles.txt &amp;ndash;save-session=out.txt&lt;/p&gt;

&lt;p&gt;当你按下Ctrl-C或者 aria2 退出时，所有的错误（error）/未完成（unfinished）下载将会保存到 out.txt 文件中。注意通过 XML-RPC 方式(aria2.addTorrent and aria2.addMetalink)添加的下载不会被保存！你可以使用这个文件作为一个输入文件列表（input file list）来重新开始下载。&lt;/p&gt;

&lt;p&gt;aria2c -iout.txt&lt;/p&gt;

&lt;p&gt;Metalink Download（不翻译）&lt;br /&gt;
BT下载（BitTorrent Download）&lt;br /&gt;
通过网上的种子文件下载（Download files from remote BitTorrent file）&lt;/p&gt;

&lt;p&gt;aria2c &lt;a href=&#34;http://site/file.torrent&#34; target=&#34;_blank&#34;&gt;http://site/file.torrent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过网上的种子文件下载，种子保存在内存（Download files from remote BitTorrent file; torrent file itself is processed in memory）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;follow-torrent=mem &lt;a href=&#34;http://site/file.torrent&#34; target=&#34;_blank&#34;&gt;http://site/file.torrent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过本地的种子文件下载（Download using a local torrent file）&lt;/p&gt;

&lt;p&gt;aria2c -u40K /path/to/file.torrent&lt;/p&gt;

&lt;p&gt;说明： -u, –max-upload-limit 指定最大的上传速度&lt;/p&gt;

&lt;p&gt;说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。&lt;/p&gt;

&lt;p&gt;你可以同时进行多个 bt 的下载：&lt;/p&gt;

&lt;p&gt;aria2c /path/to/file1.torrent /path/to/file2.torrent&lt;/p&gt;

&lt;p&gt;通过 bt magnet uri 下载（Download using BitTorrent Magnet URI）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ldquo;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&amp;amp;dn=aria2&amp;rdquo;&lt;/p&gt;

&lt;p&gt;说明：在 bt magnet uri 包含&amp;rdquo;&amp;amp;&amp;ldquo;的时候记住要加单引号或者双引号。强烈推荐打开 DHT 选项。 –enable-dht&lt;br /&gt;
保存元数据到 .torrent 文件中（Save metadata as .torrent file）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-save-metadata &amp;ldquo;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&amp;amp;dn=aria2&amp;rdquo;&lt;/p&gt;

&lt;p&gt;上面那个命令会保存元数据到一个名为&amp;rdquo;248d0a1cd08284299de78d5c1ed359bb46717d8c.torrent&amp;rdquo;的种子文件。&lt;br /&gt;
自动调节连接数（Adjust the number of peers adaptively）&lt;/p&gt;

&lt;p&gt;如果每个种子的下载速度都低于 200K 的话， aria2 会临时增加连接数来试着提高下载速度。&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-request-peer-speed-limit=200K file.torrent&lt;/p&gt;

&lt;p&gt;说明：配置 –bt-request-peer-speed-limit 选项为合适的值可以在某些情况下提高你的下载速度。&lt;br /&gt;
打开 DHT （Enable DHT）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;enable-dht &lt;a href=&#34;http://site/file.torrent&#34; target=&#34;_blank&#34;&gt;http://site/file.torrent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明：从 1.7.2 版本开始， DHT 默认是打开的。当通过 HTTP/FTP 下载的时候 DHT 不会启用。当首个种子下载开始， aria2 初始化 DHT 功能，之后， DHT 会一直运行知道 aria2 退出为止。&lt;br /&gt;
打开 IPv6 的 DHT （Enable IPv6 DHT）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;enable-dht6 &amp;ndash;dht-listen-port=6881 &amp;ndash;dht-listen-addr6=YOUR_GLOBAL_UNICAST_IPV6_ADDR &amp;ndash;enable-async-dns6&lt;/p&gt;

&lt;p&gt;说明：如果 aria2c 编译的时候没有加入 c-ares ， –enable-async-dns6 不是必须的。 aria2 会在 IPv4 和 IPv6 之间对 DHT 共享一些端口。&lt;br /&gt;
Add and remove tracker URI&lt;/p&gt;

&lt;p&gt;接下来的例子指示 aria2 移除 file.torrent 文件中所有的 tracker announce URIs ，并用&amp;rdquo;&lt;a href=&#34;http://tracker1/announce&amp;quot;&#34; target=&#34;_blank&#34;&gt;http://tracker1/announce&amp;quot;&lt;/a&gt; 和 &amp;ldquo;&lt;a href=&#34;http://tracker2/announce&amp;quot;&#34; target=&#34;_blank&#34;&gt;http://tracker2/announce&amp;quot;&lt;/a&gt; 代替。&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-exclude-tracker=&amp;rdquo;*&amp;rdquo; &amp;ndash;bt-tracker=&amp;ldquo;&lt;a href=&#34;http://tracker1/announce,http://tracker2/announce&amp;quot;&#34; target=&#34;_blank&#34;&gt;http://tracker1/announce,http://tracker2/announce&amp;quot;&lt;/a&gt; file.torrent&lt;/p&gt;

&lt;p&gt;加密（Encryption）&lt;/p&gt;

&lt;p&gt;默认情况下， aria2 能够同时支持加密和非加密连接。它会先尝试使用加密连接，如果失败则尝试非加密连接。&lt;/p&gt;

&lt;p&gt;强制只使用加密连接：&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-require-crypto=true &lt;a href=&#34;http://site/file.torrent&#34; target=&#34;_blank&#34;&gt;http://site/file.torrent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一共有两种加密类型：只加密头或者全部加密。默认下，如果对方支持两种加密类型， aria2 会选择只加密头。如果想让 aria2 总是使用全加密连接：&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-min-crypto-level=arc4 &lt;a href=&#34;http://site/file.torrent&#34; target=&#34;_blank&#34;&gt;http://site/file.torrent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打印一个种子文件中的内容（Print the contents of the torrent file）&lt;/p&gt;

&lt;p&gt;aria2c -S file.torrent&lt;/p&gt;

&lt;p&gt;选择性下载文件（Download only selected files using index (usually called &amp;ldquo;selectable download&amp;rdquo;)）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;select-file=1-4,8 -Tfile.torrent&lt;/p&gt;

&lt;p&gt;说明：序号（index）可以通过 -S 选项输出&lt;br /&gt;
改变监听端口（Change the listening port for incoming peer）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;listen-port=6881-6883 file.torrent&lt;/p&gt;

&lt;p&gt;说明：确认该 TCP 端口是可用的&lt;br /&gt;
指定 BT 下载停止的条件（Specify the condition to stop program after torrent download finished）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;seed-time=120 &amp;ndash;seed-ratio=1.0 file.torrent&lt;/p&gt;

&lt;p&gt;说明：在上面的这个例子中， 当做种 120分钟 或者种子率大于1以后， aria2 会退出。&lt;br /&gt;
调节上传速度（Throttle upload speed）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;max-upload-limit=100K file.torrent&lt;/p&gt;

&lt;p&gt;为已经下载完成的文件做种（Seeding already downloaded file）&lt;/p&gt;

&lt;p&gt;你可以使用 -V 选项给已经下载好的文件做种。它会先校验文件的完整性。&lt;/p&gt;

&lt;p&gt;aria2c -V -d/path/to/dir file.torrent&lt;/p&gt;

&lt;p&gt;如果你肯定文件是正确的，你可以使用 –bt-seed-unverified 选项跳过做种前的文件校验。&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-seed-unverified -d/path/to/dir file.torrent&lt;/p&gt;

&lt;p&gt;你可以给多个文件做种：&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-seed-unverified -d/path/to/dir file1.torrent file2.torrent&lt;/p&gt;

&lt;p&gt;用序号指定文件名（Specify file name with index）&lt;/p&gt;

&lt;p&gt;为 BitTorrent 下载下来的文件指定文件名，你首先需要通过 -S 选项知道该文件的序号。比如一个种子文件 -S 选项输出如下：&lt;/p&gt;

&lt;p&gt;idx|path/length&lt;br /&gt;
===+======================&lt;br /&gt;
1|dist/base-2.6.18.iso&lt;br /&gt;
|99.9MiB&lt;br /&gt;
&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;br /&gt;
2|dist/driver-2.6.18.iso&lt;br /&gt;
|169.0MiB&lt;br /&gt;
&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/p&gt;

&lt;p&gt;把 dist/base-2.6.18.iso 保存为 tmp/mydir/base.iso ， /dist/driver-2.6.18.iso 保存为 /tmp/dir/driver.iso ，可以使用一下的命令：&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;dir=/tmp &amp;ndash;index-out=1=mydir/base.iso &amp;ndash;index-out=2=dir/driver.iso file.torrent&lt;/p&gt;

&lt;p&gt;说明： –index-out 选项针对通过 HTTP 方式获取种子文件的方式无效。它只能针对本地种子文件的下载。 aria2 不会记住 –index-out 选项中指定的地址，你必须在每次开始该任务的时候重新指定 –index-out 的值。如果你忘了再次指定输出文件的地址， aria2 不会提醒你，所以你必须谨慎地使用这个选项。&lt;br /&gt;
为预览的文件指定优先块（Prioritize piece for previewing files）&lt;/p&gt;

&lt;p&gt;优先下载每个文件开头的 1MiB 的内容。&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;bt-prioritize-piece=head file.torrent&lt;/p&gt;

&lt;p&gt;使用代理下载（Use With Proxy）&lt;br /&gt;
为所有的连接设置代理服务器（Set proxy server to use all protocols(HTTP(S)/FTP)）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;all-proxy=&amp;lsquo;&lt;a href=&#34;http://proxy:8080&#39;&#34; target=&#34;_blank&#34;&gt;http://proxy:8080&#39;&lt;/a&gt; &lt;a href=&#34;http://host/file&#34; target=&#34;_blank&#34;&gt;http://host/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明： –all-proxy 选项会被具体的代理选项重载： –http-proxy, –https-proxy, –ftp-proxy.&lt;br /&gt;
只为 HTTP 设置代理服务器（Set proxy server to be in HTTP only）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;http-proxy=&amp;lsquo;&lt;a href=&#34;http://proxy:8080&#39;&#34; target=&#34;_blank&#34;&gt;http://proxy:8080&#39;&lt;/a&gt; &lt;a href=&#34;http://host/file&#34; target=&#34;_blank&#34;&gt;http://host/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;设置需要验证的代理服务器（Use proxy that requires authentication）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;http-proxy=&amp;lsquo;&lt;a href=&#34;http://proxy:8080&#39;&#34; target=&#34;_blank&#34;&gt;http://proxy:8080&#39;&lt;/a&gt; &amp;ndash;http-proxy-user=&amp;lsquo;username&amp;rsquo; &amp;ndash;http-proxy-passwd=&amp;lsquo;password&amp;rsquo; &lt;a href=&#34;http://host/file&#34; target=&#34;_blank&#34;&gt;http://host/file&lt;/a&gt;&lt;br /&gt;
aria2c &amp;ndash;http-proxy=&amp;lsquo;&lt;a href=&#34;http://username:password@proxy:8080&#39;&#34; target=&#34;_blank&#34;&gt;http://username:password@proxy:8080&#39;&lt;/a&gt; &lt;a href=&#34;http://host/file&#34; target=&#34;_blank&#34;&gt;http://host/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明：用户名和密码需要是 percent-encoded 格式。比如，如果用户名是 myid@domain, 那么 percent-encoded 格式就是 myid%40domain.&lt;br /&gt;
高级HTTP功能（Advanced HTTP Features）&lt;br /&gt;
载入 cookies （Load cookies）&lt;/p&gt;

&lt;p&gt;载入 Mozilla/Firefox(1.x/2.x) 和 Netscape 格式:&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;load-cookies=cookies.txt &lt;a href=&#34;http://host/file&#34; target=&#34;_blank&#34;&gt;http://host/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;载入 Firefox3 格式:&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;load-cookies=cookies.sqlite &lt;a href=&#34;http://host/file&#34; target=&#34;_blank&#34;&gt;http://host/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明：你可以不加任何修改直接读取 Firefox/Mozilla&amp;rsquo;s 的 cookie 内容。&lt;br /&gt;
继续浏览器或者其它程序开始的下载任务（Resume download started by web browsers or another programs）&lt;/p&gt;

&lt;p&gt;aria2c -c -s2 &lt;a href=&#34;http://host/partiallydownloadedfile.zip&#34; target=&#34;_blank&#34;&gt;http://host/partiallydownloadedfile.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其它高级功能（Other Advanced Features）&lt;br /&gt;
调节下载速度（Throttle download speed）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;max-download-limit=100K &lt;a href=&#34;http://host/file&#34; target=&#34;_blank&#34;&gt;http://host/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用 -V 选项修复一个被破坏的下载文件（Repair a damaged download using -V option）&lt;/p&gt;

&lt;p&gt;aria2c -V file.metalink&lt;/p&gt;

&lt;p&gt;说明：这个选项只能对支持校验码的 BitTorrent 或者 metalink 使用。&lt;br /&gt;
如果下载速度低于某个特定值就丢弃连接（Drop connection if download speed is lower than specified value）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;lowest-speed-limit=10K file.metalink&lt;/p&gt;

&lt;p&gt;支持参数的 URI （Parameterized URI support）&lt;/p&gt;

&lt;p&gt;你可以这样使用 URI ：&lt;/p&gt;

&lt;p&gt;aria2c -P http://{host1,host2,host3}/file.iso&lt;/p&gt;

&lt;p&gt;你可以指定数字序号（You can specify numeric sequence using []）&lt;/p&gt;

&lt;p&gt;aria2c -Z -P &lt;a href=&#34;http://host/image[000-100].png&#34; target=&#34;_blank&#34;&gt;http://host/image[000-100].png&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说明： -Z 选项是必须的，如果所有的 URL 都是指向不同的文件的话。&lt;/p&gt;

&lt;p&gt;可以指定步长（You can specify step counter）&lt;/p&gt;

&lt;p&gt;aria2c -Z -P &lt;a href=&#34;http://host/image[A-Z:2].png&#34; target=&#34;_blank&#34;&gt;http://host/image[A-Z:2].png&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Time-stamping&lt;/p&gt;

&lt;p&gt;aria2 会在下载完成的时候从服务器拿到该文件的 timestamp 并设置到本地文件&lt;/p&gt;

&lt;p&gt;aria2c -R &lt;a href=&#34;http://host/file.iso&#34; target=&#34;_blank&#34;&gt;http://host/file.iso&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当下载完成后执行一条命令（Execute command when download finishes）&lt;/p&gt;

&lt;p&gt;aria2c &amp;ndash;on-download-complete=COMMAND &lt;a href=&#34;http://example.org/file.iso&#34; target=&#34;_blank&#34;&gt;http://example.org/file.iso&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参见 –on-download-error, –on-download-start 和 –on-download-stop 选项， 或者执行：&lt;/p&gt;

&lt;p&gt;aria2c -h #hook&lt;/p&gt;

&lt;p&gt;写入到 /dev/null （Writing to /dev/null）&lt;/p&gt;

&lt;p&gt;aria2c -d /dev -o null &amp;ndash;allow-overwrite=true &lt;a href=&#34;http://example.org/file&#34; target=&#34;_blank&#34;&gt;http://example.org/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;需要 –allow-overwrite=true 是为了避免 aria2 重命名已经存在的 /dev/null。&lt;br /&gt;
输入文件（Input File）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://server/file.iso&#34; target=&#34;_blank&#34;&gt;http://server/file.iso&lt;/a&gt; &lt;a href=&#34;http://mirror/file.iso&#34; target=&#34;_blank&#34;&gt;http://mirror/file.iso&lt;/a&gt;&lt;br /&gt;
dir=/iso_images&lt;br /&gt;
out=file.img&lt;br /&gt;
&lt;a href=&#34;http://foo/bar&#34; target=&#34;_blank&#34;&gt;http://foo/bar&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 adb</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-adb/</link>
            <pubDate>Sat, 08 Oct 2016 16:46:14 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-adb/</guid>
            <description>

&lt;p&gt;sudo apt-get install android-tools-adb&lt;br /&gt;
sudo apt-get install android-tools-fastboot&lt;/p&gt;

&lt;h1 id=&#34;启动fastboot模式&#34;&gt;启动fastboot模式&lt;/h1&gt;

&lt;p&gt;adb reboot bootloader&lt;/p&gt;

&lt;h2 id=&#34;查看手机上应用&#34;&gt;查看手机上应用&lt;/h2&gt;

&lt;p&gt;adb shell pm list packages&lt;br /&gt;
pm list packages -f 显示安装位置&lt;/p&gt;

&lt;p&gt;配置USB访问权限&lt;code&gt;/etc/udev/rules.d/51-android.rules&lt;/code&gt;&lt;br /&gt;
wget -S -O - &lt;a href=&#34;http://source.android.com/source/51-android.rules&#34; target=&#34;_blank&#34;&gt;http://source.android.com/source/51-android.rules&lt;/a&gt; | sed &amp;ldquo;s/&lt;username&gt;/$USER/&amp;rdquo; | sudo tee &amp;gt;/dev/null /etc/udev/rules.d/51-android.rules;&lt;br /&gt;
sudo udevadm control &amp;ndash;reload-rules&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/u010375364/article/details/52344120&#34; target=&#34;_blank&#34;&gt;一份超全超详细的 ADB 用法大全 - MengGang - CSDN博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;bmgr是一个shell工具你可以用来与备份管理器在Android设备（支持API级别8或更高）。它提供了命令来指导的备份和恢复操作,这样你不需要反复清除数据或采取类似的侵入性的步骤来测试您的应用程序的备份代理。这些命令是通过adb shell。&lt;/p&gt;

&lt;p&gt;使用备份操作&lt;br /&gt;
通常，应用程序必须通知备份管理器在它的数据已经改变。通过dataChanged()。备份管理器将调用您的备份代理的onBackup()实现在未来某个时刻。如果调用dataChanged()，可以调用一个备份请求从命令行运行bmgr备份命令。&lt;/p&gt;

&lt;p&gt;命令：&lt;br /&gt;
adb shell bmgr backup &lt;package&gt;&lt;/p&gt;

&lt;p&gt;当您执行该备份命令,您的应用程序的备份代理将调用来执行备份操作在未来一段时间内(通过你的onBackup()方法),尽管没有保证当它会发生。然而,您可以强制执行所有没有运行的备份操作，通过使用bmgr运行命令:&lt;/p&gt;

&lt;p&gt;命令：&lt;br /&gt;
Adb shell bmgr run&lt;/p&gt;

&lt;p&gt;这个命令会导致所有调用备份代理的应用程序的都备份。&lt;/p&gt;

&lt;p&gt;使用恢复操作&lt;br /&gt;
恢复操作不像备份操作，这是成批的在一起运行在一个偶然的基础上，立即执行恢复操作。备份管理器目前提供了两种类型的恢复操作。&lt;br /&gt;
第一种恢复整个装置的数据备份。典型的表现只有当一个设备是第一个提供(复制设置和其他保存的状态从用户之前的设备)，是一个操作，只有系统可以执行。&lt;br /&gt;
第二种恢复操作单个应用程序恢复到它的“活跃的”数据集；也就是说，应用程序将放弃其当前数据和恢复到最后一次正确数据，保存在当前的备份映像。&lt;br /&gt;
您可以调用第二个恢复操作与requestRestore()方法。备份管理器将调用您的备份代理的onRestore()实现。&lt;/p&gt;

&lt;p&gt;当测试您的应用程序，你可以立即调用恢复操作，绕过requestRestore（）方法。使用bmgr恢复命令：&lt;br /&gt;
adb shell bmgr restore &lt;package&gt;&lt;br /&gt;
备份管理器将立即实例化应用程序的备份代理和调用它来恢复。这将发生，即使应用程序是当前没有运行。&lt;/p&gt;

&lt;p&gt;其他命令：&lt;br /&gt;
Wiping data（擦拭数据）&lt;/p&gt;

&lt;p&gt;一个应用程序的数据可以被清除从Activity数据集合中。这个操作非常有用，当你在开发一个备份代理。以防错误引导你写错误的数据或保存的状态信息。你可以擦拭一个应用程序的数据与bmgr擦拭命令：&lt;br /&gt;
adb  shell  bmgr  wipe &lt;package&gt;&lt;/p&gt;

&lt;p&gt;接下来的备份操作应用程序的代理进程将看起来好像应用程序从未支持任何东西之前。&lt;/p&gt;

&lt;p&gt;查看backup（备份）是否可用&lt;br /&gt;
adb shell bmgr enabled&lt;/p&gt;

&lt;p&gt;如果备份操作可用的，如果您的应用程序的备份代理是从未被调用备份，以验证操作系统是否认为它应该执行这些操作。&lt;/p&gt;

&lt;p&gt;你也可以直接禁用或启用备份管理器：&lt;br /&gt;
adb shell bmgr enable &lt;boolean&gt;&lt;/p&gt;

&lt;p&gt;警告!&lt;br /&gt;
当备份是禁用的，当前的备份运输将明确地擦拭Activity中的数据。如果当一个用户说他们不希望他们的数据备份，备份管理器方面希望。则没有新的数据将被保存从设备，没有恢复操作将成为完成恢复操作。除非备份管理器是重新启用(通过设置或通过以上bmgr命令)。&lt;/p&gt;

&lt;h1 id=&#34;adb&#34;&gt;adb&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;启动adb服务,如果它没启动的话&lt;br /&gt;
adb start-server&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关闭服务&lt;br /&gt;
adb kill-server&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;查看所连接的设备以及设备所对应的序列号&lt;br /&gt;
adb devices&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;安装app,需要注意的是如果连接了两台设备,则会报错,此时可以添加-s &lt;serialNumber&gt;来处理&lt;br /&gt;
adb install -r xxxx.apk&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;卸载app&lt;br /&gt;
adb uninstall packagename&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;连接到指定的ip,这个通常配合wifidebug&lt;br /&gt;
adb connect &lt;device-ip-address&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从手 机复制文件出来&lt;br /&gt;
adb pull &lt;remote&gt; &lt;local&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;向手机发送文件&lt;br /&gt;
adb push &lt;local&gt; &lt;remote&gt;&lt;br /&gt;
adb push foo.txt /sdcard/foo.txt&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看bug报告&lt;br /&gt;
adb bugreport&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取设备的ID和序列号&lt;br /&gt;
adb get-product&lt;br /&gt;
adb get-serialno&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入shell环境&lt;br /&gt;
adb shell&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印出内核的调试信息&lt;br /&gt;
adb shell dmesg&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;清除应用的数据,很常用吧?&lt;br /&gt;
adb shell pm clear packagename&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看栈顶Activity,可以用来获取包名&lt;br /&gt;
adb shell dumpsys activity top&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看所有已安装的应用的包名&lt;br /&gt;
adb shell pm list packages -f&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;am的状态 Activity Manager State&lt;br /&gt;
adb shell dumpsys activity&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包信息 Package Information&lt;br /&gt;
adb shell dumpsys package&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内存使用情况Memory Usage&lt;br /&gt;
adb shell dumpsys meminfo&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory Use Over Time&lt;br /&gt;
adb shell dumpsys procstats&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Graphics State&lt;br /&gt;
adb shell dumpsys gfxinfo&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;adb shell cat /proc/cpuinfo&lt;/p&gt;

&lt;p&gt;6、删除Android系统Rom自带的软件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a.确定手机root了,取得了root权限才能删除系统文件呀.  
b.下载Android_db.rar,解压到%windir/%System32下.  
c.手机连接数据线,在电脑上打开cmd,然后输入命令  
        adb remount  
        adb shell  
        su  
        执行完成之后,你会看到:  
        * daemon not running. starting it now *  
        * daemon started successfully *  
d.接着就是基础 命令行模式了,输入  
        cd system/app  
        你会发现没啥变化,然后输入ls回车.  
        这时候列表显示了system/app里面的所有文件,也就是Rom集成的一些软件了.  
e.开始删除吧！比如删除Youtube,他的文件名是Youtube.odex和Youtube.apk  
        我们要删除这2个文件,敲入以下命令:  
        rm Youtube.*  
        重启,Youtube已经删除掉了,注意各位同学千万不要删除你不知道是啥的东西.  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 sed</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-sed/</link>
            <pubDate>Tue, 27 Sep 2016 15:57:46 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-sed/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://kodango.com/sed-address-matching-summary&#34; target=&#34;_blank&#34;&gt;Sed 命令地址匹配问题总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-1762006-1-1.html&#34; target=&#34;_blank&#34;&gt;文本编辑的一点心得&amp;ndash;sed篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上。&lt;br /&gt;
sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。&lt;/p&gt;

&lt;h2 id=&#34;命令行参数&#34;&gt;命令行参数：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;-e 多点编辑  
-i --in-place ：直接修改文件内容((危险动作))，而不是输出到终端。  
-E -r --regexp-extended ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)  
-n  加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-定址&#34;&gt;1. 定址&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1、空(默认)：表示在全文范围  
2、单地址：  
　　n：指定行；  
　　/pattern/：被此模式所匹配到的每一行；  
3、地址范围：  
　　n,N：从起始行到结束行  
　　n,+N：从第起始行，向后数多少行  
　　n,/par1/：从起始行到pat1第一次匹配到的行  
　　/pat1/,/pat2/：从pat1第一次匹配到的行到pat2第一次匹配到的行  
　　$：最后一行  
 1，3表示1，2，3行，美元符号($)表示最后一行。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-定界符-分隔符&#34;&gt;2. 定界符|分隔符&lt;/h3&gt;

&lt;p&gt;sed s指令后加&lt;code&gt;@,#,$ /&lt;/code&gt;表示分隔符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo this is a test line | sed &#39;s/\w\+/[&amp;amp;]/g&#39;&lt;/code&gt;&lt;br /&gt;
  [this] [is] [a] [test] [line]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;s命令后面的第一个字段就是定界符,可以使用任意字符作为定姐夫@,#,$ / ：| +&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;sed 只替换匹配中的内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\w\+&lt;/code&gt; 匹配每一个单词&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;   对应于之前所匹配到的单词&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;  从开头匹配&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.*&lt;/code&gt;  匹配任意字符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;# *&lt;/code&gt; 匹配#后面连续多个空格&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3-组合命令-命令分隔&#34;&gt;3. 组合命令{}   命令分隔 ;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sed -i &#39;9,${s/[ \t]*$/  /;s/^[ \t]*$//}&#39; **/*.md&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-指令&#34;&gt;4. 指令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;模式空间(pattern space): [操作区,命令行]  
a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～  
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；  
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！  
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；  
p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～  

r : /PATH/FROM/FILE：读取指定文件的内容，追加到当前模式空间后面  
= ：显示行号                                           sed -n &#39;/music/=&#39; quote.txt  
! ：命令前加!,给定界符取反，不在定界范围内才执行命令  
s ：替换，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！  
      修饰标记：  
       /g：全局替换，没有此标记，只替换正则匹配到的第一项  
       /w /PATH/TO/FILE：将替换后的内容保存一份至指定文件  
       /p：将替换成功的内容送至标准输出  

n ：读取文件下一行到[pattern]模式空间中  
N ：读取文件下一行追加到[pattern]模式空间中  
d ：删除模式空间中的行  
D ：删除模式空间中的所有行  

保持空间(hold space): 缓冲区  
sed每次执行时还拥有一个保持空间(hold space)缓冲区,用来临时保存内容，开始时默认是一个空行。  
保持空间用于保存模式空间的内容，模式空间的内容可以复制到保持空间，同样地保持空间的内容可以复制回模式空间。sed提供了几组命令用来完成复制的工作，其它命令无法匹配也不能修改模式空间的内容  
H: 保存（Hold) 	h/H 	将[模式空间pattern]的内容copy或者append到[保持空间hold --缓存区]  
G: 取回（Get） 	g/G 	将[保持空间hold]的内容copy或者append到[模式空间pattern]  
x: 交换（Exchange） 	x 	交换模式空间和保持空间的内容  

一、标签  
b label ,无条件跳转到标签label,如果label没有指定,跳转到命令的结尾  
t label ,如果最后一次输入的最后一个 s/// 子命令执行成功,跳转到标签label,如果label没有指定,跳转到命令的结尾  
:a                   #定义标签a  
$!N                  #不是最后一行，执行N命令  
/ms$/s/\n/ /         #如果以ms结尾，将\n替换为空格  
ta                   #如果s///命令执行成功，跳转到标签a处  
P                    #打印pattern space的第一行  
D                    #删除pattern space的第一行，循环  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#正则匹配：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^ 行的开始 如：/^sed/匹配所有以sed开头的行。  
$ 行的结束 如：/sed$/匹配所有以sed结尾的行。  
. 匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。  
* 匹配零或多个字符 如：`/ *sed/`匹配所有模板是一个或多个空格后紧跟sed的行。  
[] 匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。  
[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。  
\(..\) 保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。  
&amp;amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;amp;**/，love这成**love**。  
  用来精确匹配一个单词 sed -n &#39;/\&amp;lt;acc=701\&amp;gt;/&#39;p  
\&amp;lt; 锚定单词的开始，如:/\&amp;lt;love/匹配包含以love开头的单词的行。  
\&amp;gt; 锚定单词的结束，如/love\&amp;gt;/匹配包含以love结尾的单词的行。  

x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。  
x\{m,\}重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。  
x\{m,n\}重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5--10个o的行。  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;经典案例&#34;&gt;经典案例&lt;/h1&gt;

&lt;h2 id=&#34;sed-替换字符-但是带转义的不替换&#34;&gt;sed 替换字符，但是带转义的不替换&lt;/h2&gt;

&lt;p&gt;sed -i  &amp;lsquo;/^1/!s/1/X/g&amp;rsquo;   ## 替换1为Ｘ但是行首的1不替换&lt;br /&gt;
sed  &amp;lsquo;/\,/!s/,/\n/g&amp;rsquo; &amp;lt;&amp;lt;&amp;lt;$a &amp;gt;b.sh&lt;/p&gt;

&lt;h2 id=&#34;谍中谍-sed中sed&#34;&gt;谍中谍，sed中sed&lt;/h2&gt;

&lt;h2 id=&#34;匹配替换第三列-内容-key&#34;&gt;匹配替换第三列&amp;rdquo;内容 key&lt;/h2&gt;

&lt;p&gt;&amp;lsquo;Key&amp;rsquo; =&amp;gt; env(&amp;lsquo;ms_door_key&amp;rsquo;,    &amp;lsquo;35gh6djhd8imd92ed&amp;rsquo;),&lt;br /&gt;
&lt;code&gt;sed &amp;quot;/&#39;Key&#39;/s/&#39;[^&#39;]*&#39;/&#39;123456&#39;/3&amp;quot; config.php&lt;/code&gt; &amp;gt;&amp;gt; &amp;lsquo;Key&amp;rsquo; =&amp;gt; env(&amp;lsquo;ms_door_key&amp;rsquo;,    &amp;lsquo;123456&amp;rsquo;),&lt;br /&gt;
    [^&amp;lsquo;]  匹配除&amp;rsquo;外的任意字符&lt;br /&gt;
    /3    仅替换第三次匹配的内容&lt;br /&gt;
&amp;lsquo;Secret&amp;rsquo; =&amp;gt; env(ms_door_secret),&amp;lsquo;9kd7dnc0667sni82n28dd&amp;rsquo;),&lt;br /&gt;
&lt;code&gt;sed &amp;quot;/&#39;Secret&#39;/{s/&#39;[^&#39;]*&#39;/&#39;222222222&#39;/3;t;s//&#39;222222222&#39;/2}&amp;quot; config.php&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;显示第10行到最后的内容&#34;&gt;显示第10行到最后的内容&lt;/h2&gt;

&lt;p&gt;cat /etc/passwd |sed -n &amp;lsquo;10,$p&amp;rsquo;&lt;br /&gt;
cat /etc/passwd |tail -n+10|head -n10&lt;br /&gt;
cat /etc/passwd |sed -n &amp;lsquo;10,19p&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;sed-查找制定内容-并在其后插入多行内容&#34;&gt;sed 查找制定内容,并在其后插入多行内容&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;### 在指定内容后插入  
RUN  sed -i &#39;/client\]/a  max_allowed_packet = 48M &#39; /etc/mysql/my.cnf  
###  
RUN  sed -i &#39;/mysqld\]/a   \  
event_scheduler=ON   \n\  
default-storage-engine=INNODB   \n\  
#default-character-set=utf8    \n\  
character-set-server = utf8    \n\  
max_allowed_packet = 16M    \n\  
wait_timeout	= 500    \n\  
interactive_timeout	= 500    \n\  
connect_timeout = 20    \n\  
&#39; /etc/mysql/my.cnf  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.行首为特定字符串（server开头的行）的行首添加字符“#”，注释掉以特定字符串为首的行。(替换功能)&lt;/p&gt;

&lt;p&gt;sed  -i  &amp;lsquo; s/^server/#server/g &amp;rsquo;    /etc/ntp.conf&lt;/p&gt;

&lt;p&gt;3.判断文件中是否存在特定字符串如果存在则不再重复加入，如果不存在，就添加字符串。（重复添加命令只保留一次）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /bin/bash  
grep -q &#39;10.114.0.2&#39;  /etc/hosts  
if  [ $?  -eq  0 ];then  
return  
else  
sed &#39;$a\  
10.114.0.2 l2 l02 w6\  
10.114.0.4 l4 l04 w7\  
&#39; /etc/hosts  
if  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查找并删除匹配内容-之前-之后-所有的行&#34;&gt;查找并删除匹配内容 之前|之后 所有的行&lt;/h2&gt;

&lt;p&gt;sed &amp;lsquo;/^title/,$!d&amp;rsquo; file  ## 删除到 title 行   (不包含 title）&lt;br /&gt;
sed &amp;lsquo;/^title/,$d&amp;rsquo; file   ## 从 title 开始删除 （包含 title)&lt;br /&gt;
sed  &amp;lsquo;0,/&amp;mdash;/d&amp;rsquo; A.txt    ## 删除开头到 &amp;mdash; 行  (包含 &amp;mdash;)&lt;/p&gt;

&lt;p&gt;#添加/移除注释&lt;br /&gt;
sed -i &amp;lsquo;/iptables/s/^#//&amp;rsquo;   # 取消注释&lt;br /&gt;
sed -i &amp;lsquo;/iptables/s/^/#/&amp;rsquo;   # 增加注释&lt;/p&gt;

&lt;p&gt;ENV LS_SETTINGS_DIR /etc/logstash&lt;br /&gt;
&lt;code&gt;sed -ri &#39;s/^path\.config:/#&amp;amp;/g&#39; &amp;quot;$LS_SETTINGS_DIR/logstash.yml&amp;quot;;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;批量替换&#34;&gt;批量替换&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;find . -name &amp;quot;*.htm&amp;quot; -type f -print | xargs sed -i &#39;s#http://aywusq#https://aywusq#g&#39;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;find ./ -path &amp;quot;./file&amp;quot; -prune -o -name &amp;quot;*.htm&amp;quot; |xargs grep -ins bizchinalinyi&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;合并行&#34;&gt;合并行&lt;/h1&gt;

&lt;h2 id=&#34;多空行合并为一行&#34;&gt;多空行合并为一行&lt;/h2&gt;

&lt;p&gt;sed &amp;lsquo;/^$/{N/^\n$/D&amp;rsquo;}&lt;br /&gt;
&lt;code&gt;sed -i -rn &#39;h;n;:a;H;n;$!ba;g;s/(\n){2,}/\n\n/g;p&#39; test.txt&lt;/code&gt;&lt;br /&gt;
!{$!ba}就是如果不满足前面的条件，就执行$!ba&lt;br /&gt;
{}就是把要执行的命令括起来&lt;br /&gt;
！{}就是括号里的都不执行&lt;/p&gt;

&lt;h2 id=&#34;删除重复行-uniq-重行&#34;&gt;删除重复行 uniq  重行&lt;/h2&gt;

&lt;h1 id=&#34;只保留重复行中的第一行-其他行删除&#34;&gt;只保留重复行中的第一行，其他行删除&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;sed &#39;$!N; /^\(.*\)\n\1$/!P; D&#39;&lt;/code&gt;&lt;br /&gt;
 $!N; 不是最后一行 读取下一行到模式空间&lt;br /&gt;
 两行合并到一行 匹配两行如果一样就删除&lt;/p&gt;

&lt;h2 id=&#34;sed行首删除一个字符&#34;&gt;sed行首删除一个字符&lt;/h2&gt;

&lt;h2 id=&#34;sed行首添加一个字符&#34;&gt;sed行首添加一个字符&lt;/h2&gt;

&lt;p&gt;sed &amp;lsquo;1 a\string1\n\string2\n&amp;rsquo; /etc/passwd 在第1行后插入两行字符串。&lt;br /&gt;
sed &amp;lsquo;1 i\string1\n\string2\n&amp;rsquo; /etc/passwd 在第1行前插入两行字符串&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# enable snd-soc-wmt-fm34  
sed -i &#39;/snd-soc-wmt-fm34/s/^#//&#39; fs_patch/load_drivers.sh  

# s/^#//表示将字符串开头的#字符替换为空(即去除行首的#字符)  
# /snd-soc-wmt-fm34/表示匹配含有snd-soc-wmt-fm34字符串的行  

# disable snd-soc-wmt-fm34 back  
sed -i &#39;/snd-soc-wmt-fm34/s/^/#&amp;amp;/&#39; fs_patch/load_drivers.sh  

# 这里和上面的删除操作唯一的不同就在于s/^/#&amp;amp;/部分。其中，^字符匹配行首，#字符是一般字符表示添加该字符  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find . -name &#39;*.php&#39;  -exec sed -rni &#39;h;n;:a;H;n;$!ba;g;s/(\n){2,}/\n\n/g;p&#39; &amp;quot;{}&amp;quot; \;&lt;/code&gt;&lt;br /&gt;
################################################################################&lt;/p&gt;

&lt;h3 id=&#34;匹配不替换-不匹配替换&#34;&gt;匹配不替换 不匹配替换&lt;/h3&gt;

&lt;p&gt;sed &amp;lsquo;/^1/!s/1/X/g&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;排序删除重复行&#34;&gt;排序删除重复行&lt;/h2&gt;

&lt;p&gt;file=&amp;lsquo;test.txt&amp;rsquo;&lt;br /&gt;
sort -n $file | uniq&lt;br /&gt;
sort -n $file | awk &amp;lsquo;{if($0!=line)print; line=$0}&amp;rsquo;&lt;br /&gt;
sort -n $file | sed &amp;lsquo;$!N; /^.∗\n\1$/!P; D&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;移动行&#34;&gt;移动行&lt;/h2&gt;

&lt;p&gt;一、把上面的某行移动到下面是容易的，用 h 存到保留区，用 G 取出就行了，例如，把第六行变成第九行：&lt;br /&gt;
sed &amp;lsquo;6{h;d};9G&amp;rsquo; #第6行存到暂存区并删除 第9行取出并追加&lt;br /&gt;
二、由于sed是按顺序读取文本，所以把下面的行移动到上面稍微复杂一些，例如，把第七行放到第二行：&lt;br /&gt;
sed -n &amp;lsquo;2!{p;d};:1;6!{N;b1};h;n;p;g;p&amp;rsquo;&lt;br /&gt;
前面的数字是移动后的位置，后面的数字是将要被移动的行数减一。&lt;/p&gt;

&lt;h2 id=&#34;sed-转义单引号的问题&#34;&gt;sed 转义单引号的问题&lt;/h2&gt;

&lt;p&gt;sed命令中，使用单引号来制定操作，如sed &amp;rsquo;s/regular/replace/&amp;lsquo;。如果想在单引号中转义单引号采用转义字符是不行的。解决的方法是把sed部分用单引号分割开，在外面转义。&lt;/p&gt;

&lt;p&gt;如：A:  nl /etc/passwd | sed &amp;lsquo;2a I\&amp;lsquo;am Dophi!&amp;rsquo;     &amp;mdash;&amp;mdash;&amp;ndash;错误&lt;br /&gt;
      B: nl /etc/passwd | sed &amp;lsquo;2a I&amp;rsquo;\&amp;ldquo;am Dophi&amp;rsquo;    &amp;mdash;&amp;mdash;&amp;mdash;正确，都是单引号，单引号之间没有空格&lt;br /&gt;
&lt;code&gt;sed -i &amp;quot;s|\(&#39;debug&#39; =&amp;gt;\) .*|\1 ${DEBUG},|&amp;quot; config.php&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;rvm采用国内镜像&#34;&gt;rvm采用国内镜像&lt;/h2&gt;

&lt;p&gt;sed -i -e &amp;rsquo;s/ftp.ruby-lang.org\/pub\/ruby/ruby.taobao.org\/mirrors\/ruby/g&amp;rsquo; ~/.rvm/config/db&lt;/p&gt;

&lt;h2 id=&#34;多文件字符替換&#34;&gt;多文件字符替換&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed &#39;s/localhost/127.0.0.1/g&#39; mysql_virtual_*.cf&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;删除一个文本文件中不包含某几个关键词的所有行&#34;&gt;删除一个文本文件中不包含某几个关键词的所有行&lt;/h2&gt;

&lt;p&gt;sed -i &amp;lsquo;/aa|bb|ggg/!d&amp;rsquo; a.txt&lt;/p&gt;

&lt;h2 id=&#34;删除file文件所有包含某几个关键词的所有行&#34;&gt;删除file文件所有包含某几个关键词的所有行&lt;/h2&gt;

&lt;p&gt;sed -i &amp;lsquo;/abc/d;/efg/d&amp;rsquo; a.txt  // 删除含字符串&amp;rdquo;abc&amp;rdquo;或“efg&amp;rdquo;的行&lt;/p&gt;

&lt;h1 id=&#34;将-bin-bash-替换为-usr-bin-env-bash&#34;&gt;将 #!/bin/bash 替换为 #!/usr/bin/env bash&lt;/h1&gt;

&lt;p&gt;sed -i &amp;lsquo;/#!/bin/bash: /d&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;markdown-将行尾替换为两个空格&#34;&gt;markdown 将行尾替换为两个空格&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed &#39;9,s/[ \t]*$/  /g&#39;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;sed -i &#39;9,$s/[!^$][ \t]*$/  /&#39; **/*.md&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;sed -i &#39;9,${s/\r//;s/[ \t]*$/  /;s/^[ \t]*$//}&#39; **/*.md&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;sed -i &#39;/^$/!s/[ \t]*$/  /&#39; **/*.md&lt;/code&gt;  # 空行不替换 ,非空行增加2个空格&lt;br /&gt;
&lt;code&gt;sed -i &#39;/^-*$/!s/[ \t]*$/  /&#39; content/**/*.md&lt;/code&gt; # 除 空行 和 &amp;mdash;行 外其他行增加2空格&lt;br /&gt;
&lt;code&gt;sed -i -e &#39;s/\r//&#39; -e  &#39;/./,/^$/!d&#39; -e &#39;/^-*$/!s/[ \t]*$/  /&#39; content/**/*.md&lt;/code&gt;  # 1. 转换格式为unix 2.连续空行合并 3. 除空行和&amp;mdash;外，行尾添加空格&lt;br /&gt;
Makefile中需要对$进行转义 &lt;code&gt;sed -i -e &#39;s/\r//&#39; -e  &#39;/./,/^$$/!d&#39; -e &#39;/^-*$$/!s/[ \t]*$$/  /&#39; content/**/*.md&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;hexo-相关&#34;&gt;hexo 相关&lt;/h1&gt;

&lt;h2 id=&#34;匹配第二行的内容-并替换成当前日期&#34;&gt;匹配第二行的内容 并替换成当前日期&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed -i -u -E &amp;quot;2s#^date:.+#date: $(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot; )#g&amp;quot; sed.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;找到所有文章-并删除所有包含update&#34;&gt;找到所有文章,并删除所有包含update:&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;find . -name &amp;quot;*.md&amp;quot; -type f -exec sed -i &#39;/layout: /d&#39; {} \;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;find . -name &amp;quot;*.md&amp;quot; -type f -exec sed -i &#39;/update: /d&#39; {} \;&lt;/code&gt; # 删除 update: 行&lt;br /&gt;
&lt;code&gt;find . -name &amp;quot;*.md&amp;quot; -type f -exec sed -i &#39;3i update: &#39; {} \;&lt;/code&gt; # 第三行插入 update:&lt;br /&gt;
&lt;code&gt;find . -name &amp;quot;*.md&amp;quot; -type f -exec sed -i &#39;1{h;d};3G&#39; {} \;&lt;/code&gt;   # 下移2行&lt;br /&gt;
&lt;code&gt;find . -name &amp;quot;*.md&amp;quot; -type f -exec sed -i &#39;2h;3G&#39; {} \;&lt;/code&gt;       # 复制第2行&lt;br /&gt;
&lt;code&gt;find . -name &amp;quot;*.md&amp;quot; -type f -exec sed -i &#39;s/^category :/categories:/&#39; {} \;&lt;/code&gt;   # 替换category为categories&lt;/p&gt;

&lt;h1 id=&#34;hexo2hugo&#34;&gt;hexo2hugo&lt;/h1&gt;

&lt;h2 id=&#34;去重-删除重复的-行&#34;&gt;去重 删除重复的 &amp;mdash; 行&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed -e &#39;N; /^\(.*\)\n\1$/!P; D&#39;&lt;/code&gt; ## 任意去重&lt;br /&gt;
 &lt;code&gt;sed -e &#39;N; /^\(---\)\n\1$/!P; D&#39;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;去除windows-r&#34;&gt;去除windows \r&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed -i &#39;s/\r//g&#39; **/*.md&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;sed -i &#39;9,$s/$/  /g&#39; **/*.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;0-首行插入&#34;&gt;0. 首行插入 &amp;mdash;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed -i &#39;1i ---&#39; **/*.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-修改date-格式为rfc3339&#34;&gt;1. 修改date 格式为rfc3339&lt;/h2&gt;

&lt;p&gt;date: 2016-09-27T15:57:46+08:00 &amp;ndash;&amp;gt; 2017-09-28T11:11:13+08:00&lt;br /&gt;
&lt;code&gt;sed -i -E &#39;/^date:/s/([0-9]{4}-[0-9]{2}-[0-9]{2})[ T]([0-9]{2}:[0-9]{2}:[0-9]{2})(\+[0-9]{2}:[0-9]{2})?/\1T\2+08:00/&#39; **/*.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-实现添加-并将里面的空格替换为-合并下面两条命令&#34;&gt;2. 实现添加[]并将里面的空格替换为，  (合并下面两条命令)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  tags: arp,linux --&amp;gt; tags: [arp,linux]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sed -i -E -e &#39;/^categories:/{s# ([^\r\n\t]*)# [\1]#;s/ /,/2g}&#39; -e &#39;/^tags/{s# ([^\r\n\t]*)# [\1]#;s/ /,/2g}&#39; **/*.md&lt;/code&gt;&lt;br /&gt;
  ##  categories 修正为数组&lt;br /&gt;
    &lt;code&gt;sed -i -E -e &#39;/^categories:/s# ([^\r\n\t]*)# [\1]#&#39; -e &#39;/^tags/s# ([^\r\n\t]*)# [\1]#&#39; *.md&lt;/code&gt;&lt;br /&gt;
  ##  从第二个空格起替换为,&lt;br /&gt;
    &lt;code&gt;sed -E &#39;/categories: /s/ /,/2g&#39; *.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;在第3行插入&#34;&gt;在第3行插入&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed -i &#39;3i update: 2016-01-01&#39; *.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sed -i &#39;1d&#39; *.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;在文件首行前-加入指定文字&#34;&gt;在文件首行前 加入指定文字&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed -i &#39;1i title: 内存对齐\ndate: $dt\ncategories: 朴素linux\ntags: linux\n---\n&#39; *.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;批量在行尾添加空格&#34;&gt;批量在行尾添加空格&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;find . -type f -name &#39;*.php&#39; -exec sed &#39;$a\\n&#39; {} \;&lt;/code&gt;&lt;br /&gt;
1) # sed &amp;lsquo;/$/a\n&amp;rsquo; test.txt，可以在文件的每行末尾添加一个回车&lt;br /&gt;
2) # sed &amp;lsquo;$a\eof&amp;rsquo; test.txt，可以在文件的末尾添加&amp;rsquo;eof&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;删除全部空行-包括空格&#34;&gt;删除全部空行 包括空格&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sed &#39;/^ *$/d&#39;test.txt&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;%s/^n//g&lt;/code&gt;  全局替换所有以回车开头的字符，替换为空。&lt;br /&gt;
&lt;code&gt;%s/^n$//g&lt;/code&gt; 如果有多个连续的空行，想保留一行&lt;/p&gt;

&lt;h2 id=&#34;替换部分&#34;&gt;替换部分&lt;/h2&gt;

&lt;p&gt;&amp;lsquo;DB_HOST&amp;rsquo;   =&amp;gt; &amp;lsquo;localhost&amp;rsquo;, // 服务器地址&lt;br /&gt;
DB_HOST=127.0.0.1   # 服务器地址&lt;br /&gt;
&lt;code&gt;sudo sed -i -u -E &amp;quot;s#&#39;DB_HOST&#39;\s+=&amp;gt; &#39;[a-zA-Z0-9._]+&#39;#&#39;DB_HOST&#39;   =&amp;gt; &#39;$DB_HOST&#39;#g&amp;quot; config.php  
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;获取本机的ip-192-168-1-100&#34;&gt;获取本机的ip  &lt;code&gt;192.168.1.100&lt;/code&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;将 IP 前面的部分予以删除&lt;br /&gt;
&lt;code&gt;ifconfig eth0 | grep &#39;inet addr&#39; | sed &#39;s/^.*addr://g&#39;&lt;/code&gt;&lt;br /&gt;
192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;将 IP 后面的部分予以删除&lt;br /&gt;
&lt;code&gt;ifconfig enp3s0 | grep &#39;inet addr&#39; | sed &#39;s/^.*addr://g&#39; | sed &#39;s/Bcast.*$//g&#39;&lt;/code&gt;&lt;br /&gt;
192.168.1.100&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;移除大部分的html标签-包括跨行标签&#34;&gt;移除大部分的HTML标签（包括跨行标签）&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;sed -e :a -e &#39;s/&amp;lt;[^&amp;gt;]*&amp;gt;//g;/&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;在某行的前一行或后一行添加内容&#34;&gt;在某行的前一行或后一行添加内容&lt;/h2&gt;

&lt;p&gt;具休操作如下：&lt;/p&gt;

&lt;p&gt;#匹配行前加&lt;br /&gt;
sed -i &amp;lsquo;/allow 361way.com/iallow www.361way.com&amp;rsquo; the.conf.file&lt;br /&gt;
#匹配行前后&lt;br /&gt;
sed -i &amp;lsquo;/allow 361way.com/aallow www.361way.com&amp;rsquo; the.conf.file&lt;/p&gt;

&lt;p&gt;而在书写的时候为便与区分，往往会在i和a前面加一个反加一个反斜扛 。代码就变成了：&lt;/p&gt;

&lt;p&gt;sed -i &amp;lsquo;/2222222222/a\3333333333&amp;rsquo; test.txt&lt;br /&gt;
sed -i &amp;lsquo;/2222222222/i\3333333333&amp;rsquo; test.txt&lt;/p&gt;

&lt;p&gt;这就就可以很方便的看出要在某一行前或某一行后加入什么内容 。不过经常我记不住a 、i 那个是前那个是后。我的记法是a = after ，i = in front 。这样就知道 i 是前，a 是后了。不过官方的man文件里不是这样解释的，man文件里是这样解释的：&lt;/p&gt;

&lt;p&gt;a&lt;br /&gt;
text   Append text, which has each embedded newline preceded by a backslash.&lt;br /&gt;
i&lt;br /&gt;
text   Insert text, which has each embedded newline preceded by a backslash.&lt;/p&gt;

&lt;p&gt;而且其可以配合find查找的内容处理，如下：&lt;/p&gt;

&lt;p&gt;find . -name server.xml|xargs sed -i &amp;lsquo;/directory/i       &lt;!--&#39;  
find . -name server.xml|xargs sed -i &#39;/pattern=&#34;%h/a       --&gt;&amp;lsquo;&lt;/p&gt;

&lt;p&gt;二、在某行（指具体行号）前或后加一行内容&lt;/p&gt;

&lt;p&gt;sed -i &amp;lsquo;N;4addpdf&amp;rsquo; a.txt&lt;br /&gt;
sed -i &amp;lsquo;N;4ieepdf&amp;rsquo; a.txt&lt;/p&gt;

&lt;p&gt;这里指定的行号是第四行 。&lt;/p&gt;

&lt;p&gt;三、删除指定行的上一行或下一行&lt;/p&gt;

&lt;p&gt;删除指定文件的上一行&lt;br /&gt;
&lt;code&gt;sed -i -e :a -e &#39;$!N;s/.*n(.*directory)/1/;ta&#39; -e &#39;P;D&#39; server.xml&lt;/code&gt;&lt;br /&gt;
删除指定文件的下一行&lt;br /&gt;
&lt;code&gt;sed -i &#39;/pattern=&amp;quot;%/{n;d}&#39; server.xml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个写起来有点长，一般如果不是shell里的需要，我更喜欢用vim去处理。另外需要注意的是，在vim里如果替换的内容里tab这样的符号是需要在编辑模式下分别按ctrl+v 和crtl+I ，而不是不停的几个空格。&lt;/p&gt;

&lt;p&gt;1、定位行：&lt;br /&gt;
sed -n &amp;lsquo;12,~3p&amp;rsquo; pass #从第12行开始，直到下一个3的倍数行（12-15行）&lt;br /&gt;
sed -n &amp;lsquo;12,+4p&amp;rsquo; pass #从第12行开始，连续4行（12-16行）&lt;br /&gt;
sed -n &amp;lsquo;12~3p&amp;rsquo; pass #从第12行开始，间隔3行输出一次（12，15，18，21&amp;hellip;）&lt;br /&gt;
sed -n &amp;lsquo;10,$p&amp;rsquo; pass   #从第10行至结尾&lt;br /&gt;
sed -n &amp;lsquo;4!p&amp;rsquo; pass   #除去第4行&lt;/p&gt;

&lt;p&gt;2、正则：&amp;rsquo;/正则式/&amp;rsquo;&lt;br /&gt;
sed -n &amp;lsquo;/root/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/^root/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/bash$/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/ro.t/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/ro*/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/[ABC]/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/[A-Z]/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/[^ABC]/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/^[^ABC]/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/&amp;lt;root/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;/root&amp;gt;/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;3、扩展正则：&lt;br /&gt;
sed -n &amp;lsquo;/root|yerik/p&amp;rsquo; /etc/passwd #拓展正则需要转义&lt;br /&gt;
sed -nr &amp;lsquo;/root|yerik/p&amp;rsquo; /etc/passwd #加-r参数支持拓展正则&lt;br /&gt;
sed -nr &amp;lsquo;/ro(ot|ye)rik/p&amp;rsquo; /etc/passwd #匹配rootrik和royerik单词&lt;br /&gt;
sed -nr &amp;lsquo;/ro?t/p&amp;rsquo; /etc/passwd   #?匹配0-1次前导字符&lt;br /&gt;
sed -nr &amp;lsquo;/ro+t/p&amp;rsquo; /etc/passwd   #匹配1-n次前导字符&lt;br /&gt;
sed -nr &amp;lsquo;/ro{2}t/p&amp;rsquo; /etc/passwd   #匹配2次前导字符&lt;br /&gt;
sed -nr &amp;lsquo;/ro{2,}t/p&amp;rsquo; /etc/passwd   #匹配多于2次前导字符&lt;br /&gt;
sed -nr &amp;lsquo;/ro{2，4}t/p&amp;rsquo; /etc/passwd #匹配2-4次前导字符&lt;br /&gt;
sed -nr &amp;lsquo;/(root)*/p&amp;rsquo; /etc/passwd   #匹配0-n次前导单词&lt;/p&gt;

&lt;p&gt;4、sed编辑（对行的插入、删除、替换操作）&lt;br /&gt;
sed &amp;lsquo;/root/a admin&amp;rsquo; /etc/passwd   #在root行后追加一个admin行&lt;br /&gt;
sed &amp;lsquo;/root/i admin&amp;rsquo; /etc/passwd   #在root行前插入一个admin&lt;br /&gt;
sed &amp;lsquo;/root/c admin&amp;rsquo; /etc/passwd   #将root行替换为admin&lt;br /&gt;
sed &amp;lsquo;/root/d&amp;rsquo; /etc/passwd    #删除含有root的行&lt;/p&gt;

&lt;p&gt;s替换&lt;br /&gt;
sed -n &amp;rsquo;s/root/admin/p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;rsquo;s/root/admin/2p&amp;rsquo; /etc/passwd        #在每行的第2个root作替换&lt;br /&gt;
sed -n &amp;rsquo;s/root/admin/gp&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;lsquo;1,10 s/root/admin/gp&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -n &amp;rsquo;s/root/AAA&amp;amp;BBB/2p&amp;rsquo; /etc/passwd       #将root替换成AAArootBBB，&amp;amp;作反向引用，代替前面的匹配项&lt;br /&gt;
sed -ne &amp;rsquo;s/root/AAA&amp;amp;BBB/&amp;rsquo; -ne &amp;rsquo;s/bash/AAA&amp;amp;BBB/p&amp;rsquo; /etc/passwd #-e将多个命令连接起来，将root或bash行作替换&lt;br /&gt;
sed -n &amp;rsquo;s/root/AAA&amp;amp;BBB/;s/bash/AAA&amp;amp;BBB/p&amp;rsquo; /etc/passwd   #与上命令功能相同&lt;br /&gt;
sed -nr &amp;rsquo;s/(root)(.&lt;em&gt;)(bash)/\3\2\1/p&amp;rsquo; /etc/passwd     #将root与bash位置替换，两标记替换&lt;br /&gt;
或sed -n &amp;rsquo;s/(root)(.&lt;/em&gt;)(bash)/\3\2\1/p&amp;rsquo; /etc/passwd&lt;br /&gt;
bash:x:0:0:root:/root:/bin/root&lt;/p&gt;

&lt;p&gt;y替换&lt;br /&gt;
echo &amp;ldquo;sorry&amp;rdquo;|sed &amp;lsquo;y/ory/ABC/&amp;rsquo; #一一对应替换（sABBC）&lt;/p&gt;

&lt;p&gt;6、sed的模式空间和保持空间&lt;br /&gt;
h：模式&amp;mdash;-&amp;gt;保持&lt;br /&gt;
H：模式&amp;mdash;&amp;gt;&amp;gt;保持&lt;br /&gt;
x：模式&amp;lt;&amp;mdash;&amp;gt;保持&lt;br /&gt;
g：保持&amp;mdash;-&amp;gt;模式&lt;br /&gt;
G：保持&amp;mdash;&amp;gt;&amp;gt;模式&lt;/p&gt;

&lt;p&gt;例如：&lt;br /&gt;
111&lt;br /&gt;
222&lt;br /&gt;
333&lt;br /&gt;
444&lt;/p&gt;

&lt;h1 id=&#34;sed-1h-2-3h-4g&#34;&gt;sed &amp;lsquo;1h;2,3H;4G&amp;rsquo;&lt;/h1&gt;

&lt;p&gt;分析&lt;br /&gt;
CMD         模式     保持&lt;br /&gt;
111         111     \n&lt;br /&gt;
1h          111     111&lt;br /&gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;111&lt;br /&gt;
222         222     111&lt;br /&gt;
2,3H        222     111\n222&lt;br /&gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;222&lt;br /&gt;
333         333     111\n222&lt;br /&gt;
2,3H        333     111\n222\n333&lt;br /&gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;333&lt;br /&gt;
444         444     111\n222\n333&lt;br /&gt;
4G          444\n111\n222\n333&lt;br /&gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;444\n111\n222\n333&lt;/p&gt;

&lt;p&gt;1－10&lt;br /&gt;
11－22&lt;br /&gt;
22－33&lt;br /&gt;
11－22&lt;br /&gt;
34－END&lt;/p&gt;

&lt;p&gt;7、sed特殊用法&lt;br /&gt;
sed -n &amp;lsquo;/root/w a.txt&amp;rsquo;    #将匹配行输出到文件&lt;br /&gt;
sed &amp;lsquo;/root/r abc.txt&amp;rsquo; /etc/passwd #把abc.txt的文件内容读入到root匹配行后&lt;br /&gt;
sed -n &amp;lsquo;/root/w a.txt&amp;rsquo;&lt;br /&gt;
sed -n &amp;lsquo;/root/{=;p}&amp;rsquo; /etc/passwd #打印行号和匹配root的行&lt;br /&gt;
sed -n &amp;lsquo;/root/{n;d}&amp;rsquo; /etc/passwd #将匹配root行的下一行删除&lt;br /&gt;
sed -n &amp;lsquo;/root/{N;d}&amp;rsquo; /etc/passwd #将匹配root行和下一行都删除&lt;br /&gt;
sed &amp;lsquo;22{h;d};23,33{H;d};44G&amp;rsquo; pass&lt;/p&gt;

&lt;p&gt;8、sed 脚本编写方法&lt;br /&gt;
&lt;1&gt;从文件读入命令&lt;br /&gt;
sed -f sed.sh&lt;br /&gt;
sed.sh文件内容：&lt;br /&gt;
s/root/yerik/p&lt;br /&gt;
s/bash/csh/p&lt;/p&gt;

&lt;p&gt;&lt;2&gt;直接运行脚本 ./sed.sh /etc/passwd&lt;br /&gt;
#!/bib/sed -f&lt;br /&gt;
s/root/yerik/p&lt;br /&gt;
s/bash/csh/p&lt;/p&gt;

&lt;p&gt;###################################&lt;br /&gt;
二、Sed练习&lt;/p&gt;

&lt;p&gt;1，删除文件每行的第一个字符。&lt;br /&gt;
sed -n &amp;rsquo;s/^.//gp&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -nr &amp;rsquo;s/(.)(.&lt;em&gt;)/\2/p&amp;rsquo; /etc/passwd&lt;br /&gt;
2，删除文件每行的第二个字符。&lt;br /&gt;
sed -nr &amp;rsquo;s/(.)(.)(.&lt;/em&gt;)/\1\3/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;3，删除文件每行的最后一个字符。&lt;br /&gt;
sed -nr &amp;rsquo;s/.$//p&amp;rsquo; /etc/passwd&lt;br /&gt;
sed -nr &amp;rsquo;s/(.*)(.)/\1/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;4，删除文件每行的倒数第二个字符。&lt;br /&gt;
sed -nr &amp;rsquo;s/(.*)(.)(.)/\1\3/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;5，删除文件每行的第二个单词。&lt;br /&gt;
sed -nr &amp;rsquo;s/([^a-Z]&lt;em&gt;)([a-Z]+)([^a-Z]+)([a-Z]+)(.&lt;/em&gt;)/\1\2\3\5/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;6，删除文件每行的倒数第二个单词。&lt;br /&gt;
sed -nr &amp;rsquo;s/(.&lt;em&gt;)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]&lt;/em&gt;)/\1\2\4\5\6/p&amp;rsquo; /etc/samba/smb.conf&lt;/p&gt;

&lt;p&gt;7，删除文件每行的最后一个单词。&lt;br /&gt;
sed -nr &amp;rsquo;s/(.&lt;em&gt;)([^a-Z]+)([a-Z]+)([^a-Z]&lt;/em&gt;)/\1\2\4/p&amp;rsquo; /etc/samba/smb.conf&lt;/p&gt;

&lt;p&gt;8，交换每行的第一个字符和第二个字符。&lt;br /&gt;
sed -nr &amp;rsquo;s/(.)(.)(.*)/\2\1\3/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;9，交换每行的第一个单词和第二个单词。&lt;br /&gt;
sed -nr &amp;rsquo;s/([^a-Z]&lt;em&gt;)([a-Z]+)([^a-Z]+)([a-Z]+)(.&lt;/em&gt;)/\1\4\3\2\5/p&amp;rsquo; /etc/samba/smb.conf&lt;/p&gt;

&lt;p&gt;10，交换每行的第一个单词和最后一个单词。&lt;br /&gt;
sed -nr &amp;rsquo;s/([^a-Z]&lt;em&gt;)([a-Z]+)([^a-Z]+)([a-Z]+)(.&lt;/em&gt;)/\1\4\3\2\5/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;11，删除一个文件中所有的数字。&lt;br /&gt;
sed &amp;rsquo;s/[0-9]*//g&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;12，删除每行开头的所有空格。&lt;br /&gt;
sed -n &amp;rsquo;s/^\ *//p&amp;rsquo; /etc/samba/smb.conf&lt;br /&gt;
sed -nr &amp;rsquo;s/( &lt;em&gt;)(.&lt;/em&gt;)/\2/p&amp;rsquo; testp&lt;/p&gt;

&lt;p&gt;13，用制表符替换文件中出现的所有空格。&lt;br /&gt;
sed -n &amp;rsquo;s/\ /\t/gp&amp;rsquo; pass&lt;/p&gt;

&lt;p&gt;14，把所有大写字母用括号（）括起来。&lt;br /&gt;
sed -nr &amp;rsquo;s/([A-Z])/(&amp;amp;)/gp&amp;rsquo; testp&lt;br /&gt;
sed -n &amp;rsquo;s/[A-Z]/(&amp;amp;)/gp&amp;rsquo; testp&lt;/p&gt;

&lt;p&gt;15，打印每行3次。&lt;br /&gt;
sed &amp;lsquo;p;p&amp;rsquo; pass&lt;/p&gt;

&lt;p&gt;16，隔行删除。&lt;br /&gt;
sed -n &amp;lsquo;1~2p&amp;rsquo; pass&lt;/p&gt;

&lt;p&gt;17，把文件从第22行到第33行复制到第44行后面。&lt;br /&gt;
sed &amp;lsquo;1,21h;22h;23,33H;44G&amp;rsquo; pass&lt;/p&gt;

&lt;p&gt;18，把文件从第22行到第33行移动到第44行后面。&lt;br /&gt;
sed &amp;lsquo;22{h;d};23,33{H;d};44G&amp;rsquo; pass&lt;/p&gt;

&lt;p&gt;19，只显示每行的第一个单词。&lt;br /&gt;
sed -nr &amp;rsquo;s/([^a-Z]&lt;em&gt;)([a-Z]+)([^a-Z]+)(.&lt;/em&gt;)/\2/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;20，打印每行的第一个单词和第三个单词。&lt;br /&gt;
sed -nr &amp;rsquo;s/([^a-Z]&lt;em&gt;)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)(.&lt;/em&gt;)/\2&amp;ndash;\4/p&amp;rsquo; /etc/passwd&lt;/p&gt;

&lt;p&gt;21，将格式为    mm/yy/dd    的日期格式换成   mm；yy；dd&lt;br /&gt;
date +%m/%Y/%d |sed -n &amp;rsquo;s#/#;#gp&amp;rsquo;&lt;/p&gt;

&lt;p&gt;22, 逆向输出&lt;br /&gt;
cat a.txt&lt;br /&gt;
ABC&lt;br /&gt;
DEF&lt;br /&gt;
XYZ&lt;br /&gt;
输出样式变成&lt;br /&gt;
XYZ&lt;br /&gt;
DEF&lt;br /&gt;
ABC&lt;/p&gt;

&lt;h2 id=&#34;一-文本间距&#34;&gt;一、文本间距&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;二倍行距&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed G  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在含空行的文件的行与行之间添加空行。输出文件的行与行之间的空行数不会多于一行。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/^$/d; G&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;三倍行距&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;G; G&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;取消二倍行距（假定偶数行为空行）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;n; d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span id=&#34;more-455230&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-编号方式&#34;&gt;二、编号方式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;标记行号（纯左对齐）。使用tab替代space可以保持页边距。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed = filename | sed &#39;N; s/n/t/&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;标记行号（号码在左，文本右对齐）。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed = filename | sed &#39;N; s/^/ /; s/*(.{6,})n/1 /&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;标记行号，但只输出非空的行。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/./=&#39; filename | sed &#39;/./N; s/n/ /&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;计算行数（类似于”wc -l”）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SED -N &#39;$=&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-文本转换与替换&#34;&gt;三、文本转换与替换&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;UNIX环境下：将DOS换行符转(CR/LF)换成Unix格式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/.$//&#39; #假定所有行均以CR/LF结尾  
sed &#39;s/^M$//&#39; #在bash/tcsh下，按Ctrl-V然后按Ctrl-M  
sed &#39;s/x0D$//&#39; #gsed 3.02.80中可用，但第一个脚本更简单一些  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;UNIX环境下：将UNIX换行符转换成DOS格式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &amp;quot;s/$/&#39;echo -e r&#39;/&amp;quot; #ksh命令行模式下  
sed &#39;s/$&#39;&amp;quot;/&#39;echo r&#39;/&amp;quot; #bash命令行模式下  
sed &amp;quot;s/$/&#39;echo r&#39;/&amp;quot; #zsh命令行模式下  
sed &#39;s/$/r/&#39; #gsed 3.02.80  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DOS环境下：将Unix换行符(LF)转换成DOS格式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &amp;quot;s/$//&amp;quot; #方法一  
sed -n p #方法二  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DOS环境下：将DOS换行符（CR/LF）转换成Unix格式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#此操作不能在DOS版的sed中实现。转用tr来代替  
tr -d r outfile #GNU tr version 1.22或以上  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除行首空白（space, tab），使文本全部左移。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/^[ t]*//&#39; #请参照文末关于&#39;t&#39;的注解  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除行末空白（space, tab）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/[ t]*$//&#39; #请参照文末关于&#39;t&#39;的注解  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;同时删除行首行尾空白（space， tab）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/^[ t]*//; s/[ t]*$//&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在每行行首插入5个空格（使页面右移）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/^/ /&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使文本全部靠右对齐（宽度为79列）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e; a -e &#39;s/^.{1, 78]$/ &amp;amp;/;ta&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使文本居中（宽度为79列）。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#方法一中，行首空格仍然有效，行尾被加上了空白以填补不足。  
#方法二中，行首空白在居中过程中被抛弃，行尾也没有补白的空白。  
sed -e :a -e &#39;s/^.{1, 77}$/ &amp;amp;/;ta&#39; #方法一  
sed -e :a -e &#39;s/^.{1, 77}$/ &amp;amp;/;ta&#39; -e &#39;s/( *)1/1/&#39; #方法二  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查找与替换：将每行中的”foo”替换成”bar”&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/foo/bar/&#39; #只替换每行中的第一个实例  
sed &#39;s/foo/bar/4′ #只替换每行中的第四个实例  
sed &#39;s/foo/bar/g&#39; #替换一行中出现的所有实例  
sed &#39;s/(.*)foo(.*foo)/1bar2/&#39; #替换每行倒数第二个实例  
sed &#39;s/(.*)foo/1bar/&#39; #只替换替换每行倒数第一个实例  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查找与替换：将不含”baz”的行中的”foo”替换成”bar”&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/baz/!s/foo/bar/g&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;将”scarlet””ruby””puce”换为”red”&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/scarlet/red/g; s/ruby/red/g; s/puce/red/g&#39; #适用于大部分sed  
gsed &#39;s/scarlet|ruby|puce/red/g&#39; #只适用于GNU的sed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;颠倒行序（使末行变首行，首行变末行） （类似tac）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#HHsed的特性（或者是Bug）会导致空行被删除  
sed &#39;1!G;h;$!d&#39; #方法一  
sed -n &#39;1!G; h; $p&#39; #方法二  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;反序输出每一行（类似rev）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/n/!G;s/(.)(.*n)/&amp;amp;21/;//D;s/.//&#39; /*这里似乎有点问题*/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;如果某行以反斜线结尾，则将下一行接在它的后面&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e :a -e &#39;/$/N; s/n//; ta&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;如果某行以等号开头，&lt;br /&gt;
则将它接在上一行的行尾，并将等号用一个空格来替换&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e :a -e &#39;$!N; s/n=/ /; ta&#39; -e &#39;P;D&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;给数值字符串加逗点，如将”1234567″变为”1,234,567″&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gsed &#39;:a; s/B[0-9]{3}&amp;gt;/,&amp;amp;/;ta&#39; #GNU sed  
sed -e :a -e &#39;s/(.*[0-9]([0-9]{3})/1,2/;ta&#39; #其它sed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;给带小数点和负号的数字加逗点（GNU sed）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gsed &#39;:a;s/(^|[^0-9])([0-9]+)([0-9]{3}/12,3/g;ta&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;每隔五行加入一个空行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gsed &#39;0~5G&#39; #只适用于GNU sed  
sed &#39;n;n;n;n;G&#39; #其它sed  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-选择输出特定的行&#34;&gt;四、选择输出特定的行&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;输出文件的前十行（与head类似）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 10q  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出文件和第一行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed q  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出文件和末尾10行（与tail类似）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e :a -e &#39;$q; N;11, $D;ba&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出文件的最后两行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;$!N; $!D&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出文件的末行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;$!d&#39; #方法一  
sed -n &#39;$p&#39; #方法二  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出符合正则表达式的行（类似grep）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;/regexp/p&#39; #方法一  
sed &#39;/regexp/!d/ #方法二  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出不符合正则表达式的行（类似grep -v）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;/regexp/!p&#39; #方法一，其实现与上面的描述是一致的  
sed &#39;/regexp/d&#39; #方法二，这样的语法更简单  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出某一正则表达式之前的一行，但不输出含有该正则表达式的行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;/regexp/{g;1!p;};h&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出某一正则表达式之后的一行，但不输出含有该正则表达式的行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n&#39;/regexp/{n;p;}&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出某一正则表达式之前和之后的一行，以及该正则表达式出现的行的行号（与”grep&lt;br /&gt;
-A1 -B1″）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n -e &#39;/regexp/{=;x;l!p;g;$!N;p;D;}&#39; -e h  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提取含AAA和BBB和CCC（任意顺序）的行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/AAA/!d; /BBB/!d; /CCC/!d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提取含AAA和BBB和CCC（按该顺序）的行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/AAA.*BBB.*CCC/!d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提取含AAA或BBB或CCC的行（类似于egrep）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e &#39;/AAA/b&#39; -e &#39;/BBB/b&#39; -e&#39;/CCC/b&#39; -e d #适用于大部分sed  
gsed &#39;/AAA|BBB|CCC/!d&#39; #只适用于GNU sed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出含有AAA的段落（空行分隔段落）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#以下脚本在HHsed v1.5 中要在&#39;x;&#39;后加上&#39;G;&#39;  
sed -e &#39;/./{H;$!d;}&#39; -e &#39;x; /AAA/!d;&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出含AAA和BBB和CCC（任意顺序）的段落&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e &#39;/./{H; $!d;}&#39; -e &#39;x;/AAA/!d; /BBB/!d; /CCC/!d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出含AAA或BBB或CCC的段落&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e &#39;/./{H;$!d;}&#39; -e &#39;x;/AAA/b&#39; -e &#39;/BBB/b&#39; -e &#39;/CCC/b&#39; -e d  
gsed &#39;/./{H;$!d;};x;/AAA|BBB|CCC/b;d&#39; #只适用于GNU sed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出长度不小于65个字符的行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;/^.{65}/p&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出长度小于65个字符的行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;/^.{65}/!p&#39; #方法一，其实现与上面的描述是一致的  
sed &#39;/^.{65}/d&#39; #方法二，这样的语法更简单  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出从给定正则表达式到文件末尾的部分&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;/regexp/,$p&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出指定行号的部分（如输出8-12行，包括本身）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;8, 12p&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出第52行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;52p&#39; #方法一  
sed &#39;52!d&#39; #方法二  
sed &#39;52q;d&#39; #方法三（在文件较大时效率更高）  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;从第三行开始，每七行输出一次&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gsed -n &#39;3~7p&#39; #只适用于GNU sed  
sed -n &#39;3,${p;n;n;n;n;n;n;} #适用于其它sed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出两个正则表达式之间的部分（包含本身）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &amp;quot;/regexp1/,/regexp2/p&#39; #大小写敏感  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;五-选择性删除特定行&#34;&gt;五、选择性删除特定行&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;输出除两正则表达式之间部分之外的全部&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/regexp1/,/regexp2/d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除重复、连续的行（类似uniq）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#一系列重复的行中的第一行将被保留，其余的被删除  
sed &#39;$!N; /^(.*)n1$/!P; D&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除重复、不连续的行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#注意不要造成缓冲区溢出，否则使用GNU sed  
sed -n &#39;G; s/n/&amp;amp;&amp;amp;/; /^([ -~]*n).*n1/d; s/n//; h; P&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除文件的前十行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;1, 10d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除文件的末行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;$d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除文件的最后两行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;N; $!P;$!D;$d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除文件的最后10行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e :a -e &#39;$d;N;2,10ba&#39; -e &#39;P;D&#39; #方法一  
sed -n -e :a -e &#39;1, 10!{P;N;D;};N;ba&#39; #方法二  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;每8行删除一次&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gsed &#39;0~8d&#39; #只适用于GNU sed  
sed &#39;n;n;n;n;n;n;n;d;&#39; #适用于其它sed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除文件中连续的空行（只保留一个空行），包括开头和结尾 （类似cat&lt;br /&gt;
-s）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/./,/^$/!d&#39; #方法一，文件开头无空行，结尾保留一个空行  
sed &#39;/^$/N;/n$/D&#39; #方法二，文件开头允许一个空行，结尾无空行  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除所有连续的空行，除了前两个之外&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/^$/N;/n$/N;//D&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除文首所有的空行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/./,$!d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除文末所有空行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e :a -e &#39;/^n*$/{$d;N;ba&#39; -e &#39;}&#39; #适用于所有sed  
sed -e :a -e &#39;/^n*$/N;/n$/ba&#39; #同上，但不包括gsed 3.02*  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除每一段落的最后一行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;/^$/{p;h;};/./{x;/./p;}&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;六-特殊用法&#34;&gt;六、特殊用法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;去除man文档中的特殊字符（char，backspace）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#如果你使用Unix System V 或者 bash shell，&#39;echo&#39;命令需要一个&#39;-e&#39;参数  
sed &amp;quot;s/.`echo b`//g&amp;quot; #Unix 环境下双引号是必需的  
sed &#39;s/.^H//g&#39; #在bash/tcsh, 按Ctrl+V 然后按Ctrl+H  
sed &#39;s/.x08//g&#39; #sed v1.5的十六进制表达式  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;获取Usenet/e-mail的头信息&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/^$/q&#39; #删除第一个空行后的所有行  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;获取Subject头信息，但是要删除原始的”Subject:”部分&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/^Subject: */!d; s///;q&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;获取返回地址头信息&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/^Reply-To:/q; /^From:/h; /./d;g;q&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;为每一行行首添加一个尖括号和一个空格（引用）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/^ /&amp;gt; /&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除行首的尖括号和空格（去除引用）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/^&amp;gt; //&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;去除大部分HTML标签（适用于多行标签）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e :a -e &#39;s/&amp;lt;[^&amp;gt;]*&amp;gt;//g;/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提取多部分的UU编码的二进制文件，删除不必要的头信息，只留下UU编码的部分&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#传送给sed的文件必须按适当的顺序  
#版本一可以在命令行下输入  
#版本二可以写成可执行的Unix脚本  
sed &#39;/^end/,/^begin/d&#39; file1 file2 ... fileX | uudecode #版本一  
sed &#39;/^end/,/^begin/d&#39; &amp;quot;$@&amp;quot; | uudecode #版本二  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;七-典型用法&#34;&gt;七、典型用法&lt;/h2&gt;

&lt;p&gt;sed接受一个或多个命令并按顺序对每一行输入执行全部这些命令。当所有的命令都对第一行执行以后，这一行被输出，然后开始对第二行进行处理，如此循环。前面的例子假定输入来自标准输入设备（如控制台，一般是通过管道的输入）。如果输入不来自stdin，可以在命令行中添加一个或多个文件名。输出将被送到标准输出设备。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat filename | sed &#39;10q&#39; #使用管道输入  
sed &#39;10q&#39; filename #同样的效果，不过免去了使用cat  
sed &#39;10q&#39; filename &amp;gt; newfile #重定向输出到磁盘  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多语法讲解，包括用包含编辑命令的文件来代替命令行输入，请参阅&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;《sed&amp;amp;awk，2nd Edition》by Dale Dougherty &amp;amp; Arnold Robbins(O’Reilly,&lt;br /&gt;
1997; &lt;a href=&#34;http://www.ora.com)&#34; target=&#34;_blank&#34;&gt;http://www.ora.com)&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;《UNIX Text Processing》by Dale Dougherty &amp;amp; Tim O’reilly(Hayden&lt;br /&gt;
Books, 1987)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者参考Mike Arst写的教程。&lt;/p&gt;

&lt;p&gt;要想发掘出sed的全部力量，你必须懂得”正则表达式”。关于正则表达式，请参阅：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;《Mastering Regular Expressions》 by Jeffrey Freidl (O’Reilly, 1997)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unix系统中的man手册也会有所帮助（试试”man sed”，”man regexp”，&lt;br /&gt;
或者看看”man&lt;br /&gt;
ed”中关于正则表达式的部分），不过man手册是出了名的难懂。它并不是用来教那些sed和正则表达式的初学者的，它是一个写给那些已经掌握了这些工具的人的手册。&lt;/p&gt;

&lt;h2 id=&#34;八-引号的语法&#34;&gt;八、引号的语法&lt;/h2&gt;

&lt;p&gt;以上的例子使用单引号而不是双引号来容纳编辑命令，因为sed通常用于Unix平台。单引号可以防止Unix&lt;br /&gt;
shell对’\$”`’这样的字符进行解释和展开，如果它们被包含在双引号中，那么这些就会发生。使用csh或其衍生而来的shell的人，即使是在单引号中，还需要把’!’前加上反斜线才能正确的运行上面的例子。DOS版本的sed总是要求用双引号而不是单引号来包含编辑命令。&lt;/p&gt;

&lt;h2 id=&#34;九-在sed脚本中使用-t&#34;&gt;九、在sed脚本中使用’t’&lt;/h2&gt;

&lt;p&gt;为了文档的清晰，我们使用了表达式’t’来代表一个脚本中的制表符。但是多数sed版本不识别’t’这个缩写，因此，在编写这些脚本时你要按TAB键。’t’这个缩写是为awk,perl,HHsed,sedmod,GNU&lt;br /&gt;
sed v3.02.80的正则表达式所支持的元字符。&lt;/p&gt;

&lt;h2 id=&#34;十-sed的版本&#34;&gt;十、sed的版本&lt;/h2&gt;

&lt;p&gt;sed的版本之间确不太一样，可能在语法上有些许的不同。具体说来，很多版本不支持编辑命令中的标签（:name）或分支符（b，t），除了尾部的这些元素。我们使用了可以为大多数sed用户移植的语法，尽管GNU版本的sed允许更简洁的语法。\&lt;br /&gt;
当读者看到一个相当长的命令像：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e &#39;/AAA/b&#39; -e &#39;/BBB/b&#39; -e &#39;/CCC/b&#39; -e d  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道GNU可以让你把它减缩为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;/AAA/b;/BBB/b;/CCC/b;d&#39; #或者更简单  
sed &#39;/AAA|BBB|CCC/b;d&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是很令人高兴的。&lt;/p&gt;

&lt;p&gt;另外，记住：很多sed的版本接受这样的命令像”/one/ s/RE1/RE2/”,&lt;br /&gt;
有一些不允许”/one/!&lt;br /&gt;
s/RE1/RE2/”这样在’s’前包含空格的命令。这时，在输入命令的时候要去除空格。&lt;/p&gt;

&lt;h2 id=&#34;十一-优化速度&#34;&gt;十一、优化速度&lt;/h2&gt;

&lt;p&gt;当执行速度需要优化（由于输入文件很大或者处理器、CPU较慢）时，如果的替换命令前给出查找命令，替换操作会变得更快。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/foo/bar/g&#39; filename #标准的替换操作  
sed &#39;/foo/ s/foo/bar/g&#39; filename #这样执行起来更快  
sed &#39;/foo/ s//bar/g&#39; filename #sed速记语法  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在进行行的选择和删除操作时，如果你操作的行只是包含在文件前面的一部分时，在脚本中加入一个退出命令’q’会大幅缩减处理大文件的时间。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n &#39;45,50p&#39; filename #输出45-50行  
sed -n &#39;51q; 45,50p&#39; filename #同样的功能，但执行得更快  
文本分隔：－－－－－－  
# 在每一行后面增加一空行。　sed G  
# 在每一行后面增加两行空行。　sed &amp;quot;G;G&amp;quot;  
# 删除文本中所有的空行。sed &amp;quot;/^$/d&amp;quot;  
# 将原来的所有空行删除并在每一行后面增加一空行。sed &amp;quot;/^$/d;G&amp;quot;   这样在输出的文本中每一行后面将有且只有一空行。  
# 将第一个脚本所产生的所有空行删除(即删除所有偶数行)。　sed &amp;quot;n;d&amp;quot;  在sed中用n表示奇数行，用p表示偶数行。  
# 在每5行后增加一空白行 (在第5，10，15，20，等行后增加一空白行)。sed &amp;quot;n;n;n;n;G;&amp;quot;  

# 在包含“regex”的行之前插入一空行。　sed &amp;quot;/regex/{x;p;x;}&amp;quot;  #插入两个空行sed &amp;quot;/regex/{x;p;p;x;}&amp;quot;  
# 在包含“regex”的行之后插入一空行。　sed &amp;quot;/regex/G&amp;quot;       　#插入两个空行sed &amp;quot;/regex/{G;G;}&amp;quot;  
# 在包含“regex”的行之前和之后各插入一空行。　sed &amp;quot;/regex/{x;p;x;G;}&amp;quot;   #各插入两个空行sed &amp;quot;/regex/{x;p;p;x;G;G;}&amp;quot;  

编号：－－－－－－  
# 为文件中的每一行进行编号(简单的左对齐方式)。使用“制表符”对齐边缘。　sed = filename | sed &amp;quot;N;s/\n/\t/&amp;quot;  
# 对文件中的所有行编号(行号在左，文字右端对齐)。　sed = filename | sed &amp;quot;N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /&amp;quot;  
# 对文件中的所有行编号，不含空白行。　sed &amp;quot;/./=&amp;quot; filename | sed &amp;quot;/./N; s/\n/ /&amp;quot;  
# 对文件中的所有行编号，并加上&amp;quot;:&amp;quot; ，含空白行。 sed &amp;quot;/./=&amp;quot; filename |sed &amp;quot;/./N; s/\n/:/&amp;quot;  
# 计算行数 (模拟 &amp;quot;wc -l&amp;quot;)。　sed -n &amp;quot;$=&amp;quot;  

文本转换和替代：－－－－－－  

# 替换每一行中的“foo”都换成“bar”。          sed &amp;quot;s/foo/bar/g&amp;quot;  
# 替换每一行中的第一个“foo”字串为“bar”。　　sed &amp;quot;s/foo/bar/&amp;quot;  
# 替换每一行中的第四个“foo”字串为“bar”。    sed &amp;quot;s/foo/bar/4&amp;quot;  
# 替换倒数第二个“foo”字串为“bar”。          sed &amp;quot;s/\(.*\)foo\(.*foo\)/\1bar\2/&amp;quot;  
# 替换最后一个“foo” 字串为“bar”。           sed &amp;quot;s/\(.*\)foo/\1bar/&amp;quot;  
# 只在行中出现字串“baz”的情况下将“foo”替换成“bar”。　sed &amp;quot;/baz/s/foo/bar/g&amp;quot;  
# 行中未出现字串“baz”的情况下将“foo”替换成“bar”。　sed &amp;quot;/baz/!s/foo/bar/g&amp;quot;  

# 将文本中第1-3行中第三个&amp;quot;a&amp;quot;替换为&amp;quot;b&amp;quot;。　　   sed &amp;quot;1,3s/a/b/3&amp;quot;  
# 将文本中第3-5行中第一、三个&amp;quot;a&amp;quot;替换为&amp;quot;b&amp;quot;。   sed -e &amp;quot;3,5s/a/b/1&amp;quot; -e &amp;quot;3,5s/a/b/3&amp;quot;  
# 除了第四行外将所有行的第二个&amp;quot;a&amp;quot;替换为&amp;quot;b&amp;quot;。  sed &amp;quot;4!s/a/b/2&amp;quot;  

# 不管是“scarlet”“ruby”还是“puce”，一律换成“red”。sed &amp;quot;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g&amp;quot;  

# 将每一行前导的“空白字符”(空格，制表符)删除使之左对齐。　sed &amp;quot;s/^[ \t]*//&amp;quot;  
# 将每一行拖尾的“空白字符”(空格，制表符)删除。　sed &amp;quot;s/[ \t]*$//&amp;quot;  
# 将每一行中的前导和拖尾的空白字符删除。　sed &amp;quot;s/^[ \t]*//;s/[ \t]*$//&amp;quot;  
# 在行首插入字符(含空格)。           sed &amp;quot;s/^/bathome/&amp;quot;  
# 在行首插入“header”，在行尾插入“footer”。 sed &#39;s/^\(.*\)$/header\1 footer/&#39;  

# 在每一行开头处插入5个空格(使全文向右移动5个字符的位置)。　sed &amp;quot;s/^/     /&amp;quot;  
# 以79个字符为宽度，将所有文本右对齐。　sed -e :a -e &amp;quot;s/^.\{1,78\}$/ &amp;amp;/;ta&amp;quot;    # 78个字符外加最后的一个空格  
# 以79个字符为宽度，使所有文本居中。在方法1中，为了让文本居中每一行的前头和后头都填充了空格。 在方法2中，在居中文本的过程中只在文本的前面填充空格，并且最终这些空格将有一半会被删除。此外每一行的后头并未填充空格。  
sed  -e :a -e &amp;quot;s/^.\{1,77\}$/ &amp;amp; /;ta&amp;quot;                     # 方法1  
sed  -e :a -e &amp;quot;s/^.\{1,77\}$/ &amp;amp;/;ta&amp;quot; -e &amp;quot;s/\( *\)\1/\1/&amp;quot;  # 方法2  

# 所有以http://开头的行都会被替换成它自已加192.168.0.1，变成http://192.168.0.1localhost。sed &amp;quot;s/^http\:\/\//&amp;amp;192.168.0.1/&amp;quot;   &amp;amp;符号表示替换换字符串中被找到的部份。  
# love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。  sed -n &amp;quot;s/\(love\)able/\1rs/p&amp;quot;  
# 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。 sed &amp;quot;s#10#100#g&amp;quot;  
# 对于模板test和west之间的行，每行的末尾用字符串sed test替换。 sed &amp;quot;/test/,/check/s/$/sed test/&amp;quot;  
# 用&amp;quot;pause&amp;quot;来取代第5－－－－－－8行所有的内容(非每行)。 sed &amp;quot;5,8c\pause&amp;quot;  c开关是sed中用用户输入内容来取代原本内容的，其后紧跟&amp;quot;\&amp;quot;，用这种方法同样可以将指定行替换为空行(并不是严格意义上的空行，至少有一个空格)  

# 倒置所有行，第一行成为最后一行，依次类推(模拟“tac”)。由于某些原因，使用下面命令时HHsed v1.5会将文件中的空行删除  
sed &amp;quot;1!G;h;$!d&amp;quot;               # 方法1  
sed -n &amp;quot;1!G;h;$p&amp;quot;             # 方法2  

# 将行中的字符逆序排列，第一个字成为最后一字，……(模拟“rev”)。　sed &amp;quot;/\n/!G;s/\(.\)\(.*\n\)/&amp;amp;\2\1/;//D;s/.//&amp;quot;  
# 将文件中包含的字符串(本例为“they”)中的4个字按4132顺序变换(变为yteh)。sed &amp;quot;s/\(t\)\(h\)\(e\)\(y\)/\4\1\3\2/&amp;quot;  

# 将每两行连接成一行(类似“paste”)。　sed &amp;quot;$!N;s/\n/ /&amp;quot;  
# 如果当前行以反斜杠“\”结束，则将下一行并到当前行末尾并去掉原来行尾的反斜杠。　sed -e :a -e &amp;quot;/\\$/N; s/\\\n//; ta&amp;quot;  
# 如果当前行以等号开头，将当前行并到上一行末尾并以单个空格代替原来行头的“=”。　sed -e :a -e &amp;quot;$!N;s/\n=/ /;ta&amp;quot; -e &amp;quot;P;D&amp;quot;  

# 为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567”。sed -e :a -e &amp;quot;s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta&amp;quot;  # 其他sed  
# 为带有小数点和负号的数值增加逗号分隔符(GNU sed)gsed -r &amp;quot;:a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta&amp;quot;  

选择性地显示特定行：－－－－－－  

# 只显示匹配正则表达式的行(模拟“grep”)。sed -n &amp;quot;/regexp/p&amp;quot;  # 方法1　　sed &amp;quot;/regexp/!d&amp;quot; # 方法2  
# 只显示不包含正则表达式的行。sed -n &amp;quot;/regexp/!p&amp;quot; # 方法1，与前面的命令相对应。sed &amp;quot;/regexp/d&amp;quot;  # 方法2，类似的语法  
# 显示匹配或发生的行。sed -n &amp;quot;s/^test/mytest/p&amp;quot;  -n开关是表示输出由编辑指令控制，p开关是有条件显示开关。  

# 显示从包含正则表达式的行开始到最后一行结束。　sed -n &amp;quot;/regexp/,$p&amp;quot;  
# 显示通篇文档，除了两个正则表达式之间的内容。　sed &amp;quot;/start/,/end/d&amp;quot;　  

# 显示两个正则表达式之间的文本(包含)。　sed -n &amp;quot;/start/,/end/p&amp;quot;   # 区分大小写方式  
# 显示从第五行开始到第一个包含以test开始的行之间的所有行。sed -n &amp;quot;5,/^test/p&amp;quot;  

# 查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行。　sed -n &amp;quot;/regexp/{g;1!p;};h&amp;quot;  
# 查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行。　sed -n &amp;quot;/regexp/{n;p;}&amp;quot;  
# 显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所在行的行号 (类似“grep -A1 -B1”)。　sed -n -e &amp;quot;/regexp/{=;x;1!p;g;$!N;p;D;}&amp;quot; -e h  

# 显示既包“AAA”“BBB”“CCC”的行(任意次序)。　sed &amp;quot;/AAA/!d; /BBB/!d; /CCC/!d&amp;quot;  # 字串的次序不影响结果  
# 显示包含“AAA”、“BBB”和“CCC”的行(固定次序)。　sed &amp;quot;/AAA.*BBB.*CCC/!d&amp;quot;  
# 显示包含“AAA”“BBB”“CCC”任一字符串的行 (模拟“egrep”)　sed -e &amp;quot;/AAA/b&amp;quot; -e &amp;quot;/BBB/b&amp;quot; -e &amp;quot;/CCC/b&amp;quot; -e d    # 多数sed  

# 显示包含“AAA”的段落 (段落间以空行分隔)HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样。　sed -e &amp;quot;/./{H;$!d;}&amp;quot; -e &amp;quot;x;/AAA/!d;&amp;quot;  
# 显示包含“AAA”“BBB”和“CCC”三个字串的段落 (任意次序)。　sed -e &amp;quot;/./{H;$!d;}&amp;quot; -e &amp;quot;x;/AAA/!d;/BBB/!d;/CCC/!d&amp;quot;  
# 显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 (任意次序)。sed -e &amp;quot;/./{H;$!d;}&amp;quot; -e &amp;quot;x;/AAA/b&amp;quot; -e &amp;quot;/BBB/b&amp;quot; -e &amp;quot;/CCC/b&amp;quot; -e d  

# 显示指定行号范围(从第8至第12行，含8和12行)。sed -n &amp;quot;8,12p&amp;quot; # 方法1　sed &amp;quot;8,12!d&amp;quot;　# 方法2  
# 显示第52行。sed -n &amp;quot;52p&amp;quot;  # 方法1　　　sed &amp;quot;52!d&amp;quot; # 方法2　　　sed &amp;quot;52q;d&amp;quot; # 方法3, 处理大文件时更有效率  
# 从第3行开始，每7行显示一次   sed -n &amp;quot;3,${p;n;n;n;n;n;n;}&amp;quot;  
# 不显示文本中前10行。　　sed 1,10d  
# 显示文本的奇数行(含空行)。sed -n -e &amp;quot;p&amp;quot; -e &amp;quot;n&amp;quot;  在sed中用n表示奇数行，用p表示偶数行。  
# 显示文本的偶数行(含空行)。sed -n -e &amp;quot;n&amp;quot; -e &amp;quot;p&amp;quot;  
# 显示3的倍数行。           sed -n &amp;quot;n;n;p&amp;quot; 先用n开关将输出定向到编辑指令，然后输入法3-1个n;最后用显示开关p结尾，也就时说3前的数字的倍数行不显示，只显示3的倍数行。  
# 显示文件中的前10行 (模拟“head”的行为)。　sed 10q  
# 显示文件中的第一行 (模拟“head -1”命令)。　sed q  
# 显示文件中的最后10行 (模拟“tail”)。　sed -e :a -e &amp;quot;$q;N;11,$D;ba&amp;quot;  
# 显示文件中的最后2行(模拟“tail -2”命令)。　sed &amp;quot;$!N;$!D&amp;quot;  
# 显示文件中的最后一行(模拟“tail -1”)。sed &amp;quot;$!d&amp;quot;   # 方法1　sed -n &amp;quot;$p&amp;quot; # 方法2  
# 显示文件中的倒数第二行  
sed -e &amp;quot;$!{h;d;}&amp;quot; -e x              # 当文件中只有一行时，输入空行  
sed -e &amp;quot;1{$q;}&amp;quot; -e &amp;quot;$!{h;d;}&amp;quot; -e x  # 当文件中只有一行时，显示该行  
sed -e &amp;quot;1{$d;}&amp;quot; -e &amp;quot;$!{h;d;}&amp;quot; -e x  # 当文件中只有一行时，不输出  

# 显示文本含有数字的行。sed -n &amp;quot;/[0-9]/p&amp;quot;  
# 显示文本不含有数字的行。sed &amp;quot;/[0-9]/d&amp;quot;  

# 显示包含65个或以上字符的行。　sed -n &amp;quot;/^.\{65\}/p&amp;quot;  
# 显示包含65个以下字符的行。sed -n &amp;quot;/^.\{65\}/!p&amp;quot;  # 方法1，与上面的脚本相对应。　sed &amp;quot;/^.\{65\}/d&amp;quot; # 方法2，更简便一点的方法。  

选择性地删除特定行：－－－－－－  

# 删除匹配式样的行。　sed &amp;quot;/pattern/d&amp;quot;     # 删除含pattern的行。当然pattern可以换成任何有效的正则表达式  
# 删除匹配式样以外的行。　sed &amp;quot;/pattern/!d&amp;quot;  

# 删除文件中相邻的重复行(模拟“uniq”)只保留重复行中的第一行，其他行删除。　sed &amp;quot;$!N; /^\(.*\)\n\1$/!P; D&amp;quot;  
# 删除文件中的重复行，不管有无相邻。　sed -n &amp;quot;G; s/\n/&amp;amp;&amp;amp;/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P&amp;quot;  
# 删除除重复行外的所有行(模拟“uniq -d”)。　sed &amp;quot;$!N; s/^\(.*\)\n\1$/\1/; t; D&amp;quot;  

# 删除文件中开头的10行。　sed &amp;quot;1,10d&amp;quot;  
# 删除文件中的最后一行。　sed &amp;quot;$d&amp;quot;  
# 删除example文件的第二行。 sed &amp;quot;2d&amp;quot;  
# 删除文件中的最后两行。　sed &amp;quot;N;$!P;$!D;$d&amp;quot;  
# 删除文件中的最后10行。sed -e :a -e &amp;quot;$d;N;2,10ba&amp;quot; -e &amp;quot;P;D&amp;quot;   # 方法1　　sed -n -e :a -e &amp;quot;1,10!{P;N;D;};N;ba&amp;quot;  # 方法2  
# 删除example文件的第二行到末尾所有行。 sed &amp;quot;2,$d&amp;quot; example  
# 删除文件中第2行到第一个&amp;quot;write&amp;quot;所在行(含该行)之间的所有内容。 sed &amp;quot;2,/write/d&amp;quot;  
# 删除8的倍数行。sed &amp;quot;n;n;n;n;n;n;n;d;&amp;quot;  

# 删除文件中的所有空行。sed &amp;quot;/^$/d&amp;quot;  # 方法1　　sed &amp;quot;/./!d&amp;quot;　# 方法2  
# 只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。(模拟“cat -s”)  
sed &amp;quot;/./,/^$/!d&amp;quot;        #方法1，删除文件顶部的空行，允许尾部保留一空行  
sed &amp;quot;/^$/N;/\n$/D&amp;quot;      #方法2，允许顶部保留一空行，尾部不留空行  
# 只保留多个相邻空行的前两行。　sed &amp;quot;/^$/N;/\n$/N;//D&amp;quot;  
# 删除文件顶部的所有空行。　sed &amp;quot;/./,$!d&amp;quot;  
# 删除文件尾部的所有空行。　　sed -e :a -e &amp;quot;/^\n*$/{$d;N;ba&amp;quot; -e &amp;quot;}&amp;quot;  # 对所有sed有效  

# 删除每个段落的最后一行。　sed -n &amp;quot;/^$/{p;h;};/./{x;/./p;}&amp;quot;  

# 删除文本所有行首的四个字符。sed &amp;quot;s/^....//&amp;quot;  
# 删除文本所有行尾的四个字符。sed &amp;quot;s/....$//&amp;quot;  

多点编辑：e命令 －－－－－－  
# (-e)选项允许在同一行里执行多条命令。 sed -e &amp;quot;1,5d&amp;quot; -e &amp;quot;s/test/check/&amp;quot;  
# 给sed表达式赋值。  sed --expression=&amp;quot;s/test/check/&amp;quot; --expression=&amp;quot;/love/d&amp;quot; 一个比-e更好的命令是--expression。  

从文件读入：r命令 －－－－－－  
#　file里的内容被读进来，显示在与test匹配的行后面。 sed &amp;quot;/test/r file&amp;quot; 如果匹配多行，则file的内容将显示在所有匹配行的下面。  

写入文件：w命令 －－－－－－  
# 在example中所有包含test的行都被写入file里。 sed -n &amp;quot;/test/w file&amp;quot;  

追加命令：a命令 －－－－－－  
# 在所有包含test行的下一行插入“newline”行。sed &amp;quot;/test/a\newline&amp;quot;  
# 在文本中每一行下插入“newline”行。        sed &amp;quot;a\newline&amp;quot;  

插入：i命令 －－－－－－  
# 在所有包含test行的上一行插入“newline”行。sed &amp;quot;/test/i\newline&amp;quot;  
# 在文本中每一行上面插入“newline”行。      sed &amp;quot;i\newline&amp;quot;  

下一个：n命令 －－－－－－  
# 如果test被匹配，则将下一行中的aa替换为bb，并打印该行。 sed &amp;quot;/test/{ n; s/aa/bb/; }&amp;quot;　注意：如果连续有三行包含test和aa,只有第二行的aa会被替换。  

变形：y命令－－－－－－  
将文本中的字母换成大写。sed &amp;quot;y/abcdefg/ABCDEFG/&amp;quot; y开关是sed中真正的变形开关，同理可以将文本中的数字全变成大写数字。  
# 把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。 sed &amp;quot;1,10y/abcde/ABCDE/&amp;quot;  

退出：q命令 －－－－－－  
# 打印完第10行后，退出sed。 sed &amp;quot;10q&amp;quot;  

保持和获取：h命令和G命令 －－－－－－  
# 在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保 持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中 的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。 sed -e &amp;quot;/test/h&amp;quot; -e &amp;quot;$G  

保持和互换：h命令和x命令 －－－－－－  
# 互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。  sed -e &amp;quot;/test/h&amp;quot; -e &amp;quot;/check/x&amp;quot; example -----  

特殊应用：－－－－－－  
# 移除手册页(man page)中的nroff标记。在Unix System V或bash shell下使用&amp;quot;echo&amp;quot;命令时可能需要加上 -e 选项。  
sed &amp;quot;s/.^H//g&amp;quot;             # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H  
sed &amp;quot;s/.\x08//g&amp;quot;           # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法  
# 提取新闻组或 e-mail 的邮件头。　sed &amp;quot;/^$/q&amp;quot;                # 删除第一行空行后的所有内容  
# 提取新闻组或 e-mail 的正文部分。　sed &amp;quot;1,/^$/d&amp;quot;              # 删除第一行空行之前的所有内容  
# 从邮件头提取“Subject”(标题栏字段)，并移除开头的“Subject:”字样。　sed &amp;quot;/^Subject: */!d; s///;q&amp;quot;  
# 从邮件头获得回复地址。　sed &amp;quot;/^Reply-To:/q; /^From:/h; /./d;g;q&amp;quot;  
# 获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮地址的部分剃除。(见上一脚本)。　sed &amp;quot;s/ *(.*)//; s/&amp;gt;.*//; s/.*[:&amp;lt;] *//&amp;quot;  
# 在每一行开头加上一个尖括号和空格(引用信息)。　sed &amp;quot;s/^/&amp;gt; /&amp;quot;  
# 将每一行开头处的尖括号和空格删除(解除引用)。　sed &amp;quot;s/^&amp;gt; //&amp;quot;  
# 移除大部分的HTML标签(包括跨行标签)。　sed -e :a -e &amp;quot;s/&amp;lt;[^&amp;gt;[]*&amp;gt;//g;/&amp;lt;/N;//ba&amp;quot;  
# 将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入；第二种版本则可以放入一个带执行权限的shell脚本中。(由Rahul Dhesi的一个脚本修改而来。)  
sed &amp;quot;/^end/,/^begin/d&amp;quot; file1 file2 ... fileX | uudecode   # vers. 1  
sed &amp;quot;/^end/,/^begin/d&amp;quot; &amp;quot;$@&amp;quot; | uudecode                    # vers. 2  
# 将文件中的段落以字母顺序排序。段落间以(一行或多行)空行分隔。sed &amp;quot;/./{H;d;};x;s/\n/={NL}=/g&amp;quot; file | sort | sed &amp;quot;1s/={NL}=//;s/={NL}=/\n/g&amp;quot;  
# 分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件命名为与原来相同的名字(只是扩展名不同)。(DOS环境：“dir /b”显示不带路径的文件名)。  
echo @echo off &amp;gt;zipup.bat  
dir /b *.txt | sed &amp;quot;s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/&amp;quot; &amp;gt;&amp;gt;zipup.bat  

使用SED：Sed接受一个或多个编辑命令，并且每读入一行后就依次应用这些命令。当读入第一行输入后，sed对其应用所有的命令，然后将结果输出。接着再读入第二行输入，对其应用所有的命令……并重复这个过程。上一个例子中sed由标准输入设备(即命令解释器，通常是以管道输入的形式)获得输入。在命令行给出一个或多个文件名作为参数时，这些文件取代标准输入设备成为sed的输入。sed的输出将被送到标准输出(显示器)。因此：  

cat filename | sed &amp;quot;10q&amp;quot;         # 使用管道输入  
sed &amp;quot;10q&amp;quot; filename               # 同样效果，但不使用管道输入  
sed &amp;quot;10q&amp;quot; filename &amp;gt; newfile     # 将输出转移(重定向)到磁盘上  

　　括号语法：前面的例子对sed命令基本上都使用单引号(&amp;quot;...&amp;quot;)而非双引号(&amp;quot;...&amp;quot;)这是因为sed通常是在Unix平台上使用。单引号下，Unix的shell(命令解释器)不会对美元符($)和后引号(`...`)进行解释和执行。而在双引号下美元符会被展开为变量或参数的值，后引号中的命令被执行并以输出的结果代替后引号中的内容。而在“csh”及其衍生的shell中使用感叹号(!)时需要在其前面加上转义用的反斜杠(就像这样：\!)以保证上面所使用的例子能正常运行(包括使用单引号的情况下)。DOS版本的Sed则一律使用双引号(&amp;quot;...&amp;quot;)而不是引号来圈起命令。  

　　&amp;quot;\t&amp;quot;的用法：为了使本文保持行文简洁，我们在脚本中使用&amp;quot;\t&amp;quot;来表示一个制表符。但是现在大部分版本的sed还不能识别&amp;quot;\t&amp;quot;的简写方式，因此当在命令行中为脚本输入制表符时，你应该直接按TAB键来输入制表符而不是输入&amp;quot;\t&amp;quot;。下列的工具软件都支持&amp;quot;\t&amp;quot;做为一个正则表达式的字元来表示制表符：awk、perl、HHsed、sedmod以及GNUsed v3.02.80。  
脚本  
Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。  

小技巧  
在sed的命令行中引用shell变量时要使用双引号，而不是通常所用的单引号。下面是一个根据name变量的内容来删除named.conf文件中zone段的脚本：  

name=&amp;quot;zone\ &amp;quot;localhost&amp;quot;&amp;quot;sed &amp;quot;/$name/,/};/d&amp;quot; named.conf  

###############################################################################################################  

1. Sed简介  
sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”(pattern space)，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed 3.02。  

2. 定址  
可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围(包括行数表示的那两行)。如1,3表示1,2,3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定。  

3. Sed命令  
调用sed命令有两种形式：  
sed [options] &amp;quot;command&amp;quot; file(s)  
sed [options] -f scriptfile file(s)  

a\　　在当前行后面加入一行文本。  
b　　lable　　分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。  
c\　　用新的文本改变本行的文本。  
d　　从模板块(Pattern　　space)位置删除行。d开关是表示删除的意思。  
D　　删除模板块的第一行。  
i\　　在当前行上面插入文本。  
h　　拷贝模板块的内容到内存中的缓冲区。  
H　　追加模板块的内容到内存中的缓冲区  
g　　获得内存缓冲区的内容，并替代当前模板块中的文本。  
G　　获得内存缓冲区的内容，并追加到当前模板块文本的后面。  
l　　列表不能打印字符的清单。  
n　　读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。  
N　　追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。  
p　　打印模板块的行。  
P(大写)　　打印模板块的第一行。  
q　　退出Sed。  
r　　file　　从file中读行。  
t　　label　　if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。  
T　　label　　错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。  
w　　file　　写并追加模板块到file末尾。  
W　　file　　写并追加模板块的第一行到file末尾。  
!　　表示后面的命令对所有没有被选定的行发生作用。  
s/re/string　　用string替换正则表达式re。  
=　　打印当前行号码。  
#　　把注释扩展到下一个换行符以前。  

以下的是替换标记  
g　　表示行内全面替换。  
p　　表示打印行。  
w　　表示把行写入一个文件。  
x　　表示互换模板块中的文本和缓冲区中的文本。  
y　　表示把一个字符翻译为另外的字符(但是不用于正则表达式)  

4. 选项  
-e　　command,　　--expression=command　　允许多台编辑。  
-h,　　--help　　打印帮助，并显示bug列表的地址。  
-n,　　--quiet,　　--silent　　取消默认输出。  
-f,　　--filer=script-file　　引导sed脚本文件名。  
-V,　　--version　　打印版本和版权信息。  

5. 元字符集  
^　　锚定行的开始　　如：/^sed/匹配所有以sed开头的行。  
$　　锚定行的结束　　如：/sed$/匹配所有以sed结尾的行。  
$p  最后一行  
.　　匹配一个非换行符的字符　　如：/s.d/匹配s后接一个任意字符，然后是d。  
*　　匹配零或多个字符　　如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。  
[]　　匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。  
[^]　　匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。  
\(..\)　　保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。  
&amp;amp;　　保存搜索字符用来替换其他字符，如s/love/**&amp;amp;**/，love这成**love**。  
\&amp;lt;　　锚定单词的开始，如:/\&amp;lt;love/匹配包含以love开头的单词的行。  
\&amp;gt;　　锚定单词的结束，如/love\&amp;gt;/匹配包含以love结尾的单词的行。  
x\{m\}　　重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。  
x\{m,\}　　重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。  
x\{m,n\}　　重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5--10个o的行。  

6.执行档案内的编辑指令  
当执行的指令太多 , 在命令列上撰写起来十分混乱 , 此时 , 可将这些指令整理储存在档案(譬如档名为 script_file )内 , 用选项 -f script_file , 则让 sed 执行script_file 内的编辑指令。其命令的格示如下 : sed -f script_file 文件档,其中, 执行 script_file 内编辑指令的顺序是由上而下。例如上一节的例子 , 其可改成如下命令: sed -f ysb.scr yel.dat,其中 , ysb.scr 档的内容如下 : 1,10d s/yellow/black/g,另外, 在命令列上可混合使用选项 -e 与 -f , sed 执行指令顺序依然是由命令列的左到右, 如执行至 -f 後档案内的指令 , 则由上而下执行。  

7. 执行多个文件档的编辑  
在 sed 命令列上 , 一次可执行编辑多个文件档 , 它们跟在编辑指令之後。例如 , 替换white.dat、red.dat、black.dat 档内的 &amp;quot;yellow&amp;quot; 字串成 &amp;quot;blue&amp;quot; , 其命令如下: sed -e &#39;s/yellow/blue/g&#39; white.dat red.dat black.dat,上述命令执行时 , sed 依 white.dat、red.dat、black.dat 顺序 , 执行编辑指令 s/yellow/blue/(请参照[section 4.1] ,进行字串的替换.。  

8.执行输出的控制  

在命令列上的选项 -n (解[7]) 表示输出由编辑指令控制。由前章内容得知 ,sed 会 &amp;quot;自动的&amp;quot; 将资料由 pattern space 输送到标准输出档。但藉着选项 -n , 可将 sed 这 &amp;quot;自动的&amp;quot; 的动作改成 &amp;quot;被动的&amp;quot; 由它所执行的编辑指令(解[8])来决定结果是否输出。由上述可知 , 选项 -n 必须与编辑指令一起配合 , 否则无法获得结果。  
例如 ,印出 white.dat 档内含有 &amp;quot;white&amp;quot;  字串的资料行 , 其命令如下: sed -n -e &#39;/white/p&#39; white.dat  
上面命令中 , 选项 -n 与编辑指令 /white/p (参照[section4.6]) 一起配合控制输出。其中 , 选项 -n 将输出控制权移给编辑指;/white/p 将资料行中含有 &amp;quot;white&amp;quot; 字串印出萤幕。  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds5/sed.htm&#34; target=&#34;_blank&#34;&gt;IBM Knowledge Center - sed 命令&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/3fc90059f750&#34; target=&#34;_blank&#34;&gt;sed介绍 - 简书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/304400856e1e&#34; target=&#34;_blank&#34;&gt;Sed and awk 笔记之 sed 篇：简单介绍 - 简书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/9d9a34e2b2dd&#34; target=&#34;_blank&#34;&gt;Linux之Sed工具的使用详解 - 简书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhiyan.de/sed1line/&#34; target=&#34;_blank&#34;&gt;sed一句话技巧 « Zhiyan - 段志岩&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 sed</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-sed1line/</link>
            <pubDate>Tue, 27 Sep 2016 15:57:46 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-sed1line/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://sed.sourceforge.net/sed1line_zh-CN.html&#34; target=&#34;_blank&#34;&gt;http://sed.sourceforge.net/sed1line_zh-CN.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;# 在每一行后面增加一空行&lt;br /&gt;
 sed G&lt;/p&gt;

&lt;p&gt;# 将原来的所有空行删除并在每一行后面增加一空行。&lt;br /&gt;
 # 这样在输出的文本中每一行后面将有且只有一空行。&lt;br /&gt;
 sed &amp;lsquo;/^$/d;G&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 在每一行后面增加两行空行&lt;br /&gt;
 sed &amp;lsquo;G;G&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 将第一个脚本所产生的所有空行删除（即删除所有偶数行）&lt;br /&gt;
 sed &amp;lsquo;n;d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 在匹配式样“regex”的行之前插入一空行&lt;br /&gt;
 sed &amp;lsquo;/regex/{x;p;x;}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 在匹配式样“regex”的行之后插入一空行&lt;br /&gt;
 sed &amp;lsquo;/regex/G&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 在匹配式样“regex”的行之前和之后各插入一空行&lt;br /&gt;
 sed &amp;lsquo;/regex/{x;p;x;G;}&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;编号&#34;&gt;编号：&lt;/h2&gt;

&lt;p&gt;# 为文件中的每一行进行编号（简单的左对齐方式）。这里使用了“制表符”&lt;br /&gt;
 # （tab，见本文末尾关于&amp;rsquo;\t&amp;rsquo;的用法的描述）而不是空格来对齐边缘。&lt;br /&gt;
 sed = filename | sed &amp;lsquo;N;s/\n/\t/&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 对文件中的所有行编号（行号在左，文字右端对齐）。&lt;br /&gt;
&lt;code&gt;sed = filename | sed &#39;N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;# 对文件中的所有行编号，但只显示非空白行的行号。&lt;br /&gt;
 sed &amp;lsquo;/./=&amp;rsquo; filename | sed &amp;lsquo;/./N; s/\n/ /&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 计算行数 （模拟 &amp;ldquo;wc -l&amp;rdquo;）&lt;br /&gt;
 sed -n &amp;lsquo;$=&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;文本转换和替代&#34;&gt;文本转换和替代：&lt;/h2&gt;

&lt;p&gt;# Unix环境：转换DOS的新行符（CR/LF）为Unix格式。&lt;br /&gt;
 sed &amp;rsquo;s/.$//&amp;rsquo;                     # 假设所有行以CR/LF结束&lt;br /&gt;
 sed &amp;rsquo;s/^M$//&amp;rsquo;                    # 在bash/tcsh中，将按Ctrl-M改为按Ctrl-V&lt;br /&gt;
 sed &amp;rsquo;s/\x0D$//&amp;rsquo;                  # ssed、gsed 3.02.80，及更高版本&lt;/p&gt;

&lt;p&gt;# Unix环境：转换Unix的新行符（LF）为DOS格式。&lt;br /&gt;
 sed &amp;ldquo;s/$/&lt;code&gt;echo -e \\\r&lt;/code&gt;/&amp;rdquo;        # 在ksh下所使用的命令&lt;br /&gt;
 sed &amp;rsquo;s/$&amp;lsquo;&amp;ldquo;/&lt;code&gt;echo \\\r&lt;/code&gt;/&amp;rdquo;         # 在bash下所使用的命令&lt;br /&gt;
 sed &amp;ldquo;s/$/&lt;code&gt;echo \\\r&lt;/code&gt;/&amp;rdquo;           # 在zsh下所使用的命令&lt;br /&gt;
 sed &amp;rsquo;s/$/\r/&amp;rsquo;                    # gsed 3.02.80 及更高版本&lt;/p&gt;

&lt;p&gt;# DOS环境：转换Unix新行符（LF）为DOS格式。&lt;br /&gt;
 sed &amp;ldquo;s/$//&amp;rdquo;                      # 方法 1&lt;br /&gt;
 sed -n p                         # 方法 2&lt;/p&gt;

&lt;p&gt;# DOS环境：转换DOS新行符（CR/LF）为Unix格式。&lt;br /&gt;
 # 下面的脚本只对UnxUtils sed 4.0.7 及更高版本有效。要识别UnxUtils版本的&lt;br /&gt;
 #  sed可以通过其特有的“&amp;ndash;text”选项。你可以使用帮助选项（“&amp;ndash;help”）看&lt;br /&gt;
 # 其中有无一个“&amp;ndash;text”项以此来判断所使用的是否是UnxUtils版本。其它DOS&lt;br /&gt;
 # 版本的的sed则无法进行这一转换。但可以用“tr”来实现这一转换。&lt;br /&gt;
 sed &amp;ldquo;s/\r//&amp;rdquo; infile &amp;gt;outfile     # UnxUtils sed v4.0.7 或更高版本&lt;br /&gt;
 tr -d \r &lt;infile &gt;outfile        # GNU tr 1.22 或更高版本&lt;/p&gt;

&lt;p&gt;# 将每一行前导的“空白字符”（空格，制表符）删除&lt;br /&gt;
 # 使之左对齐&lt;br /&gt;
 sed &amp;rsquo;s/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;*//&amp;rsquo;                # 见本文末尾关于&amp;rsquo;\t&amp;rsquo;用法的描述&lt;/p&gt;

&lt;p&gt;# 将每一行拖尾的“空白字符”（空格，制表符）删除&lt;br /&gt;
 sed &amp;rsquo;s/[ \t]*$//&amp;rsquo;                # 见本文末尾关于&amp;rsquo;\t&amp;rsquo;用法的描述&lt;/p&gt;

&lt;p&gt;# 将每一行中的前导和拖尾的空白字符删除&lt;br /&gt;
 sed &amp;rsquo;s/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;em&gt;//;s/[ \t]&lt;/em&gt;$//&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 在每一行开头处插入5个空格（使全文向右移动5个字符的位置）&lt;br /&gt;
 sed &amp;rsquo;s/^/     /&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 以79个字符为宽度，将所有文本右对齐&lt;br /&gt;
 sed -e :a -e &amp;rsquo;s/^.{1,78}$/ &amp;amp;/;ta&amp;rsquo;  # 78个字符外加最后的一个空格&lt;/p&gt;

&lt;p&gt;# 以79个字符为宽度，使所有文本居中。在方法1中，为了让文本居中每一行的前&lt;br /&gt;
 # 头和后头都填充了空格。 在方法2中，在居中文本的过程中只在文本的前面填充&lt;br /&gt;
 # 空格，并且最终这些空格将有一半会被删除。此外每一行的后头并未填充空格。&lt;br /&gt;
 sed  -e :a -e &amp;rsquo;s/^.{1,77}$/ &amp;amp; /;ta&amp;rsquo;                     # 方法1&lt;br /&gt;
 sed  -e :a -e &amp;rsquo;s/^.{1,77}$/ &amp;amp;/;ta&amp;rsquo; -e &amp;rsquo;s/( *)\1/\1/&amp;rsquo;  # 方法2&lt;/p&gt;

&lt;p&gt;# 在每一行中查找字串“foo”，并将找到的“foo”替换为“bar”&lt;br /&gt;
 sed &amp;rsquo;s/foo/bar/&amp;rsquo;                 # 只替换每一行中的第一个“foo”字串&lt;br /&gt;
 sed &amp;rsquo;s/foo/bar/4&amp;rsquo;                # 只替换每一行中的第四个“foo”字串&lt;br /&gt;
 sed &amp;rsquo;s/foo/bar/g&amp;rsquo;                # 将每一行中的所有“foo”都换成“bar”&lt;br /&gt;
 sed &amp;rsquo;s/(.*)foo(.&lt;em&gt;foo)/\1bar\2/&amp;rsquo; # 替换倒数第二个“foo”&lt;br /&gt;
 sed &amp;rsquo;s/(.&lt;/em&gt;)foo/\1bar/&amp;rsquo;            # 替换最后一个“foo”&lt;/p&gt;

&lt;p&gt;# 只在行中出现字串“baz”的情况下将“foo”替换成“bar”&lt;br /&gt;
 sed &amp;lsquo;/baz/s/foo/bar/g&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 将“foo”替换成“bar”，并且只在行中未出现字串“baz”的情况下替换&lt;br /&gt;
 sed &amp;lsquo;/baz/!s/foo/bar/g&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 不管是“scarlet”“ruby”还是“puce”，一律换成“red”&lt;br /&gt;
 sed &amp;rsquo;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g&amp;rsquo;  #对多数的sed都有效&lt;br /&gt;
 gsed &amp;rsquo;s/scarlet|ruby|puce/red/g&amp;rsquo;               # 只对GNU sed有效&lt;/p&gt;

&lt;p&gt;# 倒置所有行，第一行成为最后一行，依次类推（模拟“tac”）。&lt;br /&gt;
 # 由于某些原因，使用下面命令时HHsed v1.5会将文件中的空行删除&lt;br /&gt;
 sed &amp;lsquo;1!G;h;$!d&amp;rsquo;               # 方法1&lt;br /&gt;
 sed -n &amp;lsquo;1!G;h;$p&amp;rsquo;             # 方法2&lt;/p&gt;

&lt;p&gt;# 将行中的字符逆序排列，第一个字成为最后一字，……（模拟“rev”）&lt;br /&gt;
 &lt;code&gt;sed &#39;/\n/!G;s/\(.\)\(.*\n\)/&amp;amp;\2\1/;//D;s/.//&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;# 将每两行连接成一行（类似“paste”）&lt;br /&gt;
 sed &amp;lsquo;$!N;s/\n/ /&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 如果当前行以反斜杠“\”结束，则将下一行并到当前行末尾&lt;br /&gt;
 # 并去掉原来行尾的反斜杠&lt;br /&gt;
 sed -e :a -e &amp;lsquo;/\$/N; s/\\n//; ta&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 如果当前行以等号开头，将当前行并到上一行末尾&lt;br /&gt;
 # 并以单个空格代替原来行头的“=”&lt;br /&gt;
 sed -e :a -e &amp;lsquo;$!N;s/\n=/ /;ta&amp;rsquo; -e &amp;lsquo;P;D&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567”&lt;br /&gt;
 gsed &amp;lsquo;:a;s/\B[0-9]{3}&amp;gt;/,&amp;amp;/;ta&amp;rsquo;                     # GNU sed&lt;br /&gt;
 sed -e :a -e &amp;rsquo;s/(.*[0-9])([0-9]{3})/\1,\2/;ta&amp;rsquo;  # 其他sed&lt;/p&gt;

&lt;p&gt;# 为带有小数点和负号的数值增加逗号分隔符（GNU sed）&lt;br /&gt;
 gsed -r &amp;lsquo;:a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 在每5行后增加一空白行 （在第5，10，15，20，等行后增加一空白行）&lt;br /&gt;
 gsed &amp;lsquo;0~5G&amp;rsquo;                      # 只对GNU sed有效&lt;br /&gt;
 sed &amp;lsquo;n;n;n;n;G;&amp;rsquo;                 # 其他sed&lt;/p&gt;

&lt;h2 id=&#34;选择性地显示特定行&#34;&gt;选择性地显示特定行：&lt;/h2&gt;

&lt;p&gt;# 显示文件中的前10行 （模拟“head”的行为）&lt;br /&gt;
 sed 10q&lt;/p&gt;

&lt;p&gt;# 显示文件中的第一行 （模拟“head -1”命令）&lt;br /&gt;
 sed q&lt;/p&gt;

&lt;p&gt;# 显示文件中的最后10行 （模拟“tail”）&lt;br /&gt;
 sed -e :a -e &amp;lsquo;$q;N;11,$D;ba&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示文件中的最后2行（模拟“tail -2”命令）&lt;br /&gt;
 sed &amp;lsquo;$!N;$!D&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示文件中的最后一行（模拟“tail -1”）&lt;br /&gt;
 sed &amp;lsquo;$!d&amp;rsquo;                        # 方法1&lt;br /&gt;
 sed -n &amp;lsquo;$p&amp;rsquo;                      # 方法2&lt;/p&gt;

&lt;p&gt;# 显示文件中的倒数第二行&lt;br /&gt;
 sed -e &amp;lsquo;$!{h;d;}&amp;rsquo; -e x              # 当文件中只有一行时，输入空行&lt;br /&gt;
 sed -e &amp;lsquo;1{$q;}&amp;rsquo; -e &amp;lsquo;$!{h;d;}&amp;rsquo; -e x  # 当文件中只有一行时，显示该行&lt;br /&gt;
 sed -e &amp;lsquo;1{$d;}&amp;rsquo; -e &amp;lsquo;$!{h;d;}&amp;rsquo; -e x  # 当文件中只有一行时，不输出&lt;/p&gt;

&lt;p&gt;# 只显示匹配正则表达式的行（模拟“grep”）&lt;br /&gt;
 sed -n &amp;lsquo;/regexp/p&amp;rsquo;               # 方法1&lt;br /&gt;
 sed &amp;lsquo;/regexp/!d&amp;rsquo;                 # 方法2&lt;/p&gt;

&lt;p&gt;# 只显示“不”匹配正则表达式的行（模拟“grep -v”）&lt;br /&gt;
 sed -n &amp;lsquo;/regexp/!p&amp;rsquo;              # 方法1，与前面的命令相对应&lt;br /&gt;
 sed &amp;lsquo;/regexp/d&amp;rsquo;                  # 方法2，类似的语法&lt;/p&gt;

&lt;p&gt;# 查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行&lt;br /&gt;
 sed -n &amp;lsquo;/regexp/{g;1!p;};h&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行&lt;br /&gt;
 sed -n &amp;lsquo;/regexp/{n;p;}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所&lt;br /&gt;
 # 在行的行号 （类似“grep -A1 -B1”）&lt;br /&gt;
 sed -n -e &amp;lsquo;/regexp/{=;x;1!p;g;$!N;p;D;}&amp;rsquo; -e h&lt;/p&gt;

&lt;p&gt;# 显示包含“AAA”、“BBB”或“CCC”的行（任意次序）&lt;br /&gt;
 sed &amp;lsquo;/AAA/!d; /BBB/!d; /CCC/!d&amp;rsquo;  # 字串的次序不影响结果&lt;/p&gt;

&lt;p&gt;# 显示包含“AAA”、“BBB”和“CCC”的行（固定次序）&lt;br /&gt;
 sed &amp;lsquo;/AAA.*BBB.*CCC/!d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示包含“AAA”“BBB”或“CCC”的行 （模拟“egrep”）&lt;br /&gt;
 sed -e &amp;lsquo;/AAA/b&amp;rsquo; -e &amp;lsquo;/BBB/b&amp;rsquo; -e &amp;lsquo;/CCC/b&amp;rsquo; -e d    # 多数sed&lt;br /&gt;
 gsed &amp;lsquo;/AAA|BBB|CCC/!d&amp;rsquo;                        # 对GNU sed有效&lt;/p&gt;

&lt;p&gt;# 显示包含“AAA”的段落 （段落间以空行分隔）&lt;br /&gt;
 # HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样&lt;br /&gt;
 sed -e &amp;lsquo;/./{H;$!d;}&amp;rsquo; -e &amp;lsquo;x;/AAA/!d;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示包含“AAA”“BBB”和“CCC”三个字串的段落 （任意次序）&lt;br /&gt;
 sed -e &amp;lsquo;/./{H;$!d;}&amp;rsquo; -e &amp;lsquo;x;/AAA/!d;/BBB/!d;/CCC/!d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 （任意次序）&lt;br /&gt;
 sed -e &amp;lsquo;/./{H;$!d;}&amp;rsquo; -e &amp;lsquo;x;/AAA/b&amp;rsquo; -e &amp;lsquo;/BBB/b&amp;rsquo; -e &amp;lsquo;/CCC/b&amp;rsquo; -e d&lt;br /&gt;
 gsed &amp;lsquo;/./{H;$!d;};x;/AAA|BBB|CCC/b;d&amp;rsquo;         # 只对GNU sed有效&lt;/p&gt;

&lt;p&gt;# 显示包含65个或以上字符的行&lt;br /&gt;
 sed -n &amp;lsquo;/^.{65}/p&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示包含65个以下字符的行&lt;br /&gt;
 sed -n &amp;lsquo;/^.{65}/!p&amp;rsquo;            # 方法1，与上面的脚本相对应&lt;br /&gt;
 sed &amp;lsquo;/^.{65}/d&amp;rsquo;                # 方法2，更简便一点的方法&lt;/p&gt;

&lt;p&gt;# 显示部分文本——从包含正则表达式的行开始到最后一行结束&lt;br /&gt;
 sed -n &amp;lsquo;/regexp/,$p&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 显示部分文本——指定行号范围（从第8至第12行，含8和12行）&lt;br /&gt;
 sed -n &amp;lsquo;8,12p&amp;rsquo;                   # 方法1&lt;br /&gt;
 sed &amp;lsquo;8,12!d&amp;rsquo;                     # 方法2&lt;/p&gt;

&lt;p&gt;# 显示第52行&lt;br /&gt;
 sed -n &amp;lsquo;52p&amp;rsquo;                     # 方法1&lt;br /&gt;
 sed &amp;lsquo;52!d&amp;rsquo;                       # 方法2&lt;br /&gt;
 sed &amp;lsquo;52q;d&amp;rsquo;                      # 方法3, 处理大文件时更有效率&lt;/p&gt;

&lt;p&gt;# 从第3行开始，每7行显示一次&lt;br /&gt;
 gsed -n &amp;lsquo;3~7p&amp;rsquo;                   # 只对GNU sed有效&lt;br /&gt;
 sed -n &amp;lsquo;3,${p;n;n;n;n;n;n;}&amp;rsquo;     # 其他sed&lt;/p&gt;

&lt;p&gt;# 显示两个正则表达式之间的文本（包含）&lt;br /&gt;
 sed -n &amp;lsquo;/Iowa/,/Montana/p&amp;rsquo;       # 区分大小写方式&lt;/p&gt;

&lt;h2 id=&#34;选择性地删除特定行&#34;&gt;选择性地删除特定行：&lt;/h2&gt;

&lt;p&gt;# 显示通篇文档，除了两个正则表达式之间的内容&lt;br /&gt;
 sed &amp;lsquo;/Iowa/,/Montana/d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件中相邻的重复行（模拟“uniq”）&lt;br /&gt;
 # 只保留重复行中的第一行，其他行删除&lt;br /&gt;
 sed &amp;lsquo;$!N; /^(.*)\n\1$/!P; D&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件中的重复行，不管有无相邻。注意hold space所能支持的缓存&lt;br /&gt;
 # 大小，或者使用GNU sed。&lt;br /&gt;
 sed -n &amp;lsquo;G; s/\n/&amp;amp;&amp;amp;/; /^([ -~]&lt;em&gt;\n).&lt;/em&gt;\n\1/d; s/\n//; h; P&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除除重复行外的所有行（模拟“uniq -d”）&lt;br /&gt;
 sed &amp;lsquo;$!N; s/^(.*)\n\1$/\1/; t; D&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件中开头的10行&lt;br /&gt;
 sed &amp;lsquo;1,10d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件中的最后一行&lt;br /&gt;
 sed &amp;lsquo;$d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件中的最后两行&lt;br /&gt;
 sed &amp;lsquo;N;$!P;$!D;$d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件中的最后10行&lt;br /&gt;
 sed -e :a -e &amp;lsquo;$d;N;2,10ba&amp;rsquo; -e &amp;lsquo;P;D&amp;rsquo;   # 方法1&lt;br /&gt;
 sed -n -e :a -e &amp;lsquo;1,10!{P;N;D;};N;ba&amp;rsquo;  # 方法2&lt;/p&gt;

&lt;p&gt;# 删除8的倍数行&lt;br /&gt;
 gsed &amp;lsquo;0~8d&amp;rsquo;                           # 只对GNU sed有效&lt;br /&gt;
 sed &amp;lsquo;n;n;n;n;n;n;n;d;&amp;rsquo;                # 其他sed&lt;/p&gt;

&lt;p&gt;# 删除匹配式样的行&lt;br /&gt;
 sed &amp;lsquo;/pattern/d&amp;rsquo;                      # 删除含pattern的行。当然pattern&lt;br /&gt;
                                       # 可以换成任何有效的正则表达式&lt;/p&gt;

&lt;p&gt;# 删除文件中的所有空行（与“grep &amp;lsquo;.&amp;rsquo; ”效果相同）&lt;br /&gt;
 sed &amp;lsquo;/^$/d&amp;rsquo;                           # 方法1&lt;br /&gt;
 sed &amp;lsquo;/./!d&amp;rsquo;                           # 方法2&lt;/p&gt;

&lt;p&gt;# 只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。&lt;br /&gt;
 # （模拟“cat -s”）&lt;br /&gt;
 sed &amp;lsquo;/./,/^$/!d&amp;rsquo;        #方法1，删除文件顶部的空行，允许尾部保留一空行&lt;br /&gt;
 sed &amp;lsquo;/^$/N;/\n$/D&amp;rsquo;      #方法2，允许顶部保留一空行，尾部不留空行&lt;/p&gt;

&lt;p&gt;# 只保留多个相邻空行的前两行。&lt;br /&gt;
 sed &amp;lsquo;/^$/N;/\n$/N;//D&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件顶部的所有空行&lt;br /&gt;
 sed &amp;lsquo;/./,$!d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 删除文件尾部的所有空行&lt;br /&gt;
 sed -e :a -e &amp;lsquo;/^\n&lt;em&gt;$/{$d;N;ba&amp;rsquo; -e &amp;lsquo;}&amp;rsquo;  # 对所有sed有效&lt;br /&gt;
 sed -e :a -e &amp;lsquo;/^\n&lt;/em&gt;$/N;/\n$/ba&amp;rsquo;        # 同上，但只对 gsed 3.02.*有效&lt;/p&gt;

&lt;p&gt;# 删除每个段落的最后一行&lt;br /&gt;
 sed -n &amp;lsquo;/^$/{p;h;};/./{x;/./p;}&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;特殊应用&#34;&gt;特殊应用：&lt;/h2&gt;

&lt;p&gt;# 移除手册页（man page）中的nroff标记。在Unix System V或bash shell下使&lt;br /&gt;
 # 用&amp;rsquo;echo&amp;rsquo;命令时可能需要加上 -e 选项。&lt;br /&gt;
 sed &amp;ldquo;s/.&lt;code&gt;echo \\\b&lt;/code&gt;//g&amp;rdquo;    # 外层的双括号是必须的（Unix环境）&lt;br /&gt;
 sed &amp;rsquo;s/.^H//g&amp;rsquo;             # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H&lt;br /&gt;
 sed &amp;rsquo;s/.\x08//g&amp;rsquo;           # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法&lt;/p&gt;

&lt;p&gt;# 提取新闻组或 e-mail 的邮件头&lt;br /&gt;
 sed &amp;lsquo;/^$/q&amp;rsquo;                # 删除第一行空行后的所有内容&lt;/p&gt;

&lt;p&gt;# 提取新闻组或 e-mail 的正文部分&lt;br /&gt;
 sed &amp;lsquo;1,/^$/d&amp;rsquo;              # 删除第一行空行之前的所有内容&lt;/p&gt;

&lt;p&gt;# 从邮件头提取“Subject”（标题栏字段），并移除开头的“Subject:”字样&lt;br /&gt;
 sed &amp;lsquo;/^Subject: */!d; s///;q&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 从邮件头获得回复地址&lt;br /&gt;
 sed &amp;lsquo;/^Reply-To:/q; /^From:/h; /./d;g;q&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮&lt;br /&gt;
 # 地址的部分剃除。（见上一脚本）&lt;br /&gt;
 sed &amp;rsquo;s/ &lt;em&gt;(.&lt;/em&gt;)//; s/&amp;gt;.&lt;em&gt;//; s/.&lt;/em&gt;[:&amp;lt;] *//&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 在每一行开头加上一个尖括号和空格（引用信息）&lt;br /&gt;
 sed &amp;rsquo;s/^/&amp;gt; /&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 将每一行开头处的尖括号和空格删除（解除引用）&lt;br /&gt;
 sed &amp;rsquo;s/^&amp;gt; //&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 移除大部分的HTML标签（包括跨行标签）&lt;br /&gt;
 sed -e :a -e &amp;rsquo;s/&amp;lt;[^&amp;gt;]*&amp;gt;//g;/&amp;lt;/N;//ba&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。&lt;br /&gt;
 # 文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入；&lt;br /&gt;
 # 第二种版本则可以放入一个带执行权限的shell脚本中。（由Rahul Dhesi的一&lt;br /&gt;
 # 个脚本修改而来。）&lt;br /&gt;
 sed &amp;lsquo;/^end/,/^begin/d&amp;rsquo; file1 file2 &amp;hellip; fileX | uudecode   # vers. 1&lt;br /&gt;
 sed &amp;lsquo;/^end/,/^begin/d&amp;rsquo; &amp;ldquo;$@&amp;rdquo; | uudecode                    # vers. 2&lt;/p&gt;

&lt;p&gt;# 将文件中的段落以字母顺序排序。段落间以（一行或多行）空行分隔。GNU sed使用&lt;br /&gt;
 # 字元“\v”来表示垂直制表符，这里用它来作为换行符的占位符——当然你也可以&lt;br /&gt;
 # 用其他未在文件中使用的字符来代替它。&lt;br /&gt;
 sed &amp;lsquo;/./{H;d;};x;s/\n/={NL}=/g&amp;rsquo; file | sort | sed &amp;lsquo;1s/={NL}=//;s/={NL}=/\n/g&amp;rsquo;&lt;br /&gt;
 gsed &amp;lsquo;/./{H;d};x;y/\n/\v/&amp;rsquo; file | sort | sed &amp;lsquo;1s/\v//;y/\v/\n/&amp;rsquo;&lt;/p&gt;

&lt;p&gt;# 分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件&lt;br /&gt;
 # 命名为与原来相同的名字（只是扩展名不同）。（DOS环境：“dir /b”&lt;br /&gt;
 # 显示不带路径的文件名）。&lt;br /&gt;
 echo @echo off &amp;gt;zipup.bat&lt;br /&gt;
 dir /b &lt;em&gt;.txt | sed &amp;ldquo;s/^(.&lt;/em&gt;).TXT/pkzip -mo \1 \1.TXT/&amp;rdquo; &amp;gt;&amp;gt;zipup.bat&lt;/p&gt;

&lt;p&gt;使用SED：Sed接受一个或多个编辑命令，并且每读入一行后就依次应用这些命令。&lt;br /&gt;
当读入第一行输入后，sed对其应用所有的命令，然后将结果输出。接着再读入第二&lt;br /&gt;
行输入，对其应用所有的命令……并重复这个过程。上一个例子中sed由标准输入设&lt;br /&gt;
备（即命令解释器，通常是以管道输入的形式）获得输入。在命令行给出一个或多&lt;br /&gt;
个文件名作为参数时，这些文件取代标准输入设备成为sed的输入。sed的输出将被&lt;br /&gt;
送到标准输出（显示器）。因此：&lt;/p&gt;

&lt;p&gt;cat filename | sed &amp;lsquo;10q&amp;rsquo;         # 使用管道输入&lt;br /&gt;
 sed &amp;lsquo;10q&amp;rsquo; filename               # 同样效果，但不使用管道输入&lt;br /&gt;
 sed &amp;lsquo;10q&amp;rsquo; filename &amp;gt; newfile     # 将输出转移（重定向）到磁盘上&lt;/p&gt;

&lt;p&gt;要了解sed命令的使用说明，包括如何通过脚本文件（而非从命令行）来使用这些命&lt;br /&gt;
令，请参阅《sed &amp;amp; awk》第二版，作者Dale Dougherty和Arnold Robbins&lt;br /&gt;
（O&amp;rsquo;Reilly，1997；&lt;a href=&#34;http://www.ora.com），《UNIX&#34; target=&#34;_blank&#34;&gt;http://www.ora.com），《UNIX&lt;/a&gt; Text Processing》，作者&lt;br /&gt;
Dale Dougherty和Tim O&amp;rsquo;Reilly（Hayden Books，1987）或者是Mike Arst写的教&lt;br /&gt;
程——压缩包的名称是“U-SEDIT2.ZIP”（在许多站点上都找得到）。要发掘sed&lt;br /&gt;
的潜力，则必须对“正则表达式”有足够的理解。正则表达式的资料可以看&lt;br /&gt;
《Mastering Regular Expressions》作者Jeffrey Friedl（O&amp;rsquo;reilly 1997）。&lt;br /&gt;
Unix系统所提供的手册页（“man”）也会有所帮助（试一下这些命令&lt;br /&gt;
“man sed”、“man regexp”，或者看“man ed”中关于正则表达式的部分），但&lt;br /&gt;
手册提供的信息比较“抽象”——这也是它一直为人所诟病的。不过，它本来就不&lt;br /&gt;
是用来教初学者如何使用sed或正则表达式的教材，而只是为那些熟悉这些工具的人&lt;br /&gt;
提供的一些文本参考。&lt;/p&gt;

&lt;p&gt;括号语法：前面的例子对sed命令基本上都使用单引号（&amp;rsquo;&amp;hellip;&amp;lsquo;）而非双引号&lt;br /&gt;
（&amp;rdquo;&amp;hellip;&amp;ldquo;）这是因为sed通常是在Unix平台上使用。单引号下，Unix的shell（命令&lt;br /&gt;
解释器）不会对美元符（$）和后引号（&lt;code&gt;...&lt;/code&gt;）进行解释和执行。而在双引号下&lt;br /&gt;
美元符会被展开为变量或参数的值，后引号中的命令被执行并以输出的结果代替&lt;br /&gt;
后引号中的内容。而在“csh”及其衍生的shell中使用感叹号（!）时需要在其前&lt;br /&gt;
面加上转义用的反斜杠（就像这样：!）以保证上面所使用的例子能正常运行&lt;br /&gt;
（包括使用单引号的情况下）。DOS版本的Sed则一律使用双引号（&amp;rdquo;&amp;hellip;&amp;ldquo;）而不是&lt;br /&gt;
引号来圈起命令。&lt;/p&gt;

&lt;p&gt;&amp;lsquo;\t&amp;rsquo;的用法：为了使本文保持行文简洁，我们在脚本中使用&amp;rsquo;\t&amp;rsquo;来表示一个制表&lt;br /&gt;
符。但是现在大部分版本的sed还不能识别&amp;rsquo;\t&amp;rsquo;的简写方式，因此当在命令行中为&lt;br /&gt;
脚本输入制表符时，你应该直接按TAB键来输入制表符而不是输入&amp;rsquo;\t&amp;rsquo;。下列的工&lt;br /&gt;
具软件都支持&amp;rsquo;\t&amp;rsquo;做为一个正则表达式的字元来表示制表符：awk、perl、HHsed、&lt;br /&gt;
sedmod以及GNU sed v3.02.80。&lt;/p&gt;

&lt;p&gt;不同版本的SED：不同的版本间的sed会有些不同之处，可以想象它们之间在语法上&lt;br /&gt;
会有差异。具体而言，它们中大部分不支持在编辑命令中间使用标签（:name）或分&lt;br /&gt;
支命令（b,t），除非是放在那些的末尾。这篇文档中我们尽量选用了可移植性较高&lt;br /&gt;
的语法，以使大多数版本的sed的用户都能使用这些脚本。不过GNU版本的sed允许使&lt;br /&gt;
用更简洁的语法。想像一下当读者看到一个很长的命令时的心情：&lt;/p&gt;

&lt;p&gt;sed -e &amp;lsquo;/AAA/b&amp;rsquo; -e &amp;lsquo;/BBB/b&amp;rsquo; -e &amp;lsquo;/CCC/b&amp;rsquo; -e d&lt;/p&gt;

&lt;p&gt;好消息是GNU sed能让命令更紧凑：&lt;/p&gt;

&lt;p&gt;sed &amp;lsquo;/AAA/b;/BBB/b;/CCC/b;d&amp;rsquo;      # 甚至可以写成&lt;br /&gt;
   sed &amp;lsquo;/AAA|BBB|CCC/b;d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;此外，请注意虽然许多版本的sed接受象“/one/ s/RE1/RE2/”这种在&amp;rsquo;s&amp;rsquo;前带有空&lt;br /&gt;
格的命令，但这些版本中有些却不接受这样的命令:“/one/! s/RE1/RE2/”。这时&lt;br /&gt;
只需要把中间的空格去掉就行了。&lt;/p&gt;

&lt;p&gt;速度优化：当由于某种原因（比如输入文件较大、处理器或硬盘较慢等）需要提高&lt;br /&gt;
命令执行速度时，可以考虑在替换命令（“s/&amp;hellip;/&amp;hellip;/”）前面加上地址表达式来&lt;br /&gt;
提高速度。举例来说：&lt;/p&gt;

&lt;p&gt;sed &amp;rsquo;s/foo/bar/g&amp;rsquo; filename         # 标准替换命令&lt;br /&gt;
   sed &amp;lsquo;/foo/ s/foo/bar/g&amp;rsquo; filename   # 速度更快&lt;br /&gt;
   sed &amp;lsquo;/foo/ s//bar/g&amp;rsquo; filename      # 简写形式&lt;/p&gt;

&lt;p&gt;当只需要显示文件的前面的部分或需要删除后面的内容时，可以在脚本中使用“q”&lt;br /&gt;
命令（退出命令）。在处理大的文件时，这会节省大量时间。因此：&lt;/p&gt;

&lt;p&gt;sed -n &amp;lsquo;45,50p&amp;rsquo; filename           # 显示第45到50行&lt;br /&gt;
   sed -n &amp;lsquo;51q;45,50p&amp;rsquo; filename       # 一样，但快得多&lt;/p&gt;

&lt;p&gt;如果你有其他的单行脚本想与大家分享或者你发现了本文档中错误的地方，请发电&lt;br /&gt;
子邮件给本文档的作者（Eric Pement）。邮件中请记得提供你所使用的sed版本、&lt;br /&gt;
该sed所运行的操作系统及对问题的适当描述。本文所指的单行脚本指命令行的长&lt;br /&gt;
度在65个字符或65个以下的sed脚本〔译注1〕。本文档的各种脚本是由以下所列作&lt;br /&gt;
者所写或提供：&lt;/p&gt;

&lt;p&gt;Al Aab                               # 建立了“seders”邮件列表&lt;br /&gt;
 Edgar Allen                          # 许多方面&lt;br /&gt;
 Yiorgos Adamopoulos                  # 许多方面&lt;br /&gt;
 Dale Dougherty                       # 《sed &amp;amp; awk》作者&lt;br /&gt;
 Carlos Duarte                        # 《do it with sed》作者&lt;br /&gt;
 Eric Pement                          # 本文档的作者&lt;br /&gt;
 Ken Pizzini                          # GNU sed v3.02 的作者&lt;br /&gt;
 S.G. Ravenhall                       # 去html标签脚本&lt;/p&gt;

&lt;h2 id=&#34;greg-ubben-有诸多贡献并提供了许多帮助&#34;&gt;Greg Ubben                           # 有诸多贡献并提供了许多帮助&lt;/h2&gt;

&lt;p&gt;译注1：大部分情况下，sed脚本无论多长都能写成单行的形式（通过&lt;code&gt;-e&#39;选项和&lt;/code&gt;;&amp;rsquo;&lt;br /&gt;
号）——只要命令解释器支持，所以这里说的单行脚本除了能写成一行还对长度有&lt;br /&gt;
所限制。因为这些单行脚本的意义不在于它们是以单行的形式出现。而是让用户能&lt;br /&gt;
方便地在命令行中使用这些紧凑的脚本才是其意义所在。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:t&#34;&gt; \t &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:t&#34;&gt; \t &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
        <item>
            <title>SED单行脚本快速参考[同时包含awk实现]</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-sedawk/</link>
            <pubDate>Tue, 27 Sep 2016 15:57:46 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-sedawk/</guid>
            <description>

&lt;p&gt;文本间隔：&lt;/p&gt;

&lt;h1 id=&#34;在每一行后面增加一空行&#34;&gt;在每一行后面增加一空行&lt;/h1&gt;

&lt;p&gt;sed G&lt;br /&gt;
awk &amp;lsquo;{printf(&amp;ldquo;%s\n\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将原来的所有空行删除并在每一行后面增加一空行&#34;&gt;将原来的所有空行删除并在每一行后面增加一空行。&lt;/h1&gt;

&lt;h1 id=&#34;这样在输出的文本中每一行后面将有且只有一空行&#34;&gt;这样在输出的文本中每一行后面将有且只有一空行。&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/^$/d;G&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;!/^$/{printf(&amp;ldquo;%s\n\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;在每一行后面增加两行空行&#34;&gt;在每一行后面增加两行空行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;G;G&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{printf(&amp;ldquo;%s\n\n\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将第一个脚本所产生的所有空行删除-即删除所有偶数行&#34;&gt;将第一个脚本所产生的所有空行删除（即删除所有偶数行）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;n;d&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{f=!f;if(f)print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;在匹配式样-regex-的行之前插入一空行&#34;&gt;在匹配式样“regex”的行之前插入一空行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/regex/{x;p;x;}&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(/regex/)printf(&amp;rdquo;\n%s\n&amp;rdquo;,$0);else print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;在匹配式样-regex-的行之后插入一空行&#34;&gt;在匹配式样“regex”的行之后插入一空行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/regex/G&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(/regex/)printf(&amp;ldquo;%s\n\n&amp;rdquo;,$0);else print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;在匹配式样-regex-的行之前和之后各插入一空行&#34;&gt;在匹配式样“regex”的行之前和之后各插入一空行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/regex/{x;p;x;G;}&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(/regex/)printf(&amp;rdquo;\n%s\n\n&amp;rdquo;,$0);else print $0}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;编号：&lt;/p&gt;

&lt;h1 id=&#34;为文件中的每一行进行编号-简单的左对齐方式-这里使用了-制表符&#34;&gt;为文件中的每一行进行编号（简单的左对齐方式）。这里使用了“制表符”&lt;/h1&gt;

&lt;h1 id=&#34;tab-见本文末尾关于-t-的用法的描述-而不是空格来对齐边缘&#34;&gt;（tab，见本文末尾关于’\t’的用法的描述）而不是空格来对齐边缘。&lt;/h1&gt;

&lt;p&gt;sed = filename | sed &amp;lsquo;N;s/\n/\t/&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{i++;printf(&amp;ldquo;%d\t%s\n&amp;rdquo;,i,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;对文件中的所有行编号-行号在左-文字右端对齐&#34;&gt;对文件中的所有行编号（行号在左，文字右端对齐）。&lt;/h1&gt;

&lt;p&gt;sed = filename | sed &amp;lsquo;N; s/^/     /; s/ *(.{6,})\n/\1  /&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{i++;printf(&amp;ldquo;%6d  %s\n&amp;rdquo;,i,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;对文件中的所有行编号-但只显示非空白行的行号&#34;&gt;对文件中的所有行编号，但只显示非空白行的行号。&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/./=&amp;rsquo; filename | sed &amp;lsquo;/./N; s/\n/ /&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{i++;if(!/^$/)printf(&amp;ldquo;%d %s\n&amp;rdquo;,i,$0);else print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;计算行数-模拟-wc-l&#34;&gt;计算行数 （模拟 “wc -l”）&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;$=&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{i++}END{print i}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;文本转换和替代：&lt;/p&gt;

&lt;h1 id=&#34;unix环境-转换dos的新行符-cr-lf-为unix格式&#34;&gt;Unix环境：转换DOS的新行符（CR/LF）为Unix格式。&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/.$//&amp;rsquo;                     # 假设所有行以CR/LF结束&lt;br /&gt;
sed &amp;rsquo;s/^M$//&amp;rsquo;                    # 在bash/tcsh中，将按Ctrl-M改为按Ctrl-V&lt;br /&gt;
sed &amp;rsquo;s/\x0D$//&amp;rsquo;                  # ssed、gsed 3.02.80，及更高版本&lt;br /&gt;
awk &amp;lsquo;{sub(/\x0D$/,&amp;ldquo;&amp;rdquo;);print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;unix环境-转换unix的新行符-lf-为dos格式&#34;&gt;Unix环境：转换Unix的新行符（LF）为DOS格式。&lt;/h1&gt;

&lt;p&gt;sed &amp;ldquo;s/$/&lt;code&gt;echo -e \\\r&lt;/code&gt;/&amp;rdquo;        # 在ksh下所使用的命令&lt;br /&gt;
sed &amp;rsquo;s/$&amp;lsquo;&amp;ldquo;/&lt;code&gt;echo \\\r&lt;/code&gt;/&amp;rdquo;         # 在bash下所使用的命令&lt;br /&gt;
sed &amp;ldquo;s/$/&lt;code&gt;echo \\\r&lt;/code&gt;/&amp;rdquo;           # 在zsh下所使用的命令&lt;br /&gt;
sed &amp;rsquo;s/$/\r/&amp;rsquo;                    # gsed 3.02.80 及更高版本&lt;br /&gt;
awk &amp;lsquo;{printf(&amp;ldquo;%s\r\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;dos环境-转换unix新行符-lf-为dos格式&#34;&gt;DOS环境：转换Unix新行符（LF）为DOS格式。&lt;/h1&gt;

&lt;p&gt;sed &amp;ldquo;s/$//&amp;rdquo;                      # 方法 1&lt;br /&gt;
sed -n p                         # 方法 2&lt;/p&gt;

&lt;h1 id=&#34;dos环境-转换dos新行符-cr-lf-为unix格式&#34;&gt;DOS环境：转换DOS新行符（CR/LF）为Unix格式。&lt;/h1&gt;

&lt;h1 id=&#34;下面的脚本只对unxutils-sed-4-0-7-及更高版本有效-要识别unxutils版本的&#34;&gt;下面的脚本只对UnxUtils sed 4.0.7 及更高版本有效。要识别UnxUtils版本的&lt;/h1&gt;

&lt;h1 id=&#34;sed可以通过其特有的-text-选项-你可以使用帮助选项-help-看&#34;&gt;sed可以通过其特有的“–text”选项。你可以使用帮助选项（“–help”）看&lt;/h1&gt;

&lt;h1 id=&#34;其中有无一个-text-项以此来判断所使用的是否是unxutils版本-其它dos&#34;&gt;其中有无一个“–text”项以此来判断所使用的是否是UnxUtils版本。其它DOS&lt;/h1&gt;

&lt;h1 id=&#34;版本的的sed则无法进行这一转换-但可以用-tr-来实现这一转换&#34;&gt;版本的的sed则无法进行这一转换。但可以用“tr”来实现这一转换。&lt;/h1&gt;

&lt;p&gt;sed &amp;ldquo;s/\r//&amp;rdquo; infile &amp;gt;outfile     # UnxUtils sed v4.0.7 或更高版本&lt;br /&gt;
tr -d \r &lt;infile &gt;outfile        # GNU tr 1.22 或更高版本&lt;/p&gt;

&lt;h1 id=&#34;将每一行前导的-空白字符-空格-制表符-删除&#34;&gt;将每一行前导的“空白字符”（空格，制表符）删除&lt;/h1&gt;

&lt;h1 id=&#34;使之左对齐&#34;&gt;使之左对齐&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;*//&amp;rsquo;                # 见本文末尾关于&amp;rsquo;\t&amp;rsquo;用法的描述&lt;br /&gt;
awk &amp;lsquo;{sub(/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;+/,&amp;ldquo;&amp;rdquo;);print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将每一行拖尾的-空白字符-空格-制表符-删除&#34;&gt;将每一行拖尾的“空白字符”（空格，制表符）删除&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/[ \t]*$//&amp;rsquo;                # 见本文末尾关于&amp;rsquo;\t&amp;rsquo;用法的描述&lt;br /&gt;
awk &amp;lsquo;{sub(/[ \t]+$/,&amp;ldquo;&amp;rdquo;);print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将每一行中的前导和拖尾的空白字符删除&#34;&gt;将每一行中的前导和拖尾的空白字符删除&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;em&gt;//;s/[ \t]&lt;/em&gt;$//&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{sub(/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;+/,&amp;ldquo;&amp;rdquo;);sub(/[ \t]+$/,&amp;ldquo;&amp;rdquo;);print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;在每一行开头处插入5个空格-使全文向右移动5个字符的位置&#34;&gt;在每一行开头处插入5个空格（使全文向右移动5个字符的位置）&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/^/     /&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{printf(&amp;rdquo;     %s\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;以79个字符为宽度-将所有文本右对齐&#34;&gt;以79个字符为宽度，将所有文本右对齐&lt;/h1&gt;

&lt;h1 id=&#34;78个字符外加最后的一个空格&#34;&gt;78个字符外加最后的一个空格&lt;/h1&gt;

&lt;p&gt;sed -e :a -e &amp;rsquo;s/^.{1,78}$/ &amp;amp;/;ta&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{printf(&amp;ldquo;%79s\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;以79个字符为宽度-使所有文本居中-在方法1中-为了让文本居中每一行的前&#34;&gt;以79个字符为宽度，使所有文本居中。在方法1中，为了让文本居中每一行的前&lt;/h1&gt;

&lt;h1 id=&#34;头和后头都填充了空格-在方法2中-在居中文本的过程中只在文本的前面填充&#34;&gt;头和后头都填充了空格。 在方法2中，在居中文本的过程中只在文本的前面填充&lt;/h1&gt;

&lt;h1 id=&#34;空格-并且最终这些空格将有一半会被删除-此外每一行的后头并未填充空格&#34;&gt;空格，并且最终这些空格将有一半会被删除。此外每一行的后头并未填充空格。&lt;/h1&gt;

&lt;p&gt;sed  -e :a -e &amp;rsquo;s/^.{1,77}$/ &amp;amp; /;ta&amp;rsquo;                     # 方法1&lt;br /&gt;
sed  -e :a -e &amp;rsquo;s/^.{1,77}$/ &amp;amp;/;ta&amp;rsquo; -e &amp;rsquo;s/( *)\1/\1/&amp;rsquo;  # 方法2&lt;br /&gt;
awk &amp;lsquo;{for(i=0;i&amp;lt;39-length($0)/2;i++)printf(&amp;rdquo; &amp;ldquo;);printf(&amp;rdquo;%s\n&amp;rdquo;,$0)}&amp;rsquo;  #相当于上面的方法二&lt;/p&gt;

&lt;h1 id=&#34;在每一行中查找字串-foo-并将找到的-foo-替换为-bar&#34;&gt;在每一行中查找字串“foo”，并将找到的“foo”替换为“bar”&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/foo/bar/&amp;rsquo;                 # 只替换每一行中的第一个“foo”字串&lt;br /&gt;
sed &amp;rsquo;s/foo/bar/4&amp;rsquo;                # 只替换每一行中的第四个“foo”字串&lt;br /&gt;
sed &amp;rsquo;s/foo/bar/g&amp;rsquo;                # 将每一行中的所有“foo”都换成“bar”&lt;br /&gt;
sed &amp;rsquo;s/(.*)foo(.&lt;em&gt;foo)/\1bar\2/&amp;rsquo; # 替换倒数第二个“foo”&lt;br /&gt;
sed &amp;rsquo;s/(.&lt;/em&gt;)foo/\1bar/&amp;rsquo;            # 替换最后一个“foo”&lt;br /&gt;
awk &amp;lsquo;{gsub(/foo/,&amp;ldquo;bar&amp;rdquo;);print $0}&amp;rsquo;   # 将每一行中的所有“foo”都换成“bar”&lt;/p&gt;

&lt;h1 id=&#34;只在行中出现字串-baz-的情况下将-foo-替换成-bar&#34;&gt;只在行中出现字串“baz”的情况下将“foo”替换成“bar”&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/baz/s/foo/bar/g&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(/baz/)gsub(/foo/,&amp;ldquo;bar&amp;rdquo;);print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将-foo-替换成-bar-并且只在行中未出现字串-baz-的情况下替换&#34;&gt;将“foo”替换成“bar”，并且只在行中未出现字串“baz”的情况下替换&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/baz/!s/foo/bar/g&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(/baz$/)gsub(/foo/,&amp;ldquo;bar&amp;rdquo;);print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;不管是-scarlet-ruby-还是-puce-一律换成-red&#34;&gt;不管是“scarlet”“ruby”还是“puce”，一律换成“red”&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g&amp;rsquo;  #对多数的sed都有效&lt;br /&gt;
gsed &amp;rsquo;s/scarlet|ruby|puce/red/g&amp;rsquo;               # 只对GNU sed有效&lt;br /&gt;
awk &amp;lsquo;{gsub(/scarlet|ruby|puce/,&amp;ldquo;red&amp;rdquo;);print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;倒置所有行-第一行成为最后一行-依次类推-模拟-tac&#34;&gt;倒置所有行，第一行成为最后一行，依次类推（模拟“tac”）。&lt;/h1&gt;

&lt;h1 id=&#34;由于某些原因-使用下面命令时hhsed-v1-5会将文件中的空行删除&#34;&gt;由于某些原因，使用下面命令时HHsed v1.5会将文件中的空行删除&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;1!G;h;$!d&amp;rsquo;               # 方法1&lt;br /&gt;
sed -n &amp;lsquo;1!G;h;$p&amp;rsquo;             # 方法2&lt;br /&gt;
awk &amp;lsquo;{A[i++]=$0}END{for(j=i-1;j&amp;gt;=0;j&amp;ndash;)print A[j]}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将行中的字符逆序排列-第一个字成为最后一字-模拟-rev&#34;&gt;将行中的字符逆序排列，第一个字成为最后一字，……（模拟“rev”）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/\n/!G;s/(.)(.*\n)/&amp;amp;\2\1/;//D;s/.//&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{for(i=length($0);i&amp;gt;0;i&amp;ndash;)printf(&amp;ldquo;%s&amp;rdquo;,substr($0,i,1));printf(&amp;rdquo;\n&amp;rdquo;)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将每两行连接成一行-类似-paste&#34;&gt;将每两行连接成一行（类似“paste”）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;$!N;s/\n/ /&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{f=!f;if(f)printf(&amp;ldquo;%s&amp;rdquo;,$0);else printf(&amp;rdquo; %s\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;如果当前行以反斜杠-结束-则将下一行并到当前行末尾&#34;&gt;如果当前行以反斜杠“\”结束，则将下一行并到当前行末尾&lt;/h1&gt;

&lt;h1 id=&#34;并去掉原来行尾的反斜杠&#34;&gt;并去掉原来行尾的反斜杠&lt;/h1&gt;

&lt;p&gt;sed -e :a -e &amp;lsquo;/\$/N; s/\\n//; ta&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(/\$/)printf(&amp;ldquo;%s&amp;rdquo;,substr($0,0,length($0)-1));else printf(&amp;ldquo;%s\n&amp;rdquo;,$0)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;如果当前行以等号开头-将当前行并到上一行末尾&#34;&gt;如果当前行以等号开头，将当前行并到上一行末尾&lt;/h1&gt;

&lt;h1 id=&#34;并以单个空格代替原来行头的&#34;&gt;并以单个空格代替原来行头的“=”&lt;/h1&gt;

&lt;p&gt;sed -e :a -e &amp;lsquo;$!N;s/\n=/ /;ta&amp;rsquo; -e &amp;lsquo;P;D&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(/^=/)printf(&amp;rdquo; %s&amp;rdquo;,substr($0,2));else printf(&amp;ldquo;%s%s&amp;rdquo;,a,$0);a=&amp;rdquo;\n&amp;rdquo;}END{printf(&amp;rdquo;\n&amp;rdquo;)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;为数字字串增加逗号分隔符号-将-1234567-改为-1-234-567&#34;&gt;为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567”&lt;/h1&gt;

&lt;p&gt;gsed &amp;lsquo;:a;s/\B[0-9]{3}&amp;gt;/,&amp;amp;/;ta&amp;rsquo;                     # GNU sed&lt;br /&gt;
sed -e :a -e &amp;rsquo;s/(.*[0-9])([0-9]{3})/\1,\2/;ta&amp;rsquo;  # 其他sed&lt;/p&gt;

&lt;p&gt;#awk的正则没有后向匹配和引用，搞的比较狼狈，呵呵。&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;{while(match($0,/[0-9][0-9][0-9][0-9]+/)){$0=sprintf(&amp;ldquo;%s,%s&amp;rdquo;,substr($0,0,RSTART+RLENGTH-4),substr($0,RSTART+RLENGTH-3))}print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;为带有小数点和负号的数值增加逗号分隔符-gnu-sed&#34;&gt;为带有小数点和负号的数值增加逗号分隔符（GNU sed）&lt;/h1&gt;

&lt;p&gt;gsed -r &amp;lsquo;:a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta&amp;rsquo;&lt;/p&gt;

&lt;p&gt;#和上例差不多&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;{while(match($0,/[^.0-9][0-9][0-9][0-9][0-9]+/)){$0=sprintf(&amp;ldquo;%s,%s&amp;rdquo;,substr($0,0,RSTART+RLENGTH-4),substr($0,RSTART+RLENGTH-3))}print $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;在每5行后增加一空白行-在第5-10-15-20-等行后增加一空白行&#34;&gt;在每5行后增加一空白行 （在第5，10，15，20，等行后增加一空白行）&lt;/h1&gt;

&lt;p&gt;gsed &amp;lsquo;0~5G&amp;rsquo;                      # 只对GNU sed有效&lt;br /&gt;
sed &amp;lsquo;n;n;n;n;G;&amp;rsquo;                 # 其他sed&lt;br /&gt;
awk &amp;lsquo;{print $0;i++;if(i==5){printf(&amp;rdquo;\n&amp;rdquo;);i=0}}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;选择性地显示特定行：&lt;/p&gt;

&lt;h1 id=&#34;显示文件中的前10行-模拟-head-的行为&#34;&gt;显示文件中的前10行 （模拟“head”的行为）&lt;/h1&gt;

&lt;p&gt;sed 10q&lt;br /&gt;
awk &amp;lsquo;{print;if(NR==10)exit}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示文件中的第一行-模拟-head-1-命令&#34;&gt;显示文件中的第一行 （模拟“head -1”命令）&lt;/h1&gt;

&lt;p&gt;sed q&lt;br /&gt;
awk &amp;lsquo;{print;exit}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示文件中的最后10行-模拟-tail&#34;&gt;显示文件中的最后10行 （模拟“tail”）&lt;/h1&gt;

&lt;p&gt;sed -e :a -e &amp;lsquo;$q;N;11,$D;ba&amp;rsquo;&lt;/p&gt;

&lt;p&gt;#用awk干这个有点亏，得全文缓存，对于大文件肯定很慢&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;{A[NR]=$0}END{for(i=NR-9;i&amp;lt;=NR;i++)print A[i]}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示文件中的最后2行-模拟-tail-2-命令&#34;&gt;显示文件中的最后2行（模拟“tail -2”命令）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;$!N;$!D&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{A[NR]=$0}END{for(i=NR-1;i&amp;lt;=NR;i++)print A[i]}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示文件中的最后一行-模拟-tail-1&#34;&gt;显示文件中的最后一行（模拟“tail -1”）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;$!d&amp;rsquo;                        # 方法1&lt;br /&gt;
sed -n &amp;lsquo;$p&amp;rsquo;                      # 方法2&lt;/p&gt;

&lt;p&gt;#这个比较好办，只存最后一行了。&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;{A=$0}END{print A}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示文件中的倒数第二行&#34;&gt;显示文件中的倒数第二行&lt;/h1&gt;

&lt;p&gt;sed -e &amp;lsquo;$!{h;d;}&amp;rsquo; -e x              # 当文件中只有一行时，输出空行&lt;br /&gt;
sed -e &amp;lsquo;1{$q;}&amp;rsquo; -e &amp;lsquo;$!{h;d;}&amp;rsquo; -e x  # 当文件中只有一行时，显示该行&lt;br /&gt;
sed -e &amp;lsquo;1{$d;}&amp;rsquo; -e &amp;lsquo;$!{h;d;}&amp;rsquo; -e x  # 当文件中只有一行时，不输出&lt;/p&gt;

&lt;p&gt;#存两行呗（当文件中只有一行时，输出空行）&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;{B=A;A=$0}END{print B}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;只显示匹配正则表达式的行-模拟-grep&#34;&gt;只显示匹配正则表达式的行（模拟“grep”）&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/regexp/p&amp;rsquo;               # 方法1&lt;br /&gt;
sed &amp;lsquo;/regexp/!d&amp;rsquo;                 # 方法2&lt;br /&gt;
awk &amp;lsquo;/regexp/{print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;只显示-不-匹配正则表达式的行-模拟-grep-v&#34;&gt;只显示“不”匹配正则表达式的行（模拟“grep -v”）&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/regexp/!p&amp;rsquo;              # 方法1，与前面的命令相对应&lt;br /&gt;
sed &amp;lsquo;/regexp/d&amp;rsquo;                  # 方法2，类似的语法&lt;br /&gt;
awk &amp;lsquo;!/regexp/{print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;查找-regexp-并将匹配行的上一行显示出来-但并不显示匹配行&#34;&gt;查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/regexp/{g;1!p;};h&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;/regexp/{print A}{A=$0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;查找-regexp-并将匹配行的下一行显示出来-但并不显示匹配行&#34;&gt;查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/regexp/{n;p;}&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(A)print;A=0}/regexp/{A=1}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含-regexp-的行及其前后行-并在第一行之前加上-regexp-所在行的行号-类似-grep-a1-b1&#34;&gt;显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所在行的行号 （类似“grep -A1 -B1”）&lt;/h1&gt;

&lt;p&gt;sed -n -e &amp;lsquo;/regexp/{=;x;1!p;g;$!N;p;D;}&amp;rsquo; -e h&lt;br /&gt;
awk &amp;lsquo;{if(F)print;F=0}/regexp/{print NR;print b;print;F=1}{b=$0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含-aaa-bbb-和-ccc-的行-任意次序&#34;&gt;显示包含“AAA”、“BBB”和“CCC”的行（任意次序）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/AAA/!d; /BBB/!d; /CCC/!d&amp;rsquo;   # 字串的次序不影响结果&lt;br /&gt;
awk &amp;lsquo;{if(match($0,/AAA/) &amp;amp;&amp;amp; match($0,/BBB/) &amp;amp;&amp;amp; match($0,/CCC/))print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含-aaa-bbb-和-ccc-的行-固定次序&#34;&gt;显示包含“AAA”、“BBB”和“CCC”的行（固定次序）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/AAA.*BBB.*CCC/!d&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(match($0,/AAA.*BBB.*CCC/))print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含-aaa-bbb-或-ccc-的行-模拟-egrep&#34;&gt;显示包含“AAA”“BBB”或“CCC”的行 （模拟“egrep”）&lt;/h1&gt;

&lt;p&gt;sed -e &amp;lsquo;/AAA/b&amp;rsquo; -e &amp;lsquo;/BBB/b&amp;rsquo; -e &amp;lsquo;/CCC/b&amp;rsquo; -e d    # 多数sed&lt;br /&gt;
gsed &amp;lsquo;/AAA|BBB|CCC/!d&amp;rsquo;                        # 对GNU sed有效&lt;br /&gt;
awk &amp;lsquo;/AAA/{print;next}/BBB/{print;next}/CCC/{print}&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;/AAA|BBB|CCC/{print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含-aaa-的段落-段落间以空行分隔&#34;&gt;显示包含“AAA”的段落 （段落间以空行分隔）&lt;/h1&gt;

&lt;h1 id=&#34;hhsed-v1-5-必须在-x-后加入-g-接下来的3个脚本都是这样&#34;&gt;HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样&lt;/h1&gt;

&lt;p&gt;sed -e &amp;lsquo;/./{H;$!d;}&amp;rsquo; -e &amp;lsquo;x;/AAA/!d;&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;BEGIN{RS=&amp;ldquo;&amp;rdquo;}/AAA/{print}&amp;rsquo;&lt;br /&gt;
awk -vRS= &amp;lsquo;/AAA/{print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含-aaa-bbb-和-ccc-三个字串的段落-任意次序&#34;&gt;显示包含“AAA”“BBB”和“CCC”三个字串的段落 （任意次序）&lt;/h1&gt;

&lt;p&gt;sed -e &amp;lsquo;/./{H;$!d;}&amp;rsquo; -e &amp;lsquo;x;/AAA/!d;/BBB/!d;/CCC/!d&amp;rsquo;&lt;br /&gt;
awk -vRS= &amp;lsquo;{if(match($0,/AAA/) &amp;amp;&amp;amp; match($0,/BBB/) &amp;amp;&amp;amp; match($0,/CCC/))print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含-aaa-bbb-ccc-三者中任一字串的段落-任意次序&#34;&gt;显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 （任意次序）&lt;/h1&gt;

&lt;p&gt;sed -e &amp;lsquo;/./{H;$!d;}&amp;rsquo; -e &amp;lsquo;x;/AAA/b&amp;rsquo; -e &amp;lsquo;/BBB/b&amp;rsquo; -e &amp;lsquo;/CCC/b&amp;rsquo; -e d&lt;br /&gt;
gsed &amp;lsquo;/./{H;$!d;};x;/AAA|BBB|CCC/b;d&amp;rsquo;         # 只对GNU sed有效&lt;br /&gt;
awk -vRS= &amp;lsquo;/AAA|BBB|CCC/{print &amp;ldquo;&amp;rdquo;;print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含65个或以上字符的行&#34;&gt;显示包含65个或以上字符的行&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/^.{65}/p&amp;rsquo;&lt;/p&gt;

&lt;p&gt;cat ll.txt | awk &amp;lsquo;{if(length($0)&amp;gt;=65)print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示包含65个以下字符的行&#34;&gt;显示包含65个以下字符的行&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/^.{65}/!p&amp;rsquo;            # 方法1，与上面的脚本相对应&lt;br /&gt;
sed &amp;lsquo;/^.{65}/d&amp;rsquo;                # 方法2，更简便一点的方法&lt;br /&gt;
awk &amp;lsquo;{if(length($0)&amp;lt;=65)print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示部分文本-从包含正则表达式的行开始到最后一行结束&#34;&gt;显示部分文本——从包含正则表达式的行开始到最后一行结束&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/regexp/,$p&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;/regexp/{F=1}{if(F)print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示部分文本-指定行号范围-从第8至第12行-含8和12行&#34;&gt;显示部分文本——指定行号范围（从第8至第12行，含8和12行）&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;8,12p&amp;rsquo;                   # 方法1&lt;br /&gt;
sed &amp;lsquo;8,12!d&amp;rsquo;                     # 方法2&lt;br /&gt;
awk &amp;lsquo;{if(NR&amp;gt;=8 &amp;amp;&amp;amp; NR&amp;lt;12)print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示第52行&#34;&gt;显示第52行&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;52p&amp;rsquo;                     # 方法1&lt;br /&gt;
sed &amp;lsquo;52!d&amp;rsquo;                       # 方法2&lt;br /&gt;
sed &amp;lsquo;52q;d&amp;rsquo;                      # 方法3, 处理大文件时更有效率&lt;br /&gt;
awk &amp;lsquo;{if(NR==52){print;exit}}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;从第3行开始-每7行显示一次&#34;&gt;从第3行开始，每7行显示一次&lt;/h1&gt;

&lt;p&gt;gsed -n &amp;lsquo;3~7p&amp;rsquo;                   # 只对GNU sed有效&lt;br /&gt;
sed -n &amp;lsquo;3,${p;n;n;n;n;n;n;}&amp;rsquo;     # 其他sed&lt;br /&gt;
awk &amp;lsquo;{if(NR==3)F=1}{if(F){i++;if(i%7==1)print}}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;显示两个正则表达式之间的文本-包含&#34;&gt;显示两个正则表达式之间的文本（包含）&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/Iowa/,/Montana/p&amp;rsquo;       # 区分大小写方式&lt;br /&gt;
awk &amp;lsquo;/Iowa/{F=1}{if(F)print}/Montana/{F=0}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;选择性地删除特定行：&lt;/p&gt;

&lt;h1 id=&#34;显示通篇文档-除了两个正则表达式之间的内容&#34;&gt;显示通篇文档，除了两个正则表达式之间的内容&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/Iowa/,/Montana/d&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;/Iowa/{F=1}{if(!F)print}/Montana/{F=0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件中相邻的重复行-模拟-uniq&#34;&gt;删除文件中相邻的重复行（模拟“uniq”）&lt;/h1&gt;

&lt;h1 id=&#34;只保留重复行中的第一行-其他行删除&#34;&gt;只保留重复行中的第一行，其他行删除&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;$!N; /^(.*)\n\1$/!P; D&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if($0!=B)print;B=$0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件中的重复行-不管有无相邻-注意hold-space所能支持的缓存大小-或者使用gnu-sed&#34;&gt;删除文件中的重复行，不管有无相邻。注意hold space所能支持的缓存大小，或者使用GNU sed。&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;G; s/\n/&amp;amp;&amp;amp;/; /^([ -~]&lt;em&gt;\n).&lt;/em&gt;\n\1/d; s/\n//; h; P&amp;rsquo;  #bones7456注：我这里此命令并不能正常工作&lt;br /&gt;
awk &amp;lsquo;{if(!($0 in B))print;B[$0]=1}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除除重复行外的所有行-模拟-uniq-d&#34;&gt;删除除重复行外的所有行（模拟“uniq -d”）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;$!N; s/^(.*)\n\1$/\1/; t; D&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if($0==B &amp;amp;&amp;amp; $0!=l){print;l=$0}B=$0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件中开头的10行&#34;&gt;删除文件中开头的10行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;1,10d&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(NR&amp;gt;10)print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件中的最后一行&#34;&gt;删除文件中的最后一行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;$d&amp;rsquo;&lt;/p&gt;

&lt;p&gt;#awk在过程中并不知道文件一共有几行，所以只能通篇缓存，大文件可能不适合，下面两个也一样&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;{B[NR]=$0}END{for(i=0;i&amp;lt;=NR-1;i++)print B[i]}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件中的最后两行&#34;&gt;删除文件中的最后两行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;N;$!P;$!D;$d&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{B[NR]=$0}END{for(i=0;i&amp;lt;=NR-2;i++)print B[i]}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件中的最后10行&#34;&gt;删除文件中的最后10行&lt;/h1&gt;

&lt;p&gt;sed -e :a -e &amp;lsquo;$d;N;2,10ba&amp;rsquo; -e &amp;lsquo;P;D&amp;rsquo;   # 方法1&lt;br /&gt;
sed -n -e :a -e &amp;lsquo;1,10!{P;N;D;};N;ba&amp;rsquo;  # 方法2&lt;br /&gt;
awk &amp;lsquo;{B[NR]=$0}END{for(i=0;i&amp;lt;=NR-10;i++)print B[i]}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除8的倍数行&#34;&gt;删除8的倍数行&lt;/h1&gt;

&lt;p&gt;gsed &amp;lsquo;0~8d&amp;rsquo;                           # 只对GNU sed有效&lt;br /&gt;
sed &amp;lsquo;n;n;n;n;n;n;n;d;&amp;rsquo;                # 其他sed&lt;br /&gt;
awk &amp;lsquo;{if(NR%8!=0)print}&amp;rsquo; |head&lt;/p&gt;

&lt;h1 id=&#34;删除匹配式样的行&#34;&gt;删除匹配式样的行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/pattern/d&amp;rsquo;                      # 删除含pattern的行。当然pattern可以换成任何有效的正则表达式&lt;br /&gt;
awk &amp;lsquo;{if(!match($0,/pattern/))print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件中的所有空行-与-grep-效果相同&#34;&gt;删除文件中的所有空行（与“grep ‘.’ ”效果相同）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/^$/d&amp;rsquo;                           # 方法1&lt;br /&gt;
sed &amp;lsquo;/./!d&amp;rsquo;                           # 方法2&lt;br /&gt;
awk &amp;lsquo;{if(!match($0,/^$/))print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;只保留多个相邻空行的第一行-并且删除文件顶部和尾部的空行&#34;&gt;只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。&lt;/h1&gt;

&lt;h1 id=&#34;模拟-cat-s&#34;&gt;（模拟“cat -s”）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/./,/^$/!d&amp;rsquo;        #方法1，删除文件顶部的空行，允许尾部保留一空行&lt;br /&gt;
sed &amp;lsquo;/^$/N;/\n$/D&amp;rsquo;      #方法2，允许顶部保留一空行，尾部不留空行&lt;br /&gt;
awk &amp;lsquo;{if(!match($0,/^$/)){print;F=1}else{if(F)print;F=0}}&amp;rsquo;  #同上面的方法2&lt;/p&gt;

&lt;h1 id=&#34;只保留多个相邻空行的前两行&#34;&gt;只保留多个相邻空行的前两行。&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/^$/N;/\n$/N;//D&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(!match($0,/^$/)){print;F=0}else{if(F&amp;lt;2)print;F++}}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件顶部的所有空行&#34;&gt;删除文件顶部的所有空行&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/./,$!d&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{if(F || !match($0,/^$/)){print;F=1}}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除文件尾部的所有空行&#34;&gt;删除文件尾部的所有空行&lt;/h1&gt;

&lt;p&gt;sed -e :a -e &amp;lsquo;/^\n&lt;em&gt;$/{$d;N;ba&amp;rsquo; -e &amp;lsquo;}&amp;rsquo;  # 对所有sed有效&lt;br /&gt;
sed -e :a -e &amp;lsquo;/^\n&lt;/em&gt;$/N;/\n$/ba&amp;rsquo;        # 同上，但只对 gsed 3.02.*有效&lt;br /&gt;
awk &amp;lsquo;/^.+$/{for(i=l;i&amp;lt;NR-1;i++)print &amp;ldquo;&amp;rdquo;;print;l=NR}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;删除每个段落的最后一行&#34;&gt;删除每个段落的最后一行&lt;/h1&gt;

&lt;p&gt;sed -n &amp;lsquo;/^$/{p;h;};/./{x;/./p;}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;#很长，很ugly，应该有更好的办法&lt;/p&gt;

&lt;p&gt;awk -vRS= &amp;lsquo;{B=$0;l=0;f=1;while(match(B,/\n/)&amp;gt;0){print substr(B,l,RSTART-l-f);l=RSTART;sub(/\n/,&amp;ldquo;&amp;rdquo;,B);f=0};print &amp;ldquo;&amp;rdquo;}&amp;rsquo;&lt;/p&gt;

&lt;p&gt;特殊应用：&lt;/p&gt;

&lt;h1 id=&#34;移除手册页-man-page-中的nroff标记-在unix-system-v或bash-shell下使&#34;&gt;移除手册页（man page）中的nroff标记。在Unix System V或bash shell下使&lt;/h1&gt;

&lt;h1 id=&#34;用-echo-命令时可能需要加上-e-选项&#34;&gt;用’echo’命令时可能需要加上 -e 选项。&lt;/h1&gt;

&lt;p&gt;sed &amp;ldquo;s/.&lt;code&gt;echo \\\b&lt;/code&gt;//g&amp;rdquo;    # 外层的双括号是必须的（Unix环境）&lt;br /&gt;
sed &amp;rsquo;s/.^H//g&amp;rsquo;             # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H&lt;br /&gt;
sed &amp;rsquo;s/.\x08//g&amp;rsquo;           # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法&lt;br /&gt;
awk &amp;lsquo;{gsub(/.\x08/,&amp;ldquo;&amp;rdquo;,$0);print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;提取新闻组或-e-mail-的邮件头&#34;&gt;提取新闻组或 e-mail 的邮件头&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/^$/q&amp;rsquo;                # 删除第一行空行后的所有内容&lt;br /&gt;
awk &amp;lsquo;{print}/^$/{exit}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;提取新闻组或-e-mail-的正文部分&#34;&gt;提取新闻组或 e-mail 的正文部分&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;1,/^$/d&amp;rsquo;              # 删除第一行空行之前的所有内容&lt;br /&gt;
awk &amp;lsquo;{if(F)print}/^$/{F=1}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;从邮件头提取-subject-标题栏字段-并移除开头的-subject-字样&#34;&gt;从邮件头提取“Subject”（标题栏字段），并移除开头的“Subject:”字样&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/^Subject: &lt;em&gt;/!d; s///;q&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;/^Subject:.&lt;/em&gt;/{print substr($0,10)}/^$/{exit}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;从邮件头获得回复地址&#34;&gt;从邮件头获得回复地址&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/^Reply-To:/q; /^From:/h; /./d;g;q&amp;rsquo;&lt;/p&gt;

&lt;p&gt;#好像是输出第一个Reply-To:开头的行？From是干啥用的？不清楚规则。。&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;/^Reply-To:.*/{print;exit}/^$/{exit}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;获取邮件地址-在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮地址的部分剃除-见上一脚本&#34;&gt;获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮地址的部分剃除。（见上一脚本）&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/ &lt;em&gt;(.&lt;/em&gt;)//; s/&amp;gt;.&lt;em&gt;//; s/.&lt;/em&gt;[:&amp;lt;] *//&amp;rsquo;&lt;/p&gt;

&lt;p&gt;#取尖括号里的东西吧？&lt;/p&gt;

&lt;p&gt;awk -F&amp;rsquo;[&amp;lt;&amp;gt;]+&amp;rsquo; &amp;lsquo;{print $2}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;在每一行开头加上一个尖括号和空格-引用信息&#34;&gt;在每一行开头加上一个尖括号和空格（引用信息）&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/^/&amp;gt; /&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;{print &amp;ldquo;&amp;gt; &amp;rdquo; $0}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将每一行开头处的尖括号和空格删除-解除引用&#34;&gt;将每一行开头处的尖括号和空格删除（解除引用）&lt;/h1&gt;

&lt;p&gt;sed &amp;rsquo;s/^&amp;gt; //&amp;rsquo;&lt;br /&gt;
awk &amp;lsquo;/^&amp;gt; /{print substr($0,3)}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;移除大部分的html标签-包括跨行标签&#34;&gt;移除大部分的HTML标签（包括跨行标签）&lt;/h1&gt;

&lt;p&gt;sed -e :a -e &amp;rsquo;s/&amp;lt;[^&amp;gt;]&lt;em&gt;&amp;gt;//g;/&lt;/N;//ba&#39;  
awk &#39;{gsub(/&lt;[^&gt;]&lt;/em&gt;&amp;gt;/,&amp;ldquo;&amp;rdquo;,$0);print}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;将分成多卷的uuencode文件解码-移除文件头信息-只保留uuencode编码部分&#34;&gt;将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。&lt;/h1&gt;

&lt;h1 id=&#34;文件必须以特定顺序传给sed-下面第一种版本的脚本可以直接在命令行下输入&#34;&gt;文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入；&lt;/h1&gt;

&lt;h1 id=&#34;第二种版本则可以放入一个带执行权限的shell脚本中-由rahul-dhesi的一&#34;&gt;第二种版本则可以放入一个带执行权限的shell脚本中。（由Rahul Dhesi的一&lt;/h1&gt;

&lt;h1 id=&#34;个脚本修改而来&#34;&gt;个脚本修改而来。）&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/^end/,/^begin/d&amp;rsquo; file1 file2 &amp;hellip; fileX | uudecode   # vers. 1&lt;br /&gt;
sed &amp;lsquo;/^end/,/^begin/d&amp;rsquo; &amp;ldquo;$@&amp;rdquo; | uudecode                    # vers. 2&lt;/p&gt;

&lt;p&gt;#我不想装个uudecode验证，大致写个吧&lt;/p&gt;

&lt;p&gt;awk &amp;lsquo;/^end/{F=0}{if(F)print}/^begin/{F=1}&amp;rsquo; file1 file2 &amp;hellip; fileX&lt;/p&gt;

&lt;h1 id=&#34;将文件中的段落以字母顺序排序-段落间以-一行或多行-空行分隔-gnu-sed使用&#34;&gt;将文件中的段落以字母顺序排序。段落间以（一行或多行）空行分隔。GNU sed使用&lt;/h1&gt;

&lt;h1 id=&#34;字元-v-来表示垂直制表符-这里用它来作为换行符的占位符-当然你也可以&#34;&gt;字元“\v”来表示垂直制表符，这里用它来作为换行符的占位符——当然你也可以&lt;/h1&gt;

&lt;h1 id=&#34;用其他未在文件中使用的字符来代替它&#34;&gt;用其他未在文件中使用的字符来代替它。&lt;/h1&gt;

&lt;p&gt;sed &amp;lsquo;/./{H;d;};x;s/\n/={NL}=/g&amp;rsquo; file | sort | sed &amp;lsquo;1s/={NL}=//;s/={NL}=/\n/g&amp;rsquo;&lt;br /&gt;
gsed &amp;lsquo;/./{H;d};x;y/\n/\v/&amp;rsquo; file | sort | sed &amp;lsquo;1s/\v//;y/\v/\n/&amp;rsquo;&lt;br /&gt;
awk -vRS= &amp;lsquo;{gsub(/\n/,&amp;rdquo;\v&amp;rdquo;,$0);print}&amp;rsquo; ll.txt | sort | awk &amp;lsquo;{gsub(/\v/,&amp;rdquo;\n&amp;rdquo;,$0);print;print &amp;ldquo;&amp;rdquo;}&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;分别压缩每个-txt文件-压缩后删除原来的文件并将压缩后的-zip文件&#34;&gt;分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件&lt;/h1&gt;

&lt;h1 id=&#34;命名为与原来相同的名字-只是扩展名不同-dos环境-dir-b&#34;&gt;命名为与原来相同的名字（只是扩展名不同）。（DOS环境：“dir /b”&lt;/h1&gt;

&lt;h1 id=&#34;显示不带路径的文件名&#34;&gt;显示不带路径的文件名）。&lt;/h1&gt;

&lt;p&gt;echo @echo off &amp;gt;zipup.bat&lt;br /&gt;
dir /b &lt;em&gt;.txt | sed &amp;ldquo;s/^(.&lt;/em&gt;).TXT/pkzip -mo \1 \1.TXT/&amp;rdquo; &amp;gt;&amp;gt;zipup.bat&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:t&#34;&gt; \t &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:t&#34;&gt; \t &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:t&#34;&gt; \t &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:t&#34;&gt; \t &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 Composer</title>
            <link>//blog.pytool.com/cmd/2016-03-29-linux%E5%91%BD%E4%BB%A4-composer/</link>
            <pubDate>Tue, 29 Mar 2016 20:57:24 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-03-29-linux%E5%91%BD%E4%BB%A4-composer/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://pkg.phpcomposer.com/&#34; target=&#34;_blank&#34;&gt;install&lt;/a&gt;&lt;br /&gt;
Packagist 镜像&lt;/p&gt;

&lt;p&gt;请各位使用本镜像的同学注意：&lt;/p&gt;

&lt;p&gt;本镜像已经依照 composer 官方的数据源安全策略完全升级并支持 https 协议！请各位同学 按照下面所示的两个方法将 &lt;a href=&#34;http://packagist.phpcomposer.com&#34; target=&#34;_blank&#34;&gt;http://packagist.phpcomposer.com&lt;/a&gt; 修改为 &lt;a href=&#34;https://packagist.phpcomposer.com&#34; target=&#34;_blank&#34;&gt;https://packagist.phpcomposer.com&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;还没安装 Composer 吗？请往下看如何安装 Composer 。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;p&gt;有两种方式启用本镜像服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;系统全局配置： 即将配置信息添加到 Composer 的全局配置文件 config.json 中。见“例1”  
单个项目配置： 将配置信息添加到某个项目的 composer.json 文件中。见“例2”  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例1：修改 composer 的全局配置文件（推荐方式）&lt;/p&gt;

&lt;p&gt;打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;composer config -g repo.packagist composer https://packagist.phpcomposer.com  
&lt;/code&gt;&lt;br /&gt;
例2：修改当前项目的 composer.json 配置文件：&lt;/p&gt;

&lt;p&gt;打开命令行窗口（windows用户）或控制台（Linux、Mac 用户），进入你的项目的根目录（也就是 composer.json 文件所在目录），执行如下命令：&lt;/p&gt;

&lt;p&gt;composer config repo.packagist composer &lt;a href=&#34;https://packagist.phpcomposer.com&#34; target=&#34;_blank&#34;&gt;https://packagist.phpcomposer.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上述命令将会在当前项目中的 composer.json 文件的末尾自动添加镜像的配置信息（你也可以自己手工添加）：&lt;/p&gt;

&lt;p&gt;&amp;ldquo;repositories&amp;rdquo;: {&lt;br /&gt;
    &amp;ldquo;packagist&amp;rdquo;: {&lt;br /&gt;
        &amp;ldquo;type&amp;rdquo;: &amp;ldquo;composer&amp;rdquo;,&lt;br /&gt;
        &amp;ldquo;url&amp;rdquo;: &amp;ldquo;&lt;a href=&#34;https://packagist.phpcomposer.com&amp;quot;&#34; target=&#34;_blank&#34;&gt;https://packagist.phpcomposer.com&amp;quot;&lt;/a&gt;&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;以 laravel 项目的 composer.json 配置文件为例，执行上述命令后如下所示（注意最后几行）：&lt;/p&gt;

&lt;p&gt;{&lt;br /&gt;
    &amp;ldquo;name&amp;rdquo;: &amp;ldquo;laravel/laravel&amp;rdquo;,&lt;br /&gt;
    &amp;ldquo;description&amp;rdquo;: &amp;ldquo;The Laravel Framework.&amp;rdquo;,&lt;br /&gt;
    &amp;ldquo;keywords&amp;rdquo;: [&amp;ldquo;framework&amp;rdquo;, &amp;ldquo;laravel&amp;rdquo;],&lt;br /&gt;
    &amp;ldquo;license&amp;rdquo;: &amp;ldquo;MIT&amp;rdquo;,&lt;br /&gt;
    &amp;ldquo;type&amp;rdquo;: &amp;ldquo;project&amp;rdquo;,&lt;br /&gt;
    &amp;ldquo;config&amp;rdquo;: {&lt;br /&gt;
        &amp;ldquo;preferred-install&amp;rdquo;: &amp;ldquo;dist&amp;rdquo;&lt;br /&gt;
    },&lt;br /&gt;
    &amp;ldquo;repositories&amp;rdquo;: {&lt;br /&gt;
        &amp;ldquo;packagist&amp;rdquo;: {&lt;br /&gt;
            &amp;ldquo;type&amp;rdquo;: &amp;ldquo;composer&amp;rdquo;,&lt;br /&gt;
            &amp;ldquo;url&amp;rdquo;: &amp;ldquo;&lt;a href=&#34;https://packagist.phpcomposer.com&amp;quot;&#34; target=&#34;_blank&#34;&gt;https://packagist.phpcomposer.com&amp;quot;&lt;/a&gt;&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;OK，一切搞定！试一下 composer install 来体验飞一般的速度吧！&lt;/p&gt;

&lt;h2 id=&#34;安装composer&#34;&gt;安装composer&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;code&gt;sudo apt install composer --no-install-recommends&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;curl -sS https://getcomposer.org/installer | php&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;php -r &amp;quot;readfile(&#39;https://getcomposer.org/installer&#39;);&amp;quot; | php&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;curl -sS https://getcomposer.org/installer | php7.0 -- --install-dir=/usr/local/bin --filename=composer&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;php7.0 -r &amp;quot;readfile(&#39;https://getcomposer.org/installer&#39;);&amp;quot; |  php7.0 -- --install-dir /usr/local/bin --filename composer&lt;/code&gt;&lt;br /&gt;
3.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php -r &amp;quot;copy(&#39;https://getcomposer.org/installer&#39;, &#39;composer-setup.php&#39;);&amp;quot;  
php -r &amp;quot;if (hash_file(&#39;SHA384&#39;, &#39;composer-setup.php&#39;) === &#39;070854512ef404f16bac87071a6db9fd9721da1684cd4589b1196c3faf71b9a2682e2311b36a5079825e155ac7ce150d&#39;) { echo &#39;Installer verified&#39;; } else { echo &#39;Installer corrupt&#39;; unlink(&#39;composer-setup.php&#39;); } echo PHP_EOL;&amp;quot;  
php composer-setup.php  
php -r &amp;quot;unlink(&#39;composer-setup.php&#39;);&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;php composer.phar install&lt;/p&gt;

&lt;p&gt;sudo mv composer.phar /usr/bin/composer&lt;/p&gt;

&lt;p&gt;Windows 系统：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;找到并进入 PHP 的安装目录（和你在命令行中执行的 php 指令应该是同一套 PHP）。  
将 composer.phar 复制到 PHP 的安装目录下面，也就是和 php.exe 在同一级目录。  
在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@php &amp;ldquo;%~dp0composer.phar&amp;rdquo; %*&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;修改composer Packagist 镜像&lt;br /&gt;
composer config -g repo.packagist composer &lt;a href=&#34;https://packagist.phpcomposer.com&#34; target=&#34;_blank&#34;&gt;https://packagist.phpcomposer.com&lt;/a&gt;&lt;br /&gt;
composer config repo.packagist composer &lt;a href=&#34;https://packagist.phpcomposer.com&#34; target=&#34;_blank&#34;&gt;https://packagist.phpcomposer.com&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;更新composer&lt;br /&gt;
&lt;code&gt;composer selfupdate&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;################################################################################&lt;/p&gt;

&lt;h1 id=&#34;安装-laravel&#34;&gt;安装 Laravel&lt;/h1&gt;

&lt;p&gt;/etc/apt/sources.list.d/ondrej-php-7_0-trusty.list&lt;br /&gt;
  deb &lt;a href=&#34;http://ppa.launchpad.net/ondrej/php/ubuntu&#34; target=&#34;_blank&#34;&gt;http://ppa.launchpad.net/ondrej/php/ubuntu&lt;/a&gt; trusty main&lt;/p&gt;

&lt;p&gt;sudo apt-get update&lt;br /&gt;
sudo apt-get install php-mbstring&lt;br /&gt;
sudo apt-get install mcrypt php7.0-mcrypt&lt;br /&gt;
sudo apt-get upgrade&lt;/p&gt;

&lt;p&gt;composer create-project laravel/laravel learnlaravel5&lt;/p&gt;

&lt;p&gt;composer update&lt;/p&gt;

&lt;p&gt;cd public&lt;br /&gt;
php -S 0.0.0.0:1024&lt;/p&gt;

&lt;h2 id=&#34;添加用户&#34;&gt;添加用户&lt;/h2&gt;

&lt;p&gt;;&amp;ldquo;laravel/framework&amp;rdquo;: &amp;ldquo;5.2.* &amp;ldquo;,&lt;br /&gt;
php artisan make:auth&lt;/p&gt;

&lt;h2 id=&#34;添加数据库&#34;&gt;添加数据库&lt;/h2&gt;

&lt;p&gt;;could not find driver&lt;br /&gt;
sudo apt-get -y install php-mysql&lt;/p&gt;

&lt;p&gt;;SQLSTATE[HY000] [1044] Access denied for user &amp;lsquo;homestead&amp;rsquo;@&amp;lsquo;%&amp;rsquo; to database &amp;lsquo;homestead&amp;rsquo;&lt;br /&gt;
vim .env&lt;br /&gt;
  DB_HOST=127.0.0.1&lt;br /&gt;
  DB_PORT=3306&lt;br /&gt;
  DB_DATABASE=laravel5&lt;br /&gt;
  DB_USERNAME=root&lt;br /&gt;
  DB_PASSWORD=&amp;rdquo;&lt;br /&gt;
php artisan config:clear&lt;/p&gt;

&lt;p&gt;create user homestead;&lt;br /&gt;
set password for homestead = password(&amp;lsquo;secret&amp;rsquo;);&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>强大的管理web包管理工具 bower</title>
            <link>//blog.pytool.com/cmd/2016-06-01-linux%E5%91%BD%E4%BB%A4-bower/</link>
            <pubDate>Thu, 24 Mar 2016 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-06-01-linux%E5%91%BD%E4%BB%A4-bower/</guid>
            <description>&lt;p&gt;先安装bower(确保先有node环境)&lt;br /&gt;
npm install bower -g&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 VLC</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-vlc/</link>
            <pubDate>Fri, 26 Feb 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-vlc/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/gavinr/article/details/7287939&#34; target=&#34;_blank&#34;&gt;vlc的流输出功能&lt;/a&gt;&lt;br /&gt;
2)使用rtsp进行传输&lt;br /&gt;
vlc Android.mp4 -vvv  &amp;ndash;loop &amp;ndash;sout &amp;ldquo;#rtp{sdp=rtsp://127.0.0.1:10086/stream}&amp;rdquo;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux命令 ffmpeg</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-ffmpeg/</link>
            <pubDate>Fri, 26 Feb 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-ffmpeg/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://wenku.baidu.com/view/296eefcaf90f76c661371af1.html&#34; target=&#34;_blank&#34;&gt;FFmpeg基础&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/doublefi123/article/details/24325159&#34; target=&#34;_blank&#34;&gt;FFmpeg基本用法&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/dwdxdy/p/3240167.html&#34; target=&#34;_blank&#34;&gt;FFmpeg常用基本命令&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/hsg1040175759/article/details/18715249&#34; target=&#34;_blank&#34;&gt;ffmpeg 使用小记&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/xiaofengfeng/p/3573025.html&#34; target=&#34;_blank&#34;&gt;ffmpeg常用转换命令，支持WAV转AMR&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.easydarwin.org/article/Streaming/62.html&#34; target=&#34;_blank&#34;&gt;用ffmpeg+nginx服务器实现类似酒店视频直播系统&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.easydarwin.org/article/EasyDarwin/30.html&#34; target=&#34;_blank&#34;&gt;ffmpeg推送,EasyDarwin转发,vlc播放 实现整个RTSP直播&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/leixiaohua1020/article/details/12029543&#34; target=&#34;_blank&#34;&gt;ffmpeg处理RTMP流媒体的命令大全&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/dongdong_java/article/details/19604975?utm_source=tuicool&amp;amp;utm_medium=referral&#34; target=&#34;_blank&#34;&gt;ffmpeg RTMP&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/leixiaohua1020/article/details/38284961&#34; target=&#34;_blank&#34;&gt;FFmpeg获取DirectShow设备数据（摄像头，录屏）&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://hdu104.com/294&#34; target=&#34;_blank&#34;&gt;基于Nginx搭建mp4/flv流媒体服务器&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.mamicode.com/info-detail-1164079.html&#34; target=&#34;_blank&#34;&gt;M3U8 的简单实现 nginx+ffmpeg&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/kuoxin/p/4623642.html&#34; target=&#34;_blank&#34;&gt;使用FFmpeg生成HLS视频&lt;/a&gt;&lt;br /&gt;
##############################&lt;br /&gt;
 ffmpeg强制使用TCP方式读取rtsp流&lt;br /&gt;
 “ffmpeg &lt;em&gt;-rtsp_transport&lt;/em&gt; tcp -i rtsp://admin&amp;hellip;&amp;hellip;.”&lt;br /&gt;
#######&lt;/p&gt;

&lt;p&gt;##############################&lt;/p&gt;

&lt;h1 id=&#34;内存虚拟硬盘&#34;&gt;内存虚拟硬盘&lt;/h1&gt;

&lt;p&gt;sudo mkdir /mnt/ramdisk&lt;/p&gt;

&lt;p&gt;sudo mount -t tmpfs tmpfs /mnt/ramdisk  -o size=2G,defaults,noatime,mode=777&lt;br /&gt;
sudo mkdir -p /mnt/ramdisk/hls/mystream/&lt;/p&gt;

&lt;h1 id=&#34;ffmpeg-loglevel-verbose-re-i-android-mp4-vcodec-libx264-vprofile-baseline-acodec-libmp3lame-ar-44100-ac-1-f-flv-rtmp-localhost-1935-hls-movie&#34;&gt;ffmpeg -loglevel verbose -re -i Android.mp4  -vcodec libx264 -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1    -f flv rtmp://localhost:1935/hls/movie&lt;/h1&gt;

&lt;p&gt;ffmpeg -loglevel verbose -re -i demo.mp4  -vcodec libx264 -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1    -f flv rtmp://localhost:1935/hls/mystream&lt;/p&gt;

&lt;h2 id=&#34;推送hls直播&#34;&gt;推送HLS直播&lt;/h2&gt;

&lt;p&gt;ffmpeg -re -i demo.mp4 -c:v libx264 -c:a aac -f hls -hls_list_size 5 -hls_wrap 5 /mnt/ramdisk/hls/mystream/index.m3u8&lt;br /&gt;
sudo ffmpeg -re -i demo.mp4 -c:v libx264 -c:a copy -f hls -hls_list_size 5 -hls_wrap 5 /mnt/ramdisk/hls/mystream/index.m3u8&lt;br /&gt;
sudo ffmpeg -re -i demo.mp4 -c:v libx264 -c:a copy -f hls -hls_list_size 5 -hls_wrap 5 /home/ubuntu/EasyDarwin/EasyDarwin/x64/Movies/hls/mystream/index.m3u8&lt;/p&gt;

&lt;p&gt;sudo ffmpeg -re -i demo.mp4 -c:v copy -acodec copy  -f rtsp rtsp://139.129.108.163:6554/test.sdp&lt;br /&gt;
sudo ffmpeg -re -i demo.mp4 -vcodec copy -acodec copy  -rtsp_transport tcp -f rtsp rtsp://139.129.108.163:6554/test.sdp&lt;/p&gt;

&lt;p&gt;sudo ffmpeg -re -i demo.mp4 -vcodec copy -acodec copy  -rtsp_transport tcp -f rtsp rtsp://121.40.50.44:554/test.sdp&lt;br /&gt;
1.点播&lt;br /&gt;
在对应路径下直接可以播放&lt;br /&gt;
2.rtsp直播&lt;br /&gt;
ffmpeg -re -i localFile.mp4 -c copy -f flv rtmp://server/live/streamName&lt;br /&gt;
3.实现hls直播&lt;br /&gt;
rtmp{&lt;br /&gt;
    server {&lt;br /&gt;
        listen 1935;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    application myapp {  
        live on;  
        exec ffmpeg -i rtmp://localhost/myapp/$name -c:a copy  -c:v libx264 -b:v 512K -g 30 -f flv rtmp://localhost/hls/$name_low;  
    }  

    application hls {  
        live on;  
        hls on;  
        hls_path /mnt/ramdisk/hls;  
        hls_nested on;  
        hls_fragment 2s;  
        hls_playlist_length 6s;  
        hls_variant_hi  BANDWIDTH=640000;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
http{&lt;br /&gt;
    server {&lt;br /&gt;
        location /hls {&lt;br /&gt;
            types {&lt;br /&gt;
                application/x-mpegURL m3u8;&lt;br /&gt;
                application/vnd.apple.mpegusr m3u8;&lt;br /&gt;
                video/mp2t ts;&lt;br /&gt;
            }&lt;br /&gt;
            root /mnt/ramdisk;&lt;br /&gt;
            # alias /usr/local/nginx/html/hls/;&lt;br /&gt;
            add_header Cache-Control no-cache;&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;ffmpeg -loglevel verbose -re -i demo.mp4  -vcodec libx264 -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1    -f flv rtmp://localhost:1935/hls/mystream&lt;br /&gt;
&lt;a href=&#34;http://www.cutv.com/demo/live_test.swf&#34; target=&#34;_blank&#34;&gt;测试地址&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://127.0.0.1:8080/hls/mystream.m3u8&#34; target=&#34;_blank&#34;&gt;http://127.0.0.1:8080/hls/mystream.m3u8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://192.168.1.108/hls/mystream/index.m3u8&#34; target=&#34;_blank&#34;&gt;http://192.168.1.108/hls/mystream/index.m3u8&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;nginx-rtmp&#34;&gt;Nginx RTMP&lt;/h2&gt;

&lt;p&gt;实现rtmp 转播&lt;br /&gt;
ffmpeg -i rtsp://218.204.223.237:554/live/1/67A7572844E51A64/f68g2mj7wjua3la7.sdp -vcodec copy -acodec copy  -f flv rtmp://localhost:1935/myapp/mystream&lt;br /&gt;
实现hls转播&lt;br /&gt;
ffmpeg -i rtsp://218.204.223.237:554/live/1/67A7572844E51A64/f68g2mj7wjua3la7.sdp -vcodec copy -acodec copy  -f flv rtmp://localhost:1935/hls/mystream&lt;/p&gt;

&lt;p&gt;#######easyDarwin###############&lt;br /&gt;
[ffmpeg推送,EasyDarwin转发,vlc播放 实现整个RTSP直播]&lt;br /&gt;
2、例如，我们的摄像机地址是 rtsp://admin:admin@192.168.66.119/，ffmpeg命令如下：&lt;br /&gt;
ffmpeg -i rtsp://218.204.223.237:554/live/1/67A7572844E51A64/f68g2mj7wjua3la7.sdp -vcodec copy -acodec copy  -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp&lt;/p&gt;

&lt;p&gt;也可以进行音视频转码后推送：&lt;br /&gt;
ffmpeg -i rtsp://218.204.223.237:554/live/1/67A7572844E51A64/f68g2mj7wjua3la7.sdp -vcodec libx264 -an  -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp&lt;/p&gt;

&lt;p&gt;第一步：用ffmpeg将网络直播源拉取到内网，切片成m3u8+ts（这里我们假设直播源为：&lt;a href=&#34;http://111.1.62.218/gitv_live/CCTV-1-HD/CCTV-1-HD.m3u8）&#34; target=&#34;_blank&#34;&gt;http://111.1.62.218/gitv_live/CCTV-1-HD/CCTV-1-HD.m3u8）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;执行命令：ffmpeg -i &lt;a href=&#34;http://111.1.62.218/gitv_live/CCTV-1-HD/CCTV-1-HD.m3u8&#34; target=&#34;_blank&#34;&gt;http://111.1.62.218/gitv_live/CCTV-1-HD/CCTV-1-HD.m3u8&lt;/a&gt; -f hls -hls_list_size 5 -hls_time 10 -hls_wrap 10 ./live/live.m3u8&lt;br /&gt;
###################&lt;br /&gt;
1.分离视频音频流&lt;/p&gt;

&lt;p&gt;ffmpeg -i input_file -vcodec copy -an output_file_video　　//分离视频流&lt;br /&gt;
ffmpeg -i input_file -acodec copy -vn output_file_audio　　//分离音频流&lt;br /&gt;
2.视频解复用&lt;/p&gt;

&lt;p&gt;ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264&lt;br /&gt;
ffmpeg –i test.avi –vcodec copy –an –f m4v test.264&lt;br /&gt;
3.视频转码&lt;/p&gt;

&lt;p&gt;ffmpeg –i test.mp4 –vcodec h264 –s 352*278 –an –f m4v test.264              //转码为码流原始文件&lt;br /&gt;
ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352*278 –an –f m4v test.264  //转码为码流原始文件&lt;br /&gt;
ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi            //转码为封装文件&lt;br /&gt;
//-bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制&lt;br /&gt;
4.视频封装&lt;/p&gt;

&lt;p&gt;ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file&lt;br /&gt;
5.视频剪切&lt;/p&gt;

&lt;p&gt;ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg        //提取图片&lt;br /&gt;
ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi    //剪切视频&lt;br /&gt;
//-r 提取图像的频率，-ss 开始时间，-t 持续时间&lt;br /&gt;
6.视频录制&lt;/p&gt;

&lt;p&gt;ffmpeg –i rtsp://192.168.3.205:5555/test –vcodec copy out.avi&lt;br /&gt;
7.YUV序列播放&lt;/p&gt;

&lt;p&gt;ffplay -f rawvideo -video_size 1920x1080 input.yuv&lt;br /&gt;
8.YUV序列转AVI&lt;/p&gt;

&lt;p&gt;ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi&lt;/p&gt;

&lt;p&gt;常用参数说明：&lt;/p&gt;

&lt;p&gt;主要参数：&lt;br /&gt;
-i 设置输入流&lt;br /&gt;
-f 设置输出格式&lt;br /&gt;
-ss 开始时间&lt;br /&gt;
-re 按照帧率发送&lt;/p&gt;

&lt;p&gt;视频参数：&lt;br /&gt;
-b 设定视频流量，默认为200Kbit/s&lt;br /&gt;
-b:v  设置码率-b bitrate          video bitrate (please use -b:v)&lt;br /&gt;
-r 设定帧速率，默认为25&lt;br /&gt;
-s 设定画面的分辨率 -s 640x480&lt;br /&gt;
-aspect 设定画面的比例&lt;br /&gt;
-vn 不处理视频&lt;br /&gt;
-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器&lt;br /&gt;
-c:v  设置视频编码器&lt;/p&gt;

&lt;p&gt;音频参数：&lt;br /&gt;
-ar 设定采样率&lt;br /&gt;
-ac 设定声音的Channel数&lt;br /&gt;
-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器&lt;br /&gt;
-an 不处理音频&lt;br /&gt;
-c:a  设置音频编码器&lt;/p&gt;

&lt;p&gt;ffmpeg -formats       #查看所有支持的容器格式&lt;br /&gt;
ffmpeg -codecs        #查看所有编解码器&lt;br /&gt;
ffmpeg -filters       #查看所有可用的filter&lt;br /&gt;
                    -vf 视频过滤器 -vf filter_graph    set video filters&lt;br /&gt;
                    -vf setpts=PTS/3 3倍视频&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                -af 音频过滤器  
                -af atempo=2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ffmpeg -pix_fmts      #查看所有支持的图片格式&lt;br /&gt;
ffmpeg -sample_fmts   #查看所有支持的像素格式&lt;br /&gt;
ffprobe -i money.mp4  #查看媒体信息&lt;/p&gt;

&lt;p&gt;-buildconf          show build configuration&lt;br /&gt;
-formats            show available formats&lt;br /&gt;
-devices            show available devices&lt;br /&gt;
-codecs             show available codecs&lt;br /&gt;
                   D&amp;hellip;.. = Decoding supported&lt;br /&gt;
                   .E&amp;hellip;. = Encoding supported&lt;br /&gt;
                   ..V&amp;hellip; = Video codec&lt;br /&gt;
                   ..A&amp;hellip; = Audio codec&lt;br /&gt;
                   ..S&amp;hellip; = Subtitle codec&lt;br /&gt;
                   &amp;hellip;I.. = Intra frame-only codec&lt;br /&gt;
                   &amp;hellip;.L. = Lossy compression&lt;br /&gt;
                   &amp;hellip;..S = Lossless compression&lt;br /&gt;
                   -c:v  libx264 设置视频编码器&lt;br /&gt;
                   -c:a  设置音频编码器&lt;/p&gt;

&lt;p&gt;-decoders           show available decoders&lt;br /&gt;
-encoders           show available encoders&lt;br /&gt;
-protocols          show available protocols&lt;/p&gt;

&lt;p&gt;格式转换&lt;br /&gt;
ffmpeg -i money.mp4 -c:v mpeg2video -b:v 500k -c:a libmp3lame -f mpegts money.ts&lt;br /&gt;
ffmpeg -i money.mp4 -c:v libx264 -minrate:v 500k -maxrate:v 500k -bufsize:v 125k -c:a libmp3lame -f mpegts money.ts&lt;br /&gt;
ffmpeg -i money.mp4 -c:v libx264 -x264opts bitrate=500:vbv-maxrate=500:vbv-bufsize=166:nal_hrd=cbr  -c:a libmp3lame -f mpegts money_cbr_500k.ts&lt;br /&gt;
-i    输入文件名&lt;br /&gt;
-f    设置文件输出格式（容器）&lt;br /&gt;
-c:v  设置视频编码器&lt;br /&gt;
-c:a  设置音频编码器&lt;br /&gt;
-b:v  设置码率-b bitrate          video bitrate (please use -b:v)&lt;br /&gt;
-minrate:v 500k -maxrate:v 500k -bufsize:v 125k  设置CBR（不太好用）&lt;br /&gt;
-x264opts bitrate=500:vbv-maxrate=500:vbv-bufsize=166:nal_hrd=cbr  设置CBR（好用）&lt;/p&gt;

&lt;p&gt;选择其中第一个视频流输出，设置码率&lt;br /&gt;
ffmpeg -i money.mp4 -map 0:v:0 -c:v libx264 -b:v 500k money_500k.mp4&lt;br /&gt;
ffmpeg -i money.mp4 -map 0:v:0 -c:v libx264 -b:v 300k money_300k.mp4&lt;br /&gt;
ffmpeg -i money.mp4 -map 0:v:0 -c:v libx264 -b:v 100k -s 336x188 money_100k.mp4&lt;br /&gt;
选择其中第一个音频流输出&lt;br /&gt;
ffmpeg -i money.mp4 -map 0:a:0 money_audio.mp4&lt;/p&gt;

&lt;p&gt;[ffmpeg RTMP]&lt;br /&gt;
1、ffmpeg 推送视频文件，音视频的编码格式只能为H264、AAC。&lt;br /&gt;
    ffmpeg -re -i &amp;ldquo;E:\片源\复仇者联盟720p.mov&amp;rdquo; -vcodec copy -acodec copy -f flv rtmp://192.168.11.75/live/test1&lt;br /&gt;
    ffmpeg -re -i &amp;ldquo;E:\片源\复仇者联盟720p.mov&amp;rdquo; -vcodec copy -acodec copy -f flv rtmpt://192.168.11.75:8080/live/test1&lt;/p&gt;

&lt;p&gt;2、网络摄像机 rtsp流转推rtmp直播(不过有丢包情况，还请大家多给指点)&lt;br /&gt;
    ffmpeg -i rtsp://ip address/original -crf 30 -preset ultrafast -acodec aac -strict experimental -ar 44100 -ac 2 -b:a 96k -vcodec libx264 -r 25 -b:v 500k -s 640*480 -f flv rtmp://ip address/live/stram&lt;/p&gt;

&lt;p&gt;转换为flv:&lt;br /&gt;
    ffmpeg -i test.mp3 -ab 56 -ar 22050 -b 500 -r 15 -s 320x240 test.flv&lt;br /&gt;
    ffmpeg -i test.wmv -ab 56 -ar 22050 -b 500 -r 15 -s 320x240 test.flv&lt;/p&gt;

&lt;p&gt;转换文件格式的同时抓缩微图：&lt;br /&gt;
    ffmpeg -i &amp;ldquo;test.avi&amp;rdquo; -y -f image2 -ss 8 -t 0.001 -s 350x240 &amp;lsquo;test.jpg&amp;rsquo;&lt;/p&gt;

&lt;p&gt;对已有flv抓图：&lt;br /&gt;
    ffmpeg -i &amp;ldquo;test.flv&amp;rdquo; -y -f image2 -ss 8 -t 0.001 -s 350x240 &amp;lsquo;test.jpg&amp;rsquo;&lt;/p&gt;

&lt;p&gt;转换为3gp:&lt;br /&gt;
    ffmpeg -y -i test.mpeg -bitexact -vcodec h263 -b 128 -r 15 -s 176x144 -acodec aac -ac 2 -ar 22500 -ab 24 -f 3gp test.3gp&lt;br /&gt;
    ffmpeg -y -i test.mpeg -ac 1 -acodec amr_nb -ar 8000 -s 176x144 -b 128 -r 15 test.3gp&lt;/p&gt;

&lt;p&gt;###################&lt;br /&gt;
先把ts流中的格式转换对，可以用以下命令试试：&lt;br /&gt;
ffmpeg -i your.ts -acodec copy -vcodec libx264 new.h264.ts&lt;br /&gt;
利用ffmepg把ts文件转m3u8并切片&lt;br /&gt;
ffmpeg -i 12生肖.ts -c copy -map 0 -f segment -segment_list playlist.m3u8 -segment_time 10 output%03d.ts&lt;/p&gt;

&lt;p&gt;ffmpeg -i test456.mp4 -f  segment -segment_time 10  -segment_format mpegts -segment_listlist_file.m3u8 -codec copy -bsf:v h264_mp4toannexb -map 0 output_file-%d.ts&lt;/p&gt;

&lt;p&gt;音频转换：&lt;/p&gt;

&lt;p&gt;1.转换amr到mp3：&lt;/p&gt;

&lt;p&gt;ffmpeg -i shenhuxi.amr amr2mp3.mp3&lt;br /&gt;
2.转换amr到wav：&lt;/p&gt;

&lt;p&gt;ffmpeg -acodec libamr_nb -i shenhuxi.amr amr2wav.wav&lt;br /&gt;
3.转换mp3到wav：&lt;/p&gt;

&lt;p&gt;ffmpeg -i DING.mp3 -f wav test.wav&lt;br /&gt;
4.转换wav到amr：&lt;/p&gt;

&lt;p&gt;ffmpeg -i test.wav -acodec libamr_nb -ab 12.2k -ar 8000 -ac 1 wav2amr.amr&lt;/p&gt;

&lt;p&gt;ffmpeg.exe -i PA003.wav -ar 8000 -ab 12.2k -ac 1 target.amr  此方法验证通过&lt;br /&gt;
文章来自&lt;a href=&#34;http://blog.csdn.net/tylz04/article/details/9041739&#34; target=&#34;_blank&#34;&gt;http://blog.csdn.net/tylz04/article/details/9041739&lt;/a&gt;&lt;br /&gt;
测试程序下载：&lt;a href=&#34;http://files.cnblogs.com/xiaofengfeng/WavConvertAmr.zip&#34; target=&#34;_blank&#34;&gt;http://files.cnblogs.com/xiaofengfeng/WavConvertAmr.zip&lt;/a&gt; 已测试过将WAV转AMR格式。&lt;br /&gt;
下载地址&lt;a href=&#34;http://ftp.pconline.com.cn/d56bb83a0a66440d54ef5473f548e4b9/pub/download/201010/ffmpeg-20131021.zip&#34; target=&#34;_blank&#34;&gt;http://ftp.pconline.com.cn/d56bb83a0a66440d54ef5473f548e4b9/pub/download/201010/ffmpeg-20131021.zip&lt;/a&gt;&lt;br /&gt;
5.转换wav到mp3：&lt;/p&gt;

&lt;p&gt;ffmpeg -i test.wav -f mp3 -acodec libmp3lame -y wav2mp3.mp3&lt;br /&gt;
视频转换：&lt;/p&gt;

&lt;p&gt;1.转换wmv到mp4：&lt;/p&gt;

&lt;p&gt;ffmpeg -i sample.wmv -vcodec libx264 -acodec aac out.mp4&lt;br /&gt;
2.抓取H264视频流：&lt;/p&gt;

&lt;p&gt;ffmpeg -i sample.flv -vcodec copy -vbsf h264_mp4toannexb -an out.h264&lt;br /&gt;
 2.1 vbsf为过滤方法，即将flv规定的H264组织方式转换回H264协议书规定的字节流格式  2.2 -an 禁掉源文件中的音频，因为出来的码流不需要音频  2.3 vcodec copy这个是必然的&lt;/p&gt;

&lt;p&gt;3.将H264视频流转为mp4:&lt;/p&gt;

&lt;p&gt;ffmpeg -i sample.h264 -f mp4 haha.mp4&lt;br /&gt;
4.接收rtsp并存为视频文件：&lt;/p&gt;

&lt;p&gt;ffmpeg -rtsp_transport tcp -i rtsp://streaming1.osu.edu/media2/ufsap/ufsap.mov -vcodec copy -acodec copy -t 30 -f mp4 rtsp-out.mp4&lt;br /&gt;
4.1 -rtsp_transport tcp:指明传输方式是tcp方式(也可以是udp)&lt;/p&gt;

&lt;p&gt;4.2 -t 30：指明我录制30秒&lt;/p&gt;

&lt;p&gt;ffmpeg将音频或视频编码为AMR格式音频&lt;/p&gt;

&lt;p&gt;Android编码的MP4音频格式可能为AMR，这时候用以下命令可以从MP4中直接提取AMR音频：&lt;br /&gt;
ffmpeg -i test.mp4 -c:a copy test.amr&lt;br /&gt;
将其他格式的音频或视频转成AMR的命令：&lt;br /&gt;
新写法：&lt;br /&gt;
ffmpeg -i test.mp4 -c:a libopencore_amrnb -ac 1 -ar 8000 -b:a 12.20k -y test.amr&lt;br /&gt;
旧写法：&lt;br /&gt;
ffmpeg -i test.mp4 -acodec libopencore_amrnb -ac 1 -ar 8000 -ab 12.20k -y test.amr&lt;br /&gt;
#####################################&lt;br /&gt;
 FFmpeg发送流媒体的命令（UDP，RTP，RTMP）&lt;br /&gt;
 这两天研究了FFmpeg发送流媒体的命令，在此简单记录一下以作备忘。&lt;br /&gt;
1.      UDP&lt;br /&gt;
1.1. 发送H.264裸流至组播地址&lt;br /&gt;
注：组播地址指的范围是224.0.0.0—239.255.255.255&lt;br /&gt;
下面命令实现了发送H.264裸流“chunwan.h264”至地址udp://233.233.233.223:6666&lt;/p&gt;

&lt;p&gt;ffmpeg -re -i chunwan.h264 -vcodec copy -f h264 udp://233.233.233.223:6666&lt;br /&gt;
注1：-re一定要加，代表按照帧率发送，否则ffmpeg会一股脑地按最高的效率发送数据。&lt;br /&gt;
注2：-vcodec copy要加，否则ffmpeg会重新编码输入的H.264裸流。&lt;br /&gt;
1.2. 播放承载H.264裸流的UDP&lt;/p&gt;

&lt;p&gt;ffplay -f h264 udp://233.233.233.223:6666&lt;br /&gt;
注：需要使用-f说明数据类型是H.264&lt;br /&gt;
播放的时候可以加一些参数，比如-max_delay，下面命令将-max_delay设置为100ms：&lt;/p&gt;

&lt;p&gt;ffplay -max_delay 100000 -f h264 udp://233.233.233.223:6666&lt;br /&gt;
1.3. 发送MPEG2裸流至组播地址&lt;br /&gt;
下面的命令实现了读取本地摄像头的数据，编码为MPEG2，发送至地址udp://233.233.233.223:6666。&lt;/p&gt;

&lt;p&gt;ffmpeg -re -i chunwan.h264 -vcodec mpeg2video -f mpeg2video udp://233.233.233.223:6666&lt;br /&gt;
1.4.  播放MPEG2裸流&lt;br /&gt;
指定-vcodec为mpeg2video即可。&lt;/p&gt;

&lt;p&gt;ffplay -vcodec mpeg2video udp://233.233.233.223:6666&lt;br /&gt;
2.      RTP&lt;br /&gt;
2.1. 发送H.264裸流至组播地址。&lt;br /&gt;
下面命令实现了发送H.264裸流“chunwan.h264”至地址rtp://233.233.233.223:6666&lt;/p&gt;

&lt;p&gt;ffmpeg -re -i chunwan.h264 -vcodec copy -f rtp rtp://233.233.233.223:6666&amp;gt;test.sdp&lt;br /&gt;
注1：-re一定要加，代表按照帧率发送，否则ffmpeg会一股脑地按最高的效率发送数据。&lt;br /&gt;
注2：-vcodec copy要加，否则ffmpeg会重新编码输入的H.264裸流。&lt;br /&gt;
注3：最右边的“&amp;gt;test.sdp”用于将ffmpeg的输出信息存储下来形成一个sdp文件。该文件用于RTP的接收。当不加“&amp;gt;test.sdp”的时候，ffmpeg会直接把sdp信息输出到控制台。将该信息复制出来保存成一个后缀是.sdp文本文件，也是可以用来接收该RTP流的。加上“&amp;gt;test.sdp”后，可以直接把这些sdp信息保存成文本。&lt;/p&gt;

&lt;p&gt;2.2. 播放承载H.264裸流的RTP。&lt;/p&gt;

&lt;p&gt;ffplay test.sdp&lt;br /&gt;
3.      RTMP&lt;br /&gt;
3.1. 发送H.264裸流至RTMP服务器（FlashMedia Server，Red5等）&lt;br /&gt;
面命令实现了发送H.264裸流“chunwan.h264”至主机为localhost，Application为oflaDemo，Path为livestream的RTMP URL。&lt;/p&gt;

&lt;p&gt;ffmpeg -re -i chunwan.h264 -vcodec copy -f flv rtmp://localhost/oflaDemo/livestream&lt;br /&gt;
3.2. 播放RTMP&lt;/p&gt;

&lt;p&gt;ffplay “rtmp://localhost/oflaDemo/livestream live=1”&lt;br /&gt;
注：ffplay播放的RTMP URL最好使用双引号括起来，并在后面添加live=1参数，代表实时流。实际上这个参数是传给了ffmpeg的libRTMP的。&lt;br /&gt;
有关RTMP的处理，可以参考文章：ffmpeg处理RTMP流媒体的命令大全&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;测延时&lt;br /&gt;
4.1.测延时&lt;br /&gt;
测延时有一种方式，即一路播放发送端视频，另一路播放流媒体接收下来的流。播放发送端的流有2种方式：FFmpeg和FFplay。&lt;br /&gt;
通过FFplay播放是一种众所周知的方法，例如：&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ffplay -f dshow -i video=&amp;ldquo;Integrated Camera&amp;rdquo;&lt;br /&gt;
即可播放本地名称为“Integrated Camera”的摄像头。&lt;br /&gt;
此外通过FFmpeg也可以进行播放，通过指定参数“-f sdl”即可。例如：&lt;/p&gt;

&lt;p&gt;ffmpeg -re -i chunwan.h264 -pix_fmt yuv420p –f sdl xxxx.yuv -vcodec copy -f flv rtmp://localhost/oflaDemo/livestream&lt;br /&gt;
就可以一边通过SDL播放视频，一边发送视频流至RTMP服务器。&lt;br /&gt;
注1：sdl后面指定的xxxx.yuv并不会输出出来。&lt;br /&gt;
注2：FFmpeg本身是可以指定多个输出的。本命令相当于指定了两个输出。&lt;br /&gt;
###############################&lt;br /&gt;
[ffmpeg处理RTMP流媒体的命令大全]&lt;br /&gt;
最近浏览国外网站时候发现，翻译不准确的敬请谅解。&lt;/p&gt;

&lt;p&gt;1、将文件当做直播送至live&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -re -i localFile.mp4 -c copy -f flv rtmp://server/live/streamName&lt;br /&gt;
2、将直播媒体保存至本地文件&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -i rtmp://server/live/streamName -c copy dump.flv&lt;br /&gt;
3、将其中一个直播流，视频改用h264压缩，音频不变，送至另外一个直播服务流&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv rtmp://server/live/h264Stream&lt;br /&gt;
4、将其中一个直播流，视频改用h264压缩，音频改用faac压缩，送至另外一个直播服务流&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -i rtmp://server/live/originalStream -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://server/live/h264Stream&lt;br /&gt;
5、将其中一个直播流，视频不变，音频改用faac压缩，送至另外一个直播服务流&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -i rtmp://server/live/originalStream -acodec libfaac -ar 44100 -ab 48k -vcodec copy -f flv rtmp://server/live/h264_AAC_Stream&lt;br /&gt;
6、将一个高清流，复制为几个不同视频清晰度的流重新发布，其中音频不变&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -re -i rtmp://server/live/high_FMLE_stream -acodec copy -vcodec x264lib -s 640×360 -b 500k -vpre medium -vpre baseline rtmp://server/live/baseline_500k -acodec copy -vcodec x264lib -s 480×272 -b 300k -vpre medium -vpre baseline rtmp://server/live/baseline_300k -acodec copy -vcodec x264lib -s 320×200 -b 150k -vpre medium -vpre baseline rtmp://server/live/baseline_150k -acodec libfaac -vn -ab 48k rtmp://server/live/audio_only_AAC_48k&lt;br /&gt;
7、功能一样，只是采用-x264opts选项&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -re -i rtmp://server/live/high_FMLE_stream -c:a copy -c:v x264lib -s 640×360 -x264opts bitrate=500:profile=baseline:preset=slow rtmp://server/live/baseline_500k -c:a copy -c:v x264lib -s 480×272 -x264opts bitrate=300:profile=baseline:preset=slow rtmp://server/live/baseline_300k -c:a copy -c:v x264lib -s 320×200 -x264opts bitrate=150:profile=baseline:preset=slow rtmp://server/live/baseline_150k -c:a libfaac -vn -b:a 48k rtmp://server/live/audio_only_AAC_48k&lt;br /&gt;
8、将当前摄像头及音频通过DSSHOW采集，视频h264、音频faac压缩后发布&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -r 25 -f dshow -s 640×480 -i video=”video source name”:audio=”audio source name” -vcodec libx264 -b 600k -vpre slow -acodec libfaac -ab 128k -f flv rtmp://server/application/stream_name&lt;br /&gt;
9、将一个JPG图片经过h264压缩循环输出为mp4视频&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg.exe -i INPUT.jpg -an -vcodec libx264 -coder 1 -flags +loop -cmp +chroma -subq 10 -qcomp 0.6 -qmin 10 -qmax 51 -qdiff 4 -flags2 +dct8x8 -trellis 2 -partitions +parti8x8+parti4x4 -crf 24 -threads 0 -r 25 -g 25 -y OUTPUT.mp4&lt;br /&gt;
10、将普通流视频改用h264压缩，音频不变，送至高清流服务(新版本FMS live=1)&lt;br /&gt;
[plain] view plain copy&lt;br /&gt;
ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv “rtmp://server/live/h264Stream live=1″&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>gdb使用笔记</title>
            <link>//blog.pytool.com/cmd/2016-06-01-linux%E5%91%BD%E4%BB%A4-gdb/</link>
            <pubDate>Tue, 02 Feb 2016 15:03:34 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-06-01-linux%E5%91%BD%E4%BB%A4-gdb/</guid>
            <description>

&lt;h1 id=&#34;gdb的基本使用&#34;&gt;gdb的基本使用&lt;/h1&gt;

&lt;p&gt;用gdb调试程序要确保调试的程序带有调试信息，这要求在链接程序的时候加上&amp;rdquo;-G&amp;rdquo;的参数。用gdb executable启动调试，其中executable表示执行文件的名称。启动调试后，进入交互式对话，命令提示符变成(gdb)$，等待你输入调试命令。&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;你输入run或r，回车，程序将开始运行，如果有断点会在断点处停住。  
输入break或b,后面跟行号，将会在当前文件指定行设置断点；b后面也可以跟函数名（如果是类的成员函数，需要类名::成员函数名），会在进入该函数后停住。  
info break，将会列出所有断点的信息。d breaknumber，将删除指定编号的断点，如果d后面什么都不加，将删除所有断点。disable breaknumber，并不会删除断点，只会禁用断点，可以用enable breaknumber重新启用。如果disable(enable)后面什么都不跟，将禁用(启用)所有断点。  
continue或c，将继续运行程序，直到下一个断点停住。  
step或s，单步执行，但不会进入函数。  
next或n，下一条指令，如果遇到函数会进入。  
si和ni，对应于step和next，只不过用于汇编指令。  
p 变量名。查看指定的变量值。  
还有，基本的一点，如果不输入命令直接回车，则重复执行上一条指令。  
q，退出调试过程。  
until或u，跳出循环。  
在gdb下可以直接make或编译，然后输入r，重新运行程序。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gdb真的很好用，至少纯键盘操作调试速度就比gui下快。我上面讲的只是gdb的一点皮毛，精通了gdb真的很强大。关于gdb的教程，可以看陈皓的《用gdb调试程序》，写得真不错。我很喜欢看他的教程，还有《跟我一起写makefile》以及《编程修养》，深入浅出，比外面卖的一些拼凑的教程强上百倍。&lt;/p&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux update-alternatives</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-update-alternatives/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-update-alternatives/</guid>
            <description>

&lt;p&gt;update-alternatives 可以创建、删除、修复、软连接，还能显示出已存在软连接的信息，而所有的这些就构成了备选方案系统（alternatives system）。&lt;/p&gt;

&lt;p&gt;很多时候我们会将拥有相同或相似功能的不同应用程序安装在同一个操作系统上，例如同一个操作系统上的不同文本编辑器。这给了这个系统的用户在编辑文本时有了更多的选择，如果用户愿意他们可以自由选择任意一个来使用。但是假如用户没有指定他想用哪一个编辑器，那么会怎样呢？对于程序来说它很尴尬，因为它没有人一样的意愿去做出一个所谓“好”的选择。&lt;/p&gt;

&lt;p&gt;不过alternatives系统的出现解决了这个问题。文件系统中的一个共用名（generic name）被那些拥有可交换功能的文件所共享，而备选方案系统和系统管理员共同决定具体是哪一个文件被这个共用名所指定（就是说备选方案系统并不能彻底地帮助用户来管理软连接，毕竟以人为本嘛）。举个例子，如果文本编辑器ed(1)和nvi(1)被安装在一个系统里，并且假定备选系统方案让共用名（/usr/bin/editor）默认指向/usr/bin/nvi，那么系统管理员就可以废除这个指定并且让共用名指向/usr/bin/ed，之后除非有特别明确的必要，否则备选方案系统不会改变这个设定。&lt;/p&gt;

&lt;p&gt;其实，共用名并不是直接指向已选定程序（命令）的软连接，而是指向备选方案目录（alternatives directory）中的一个名字。这个名字也是一个软连接，它才是直接指向已选定程序（命令）。这种机制的目的是将管理员所做的更改限定在/etc目录下的相应配置文件中：FHS可以很好地给出这样做的好处。&lt;/p&gt;

&lt;p&gt;当任意一个提供特定功能的文件（程序/包）被安装、删除或者更改，update-alternatives都会被调用以更新备选方案中相应文件的信息。update-alternatives经常被Debian包中psstinst（配置）或prerm（安装）脚本调用。&lt;/p&gt;

&lt;p&gt;那些为了更好地发挥作用而被同步的多个备选方案被称作组；例如，当多个版本的vi编辑器都被安装时，被/usr/share/man/man1/vi.1指定的man page就应该跟当前被/usr/bin/vi指定的vi版本相对应（不同版本的vi都有各自的man，我们要做的就是要man的时候显示的man page与我们正在使用的vi编辑器对应）。&lt;/p&gt;

&lt;p&gt;每一个链接组（link group）都有两种不同的模式：自动模式和手动模式，任一给定时刻一个组都是而且只能是其中的一种模式。如果一个组处于自动模式，当包被安装或删除时，备选方案系统会自己决定是否和如何来更新相应链接（links）。如果处于手动模式，备选方案系统会保留原先管理员所做的选择并且避免改变链接（除非发生broken）。&lt;/p&gt;

&lt;p&gt;当第一次被安装到系统时链接组被分配为自动模式；如果之后系统管理员对模式的设置做出更改，这个组会被自动转换为手动模式。&lt;/p&gt;

&lt;p&gt;备选方案都有自己的级别（priority）；当一个链接组处于自动模式时，它的成员会指向级别高的备选方案。&lt;/p&gt;

&lt;p&gt;当使用&amp;ndash;config选项时，update-alternatives 会列出所有链接组的主链接名，当前被选择的组会以*号标出。可以在提示下对链接指向做出改变，不过这会将模式变为手动。如果想回复自动模式，你可以使用&amp;ndash;auto选项，或者&amp;ndash;config重新选择标为自动的组。&lt;/p&gt;

&lt;p&gt;如果你不想用&amp;ndash;config提供的交互模式，你也可以使用&amp;ndash;set选项&lt;/p&gt;

&lt;p&gt;提供相同文件的不同包需要进行同步，换句话说，update-alternatives的使用是对所用牵连的包起作用的。&lt;/p&gt;

&lt;p&gt;update-alternatives是用来维护系统命令的符号链接，以决定系统默认使用什么命令，可以设置系统默认加载的首选程序&lt;/p&gt;

&lt;p&gt;我们可能会同时安装有很多功能类似的程序和可选配置，如Web浏览器程序(firefox，konqueror)、窗口管理器(wmaker、metacity)和鼠标的不同主题等。这样，用户在使用系统时就可进行选择，以满足自已的需求。&lt;/p&gt;

&lt;p&gt;但对于普通用户来说，在这些程序间进行选择配置会较困难。update-alternatives工具就是为了解决这个问题，帮助用户能方便地选择自已喜欢程序和配置系统功能。&lt;/p&gt;

&lt;p&gt;比如我系统已安装有java 1.6，还想要安装java 1.7，但我不想卸载java 1.6。就可以通过update-alternatives  &amp;ndash;config在多个java版本间进程切换。update-alternatives是用于在多个同类型命令中进行切换的一个命令。&lt;/p&gt;

&lt;p&gt;在说明update-alternatives的详细用法之前，先让我们看看系统中已有的例子。&lt;/p&gt;

&lt;p&gt;打开终端，执行下面的命令：&lt;/p&gt;

&lt;p&gt;[root@SC4303 ~]# java -version&lt;br /&gt;
java version &amp;ldquo;1.7.0_45&amp;rdquo;&lt;br /&gt;
OpenJDK Runtime Environment (rhel-2.4.3.3.el6-x86_64 u45-b15)&lt;br /&gt;
OpenJDK 64-Bit Server VM (build 24.45-b08, mixed mode)&lt;br /&gt;
[root@SC4303 ~]# which java&lt;br /&gt;
/usr/bin/java&lt;br /&gt;
[root@SC4303 ~]# ls -l /usr/bin/java&lt;br /&gt;
lrwxrwxrwx. 1 root root 22 Dec  8 20:49 /usr/bin/java -&amp;gt; /etc/alternatives/java&lt;br /&gt;
[root@SC4303 ~]# ls -l /etc/alternatives/java&lt;br /&gt;
lrwxrwxrwx. 1 root root 46 Dec  8 20:49 /etc/alternatives/java -&amp;gt; /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java&lt;/p&gt;

&lt;p&gt;java这个可执行命令实际是一个链接，指向了/etc/alternatives/java。而这个也是一个链接，指向了/usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java这才是最终的可执行文件。之所以建立这样两个链接，是为了方便脚本程序的编写和系统的管理。&lt;/p&gt;

&lt;p&gt;2、使用&lt;/p&gt;

&lt;p&gt;root@xj alternatives]# ll $(which update-alternatives)&lt;br /&gt;
lrwxrwxrwx. 1 root root 12 10月 27 16:39 /usr/sbin/update-alternatives -&amp;gt; alternatives&lt;br /&gt;
[root@xj alternatives]# ll $(which alternatives)&lt;br /&gt;
-rwxr-xr-x 1 root root 27496 9月  23 2013 /usr/sbin/alternatives&lt;/p&gt;

&lt;p&gt;以上可知：update-alternatives和alternatives是同一个命令，只是为了和debian系统一吗？&lt;/p&gt;

&lt;p&gt;命令格式:&lt;/p&gt;

&lt;p&gt;update-alternatives  [options]  command&lt;/p&gt;

&lt;p&gt;[root@xxj ~]$ update-alternatives&lt;br /&gt;
alternatives（备用）版本 1.3.61 - 版权 &amp;copy; 2001 红帽公司&lt;br /&gt;
在 GNU 公共许可条款下，本软件可被自由地重发行。&lt;/p&gt;

&lt;p&gt;用法：alternatives &amp;ndash;install &amp;lt;链接&amp;gt; &amp;lt;名称&amp;gt; &amp;lt;路径&amp;gt; &amp;lt;优先度&amp;gt;&lt;br /&gt;
               [&amp;ndash;initscript &amp;lt;服务&amp;gt;]&lt;br /&gt;
               [&amp;ndash;slave &amp;lt;链接&amp;gt; &amp;lt;名称&amp;gt; &amp;lt;路径&amp;gt;]*&lt;br /&gt;
  alternatives &amp;ndash;remove &amp;lt;名称&amp;gt; &amp;lt;路径&amp;gt;&lt;br /&gt;
  alternatives &amp;ndash;auto &amp;lt;名称&amp;gt;&lt;br /&gt;
  alternatives &amp;ndash;config &amp;lt;名称&amp;gt;&lt;br /&gt;
  alternatives &amp;ndash;display &amp;lt;名称&amp;gt;&lt;br /&gt;
  alternatives &amp;ndash;set &amp;lt;名称&amp;gt; &amp;lt;路径&amp;gt;&lt;br /&gt;
  alternatives &amp;ndash;list&lt;/p&gt;

&lt;p&gt;公用选项：&amp;ndash;verbose &amp;ndash;test &amp;ndash;help &amp;ndash;usage &amp;ndash;version&lt;br /&gt;
           &amp;ndash;altdir &amp;lt;目录&amp;gt; &amp;ndash;admindir &amp;lt;目录&amp;gt;&lt;/p&gt;

&lt;p&gt;install选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  install选项的功能就是增加一组新的系统命令链接符了  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用语法：&lt;/p&gt;

&lt;p&gt;update-alternatives  &amp;ndash;install link name path priority [&amp;ndash;slave link name path]&amp;hellip;&lt;/p&gt;

&lt;p&gt;其中link为系统中功能相同软件的公共链接目录，比如/usr/bin/java(需绝对目录);&lt;/p&gt;

&lt;p&gt;name为命令链接符名称,如java；&lt;/p&gt;

&lt;p&gt;path为你所要使用新命令、新软件的所在目录；&lt;/p&gt;

&lt;p&gt;priority为优先级，当命令链接已存在时，需高于当前值，因为当alternative为自动模式时,系统默认启用priority高的链接;&lt;/p&gt;

&lt;p&gt;&amp;ndash;slave为从alternative。&lt;/p&gt;

&lt;p&gt;alternative有两种模式：auto和manual，默认都为auto模式，因为大多数情况下update-alternatives命令都被postinst (configure) or prerm (install)调用的，如果将其更改成手动的话安装脚本将不会更新它了。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;update-alternatives &amp;ndash;install /usr/bin/java java /usr/local/lib/java/jdk1.7.0_67 17067&lt;/p&gt;

&lt;h1 id=&#34;usr-bin-java-java-link所在的路径&#34;&gt;/usr/bin/java   java link所在的路径&lt;/h1&gt;

&lt;h1 id=&#34;java-创建link的名称&#34;&gt;java  创建link的名称&lt;/h1&gt;

&lt;h1 id=&#34;usr-local-lib-java-jdk1-7-0-67-java链接指向的路径&#34;&gt;/usr/local/lib/java/jdk1.7.0_67  java链接指向的路径&lt;/h1&gt;

&lt;h1 id=&#34;17067-根据版本号设置的优先级-更改的优先级需要大于当前的&#34;&gt;17067  根据版本号设置的优先级（更改的优先级需要大于当前的）&lt;/h1&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这里，你不需要再/etc/alternatives/下面建立任何你想设置的链接名称，因为这完全可以通过update-alternative  --install命令来实现;而且你也不需要在/usr/bin/目录下建立相关链接名称，理由同上。你只需要确定这几个功能类似的软件的源目的地，然后执行如下命令:(以gcc为例)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#sudo update-alternatives &amp;ndash;install /usr/bin/gcc gcc /usr/bin/gcc-3.3 100(这个优先级100必须键入)&lt;br /&gt;
#sudo update-alternatives &amp;ndash;install /usr/bin/gcc gcc /usr/bin/gcc-4.1 90&lt;br /&gt;
#sudo update-alternatives &amp;ndash;install /usr/bin/gcc gcc /ur/bing/gcc-4.2 80&lt;/p&gt;

&lt;p&gt;remove选项&lt;/p&gt;

&lt;p&gt;remove选项的功能是删除一个alternative及相关从alternative&lt;/p&gt;

&lt;p&gt;使用语法：&lt;/p&gt;

&lt;p&gt;update-alternatives &amp;ndash;remove name path&lt;/p&gt;

&lt;p&gt;其中name与path与install中的一致，如果所删除的链接组中还有其他链接的话，系统将会自动从其他中选择一个priority高的链接作为默认为链接。&lt;/p&gt;

&lt;p&gt;例如：update-alternatives &amp;ndash;remove  java /usr/local/lib/java/jdk1.7.0_67&lt;br /&gt;
auto选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto选项用于修改命令的模式，  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;语法如下：&lt;/p&gt;

&lt;p&gt;update-alternatives &amp;ndash;auto name    #只有两个auto和manual模式，默认都为auto模式&lt;/p&gt;

&lt;p&gt;config选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config选项功能为在现有的命令链接选择一个作为系统默认的  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用语法为：&lt;/p&gt;

&lt;p&gt;update-alternatives &amp;ndash;config name&lt;/p&gt;

&lt;p&gt;[root@localhost yxkong]# update-alternatives &amp;ndash;config java&lt;br /&gt;
共有 2 个提供“java”的程序。&lt;/p&gt;

&lt;h2 id=&#34;选项-命令&#34;&gt;选项    命令&lt;/h2&gt;

&lt;p&gt;*+ 1      /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.51-2.4.5.5.el7.x86_64/jre/bin/java&lt;br /&gt;
2      /usr/local/lib/java/jdk1.7.0_67/bin/java&lt;br /&gt;
按 Enter 保留当前选项[+]，或者键入选项编号：2&lt;/p&gt;

&lt;p&gt;这里才是配置版本的重点，当系统中有多个版本时，可以通过该命令设置默认版本，类似于默认程序&lt;/p&gt;

&lt;p&gt;星号表示当前系统使用的，加号表示优先级最高的。输入数值可修改默认配置，直接按回车保持原来状态。&lt;/p&gt;

&lt;p&gt;display选项&lt;/p&gt;

&lt;p&gt;display选项的功能就是查看一个命令链接组的所有信息，包括链接的模式(自动还是手动)、链接priority值、所有可 用的链接命令等等。&lt;/p&gt;

&lt;p&gt;使用语法：&lt;/p&gt;

&lt;p&gt;update-alternatives &amp;ndash;display name&lt;/p&gt;

&lt;p&gt;[yxkong@localhost ~]$ update-alternatives &amp;ndash;display java&lt;br /&gt;
java - 状态为手工。&lt;br /&gt;
链接当前指向 /usr/local/lib/java/jdk1.7.0_67/bin/java&lt;br /&gt;
/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.51-2.4.5.5.el7.x86_64/jre/bin/java - 优先度 170051&lt;br /&gt;
&amp;hellip;.&lt;br /&gt;
当前“最佳”版本是 /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.51-2.4.5.5.el7.x86_64/jre/bin/java。&lt;/p&gt;

&lt;p&gt;[root@SC4303 ~]# alternatives &amp;ndash;display mta&lt;br /&gt;
mta - status is auto.&lt;br /&gt;
link currently points to /usr/sbin/sendmail.postfix&lt;br /&gt;
/usr/sbin/sendmail.postfix - priority 30&lt;br /&gt;
slave mta-mailq: /usr/bin/mailq.postfix&lt;br /&gt;
slave mta-newaliases: /usr/bin/newaliases.postfix&lt;br /&gt;
slave mta-pam: /etc/pam.d/smtp.postfix&lt;br /&gt;
slave mta-rmail: /usr/bin/rmail.postfix&lt;br /&gt;
slave mta-sendmail: /usr/lib/sendmail.postfix&lt;br /&gt;
slave mta-mailqman: /usr/share/man/man1/mailq.postfix.1.gz&lt;br /&gt;
slave mta-newaliasesman: /usr/share/man/man1/newaliases.postfix.1.gz&lt;br /&gt;
slave mta-sendmailman: /usr/share/man/man1/sendmail.postfix.1.gz&lt;br /&gt;
slave mta-aliasesman: /usr/share/man/man5/aliases.postfix.5.gz&lt;br /&gt;
Current `best‘ version is /usr/sbin/sendmail.postfix.&lt;/p&gt;

&lt;p&gt;[root@xj alternatives]# update-alternatives &amp;ndash;display mta&lt;br /&gt;
mta - 状态是自动。&lt;br /&gt;
链接目前指向 /usr/sbin/sendmail.postfix&lt;br /&gt;
/usr/sbin/sendmail.postfix - 优先度 30&lt;br /&gt;
从 mta-mailq：/usr/bin/mailq.postfix&lt;br /&gt;
从 mta-newaliases：/usr/bin/newaliases.postfix&lt;br /&gt;
从 mta-pam：/etc/pam.d/smtp.postfix&lt;br /&gt;
从 mta-rmail：/usr/bin/rmail.postfix&lt;br /&gt;
从 mta-sendmail：/usr/lib/sendmail.postfix&lt;br /&gt;
从 mta-mailqman：/usr/share/man/man1/mailq.postfix.1.gz&lt;br /&gt;
从 mta-newaliasesman：/usr/share/man/man1/newaliases.postfix.1.gz&lt;br /&gt;
从 mta-sendmailman：/usr/share/man/man1/sendmail.postfix.1.gz&lt;br /&gt;
从 mta-aliasesman：/usr/share/man/man5/aliases.postfix.5.gz&lt;br /&gt;
当前“最佳”版本是 /usr/sbin/sendmail.postfix。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux useradd</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-useradd/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-useradd/</guid>
            <description>&lt;p&gt;mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin&lt;br /&gt;
useradd -r -u 33 -g www-data -c www-data -d /var/www -s /usr/sbin/nologin www-data&lt;br /&gt;
useradd -o -r -u 501 -g www -c ftp -d /home/wwwroot/default/bizchinalinyi -s /usr/sbin/nologin ftp&lt;/p&gt;

&lt;p&gt;-c, &amp;ndash;comment comment 指定一段注释性描述。&lt;br /&gt;
-d, &amp;ndash;home-dir 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。&lt;br /&gt;
-g, &amp;ndash;gid 用户组 指定用户所属的用户组。&lt;br /&gt;
-G 用户组，用户组 指定用户所属的附加组。&lt;br /&gt;
-s, &amp;ndash;shell  Shell文件 指定用户的登录Shell。&lt;br /&gt;
-u, &amp;ndash;uid UID 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。&lt;br /&gt;
-o, &amp;ndash;non-unique 创建uid相同的账户&lt;br /&gt;
-r, &amp;ndash;system 创建系统账户uid&amp;lt;1000 递减&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Linux 监控命令</title>
            <link>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-top/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/cmd/2016-01-01-linux%E5%91%BD%E4%BB%A4-top/</guid>
            <description>&lt;p&gt;&lt;code&gt;iotop  -o&lt;/code&gt; 查看负载较高的io&lt;br /&gt;
iotop [OPTIONS]&lt;/p&gt;

&lt;p&gt;主要选项有：&lt;br /&gt;
-o :只显示有io操作的进程&lt;br /&gt;
-b :批量显示，无交互。主要用作记录到文件。&lt;br /&gt;
-n NUM:显示NUM次，主要用于非交互式模式。&lt;br /&gt;
-d SEC：刷新时间&lt;br /&gt;
-p PID:监控的指定进程pid&lt;br /&gt;
-u USER:监控的指定用户。&lt;/p&gt;

&lt;p&gt;输入大写P，则结果按CPU占用降序排序。&lt;br /&gt;
输入大写M，结果按内存占用降序排序。&lt;/p&gt;

&lt;p&gt;输入1 查看cpu核数&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
