<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>时光小栈 on 时光小栈</title>
        <link>http://blog.pytool.com/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Thu, 04 Jan 2018 16:50:24 CST</updated>
        
        <item>
            <title>Diary</title>
            <link>http://blog.pytool.com/diary/</link>
            <pubDate>Thu, 04 Jan 2018 16:50:24 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/diary/</guid>
            <description>&lt;p&gt;1月4日&lt;br /&gt;
今天下雪&lt;/p&gt;

&lt;p&gt;1月5日 周五&lt;br /&gt;
destoon 对search入口封锁了爬虫访问。&lt;code&gt;module/sell/search.inc.php&lt;/code&gt; 注释掉第二句&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Google</title>
            <link>http://blog.pytool.com/seo/google/</link>
            <pubDate>Thu, 04 Jan 2018 09:52:39 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/seo/google/</guid>
            <description>

&lt;h2 id=&#34;seo&#34;&gt;SEO&lt;/h2&gt;

&lt;h3 id=&#34;google&#34;&gt;Google&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.google.com/webmasters/tools/home?hl=zh-CN&#34;&gt;Google Console&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Etcd</title>
            <link>http://blog.pytool.com/post/etcd/docker-etcd/</link>
            <pubDate>Wed, 03 Jan 2018 17:53:25 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/etcd/docker-etcd/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://play.etcd.io/install&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# make sure etcd process has write access to this directory  
# remove this directory if the cluster is new; keep if restarting etcd  
# rm -rf /tmp/etcd/s1  


# to write service file for etcd with Docker  

cat &amp;gt; /tmp/s1.service &amp;lt;&amp;lt;EOF  
[Unit]  
Description=etcd with Docker  
Documentation=https://github.com/coreos/etcd  

[Service]  
Restart=always  
RestartSec=5s  
TimeoutStartSec=0  
LimitNOFILE=40000  

ExecStart=/usr/bin/docker \  
  run \  
  --rm \  
  --net=host \  
  --name etcd-v3.3.0-rc.0 \  
  --volume=/docker/etcd/s1:/etcd-data \  
  gcr.io/etcd-development/etcd:v3.3.0-rc.0 \  
  /usr/local/bin/etcd \  
  --name s1 \  
  --data-dir /etcd-data \  
  --listen-client-urls http://localhost:2379 \  
  --advertise-client-urls http://localhost:2379 \  
  --listen-peer-urls http://localhost:2380 \  
  --initial-advertise-peer-urls http://localhost:2380 \  
  --initial-cluster s1=http://localhost:2380,s2=http://localhost:22380,s3=http://localhost:32380 \  
  --initial-cluster-token tkn \  
  --initial-cluster-state new \  
  --auto-compaction-retention 1  

ExecStop=/usr/bin/docker stop etcd-v3.3.0-rc.0  

[Install]  
WantedBy=multi-user.target  
EOF  

sudo mv /tmp/s1.service /etc/systemd/system/s1.service  


# to start service  
sudo systemctl daemon-reload  
sudo systemctl cat s1.service  
sudo systemctl enable s1.service  
sudo systemctl start s1.service  

# to get logs from service  
sudo systemctl status s1.service -l --no-pager  
sudo journalctl -u s1.service -l --no-pager|less  
sudo journalctl -f -u s1.service  

# to stop service  
sudo systemctl stop s1.service  
sudo systemctl disable s1.service  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;机器环境变量设置&#34;&gt;机器环境变量设置&lt;/h1&gt;

&lt;p&gt;每台机器设置以下环境变量&lt;/p&gt;

&lt;p&gt;export ETCD_VERSION=v3.1.0-alpha.1&lt;br /&gt;
export TOKEN=my-etcd-token&lt;br /&gt;
export CLUSTER_STATE=new&lt;br /&gt;
export NAME_1=etcd-node-0&lt;br /&gt;
export NAME_2=etcd-node-1&lt;br /&gt;
export NAME_3=etcd-node-2&lt;br /&gt;
export HOST_1=192.168.56.101&lt;br /&gt;
export HOST_2=192.168.56.104&lt;br /&gt;
export HOST_3=192.168.56.105&lt;br /&gt;
export CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380&lt;/p&gt;

&lt;p&gt;每个机器安装etcd容器&lt;/p&gt;

&lt;p&gt;进入HOST_1机器，设置环境变量和起容器。&lt;/p&gt;

&lt;p&gt;export THIS_NAME=${NAME_1}&lt;br /&gt;
export THIS_IP=${HOST_1}&lt;/p&gt;

&lt;p&gt;sudo docker run -d &amp;ndash;net=host &amp;ndash;name etcd quay.io/coreos/etcd:${ETCD_VERSION} \&lt;br /&gt;
    /usr/local/bin/etcd \&lt;br /&gt;
    &amp;ndash;data-dir=data.etcd &amp;ndash;name ${THIS_NAME} \&lt;br /&gt;
    &amp;ndash;initial-advertise-peer-urls http://${THIS_IP}:2380 &amp;ndash;listen-peer-urls http://${THIS_IP}:2380 \&lt;br /&gt;
    &amp;ndash;advertise-client-urls http://${THIS_IP}:2379 &amp;ndash;listen-client-urls http://${THIS_IP}:2379 \&lt;br /&gt;
    &amp;ndash;initial-cluster ${CLUSTER} \&lt;br /&gt;
    &amp;ndash;initial-cluster-state ${CLUSTER_STATE} &amp;ndash;initial-cluster-token ${TOKEN}&lt;/p&gt;

&lt;p&gt;进入HOST_2机器，设置环境变量和起容器&lt;/p&gt;

&lt;p&gt;export THIS_NAME=${NAME_2}&lt;br /&gt;
export THIS_IP=${HOST_2}&lt;br /&gt;
sudo docker run &amp;ndash;net=host -d &amp;ndash;name etcd quay.io/coreos/etcd:${ETCD_VERSION} \&lt;br /&gt;
    /usr/local/bin/etcd \&lt;br /&gt;
    &amp;ndash;data-dir=data.etcd &amp;ndash;name ${THIS_NAME} \&lt;br /&gt;
    &amp;ndash;initial-advertise-peer-urls http://${THIS_IP}:2380 &amp;ndash;listen-peer-urls http://${THIS_IP}:2380 \&lt;br /&gt;
    &amp;ndash;advertise-client-urls http://${THIS_IP}:2379 &amp;ndash;listen-client-urls http://${THIS_IP}:2379 \&lt;br /&gt;
    &amp;ndash;initial-cluster ${CLUSTER} \&lt;br /&gt;
    &amp;ndash;initial-cluster-state ${CLUSTER_STATE} &amp;ndash;initial-cluster-token ${TOKEN}&lt;/p&gt;

&lt;p&gt;进入HOST_3机器，设置环境变量和起容器&lt;/p&gt;

&lt;p&gt;export THIS_NAME=${NAME_3}&lt;br /&gt;
export THIS_IP=${HOST_3}&lt;br /&gt;
sudo docker run &amp;ndash;net=host -d &amp;ndash;name etcd quay.io/coreos/etcd:${ETCD_VERSION} \&lt;br /&gt;
    /usr/local/bin/etcd \&lt;br /&gt;
    &amp;ndash;data-dir=data.etcd &amp;ndash;name ${THIS_NAME} \&lt;br /&gt;
    &amp;ndash;initial-advertise-peer-urls http://${THIS_IP}:2380 &amp;ndash;listen-peer-urls http://${THIS_IP}:2380 \&lt;br /&gt;
    &amp;ndash;advertise-client-urls http://${THIS_IP}:2379 &amp;ndash;listen-client-urls http://${THIS_IP}:2379 \&lt;br /&gt;
    &amp;ndash;initial-cluster ${CLUSTER} \&lt;br /&gt;
    &amp;ndash;initial-cluster-state ${CLUSTER_STATE} &amp;ndash;initial-cluster-token ${TOKEN}&lt;/p&gt;

&lt;p&gt;测试集群运行情况：&lt;/p&gt;

&lt;p&gt;docker exec etcd /bin/sh -c &amp;ldquo;export ETCDCTL_API=3 &amp;amp;&amp;amp; /usr/local/bin/etcdctl put foo bar&amp;rdquo;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Prometheus 详解</title>
            <link>http://blog.pytool.com/post/prometheus/prometheus/</link>
            <pubDate>Wed, 03 Jan 2018 17:17:45 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/prometheus/prometheus/</guid>
            <description>

&lt;p&gt;prometheus缺点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单机缺点，单机下存储量有限，根据你的监控量局限你的存储时间。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;内存占用率大，prometheus集成了leveldb，一个能高效插入数据的数据库，在ssd盘下io占用比较高。同时可能会有大量数据堆积内&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;docker运行prometheus&#34;&gt;docker运行prometheus&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;docker run -p 9090:9090 -v /docker/prometheus-data:/prometheus-data prom/prometheus&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;docker run -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml \&lt;br /&gt;
       -v /docker/prometheus-data:/prometheus-data \&lt;br /&gt;
       prom/prometheus&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;访问&lt;a href=&#34;http://192.168.99.100:9090/graph&#34;&gt;http://192.168.99.100:9090/graph&lt;/a&gt;&lt;br /&gt;
计算实例，指标可以从&lt;a href=&#34;http://192.168.99.100:9090/me...中找&#34;&gt;http://192.168.99.100:9090/me...中找&lt;/a&gt;&lt;br /&gt;
prometheus_target_interval_length_seconds{quantile=&amp;ldquo;0.99&amp;rdquo;}&lt;br /&gt;
或者&lt;br /&gt;
count(prometheus_target_interval_length_seconds)&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;怎么使用prometheus监控容器&lt;/p&gt;

&lt;p&gt;prometheus监控不同的目标服务需要实现不同的exporter插件,早期的时候，官方出了container-exporter项目，但是现在项目已经停止。推荐使用谷歌的cAdvisor项目作为prometheus的exporter。cAdvisor作为一个监控单机容器的项目，数据较为全面，但是也有很大的问题，例如io等数据没有等等。结合prometheus后就能在整个集群监控查询容器。举个例子，你有一个项目有3个容器分布在三台机器，你怎么监控整个项目的流量，内存量，负载量的实时数据。这就是prometheus的多维度查询解决的问题，数据从3台机器的cadvisor得到每个容器的数据，它的多维度查询语法就能让你得到你想要的数据。&lt;/p&gt;

&lt;p&gt;这里假设你有10台机器部署了容器需要监控，你在10台机器上分别部署cAdvisor容器&lt;/p&gt;

&lt;p&gt;sudo docker run \&lt;br /&gt;
    &amp;ndash;volume=/:/rootfs:ro \&lt;br /&gt;
    &amp;ndash;volume=/var/run:/var/run:rw \&lt;br /&gt;
    &amp;ndash;volume=/sys:/sys:ro \&lt;br /&gt;
    &amp;ndash;volume=/var/lib/docker/:/var/lib/docker:ro \&lt;br /&gt;
    &amp;ndash;publish=8080:8080 \&lt;br /&gt;
    &amp;ndash;detach=true \&lt;br /&gt;
    &amp;ndash;name=cadvisor \&lt;br /&gt;
    google/cadvisor:latest&lt;/p&gt;

&lt;p&gt;找一台机器部署prometheus服务，这里依然使用容器部署：&lt;/p&gt;

&lt;p&gt;docker run \&lt;br /&gt;
  -p 9090:9090 \&lt;br /&gt;
  &amp;ndash;log-driver none \&lt;br /&gt;
  -v /hdd1/prometheus/etc/:/etc/prometheus/ \&lt;br /&gt;
  -v /hdd1/prometheus/data/:/prometheus/ \&lt;br /&gt;
  -v /etc/localtime:/etc/localtime \&lt;br /&gt;
  &amp;ndash;name prometheus \&lt;br /&gt;
  prom/prometheus&lt;/p&gt;

&lt;p&gt;创建/hdd1/prometheus/etc/prometheus.yml配置文件&lt;/p&gt;

&lt;p&gt;my global config&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  global:  
    scrape_interval:     15s # By default, scrape targets every 15 seconds.  
    evaluation_interval: 15s # By default, scrape targets every 15 seconds.  
    # scrape_timeout is set to the global default (10s).  
    # Attach these labels to any time series or alerts when communicating with  
    # external systems (federation, remote storage, Alertmanager).  
    external_labels:  
        monitor: &#39;container-monitor&#39;  
  # Load and evaluate rules in this file every &#39;evaluation_interval&#39; seconds.  
  rule_files:  
     - &amp;quot;/etc/prometheus/rules/common.rules&amp;quot;  
  # A scrape configuration containing exactly one endpoint to scrape:  
  # Here it&#39;s Prometheus itself.  
  scrape_configs:  
    # The job name is added as a label `job=&amp;lt;job_name&amp;gt;` to any timeseries scraped from this config.  
    - job_name: &#39;container&#39;  
      static_configs:  
      - targets: [&#39;10.12.1.129:9090&#39;,&#39;10.12.1.130:9090&#39;,&#39;10.50.1.92:9090&#39;,&#39;10.50.1.93:9090&#39;,&#39;10.50.1.119:9090&#39;]  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件中 -targets中的端点填写你的实际cadvisor所在的ip和暴露的端口.正确启动后访问ip:9090就能查询数据了哦&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Prometheus智能化报警流程避免邮件轰炸</title>
            <link>http://blog.pytool.com/post/prometheus/prometheus-altermanager/</link>
            <pubDate>Wed, 03 Jan 2018 17:17:45 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/prometheus/prometheus-altermanager/</guid>
            <description></description>
        </item>
        
        <item>
            <title>golang微服务框架</title>
            <link>http://blog.pytool.com/post/go/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
            <pubDate>Wed, 03 Jan 2018 17:15:26 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/go/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
            <description>&lt;p&gt;负载均衡：seesaw、caddy&lt;br /&gt;
服务网关：tyk、fabio、vulcand&lt;br /&gt;
进程间通信：RESTful、RPC、自定义&lt;br /&gt;
REST框架：gin、Iris、micro、go-kit、goa&lt;br /&gt;
RPC框架：grpc、thrift、hprose&lt;br /&gt;
服务发现：etcd、consul、serf&lt;br /&gt;
调度系统：kubernetes、swarm&lt;br /&gt;
消息队列：NSQ、Nats&lt;br /&gt;
配置管理：etcd、consul、mgmt&lt;br /&gt;
服务监控：open-falcon、prometheus&lt;br /&gt;
CI/CD：Drone&lt;br /&gt;
熔断器：gateway、Hystrix-go&lt;br /&gt;
日志分析：Beats、Heka&lt;br /&gt;
APM（应用性能监控）：appdash、Cloudinsight、opentracing&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>wepack3 url-loader</title>
            <link>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack-url-loader/</link>
            <pubDate>Tue, 12 Dec 2017 15:47:11 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack-url-loader/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module: {  
  rules: [  
    {  
      test: /\.js$/,  
      use: &#39;babel-loader?cacheDirectory&#39;, // 开启 babel-loader 缓存  
      include: [path.resolve(&#39;src&#39;), path.resolve(&#39;test&#39;)],  
      exclude: /node_modules/  
    },  
    {  
      test: /\.(css|scss)$/,  
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]  
    },  
    {  
      test: /\.(png|jpe?g|gif|svg)(\?.*)?$/i,  
      loader: &#39;url-loader&#39;,  
      options: {  
        limit: 10 * 1024,  
        name: &#39;images/[name].[ext]?[hash]&#39;  
      }  
    },  
    {  
      test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,  
      loader: &#39;url-loader&#39;,  
      options: {  
        limit: 10 * 1024,  
        name: &#39;media/[name].[ext]?[hash]&#39;  
      }  
    },  
    {  
      test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,  
      loader: &#39;url-loader&#39;,  
      options: {  
        limit: 10 * 1024,  
        name: &#39;fonts/[name].[ext]?[hash]&#39;  
      }  
    }  
  ]  
},  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module: {  
     rules: [  
         {  
             // 后缀正则  
             test: /\.js$/,  
             // 加载器组  
             use: [  
                 {  
                     loader: &#39;babel-loader&#39;,  
                 },  
                 {  
                     loader: &#39;eslint-loader&#39;,  
                 },  
             ],  
             exclude: /node_modules/,  
         },  
         {  
             test: /\.less$/,  
             use: ExtractTextPlugin.extract({  
                 fallback: &#39;style-loader&#39;,  
                 use: [  
                     &#39;css-loader&#39;,  
                     &#39;postcss-loader&#39;,  
                     &#39;less-loader&#39;,  
                 ],  
             }),  
             exclude: /node_modules/,  
         },  

         {  
             test: /\.(woff|woff2)(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                     options: {  
                         name: &#39;[path][name].[ext]&#39;,  
                         limit: 10240,  
                         mimetype: &#39;application/font-woff&#39;,  
                     }  
                 },  
             ],  
             // loaders: [&#39;url-loader?&amp;amp;limit=102400&amp;amp;mimetype=application/font-woff&#39;],  
         },  
         {  
             test: /\.ttf(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                     options: {  
                         name: &#39;[path][name].[ext]&#39;,  
                         limit: 10240,  
                         mimetype: &#39;application/octet-stream&#39;,  
                     }  
                 },  
             ],  
             // loaders: [&#39;url-loader?name=[path][name].[ext]&amp;amp;limit=1024&amp;amp;mimetype=application/octet-stream&#39;],  
         },  
         {  
             test: /\.eot(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;file-loader&#39;,  
                     options: {  
                         name: &#39;[path][name].[ext]&#39;,  
                     }  
                 },  
             ],  
             // loaders: [&#39;file-loader?name=[path][name].[ext]&#39;],  
         },  
         {  
             test: /\.svg(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                 },  
             ],  
             // loaders: [&#39;url-loader?name=[path][name].[ext]&amp;amp;limit=1024&amp;amp;mimetype=image/svg+xml&#39;],  
         },  
         {  
             test: /\.(png|jpg|gif)$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                 },  
             ],  
             // loaders: [&#39;url-loader?name=[path][name].[ext]?[hash]&amp;amp;limit=204800000&#39;], // 单位bit  
             exclude: /node_modules/,  
         },  
     ],  
 },  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>wepack3 详解</title>
            <link>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack/</link>
            <pubDate>Tue, 12 Dec 2017 15:47:11 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://doc.webpack-china.org/&#34;&gt;webpack3中文文档&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000012068849&#34;&gt;Fis3构建迁移Webpack之路&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/fouber/blog/issues/6&#34;&gt;大公司里怎样开发和部署前端代码&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/webpack-china/awesome-webpack-cn&#34;&gt;awesome-webpack-cn&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000005742122&#34;&gt;webpack进阶之插件篇&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000012356915&#34;&gt;webpack飞行手册 &lt;em&gt;推荐&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.pytool.com/images/webpack.svg&#34; alt=&#34;webpack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;entry：入口，定义要打包的文件&lt;br /&gt;
output：出口，定义打包输出的文件；包括路径，文件名，还可能有运行时的访问路径（publicPath）参数&lt;br /&gt;
module: webpack将所有资源都看做是模块,而模块就需要加载器；&lt;br /&gt;
  loaders: Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。&lt;br /&gt;
plugins：定义以下额外的插件&lt;br /&gt;
resolve：定义能够被打包的文件，文件后缀名&lt;br /&gt;
    extensions: [&amp;ldquo;, &amp;lsquo;.js&amp;rsquo;, &amp;lsquo;.es6&amp;rsquo;]&lt;/p&gt;

&lt;h3 id=&#34;wenbpack-安装失败的原因&#34;&gt;wenbpack 安装失败的原因&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、网络问题    cnpm&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2、权限问题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3、node 版本问题&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==============================================&lt;/p&gt;

&lt;h3 id=&#34;webpack版本问题修改&#34;&gt;webpack版本问题修改&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新项目&lt;br /&gt;
&amp;gt;直接删除node_modules 重新安装 npm install &amp;ndash;save-dev webpack&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;旧项目&lt;br /&gt;
&amp;gt;修改package.json中的版本号   删除node_modules   重新  npm install&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===============================================&lt;/p&gt;

&lt;h3 id=&#34;学习步骤&#34;&gt;学习步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、配置文件webpack.config.js&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2、entery选项（入口配置）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3、output选项（出口配置）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4、多入口、多出口配置&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==================================================&lt;/p&gt;

&lt;h3 id=&#34;基本结构&#34;&gt;基本结构&lt;/h3&gt;

&lt;p&gt;const path=require(&amp;lsquo;path&amp;rsquo;);&lt;br /&gt;
module.export={&lt;br /&gt;
    entry:{&lt;br /&gt;
        entry:&amp;lsquo;文件路径&amp;rsquo;&lt;br /&gt;
    },       入口配置&lt;br /&gt;
    output:{&lt;br /&gt;
        path：path.resolve(__dirname,&amp;lsquo;dist&amp;rsquo;),  node语法相对路径&lt;br /&gt;
        filename:&amp;rsquo;[name].js&amp;rsquo;    //压缩后的文件名&lt;br /&gt;
    },      出口配置&lt;br /&gt;
    module:{},      解读css  图片转换压缩&lt;br /&gt;
    plugins:[]      插件&lt;br /&gt;
    devServer:{}    配置服务&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;======================================================&lt;/p&gt;

&lt;h3 id=&#34;webpack配置服务-热更新技术&#34;&gt;webpack配置服务、热更新技术&lt;/h3&gt;

&lt;p&gt;devServer:{&lt;br /&gt;
    contentBase:path.resolve(__dirname,&amp;lsquo;dist&amp;rsquo;),&lt;br /&gt;
    host:&amp;lsquo;192.168.199.106&amp;rsquo;,           //服务器地址&lt;br /&gt;
    compress:true,                    //服务器是否压缩&lt;br /&gt;
    port:1717                        //服务器端口&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;npm install webpack-dev-server &amp;ndash;save-dev&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;修改package.json&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;script&amp;rdquo;:{&lt;br /&gt;
&amp;ldquo;server&amp;rdquo;:&amp;ldquo;webpack-dev-server&amp;rdquo;&lt;br /&gt;
}&lt;br /&gt;
&amp;gt;起服务  npm run server&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;webpack3.6以上的热更新&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;=========================================================&lt;/p&gt;

&lt;h3 id=&#34;css打包&#34;&gt;css打包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;style-loader      //处理css中URL&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;css-loader        //对标签处理&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;module:{&lt;br /&gt;
        rules:[&lt;br /&gt;
            {&lt;br /&gt;
                test:/.css$/,    //通过正则的方式找到处理的扩展&lt;br /&gt;
                //use:[&amp;lsquo;style-loader&amp;rsquo;,&amp;lsquo;css-loader]&lt;br /&gt;
                //loader&lt;br /&gt;
                //use:[{&lt;br /&gt;
                    loader:&amp;lsquo;style-loader&amp;rsquo;&lt;br /&gt;
                    },{&lt;br /&gt;
                        loader:&amp;lsquo;css-loader&amp;rsquo;&lt;br /&gt;
                }]&lt;br /&gt;
            }&lt;br /&gt;
        ]&lt;br /&gt;
    },&lt;/p&gt;

&lt;p&gt;================================================================&lt;/p&gt;

&lt;h3 id=&#34;js打包&#34;&gt;js打包&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;引入插件 uglify&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;const uglify = require(&amp;lsquo;uglifyjs-webpack-plugin&amp;rsquo;);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;plugins:[&lt;br /&gt;
new uglify()&lt;br /&gt;
]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==================================================================&lt;/p&gt;

&lt;h3 id=&#34;html打包&#34;&gt;html打包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装并引入插件  html-webpack-plugin&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;const htmlPlugin = require(&amp;lsquo;html-webpack-plugin&amp;rsquo;);&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;plugins:[&lt;br /&gt;
new  htmlPlugin({&lt;br /&gt;
    minify:{&lt;br /&gt;
        removeAttributeQuotes:true&lt;br /&gt;
    },&lt;br /&gt;
    hash:true,&lt;br /&gt;
    template:&amp;lsquo;./src/index.html&amp;rsquo;&lt;br /&gt;
})&lt;br /&gt;
]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;template：是要打包的html模版路径和文件名称。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=====================================================================&lt;/p&gt;

&lt;h3 id=&#34;css图片路径问题&#34;&gt;css图片路径问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;module:[{&lt;br /&gt;
rules{&lt;br /&gt;
    test:/.(png|jpg|gif)/,&lt;br /&gt;
    use:[{&lt;br /&gt;
        loader:&amp;lsquo;url-loader&amp;rsquo;,&lt;br /&gt;
        options:{&lt;br /&gt;
            limit:50000&lt;br /&gt;
        }&lt;br /&gt;
    }]&lt;br /&gt;
}&lt;br /&gt;
}]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test:/.(png|jpg|gif)/是匹配图片文件后缀名称。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;use：是指定使用的loader和loader的配置参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;limit：是把小于500000B的文件打成Base64的格式，写入JS。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===============================================================&lt;/p&gt;

&lt;h3 id=&#34;css分离&#34;&gt;css分离&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装插件  extract-text-webpack-plugin&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;引入插件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在插件中声明&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;修改处理css&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;rules:[&lt;br /&gt;
{&lt;br /&gt;
    test:/.css$/,&lt;br /&gt;
    use:extractTextPlugin.extract({&lt;br /&gt;
        fallback:&amp;lsquo;style-loader&amp;rsquo;,&lt;br /&gt;
        use:&amp;lsquo;css-loader&amp;rsquo;&lt;br /&gt;
    })&lt;br /&gt;
}]&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===================================================================&lt;/p&gt;

&lt;h3 id=&#34;处理html中的图片&#34;&gt;处理html中的图片&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装插件  html-withimg-loader&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;配置插件&lt;br /&gt;
&amp;gt;{&lt;br /&gt;
test:/.(html|htm)$/i,&lt;br /&gt;
use:[&amp;lsquo;html-withimg-loader&amp;rsquo;]&lt;br /&gt;
}&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;====================================================================&lt;/p&gt;

&lt;h3 id=&#34;自动补全css前缀&#34;&gt;自动补全css前缀&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装插件  postcss-loader   autoprefixer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建postcss.config.js&lt;br /&gt;
&amp;gt;module.exports={&lt;br /&gt;
plugins:[&lt;br /&gt;
    require(&amp;lsquo;auotprefixer&amp;rsquo;)&lt;br /&gt;
]&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写loader&lt;br /&gt;
&amp;gt;{&lt;br /&gt;
test: /.css$/,&lt;br /&gt;
use: extractTextPlugin.extract({&lt;br /&gt;
    fallback: &amp;lsquo;style-loader&amp;rsquo;,&lt;br /&gt;
    use: [&lt;br /&gt;
        { loader: &amp;lsquo;css-loader&amp;rsquo;, options: { importLoaders: 1 } },&lt;br /&gt;
        &amp;lsquo;postcss-loader&amp;rsquo;&lt;br /&gt;
    ]&lt;br /&gt;
})&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;git@github.com:heavenswen/webpack-page.git&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//编译状态  
const Env = process.env.NODE_ENV === &#39;production&#39;  
const { join, resolve } = require(&#39;path&#39;)  
const webpack = require(&#39;webpack&#39;)  
const glob = require(&#39;glob&#39;)  
// const ImageminPlugin = require(&#39;imagemin-webpack-plugin&#39;).default;  
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)  
const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)  
const CommonsChunkPlugin = require(&#39;webpack/lib/optimize/CommonsChunkPlugin&#39;)  
const LiveReloadPlugin = require(&#39;webpack-livereload-plugin&#39;)  
const ROOT = process.cwd();  // 根目录  
// 通过允许您并行转换多个文件， HappyPack使Webpack构建更快。  
const HappyPack = require(&#39;happypack&#39;);  
const HappyThreadPool = HappyPack.ThreadPool({ size: (Env ? 10 : 4) });  
const release = Env ? &#39;/&#39; : &#39;/&#39;//域名文件夹  
//页面对应路口  
const entries = {}  
//入口对象集  
const chunks = []  
//页面list  
const pagesList = []  
//logo  
const favicon = &amp;quot;./src/assets/img/logo.png&amp;quot;  
// 页面模版  
const entryHtml = []  

//页面模版  
glob.sync(&amp;quot;./src/pages/**/*.{ejs,html}&amp;quot;).forEach(path =&amp;gt; {  
  //HtmlWebpackPlugin 不支持 .html 编译 ejs 用.ejs  
  let filename = path.split(&#39;./src/pages/&#39;)[1]  

  //入口js文件名  
  let chunk = path.split(&#39;./src/pages/&#39;)[1].split(/\.(ejs|html)/)[0]  
  //设置产出路径  
  chunk = &#39;js/&#39; + chunk  
  // 入口js路径  
  let js = path  

  //js路径  
  js = js.replace(/\/pages/ig, &#39;/entry&#39;);  
  js = js.replace(/\.(ejs|html)/gi, &#39;.js&#39;);  
  entries[chunk] = js  
  //入口js名称名称  
  chunks.push(chunk)  

  filename = filename.replace(/\.ejs/ig, &#39;.html&#39;)  
  //获得所有页面  
  pagesList.push(filename)  
  let htmlConf = {  
    filename: filename,//文件名  
    //模版位置  
    template: path,  
    inject: &#39;body&#39;,  
    favicon: favicon,  
    hash: Env,  
    env: Env,//HtmlWebpackPlugin.options.env 非打包时的处理  
    list: pagesList,//页面地址  
    chunks: [&#39;vendors&#39;, chunk] //chunk  
  }  

  //保存配置  
  entryHtml.push(htmlConf)  

})  

const config = {  
  entry: entries,  
  output: {  
    path: resolve(__dirname, &#39;./dist&#39;),  
    filename: &#39;[name].js&#39;,  
    publicPath: release  
  },  
  resolve: {  
    //路径检索  
    extensions: [&#39;.js&#39;, &#39;.vue&#39;],  
    alias: {  
      //资源  
      assets: join(__dirname, &#39;/src/assets&#39;),  
      //组件  
      components: join(__dirname, &#39;/src/components&#39;),  
      //视图  
      views: join(__dirname, &#39;/src/views&#39;),  
      root: join(__dirname, &#39;node_modules&#39;)  

    }  
  },  
  module: {  
    //忽略以下js  
    noParse: /node_modules\/(jquey|zepto|moment|chart\.js)/,  
    rules: [  
      {  
        test: /\.vue$/,  
        use: &#39;vue-loader&#39;  
      },  
      {  
        test: /\.js$/,  
        use: [{  
          loader: &#39;babel-loader?id=js&#39;,  
          options: {  
            //es6  
            presets: [&#39;es2015&#39;]  
          }  
        }],  
        exclude: /node_modules/  
      },  
      {  
        //编译sass  
        test: /\.(scss|sass)$/,  
        use: ExtractTextPlugin.extract({  
          fallback: &#39;style-loader?id=style&#39;,  
          use: [{  
            loader: &#39;css-loader?id=style&#39;,  
            options: {  
              //压缩css  
              minimize: Env  
            }  
          }, &#39;postcss-loader?id=style&#39;, &#39;sass-loader?id=style&#39;],  
        })  

      },  
      {  
        test: /\.css$/,  
        use: ExtractTextPlugin.extract({  
          fallback: &#39;style-loader?id=style&#39;,  
          use: [{  
            loader: &#39;css-loader?id=style&#39;,  
            options: {  
              //压缩css  
              minimize: Env  
            }  
          }, &#39;postcss-loader?id=style&#39;],  
        })  
      },  

      {  
        //修改html img路径  
        test: /\.html$/,  
        use: [{  
          loader: &#39;html-loader&#39;,  
          options: {  
            root: resolve(__dirname, &#39;src&#39;),  
            attrs: [&#39;img:src&#39;, &#39;img:data-src&#39;, &#39;img:data-background&#39;, &#39;link:href&#39;]  
          }  
        }]  
      },  
      {  
        test: /\.(png|jpg|jpeg|gif|svg|svgz)(\?.+)?$/,  
        exclude: /favicon\.(png|ico)$/,//除外  
        loaders: [  
          &#39;url-loader?limit=1000&amp;amp;outputPath=assets/img/&amp;amp;name=[name].[ext]?[hash]&#39;,  
          {  
            //图片压缩  
            loader: &#39;image-webpack-loader&#39;,  
            options: {  
              gifsicle: {  
                interlaced: false,  
              },  
              optipng: {  
                optimizationLevel: 1,  
              },  
              pngquant: {  
                quality: &#39;65-90&#39;,  
                speed: 4  
              },  
              mozjpeg: {  
                progressive: true,  
                quality: 65  
              }  
            }  
          }  
        ]  
      },  
      {  
        //文字资源  
        test: /\.(eot|ttf|woff|woff2)(\?.+)?$/,  
        use: [{  
          loader: &#39;url-loader&#39;,  
          options: {  
            limit: 1000,  
            name: &amp;quot;[name].[ext]?[hash]&amp;quot;,  
            outputPath: &amp;quot;assets/fonts/&amp;quot;,//产出目录  
          }  
        }]  
      },  
      {  
        //资源  
        test: /\.(apk|docx|doc|exe)(\?.+)?$/,  
        use: [{  
          loader: &#39;file-loader&#39;,  
          options: {  
            name: &amp;quot;[name].[ext]?[hash]&amp;quot;,  
            outputPath: &amp;quot;assets/file/&amp;quot;,//产出目录  
          }  
        }]  
      }  
    ]  
  },  
  plugins: [  
    //会跟 webpack-dev-server 冲突，导致js修改时找不到修改对象  
    // new LiveReloadPlugin({  
    // }),  
    new HappyPack({  
      id: &#39;js&#39;,  
      // @see https://github.com/amireh/happypack  
      threadPool: HappyThreadPool,  
      loaders: [&#39;babel-loader&#39;]  
    }),  
    new HappyPack({  
      id: &#39;styles&#39;,  
      threadPool: HappyThreadPool,  
      loaders: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]  
    }),  
    //获取公用模块生成js  
    new CommonsChunkPlugin({  
      name: &#39;vendors&#39;,  
      filename: &#39;assets/js/vendors.js?[hash]&#39;,  
      chunks: chunks,  
      minChunks: chunks.length  
    }),  
    //提取公用模块生成css  
    new ExtractTextPlugin({  
      filename: (getPath) =&amp;gt; {  
        //获得地址  
        let name = getPath(&#39;[name]&#39;)  

        if (!name.match(/vendors/ig)) {  
          let arr = name.split(&#39;/&#39;)  
          name = arr[arr.length - 1]//获得文件名  
        }  
        return &#39;assets/css/&#39; + name + &#39;.css&#39;;  
      },  
      allChunks: true  
    }),  
    //webpack3.0  
    new webpack.optimize.ModuleConcatenationPlugin()  
  ],  
  devServer: {  
    contentBase: [  
      join(ROOT, &#39;src/&#39;)  
    ],  
    port: 8010,  
    //启动路由功能  
    //historyApiFallback: false,  
    // noInfo: true,  
    hot: false,  
    //真实地址 可以用局域访问  
    disableHostCheck: true,  
    //允许其他电脑访问  
    host: &#39;0.0.0.0&#39;,  
  },  
  devtool: &#39;#eval-source-map&#39;  
}  


//页面模版  
entryHtml.forEach(function (v) {  
  config.plugins.push(new HtmlWebpackPlugin(v));  
});  

module.exports = config  

if (process.env.NODE_ENV === &#39;production&#39;) {  
  module.exports.devtool = &#39;#source-map&#39;  
  // http://vue-loader.vuejs.org/en/workflow/production.html  
  module.exports.plugins = (module.exports.plugins || []).concat([  
    new webpack.DefinePlugin({  
      &#39;process.env&#39;: {  
        NODE_ENV: &#39;&amp;quot;production&amp;quot;&#39;  
      }  
    }),  
    //压缩单元  
    new webpack.optimize.UglifyJsPlugin({  
      // 最紧凑的输出  
      beautify: false,  
      // 删除所有的注释  
      comments: false,  
      compress: {  
        // 在UglifyJs删除没有用到的代码时不输出警告  
        warnings: false,  
        // 删除所有的 `console` 语句  
        // 还可以兼容ie浏览器  
        drop_console: true,  
        // 内嵌定义了但是只用到一次的变量  
        collapse_vars: true,  
        // 提取出出现多次但是没有定义成变量去引用的静态值  
        reduce_vars: true,  
      }  
    }),  

  ])  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var path = require(&#39;path&#39;);  
var fs = require(&#39;fs&#39;);  
var webpack = require(&#39;webpack&#39;);  
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);  
var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);  
var FriendlyErrorsWebpackPlugin = require(&#39;friendly-errors-webpack-plugin&#39;);  

console.log(&#39;NODE_ENV&#39;,process.env.NODE_ENV);  

const extractCSS = new ExtractTextPlugin(&#39;css/[name]-one.css&#39;);  
const extractLESS = new ExtractTextPlugin(&#39;css/[name]-two.css&#39;);  
const extractSASS = new ExtractTextPlugin(&#39;css/[name]-three.css&#39;);  

var config = {  
    entry: {  
        main: [  
            // &#39;babel-polyfill&#39;,  
            &#39;webpack-hot-middleware/client?path=/__webpack_hmr&amp;amp;timeout=20000&amp;amp;reload=true&#39;,  
            &#39;webpack/hot/dev-server&#39;,  
            path.resolve(__dirname, &#39;src/main.js&#39;),  
            path.resolve(__dirname, &#39;src/index.js&#39;)  
        ],  
        verdor: [  
            path.resolve(__dirname, &#39;src/verdor/verdor.js&#39;),  
        ]  
    },  
    // entry: path.resolve(__filename, &#39;../src/main.js&#39;),  
    output: {  
        path: path.resolve(__filename, &#39;../dist&#39;),  
        publicPath: &#39;/&#39;,  
        filename: &#39;[name].[hash:8].bundle.js&#39;,  
        // webpack 允许你根据文件内容生成哈希值，只要用 [chunkhash] 替换 [hash] 就可以了  
        // 不要在开发环境下使用 [chunkhash]，因为这会增加编译时间。将开发和生产模式的配置分开，并在开发模式中使用 [name].js 的文件名， 在生产模式中使用 [name].[chunkhash].js 文件名。  
        //    publicPath: &#39;/&#39;,  
        //    chunkFilename: &#39;[id].[chunkhash].js&#39;  
    },  
    // 生成.map文件  
    // devtool: &#39;source-map&#39;,  
    module: {  
        rules: [  
            // 加载JSON文件 使用json-loader webpack1  
            // wenpack2 + ,json-loader 不再需要手动添加  
            // [官方: 是为了消除 webpack、 node.js 和 browserify 之间的环境差异。 https://github.com/webpack/webpack/issues/3363]  
            // {  
            //     test: /\.json$/,  
            //     use: &#39;json-loader&#39;  
            // },  

            // 处理 .json5结尾的文件  
            {  
                test: /\.json5$/,  
                use: &#39;json5-loader&#39;  
            },  
            // {  
            //     test: /\.css$/,  
            //     // 使用①生成的css文件 插入到html中  
            //     // use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]  
            //     // 使用②ExtractTextPlugin 生成style.css文件  
            //     // 在主入口文件中import  
            //     use: ExtractCSS.extract([  
            //         &#39;css-loader&#39;,  
            //         // &#39;px2rem2-loader&#39;,  
            //         &#39;postcss-loader&#39;,  
            //     ]),  
            // }  

            // 使用postcss方式， css 插入到DOM形式 ， 支持热更新  
            // {  
            //     test: /\.css$/,  
            //     use: [ &#39;style-loader&#39;, &#39;css-loader&#39;,  &#39;postcss-loader&#39; ]  
            // },  
            {  
                test: /\.less$/,  
                use: extractLESS.extract({  
                    fallback: [&#39;style-loader&#39;],  
                    use: [  
                        &#39;css-loader&#39;,  
                        &#39;postcss-loader&#39;,  
                        &#39;less-loader&#39;  
                    ]  
                })  
            },  
            {  
                test: /\.scss$/,  
                use: extractSASS.extract({  
                    fallback: [&#39;style-loader&#39;],  
                    use: [  
                        &#39;css-loader&#39;,  
                        &#39;postcss-loader&#39;,  
                        &#39;sass-loader&#39;  
                    ]  
                })  
            },  
            // ExtractTextPlugin 提取了样式出来， 官方说No Hot Module Replacement。  
            // https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/webpack-1/README.md  
            {  
                test: /\.css$/,  
                use: extractCSS.extract({  
                    fallback: [&#39;style-loader&#39;],  
                    use: [  
                        &#39;css-loader&#39;,  
                        &#39;postcss-loader&#39;  
                    ]  
                })  
            },  
            {  
                test: /\.js(x)*$/,  
                exclude: /node_modules/,  
                loader: &#39;babel-loader&#39;  
            },  
            {  
                test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,  
                loader: &#39;url-loader&#39;,  
                options: {  
                    limit: 8000,  
                    name: &#39;image/[name].[hash:7].[ext]&#39;  
                }  
            },  
            {  
                test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,  
                loader: &#39;url-loader&#39;,  
                options: {  
                    limit: 8000,  
                    name: &#39;font/[name].[hash:7].[ext]&#39;  
                }  
            },  
            // 手写一个简单的webpack loader  
            // 处理 .huangyb 后缀的文件  
            {  
                test: /\.huangyb$/,  
                loader: &#39;huangyb-loader&#39;  
            }  
        ]  
    },  
    plugins: [  
        // 生成html文件，里面的JS文件 src 地址自动添加hash  
        new HtmlWebpackPlugin({  
            title: &#39;huangyb&#39;,  
            favicon: &#39;./src/image/logoNew.gif&#39;,  
            filename: &#39;index.html&#39;,  
            minify:{  
                removeComments: true, // 删除注释  
                collapseWhitespace: true // 删除空格  
            }  
        }),  
        // CSS生成单独的文件  
        // new ExtractTextPlugin({  
        //     filename: &#39;css/[name][hash:8].css&#39;,  
        //     allChunks: true,  
        //     disable: false  
        // })  

        extractCSS,  
        extractLESS,  
        extractSASS,  

        // 用来跳过编译时出错的代码并记录，使编译后运行时的包不会发生错误  
        // * webpack3 NoEmitOnErrorsPlugin 已经 取代webpack 2 的 NoErrorsPlugin  
        new webpack.NoEmitOnErrorsPlugin(),  
        new FriendlyErrorsWebpackPlugin(), // 终端显示  

        new webpack.optimize.CommonsChunkPlugin({ // 提取公用JS代码插件  
            names: [&#39;vendor&#39;],  
            // ( 公共chunk(commnons chunk) 的名称)  
            filename: &#39;commons.js&#39;,  
            // ( 公共chunk 的文件名)  
            minChunks: 3  
            // (模块必须被3个 入口chunk 共享)  
            // CommonsChunkPlugin 可以通过传参minChunks来控制你希望重复出现几次的module 被提取出来打包。  
            // 也就是说你自己可以控制当一个模块被引入几次可以被打包到共用的chunk中，还可以规定如果这个公共模块小于一个值 minSize，  
            // 就不被提取出来这些都可以帮助你控制你想要的粒度。当你改的不是公共模块的代码，理论上webpack 打包的时候本来就不会影响其他代码。  
            // chunks: [&#39;pageA&#39;, &#39;pageB&#39;],  
            // (只使用这些 入口chunk)  
        }),  

        // OccurrenceOrderPlugin 现在默认启用，并已重命名（在 webpack 1 中为 OccurenceOrderPlugin）。 因此，请确保从您的配置中删除该插件：  
        // OccurrenceOrderPlugin is now on by default  
        // new webpack.optimize.OccurrenceOrderPlugin(),  
        new webpack.HotModuleReplacementPlugin()  
    ]  
    // resolve: {  
    //     alias: {  
    //         huangImg: path.resolve(__dirname, &#39;src/image/&#39;)  
    //     }  
    // }  
}  

module.exports = config;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*  
 * @Author: ignaciozhu  
 * @Date: 2017-05-03 16:32:21  
 * @Last Modified by: ignaciozhu  
 * @Last Modified time: 2017-06-02 11:50:06  
 */  
//配置本地反向代理文件夹所在路径  
const DIST = &#39;../../../ya/client_html/branch/nginx-1.10.1/&#39;;  
const path = require(&#39;path&#39;)  
const webpack = require(&#39;webpack&#39;)  
const HtmlWebpackPlugin = require(&amp;quot;html-webpack-plugin&amp;quot;) //自动生成一个html 引入打包之后的js  
const ExtractTextPlugin = require(&amp;quot;extract-text-webpack-plugin&amp;quot;) //默认打包css 这些全部在js 里面  用这个可以分离出来 单独生成css文件  //生产环节会用到  
const OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;) //打包完成自动打开浏览器  
const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;) //拷贝文件  当有第三方依赖可以copy到打包文件夹中  
const autoprefixer = require(&#39;autoprefixer&#39;) //自动加前缀  
const CptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;) //压缩css  
const ImageminPlugin = require(&#39;imagemin-webpack-plugin&#39;).default //压缩图片  
const { BundleAnalyzerPlugin } = require(&#39;webpack-bundle-analyzer&#39;) //生成打包图  
const UglifyJSPlugin = require(&#39;uglifyjs-webpack-plugin&#39;); //webpack3 单独分离出来了这个压缩的  

const { host, dev_port } = require(&amp;quot;./config&amp;quot;)  
const { delhttp } = require(&#39;./server/utils/method.js&#39;)  

module.exports = (env) =&amp;gt; {  
  //env 是npm script 运行webpack时传进来的  判断是否是开发环境  
  const mode = (env &amp;amp;&amp;amp; env.mode) || &amp;quot;DEV&amp;quot;  

  const options = {  
      //开发工具  
      devtool: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;source-map&amp;quot; : false,  

      //开发服务器  
      devServer: {  
        contentBase: path.resolve(__dirname, &amp;quot;dist&amp;quot;), //静态资源根目录  
        compress: true, //压缩  
        port: dev_port, //端口  
        host: delhttp(host),  
        hot: true, //热更新  
        inline: true, //iframe 模式  
        historyApiFallback: true, //浏览器 history  
        stats: { //统计  
          color: true, //输出有颜色的信息  
          errors: true, //显示错误信息  
          version: true, //显示版本号  
          warnings: true, //显示警告  
          progress: true, //显示进度,  
          timings: true, //显示时间  
        }  
      },  

      //入口  
      entry: mode === &amp;quot;DEV&amp;quot; ? [  
        &amp;quot;react-hot-loader/patch&amp;quot;, //热更新  
        `webpack-dev-server/client?${host}:${dev_port}`,  
        &amp;quot;webpack/hot/only-dev-server&amp;quot;,  
        path.resolve(__dirname, &amp;quot;src/index.js&amp;quot;),  
      ] : {  
        app: path.resolve(__dirname, &amp;quot;src/index.js&amp;quot;),  
        // vendor:[&#39;react&#39;]  
      },  

      //打包输出  
      output: {  
        path: path.resolve(__dirname, DIST + &amp;quot;dist&amp;quot;), ///myblog  
        filename: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;js/[name].js&amp;quot; : &amp;quot;./js/[name].[chunkhash:8].js&amp;quot;,  
        chunkFilename: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;js/[name]Chunk.js&amp;quot; : &amp;quot;./js/[name]Chunk.[chunkhash:8].js&amp;quot;,  
        publicPath: mode === &amp;quot;DEV&amp;quot; ? `${host}:${dev_port}/` : &amp;quot;/&amp;quot; //myblog/  
      },  

      //模块加载器  
      module: {  
        rules: [{  
          test: /\.js[x]?$/,  
          use: [{  
            loader: &amp;quot;babel-loader&amp;quot;  
          }],  
          exclude: &amp;quot;/node_modules/&amp;quot;,  
          use: [  
            // {loader:&#39;react-hot-loader&#39;},  
            {  
              loader: &amp;quot;babel-loader&amp;quot;,  
              options: {  
                //按需加载模块，antd...  
                plugins: [  
                  [&amp;quot;import&amp;quot;, [{  
                    &amp;quot;libraryName&amp;quot;: &amp;quot;antd&amp;quot;,  
                    &amp;quot;libraryDirectory&amp;quot;: &amp;quot;lib&amp;quot;,  
                    &amp;quot;style&amp;quot;: true  
                  }, {  
                    &amp;quot;libraryName&amp;quot;: &amp;quot;antd-mobile&amp;quot;,  
                    &amp;quot;libraryDirectory&amp;quot;: &amp;quot;component&amp;quot;,  
                  }, ]],  
                  // &amp;quot;transform-decorators-legacy&amp;quot;,  
                  // &amp;quot;transform-class-properties&amp;quot;  
                ]  
              }  
            },  
          ],  
          include: [path.resolve(&amp;quot;src&amp;quot;)] //只遍历src目录下的  
        }, {  
          test: /\.less$/,  
          use: mode === &amp;quot;DEV&amp;quot; //开发环境 css打包到js中  
            ? [  
              { loader: &amp;quot;style-loader&amp;quot; }, //loader 倒序执行  先执行 less-laoder  
              { loader: &amp;quot;css-loader&amp;quot;, options: { minimize: false, sourceMap: true } },  
              { loader: &amp;quot;postcss-loader&amp;quot; }, //自动加前缀  
              { loader: &amp;quot;less-loader&amp;quot;, options: { sourceMap: true } }  
            ] : ExtractTextPlugin.extract({ //生产环境 把css单独分离出来  
              fallback: &amp;quot;style-loader&amp;quot;,  
              use: [  
                &amp;quot;css-loader&amp;quot;,  
                &amp;quot;postcss-loader&amp;quot;, {  
                  loader: &amp;quot;less-loader&amp;quot;,  
                  options: {  
                    sourceMap: false,  
                  },  
                },  
              ],  
            })  
        }, {  
          test: /\.css$/,  
          use: mode === &amp;quot;DEV&amp;quot; ? [  
            { loader: &amp;quot;style-loader&amp;quot; }, //loader 倒序执行  先执行 less-laoder  
            { loader: &amp;quot;css-loader&amp;quot;, options: { minimize: false, sourceMap: true } },  
            { loader: &amp;quot;postcss-loader&amp;quot; }  
          ] : ExtractTextPlugin.extract({  
            fallback: &amp;quot;style-loader&amp;quot;,  
            use: [  
              &amp;quot;css-loader&amp;quot;,  
              &amp;quot;postcss-loader&amp;quot;, {  
                loader: &amp;quot;less-loader&amp;quot;,  
                options: {  
                  sourceMap: false  
                },  
              },  
            ],  
          })  
        }, {  
          test: /\.(jpg|jpeg|png|gif|cur|ico)$/,  
          use: [{  
            loader: &#39;file-loader&#39;,  
            options: {  
              name: &amp;quot;images/[name][hash:8].[ext]&amp;quot; //遇到图片  生成一个images文件夹  名字.后缀的图片  
            }  
          }]  
        }, {  
          test: /\.(eot|ttf|svg|woff|woff2)$/,  
          use: [{  
            loader: &amp;quot;file-loader&amp;quot;,  
            options: {  
              name: &amp;quot;fonts/[name][hash:8].[ext]&amp;quot;,  
            },  
          }, ],  
        }, ]  
      },  

      //自动补全后缀  
      resolve: {  
        enforceExtension: false, //2.0 后 不能写 extensions :[&amp;quot;&amp;quot;]  
        extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.json&#39;], //比如 test.js   可以写成 require(&#39;test&#39;)  
        alias: {  
          // Support React Native Web  
          // https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/  
          &#39;react-native&#39;: &#39;react-native-web&#39;,  
          components: path.resolve(__dirname) + &#39;/src/common/components&#39;,  
          /* container: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/container&#39;,  
           images: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/images&#39;,  
           pages: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/pages&#39;,  
           utils: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/utils&#39;,  
           data: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/server/data&#39;,  
           actions: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/actions&#39;,  
           reducers: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/reducers&#39;,*/  
        },  
        modules: [  
          path.resolve(&amp;quot;src&amp;quot;), //比如 src/app/components/xx  可以写成 app/components/xx  
          path.resolve(&amp;quot;.&amp;quot;),  
          path.resolve(&amp;quot;src/shared&amp;quot;),  
          &amp;quot;node_modules&amp;quot;,  
        ],  
      },  

      //插件  
      plugins: []  
    }  
    //根据开发环境不同  concat 不同的插件  
  if (mode === &amp;quot;DEV&amp;quot;) {  
    options.plugins = options.plugins.concat([  
      new webpack.NamedModulesPlugin(), //打印更具可读性模块名称在浏览器控制台  
      new webpack.NoEmitOnErrorsPlugin(), //错误不打断  
      new webpack.DefinePlugin({ //调试  
        __DEBUG__: true,  
      }),  
      new webpack.HotModuleReplacementPlugin(), //热加载插件  
      /*      new OpenBrowserPlugin({ //编译完成打开浏览器  
              url: `${host}:${dev_port}`  
            })*/  
    ])  
  } else {  
    options.plugins = options.plugins.concat([  
      // new BundleAnalyzerPlugin(),     //生成打包图  
      // //webpackv3.0新增 作用域提升 默认是闭包式打包 浏览器执行速度变慢  
      // //开启这个去掉模块的包裹函数,体积更小  
      // new webpack.optimize.ModuleConcatenationPlugin(),  
      new webpack.DefinePlugin({  
        &amp;quot;process.env.NODE_ENV&amp;quot;: JSON.stringify(&amp;quot;production&amp;quot;),  
        __DEBUG__: false,  
      }),  
      new UglifyJSPlugin({ //压缩  
        output: {  
          comments: false //移除所有注释  
        },  
        compress: {  
          warnings: false  
        }  
      }),  
      new ExtractTextPlugin({ // 将打包文件中的css分离成一个单独的css文件  
        filename: &#39;css/app.[contenthash:8].css&#39;,  
        allChunks: true  
      }),  
      //[1]  
      //找到所有node_modules的依赖包  分离出来  
      // /axios/ 没有用到的模块  
      new webpack.optimize.CommonsChunkPlugin({  
        name: &amp;quot;app&amp;quot;,  
        async: &amp;quot;common-in-lazy&amp;quot;,  
        children: true,  
        minChunks: ({ resource } = {}) =&amp;gt; (  
          resource &amp;amp;&amp;amp;  
          resource.includes(&#39;node_modules&#39;) &amp;amp;&amp;amp;  
          /axios/.test(resource)  
        )  
      }),  
      // [2]  
      //找到模块次数使用两次的  分离出来  
      //单独打成used-twice.js 减少包的体积  
      /**  
       * 升级到 v2.6 貌似async不起作用  article admin detail 都使用了但是moment都打包进了对应的chunk文件  
       * 导致文件增大了600kb  
       * 经过github上的提问 各路大神的帮助下  解决了上面这个问题 需要设置name!!!!!!!!!!!  
       */  
      new webpack.optimize.CommonsChunkPlugin({  
        name: &amp;quot;app&amp;quot;,  
        children: true,  
        async: &#39;used-twice&#39;,  
        minChunks: (module, count) =&amp;gt; (  
          count &amp;gt;= 2  
        ),  
      }),  
      //[3]  
      //[1][2][3] 是按需加载 大幅减少打包js体积的关键  
      //遍历node_modules目录 以.js结尾 一道vender chunk  
      //自动化分离第三方依赖  
      new webpack.optimize.CommonsChunkPlugin({  
        name: &#39;app&#39;,  
        filename: &amp;quot;js/common.[chunkhash:8].js&amp;quot;,  
        minChunks: ({ resource }) =&amp;gt; (  
          resource &amp;amp;&amp;amp;  
          resource.indexOf(&#39;node_modules&#39;) &amp;gt;= 0 &amp;amp;&amp;amp;  
          resource.match(/\.js$/)  
        )  
      }),  
      new webpack.LoaderOptionsPlugin({ //laoder最小化  
        minimize: true  
      }),  
      //图片压缩没用。。。什么鬼  
      new ImageminPlugin({  
        // disable:false,  
        test: /\.(jpe?g|png|gif|svg)$/i,  
        optipng: {  
          optimizationLevel: 7  
        }  
      }),  
      new CptimizeCssAssetsPlugin({ //压缩css  与 ExtractTextPlugin 配合使用  
        cssProcessor: require(&#39;cssnano&#39;),  
        cssProcessorOptions: { discardComments: { removeAll: true } }, //移除所有注释  
        canPrint: true //是否向控制台打印消息  
      })  
    ])  
  }  
  options.plugins.push(  
    new HtmlWebpackPlugin({  
      title: &amp;quot;西溪泊岸共享&amp;quot;,  
      filename: &amp;quot;index.html&amp;quot;, //自动把打包的js文件引入进去  
      template: path.resolve(__dirname, &amp;quot;src/index.html&amp;quot;), //模板文件  
      hash: true, //添加hash码  
      inject: true //注射所有资源到 body元素的底部     &amp;quot;head&amp;quot; &amp;quot;body&amp;quot; true false  &amp;quot;body&amp;quot; == true  
    })  
  )  
  return options  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Makefile 详解</title>
            <link>http://blog.pytool.com/post/shell/makefile/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/makefile/</guid>
            <description>

&lt;h2 id=&#34;基本原则&#34;&gt;基本原则&lt;/h2&gt;

&lt;p&gt;.PYTHON伪目标总是不如其它文件“新”，因此它总是被执行。&lt;br /&gt;
@   使命令在被执行前不被回显。&lt;br /&gt;
–   使任何命令行的任何非零退出状态都被忽略。&lt;br /&gt;
+   使命令行可以通过指定 -n、-q 或 -t 选项来执行。&lt;/p&gt;

&lt;h2 id=&#34;模式变量&#34;&gt;模式变量 %&lt;/h2&gt;

&lt;p&gt;argets定义了一系列的目标文件，可以有通配符。是目标的一个集合。&lt;br /&gt;
target-parrtern是指明了targets的模式，也就是的目标集模式。&lt;br /&gt;
prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。&lt;/p&gt;

&lt;p&gt;这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。&lt;br /&gt;
如果我们的&lt;target-parrtern&gt;定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”，意思是对&lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-parrtern&gt;模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。&lt;/p&gt;

&lt;p&gt;所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。&lt;/p&gt;

&lt;p&gt;看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;objects = foo.o bar.o  
all: $(objects)  
$(objects):  
%.o: %.c  
  $(CC) -c $(CFLAGS) $&amp;lt; -o $@  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，&lt;br /&gt;
也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。&lt;br /&gt;
而命令中的“$&amp;lt;”和“$@”则是自动化变量，“$&amp;lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ｍakefile&#34;&gt;foo.o : foo.c  
  $(CC) -c $(CFLAGS) foo.c -o foo.o  
bar.o : bar.c  
  $(CC) -c $(CFLAGS) bar.c -o bar.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：&lt;/p&gt;

&lt;p&gt;files = foo.elc bar.o lose.o&lt;/p&gt;

&lt;p&gt;$(filter %.o,$(files)): %.o: %.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       $(CC) -c $(CFLAGS) $&amp;lt; -o $@  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(filter %.elc,$(files)): %.elc: %.el&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       emacs -f batch-byte-compile $&amp;lt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。&lt;/p&gt;

&lt;h2 id=&#34;自动变量&#34;&gt;自动变量 $&lt;/h2&gt;

&lt;p&gt;$@          &amp;ndash;代表目标文件(target)&lt;br /&gt;
$^          &amp;ndash;代表所有的依赖文件(components)&lt;br /&gt;
$&amp;lt;          &amp;ndash;代表第一个依赖文件(components中最左边的那个)。&lt;/p&gt;

&lt;p&gt;要生成目标 &amp;hellip; : 生成目标所需的依赖 &amp;hellip;&lt;br /&gt;
    command #必须要以[Tab]键开始&lt;/p&gt;

&lt;p&gt;export&lt;unexport&gt; 传递变量到下级 Makefile 中&lt;/p&gt;

&lt;p&gt;$@&lt;br /&gt;
表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，&amp;rdquo;$@&amp;ldquo;就是匹配于&lt;br /&gt;
目标中模式定义的集合。&lt;br /&gt;
  $% 仅匹配目标文件&lt;br /&gt;
仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是&amp;rdquo;foo.a&lt;br /&gt;
(bar.o)&amp;ldquo;，那么，&amp;rdquo;$%&amp;ldquo;就是&amp;rdquo;bar.o&amp;rdquo;，&amp;rdquo;$@&amp;ldquo;就是&amp;rdquo;foo.a&amp;rdquo;。如果目标不是函数库文件（Unix&lt;br /&gt;
下是[.a]，Windows 下是[.lib]），那么，其值为空。&lt;br /&gt;
  $&amp;lt;&lt;br /&gt;
依赖目标中的第一个目标名字。如果依赖目标是以模式（ 即&amp;rdquo;%&amp;ldquo;）定义的，那么&amp;rdquo;$&amp;lt;&amp;ldquo;将&lt;br /&gt;
是符合模式的一系列的文件集。注意，其是一个一个取出来的。&lt;br /&gt;
  $? 依赖的集合(只提取比目标新的)&lt;br /&gt;
所有比目标新的依赖目标的集合。以空格分隔。&lt;br /&gt;
  $^ 依赖的集合(去重)&lt;br /&gt;
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量&lt;br /&gt;
会去除重复的依赖目标，只保留一份。&lt;br /&gt;
  $+ 依赖的集合(不去重)&lt;br /&gt;
这个变量很像&amp;rdquo;$^&amp;ldquo;，也是所有依赖目标的集合。只是它不去除重复的依赖目标。&lt;br /&gt;
  $* 去除后缀名(不推荐使用)&lt;br /&gt;
这个变量表示目标模式中&amp;rdquo;%&amp;ldquo;及其之前的部分。如果目标是&amp;rdquo;dir/a.foo.b&amp;rdquo;，并且目标的&lt;br /&gt;
模式是&amp;rdquo;a.%.b&amp;rdquo;，那么，&amp;rdquo;$&lt;em&gt;&amp;ldquo;的值就是&amp;rdquo;dir/a.foo&amp;rdquo;。这个变量对于构造有关联的文件名是比&lt;br /&gt;
较有较。如果目标中没有模式的定义，那么&amp;rdquo;$&lt;/em&gt;&amp;ldquo;也就不能被推导出，但是，如果目标文件的&lt;br /&gt;
后缀是 make 所识别的，那么&amp;rdquo;$&lt;em&gt;&amp;ldquo;就是除了后缀的那一部分。例如：如果目标是&amp;rdquo;foo.c&amp;rdquo;，因&lt;br /&gt;
为&amp;rdquo;.c&amp;rdquo;是 make 所能识别的后缀名，所以，&amp;rdquo;$&lt;/em&gt;&amp;ldquo;的值就是&amp;rdquo;foo&amp;rdquo;。这个特性是 GNU make 的，&lt;/p&gt;

&lt;p&gt;很有可能不兼容于其它版本的 make，所以，你应该尽量避免使用&amp;rdquo;$&lt;em&gt;&amp;ldquo;，除非是在隐含规则&lt;br /&gt;
或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么&amp;rdquo;$&lt;/em&gt;&amp;ldquo;就是空值。&lt;/p&gt;

&lt;p&gt;在Makefile中写shell代码有点诡异，和不同的shell语法不太一样，如果不了解，看Makefile会莫名其妙。下面总结了一些。&lt;/p&gt;

&lt;h2 id=&#34;makefile和shell&#34;&gt;Makefile和Shell&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Makefile本质上来讲也是shell脚本，即每条command都是shell进程，运行完shell进程都会退出&lt;br /&gt;
&lt;code&gt;Makefile  
test:  
gcc -c main.c -o main.o  
gcc -c a.c -o a.o  
&lt;/code&gt;&lt;br /&gt;
这样输入make test，结果相当于两个进程，都退出了。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;等价于在shell下输命令一样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;my_test:  
  cd /home;mkdir test  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里make my_test，结果相当于一个进程。当前目录是/root 而&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;own_test:  
  cd /home  
  mkdir test  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;make own_test&lt;/code&gt;，相当于两个进程，&lt;br /&gt;
第一个进程是cd /home,运行完回到了/root。这时再运行第二个shell命令就会在/root下创建一个test目录.(makefile中的shell进程命令，跟直接在shell输的命令相同，但是它都会结束本身，即exit)&lt;/p&gt;

&lt;h2 id=&#34;makefile-中变量赋值&#34;&gt;Makefile 中变量赋值&lt;/h2&gt;

&lt;p&gt;1：尽在Makefile文件的目标项冒号后的另起一行的代码才是shell代码。&lt;/p&gt;

&lt;p&gt;第一种方式：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xx = xx1&lt;/code&gt;         // 这里时makefile代码&lt;/p&gt;

&lt;p&gt;第二种方式：&lt;br /&gt;
yy：xx = xx2       // 这是是makefile代码，makefile允许变量赋值时，&amp;rsquo;=&amp;lsquo;号两边留空格  ？？？？？？可以吗&lt;/p&gt;

&lt;p&gt;第三种方式：&lt;br /&gt;
yy：&lt;br /&gt;
   xx=xx3         // 只有这里是shell代码 ，shell不允许‘=’号两边有空格哦。&lt;br /&gt;
yy:&lt;br /&gt;
   xx= xx3        // 只有这里是shell代码 ，shell不允许‘=’号两边有空格哦。&lt;/p&gt;

&lt;p&gt;注意此时xx的值是&amp;rdquo; xx3&amp;rdquo;，多了一个空格&lt;/p&gt;

&lt;p&gt;有一个例外：&lt;br /&gt;
xx=$(shell 这里的代码也是shell代码)&lt;/p&gt;

&lt;h2 id=&#34;变量传递&#34;&gt;变量传递&lt;/h2&gt;

&lt;p&gt;2：Makefile中的shell，每一行是一个进程，不同行之间变量值不能传递。所以，Makefile中的shell不管多长也要写在一行。&lt;br /&gt;
eg：&lt;/p&gt;

&lt;p&gt;SUBDIR=src example&lt;/p&gt;

&lt;p&gt;all:&lt;/p&gt;

&lt;p&gt;@for subdir in $(SUBDIR); /      // 这里往下是一行shell&lt;/p&gt;

&lt;p&gt;do/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   echo &amp;quot;building &amp;quot; $$subdir; /  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;done&lt;/p&gt;

&lt;h2 id=&#34;变量引用-ｍakefile变量-shell的变量&#34;&gt;变量引用 Ｍakefile变量$ shell的变量$$&lt;/h2&gt;

&lt;p&gt;3：Makefile中的变量以$开头，使用$(VAR)或${VAR}来引用变量的定义。 所以，为了避免和shell的变量冲突，shell的变量以$$开头&lt;/p&gt;

&lt;p&gt;注意：Makefile中在对一些简单变量的引用，我们也可以不使用“（）”和“{}”来标记变量名，而直接使用“$x”的格式来实现，此种用法仅限于变量名为单字符的情况。另外自动化变量也使用这种格式。对于一般多字符变量的引用必须使用括号了标记，否则make将把变量名的首字母作为作为变量而不是整个字符串（“$PATH”在Makefile中实际上是“$(P)ATH”）。这一点和shell中变量的引用方式不同。shell中变量的引用可以是“${xx}”或者“$xx”格式。但在Makefile中多字符变量名的引用只能是“$(xx)”或者“${xx}”格式。&lt;/p&gt;

&lt;p&gt;eg1：从当前目录路径中提取出 /application 或 /base_class 之前的部分&lt;br /&gt;
PROJECT_ROOT_DIR = $(shell pwd | awk -F&amp;rsquo;/application|/base_class&amp;rsquo; &amp;lsquo;{print $$1}&amp;rsquo;)&lt;br /&gt;
eg2：上例中$$subdir就是shell中的变量， 而$(SUBDIR)是Makefile的中的变量&lt;/p&gt;

&lt;h2 id=&#34;变量输出-隐藏自身的输出-出错继续运行&#34;&gt;变量输出 @隐藏自身的输出 - 出错继续运行&lt;/h2&gt;

&lt;p&gt;如果make执行的命令前面加了@字符，则不显示命令本身而只显示它的结果; Android中会定义某个变量等于@，例如 hide:= @&lt;br /&gt;
通常make执行的命令如果出错（该命令的退出状态非0）就立刻终止，不再执行后续命令，但如果命令前面加了-号，即使这条命令出错，make也会继续执行后续命令。&lt;br /&gt;
通常rm命令和mkdir命令前面要加-号，因为rm要删除的文件可能不存在，mkdir要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。&lt;/p&gt;

&lt;p&gt;1、在Makefile中只能在target中调用Shell脚本，其他地方是不能输出的。比如如下代码就是没有任何输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VAR=&amp;quot;Hello&amp;quot;  
echo &amp;quot;$(VAR)&amp;quot;  

all:  
  .....  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码任何时候都不会输出，没有在target内，如果上述代码改为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VAR=&amp;quot;Hello&amp;quot;  

all:  
   echo &amp;quot;$(VAR)&amp;quot;  
   .....  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码，在make all的时候将会执行echo命令。&lt;/p&gt;

&lt;p&gt;最后打印结果是:&lt;br /&gt;
echo &amp;ldquo;&amp;ldquo;Hello&amp;rdquo;&amp;rdquo;&lt;br /&gt;
&amp;ldquo;Hello&amp;rdquo;&lt;/p&gt;

&lt;p&gt;2、在Makefile中执行shell命令，一行创建一个进程来执行。这也是为什么很多Makefile中有很多行的末尾都是“;  \”，以此来保证代码是一行而不是多行，这样Makefile可以在一个进程中执行，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SUBDIR=src example  
all:  
   @for subdir in $(SUBDIR); \  
   do\  
       echo &amp;quot;building &amp;quot;; \  
   done  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述可以看出for循环中每行都是以”; \”结尾的。&lt;/p&gt;

&lt;p&gt;3、Makefile中所有以$打头的单词都会被解释成Makefile中的变量。如果你需要调用shell中的变量（或者正则表达式中锚定句位$），都需要加两个$符号（$$）。实例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=&amp;quot;/data/&amp;quot;  

all:  
   echo ${PATH}/*Makefile中变量，即&amp;quot;/data&amp;quot;*/  
   echo $$PATH /*shell中的变量*/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子中的第一个${PATH}引用的是Makefile中的变量，而不是shell中的PATH环境变量，后者引用的事Shell中的PATH环境变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;以上三点的是Makefile调用shell应该注意的地方，写Makefile一定要注意。  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Shell常用招式大全-入门篇</title>
            <link>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</guid>
            <description>

&lt;p&gt;采用source 而不是bash 命令 可以将环境变量传递过去&lt;/p&gt;

&lt;p&gt;本教程分为入门篇，命令篇和实战篇，结合平时工作中使用Shell的经验编写。以实例为主，侧重于应用，总结了一些实用的技巧。&lt;/p&gt;

&lt;p&gt;以下为本教程的《入门篇》，适于初学者快速入门以及老手查缺补漏。&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;第一招-helloworld&#34;&gt;第一招 HelloWorld&lt;/h1&gt;

&lt;h2 id=&#34;第一式-echo&#34;&gt;第一式：echo&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;Hello World&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;echo -n &amp;quot;Hello World&amp;quot;    # 不带换行  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;echo -e &#39;\e[0;33;1mHello\e[0m World&#39;   # 带颜色的玩法  
echo -e &#39;\e[0;33;4mHello\e[0m World&#39;   # 带颜色+下划线  
echo -e &#39;\e[0;33;5mHello\e[0m World&#39;   # 带颜色+闪烁  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式为 &lt;code&gt;\e[背景色;前景色;高亮格式m&lt;/code&gt;，请阅读&lt;a href=&#34;http://blog.chinaunix.net/uid-15007890-id-3152717.html&#34;&gt;详细文档&lt;/a&gt;后使用正确的姿势进行装逼。&lt;/p&gt;

&lt;h1 id=&#34;第二招-判断&#34;&gt;第二招 判断&lt;/h1&gt;

&lt;h2 id=&#34;第一式-if&#34;&gt;第一式：if&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;if true  
then  
    echo &amp;quot;Hello World&amp;quot;  
else  
	echo &amp;quot;Bug&amp;quot;  
fi  

if false  
then  
    echo &amp;quot;Hello World&amp;quot;  
elif true  
then  
    echo &amp;quot;Bug&amp;quot;  
else  
	echo &amp;quot;Bee&amp;quot;  
fi  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;判断原理&#34;&gt;判断原理&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;elif&lt;/code&gt;会执行它后面跟着的命令，然后看返回值是否为&lt;code&gt;0&lt;/code&gt;，如果为&lt;code&gt;0&lt;/code&gt;则执行&lt;code&gt;then&lt;/code&gt;下面的语句块，否则执行&lt;code&gt;else&lt;/code&gt;下面的语句块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]$ true  
[casheywen@ubuntu:~]$ echo $?  
0  
[casheywen@ubuntu:~]$ false  
[casheywen@ubuntu:~]$ echo $?  
1  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;事实上也为一个命令，&lt;code&gt;true&lt;/code&gt;的返回码必为&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;false&lt;/code&gt;的返回码必为&lt;code&gt;1&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt;为&lt;code&gt;shell&lt;/code&gt;内置变量，用于存放上一个命令的返回码&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-test-和&#34;&gt;第二式：test、[ ] 和 [[ ]]&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;test&lt;/code&gt;、&lt;code&gt;[ ]&lt;/code&gt;、&lt;code&gt;[[ ]]&lt;/code&gt;实际上都是&lt;code&gt;shell&lt;/code&gt;中的命令，执行之后会返回&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;，而这几个命令与&lt;code&gt;if&lt;/code&gt;相结合可以达到我们所需要的许多判断功能，例如测试字符串是否为空的三种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s=&amp;quot;&amp;quot;  
if [ -z ${s} ]  
then  
    echo &amp;quot;empty&amp;quot;  
fi  

if [[ -z ${s} ]]  
then  
    echo &amp;quot;empty&amp;quot;  
fi  

if test -z ${s}  
then  
    echo &amp;quot;empty&amp;quot;  
fi  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上，&lt;code&gt;if&lt;/code&gt;后的&lt;code&gt;[  ]&lt;/code&gt;、&lt;code&gt;[[  ]]&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;命令都是可以单独执行的，而根据&lt;code&gt;if&lt;/code&gt;的&lt;a href=&#34;#判断原理&#34;&gt;判断原理&lt;/a&gt;，后续执行哪个分支也是由&lt;code&gt;[  ]&lt;/code&gt;、&lt;code&gt;[[  ]]&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;的返回值来决定的，以下是单独执行它们的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]$ s=&amp;quot;&amp;quot;  
[casheywen@ubuntu:~]$ [ -z &amp;quot;${s}&amp;quot; ]  
[casheywen@ubuntu:~]$ echo $?  
0  
[casheywen@ubuntu:~]$ s=&amp;quot;abc&amp;quot;  
[casheywen@ubuntu:~]$ test -z &amp;quot;${s}&amp;quot;  
[casheywen@ubuntu:~]$ echo $?  
1  
[casheywen@ubuntu:~]$ s=&amp;quot;123&amp;quot;  
[casheywen@ubuntu:~]$ [[ 100 -lt ${s} ]]  
[casheywen@ubuntu:~]$ echo $?  
0  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在性能方面&lt;code&gt;[ ]&lt;/code&gt;和&lt;code&gt;test&lt;/code&gt;性能基本相同，&lt;code&gt;[[ ]]&lt;/code&gt;性能是最高的，为前两者的&lt;code&gt;5&lt;/code&gt;倍左右（以&lt;code&gt;-d&lt;/code&gt;运算符测试），所以建议尽量使用&lt;code&gt;[[ ]]&lt;/code&gt;提高脚本性能。&lt;/p&gt;

&lt;h2 id=&#34;文件测试&#34;&gt;文件测试&lt;/h2&gt;

&lt;p&gt;|运算符|描述|示例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|-e filename|如果 filename 存在，则为真     |[ -e /var/log/syslog ]|&lt;br /&gt;
|-d filename|如果 filename 为目录，则为真   |[ -d /tmp/mydir ]|&lt;br /&gt;
|-f filename|如果 filename 为常规文件，则为真|[ -f /usr/bin/grep ]|&lt;br /&gt;
|-L filename|如果 filename 为符号链接，则为真|[ -L /usr/bin/grep ]|&lt;br /&gt;
|-r filename|如果 filename 可读，则为真     |[ -r /var/log/syslog ]|&lt;br /&gt;
|-w filename|如果 filename 可写，则为真     |[ -w /var/mytmp.txt ]|&lt;br /&gt;
|-x filename|如果 filename 可执行，则为真   |[ -x /usr/bin/grep ]|&lt;br /&gt;
|filename1 -nt filename2|如果 filename1 比 filename2 新，则为真|[ /tmp/install/etc/services -nt /etc/services ]|&lt;br /&gt;
|filename1 -ot filename2|如果 filename1 比 filename2 旧，则为真|[ /boot/bzImage -ot arch/i386/boot/bzImage ]|&lt;/p&gt;

&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;

&lt;p&gt;|运算符|描述|示例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|-z string|如果 string 长度为零，则为真|&lt;code&gt;[ -z &amp;quot;${myvar}&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|-n string|如果 string 长度非零，则为真|&lt;code&gt;[ -n &amp;quot;${myvar}&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|string1 = string2|如果 string1 与 string2 相同，则为真|&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; = &amp;quot;abc&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|string1 != string2|如果 string1 与 string2 不同，则为真|&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; != &amp;quot;abc&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|string1 &amp;lt; string|如果 string1 小于 string2，则为真 | &lt;code&gt;[ &amp;quot;${myvar}&amp;quot; \&amp;lt; &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[[ &amp;quot;${myvar}&amp;quot; &amp;lt; &amp;quot;abc&amp;quot; ]]&lt;/code&gt; |&lt;br /&gt;
|string1 &amp;gt; string|如果 string1 大于 string2，则为真 | &lt;code&gt;[ &amp;quot;${myvar}&amp;quot; \&amp;gt; &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[[ &amp;quot;${myvar}&amp;quot; &amp;gt; &amp;quot;abc&amp;quot; ]]&lt;/code&gt;|&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在字符串两边加上&amp;rdquo;&amp;ldquo;防止出错&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;是字符串比较，不要错用成整数比较&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果是在&lt;code&gt;[ ]&lt;/code&gt;中使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;，需要将它们写成&lt;code&gt;\&amp;lt;&lt;/code&gt;和&lt;code&gt;\&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;整数比较&#34;&gt;整数比较&lt;/h2&gt;

&lt;p&gt;|运算符|描述|示例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|num1 -eq num2|等于|[ 3 -eq $mynum ]|&lt;br /&gt;
|num1 -ne num2|不等于|[ 3 -ne $mynum ]|&lt;br /&gt;
|num1 -lt num2|小于|[ 3 -lt $mynum ]|&lt;br /&gt;
|num1 -le num2|小于或等于|[ 3 -le $mynum ]|&lt;br /&gt;
|num1 -ge num2|大于或等于|[ 3 -ge $mynum ]|&lt;/p&gt;

&lt;h2 id=&#34;第三式&#34;&gt;第三式：&amp;amp;&amp;amp;、||&lt;/h2&gt;

&lt;p&gt;|&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;可以用来对两个判断语句求与|&lt;br /&gt;
|&amp;mdash;|&lt;br /&gt;
|&lt;code&gt;if [ -n &amp;quot;abc&amp;quot; ] &amp;amp;&amp;amp; [ -n &amp;quot;aa&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; ]] &amp;amp;&amp;amp; [[ -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if test -n &amp;quot;abc&amp;quot; &amp;amp;&amp;amp; test -n &amp;quot;aa&amp;quot;&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; &amp;amp;&amp;amp; -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;只有&lt;code&gt;[[ ]]&lt;/code&gt;才允许把&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;写在里面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;|&lt;code&gt;\|\|&lt;/code&gt;可以用来对两个判断语句求或|&lt;br /&gt;
|&amp;mdash;|&lt;br /&gt;
|&lt;code&gt;if [ -n &amp;quot;abc&amp;quot; ] \|\| [ -n &amp;quot;aa&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; ]] \|\| [[ -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if test -n &amp;quot;abc&amp;quot; \|\| test -n &amp;quot;aa&amp;quot;&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; \|\| -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;br /&gt;
&amp;gt; &lt;strong&gt;注：&lt;/strong&gt;只有&lt;code&gt;[[ ]]&lt;/code&gt;才允许把&lt;code&gt;||&lt;/code&gt;写在里面&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小技巧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;还可以用来拼接命令，达到按前一个命令成功与否来决定是否执行后一个命令的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /data &amp;amp;&amp;amp; ls         # 当`cd /data`返回0(即成功)时才执行后面的`ls`  
cd /data || cd /root   # 当`cd /data`返回非0(即失败)时才执行后面的`cd /root`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第三招-循环&#34;&gt;第三招：循环&lt;/h1&gt;

&lt;h2 id=&#34;第一式-for&#34;&gt;第一式：for&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;for i in {1..100}  
do  
    echo ${i}  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{1..100}&lt;/code&gt;属于&lt;a href=&#34;#第五招通配&#34;&gt;通配&lt;/a&gt;的一种写法，展开会是&lt;code&gt;1 2 3 ... 100&lt;/code&gt;（1~100以空格隔开）这样的字串。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;code&gt;for i in 1 2 3;&lt;/code&gt;这样的语句，&lt;code&gt;for&lt;/code&gt;会将&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;依次赋值于&lt;code&gt;i&lt;/code&gt;进行循环，而对于&lt;a href=&#34;#第五招通配&#34;&gt;通配&lt;/a&gt;的情况，&lt;code&gt;for&lt;/code&gt;则会将通配展开后将里面的每一项依次赋值于&lt;code&gt;i&lt;/code&gt;进行循环。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;for i in `seq 100`  
do  
    echo ${i}  
done  

for i in `seq 1 2 100`  
do  
    echo ${i}  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;seq&lt;/code&gt;本身为一个命令，用于输出数字组成的序列，如&lt;code&gt;seq 100&lt;/code&gt;会生成并输出&lt;code&gt;1 2 3 ... 100&lt;/code&gt;（1~100以换行符隔开）这样的序列，而&lt;code&gt;seq 1 2 100&lt;/code&gt;则会生成并输出&lt;code&gt;1 3 5 ... 99&lt;/code&gt;（以1开始，2为公差的等差数列中小于100的项，以换行符隔开）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;反引号(`)之间的命令会被执行，其输出结果会转换成一个&lt;a href=&#34;#第五式将命令执行结果存入变量&#34;&gt;变量&lt;/a&gt;，故上面的&lt;code&gt;for in&lt;/code&gt;会依次取出&lt;code&gt;seq&lt;/code&gt;的执行结果赋值于&lt;code&gt;i&lt;/code&gt;进行循环。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;for ((i = 0; i &amp;lt; 100; i++))  
do  
    echo ${i}  
done  

for ((i = 0; i &amp;lt; 100; i+= 2))  
do  
    echo ${i}  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上与C语言式的&lt;code&gt;for&lt;/code&gt;循环语法基本相同，区别在于双重括号：&lt;code&gt;(( ))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-while-until&#34;&gt;第二式：while、until&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;i=0  
while [[ ${i} -lt 100 ]]  
do  
    echo ${i}  
    ((i++))  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;i=0  
until [[ ${i} -ge 100 ]]  
do  
    echo ${i}  
    ((i++))  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;until&lt;/code&gt;的判断原理与&lt;code&gt;if&lt;/code&gt;是类似的，它会执行并它后面跟着的命令，不同点在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;是后面语句返回值为&lt;code&gt;0&lt;/code&gt;，则执行循环中的语句块，否则跳出循环;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;until&lt;/code&gt;则是后面语句返回值非&lt;code&gt;0&lt;/code&gt;，则执行循环中的语句块，否则跳出循环。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第四招-变量&#34;&gt;第四招：变量&lt;/h1&gt;

&lt;h2 id=&#34;第一式-整数&#34;&gt;第一式：整数&lt;/h2&gt;

&lt;h2 id=&#34;整数的运算&#34;&gt;整数的运算&lt;/h2&gt;

&lt;p&gt;方法较多，此处只列举最浅显易懂，并且效率最高的办法——直接将符合C语言语法的表达式放到&lt;code&gt;(( ))&lt;/code&gt;中即可达到对整数的计算目的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $(( 1+1 ))        # 最简单的1+1  
echo $(( (1+2)*3/4 ))  # 表达式中还可以带括号  
echo $(( 1&amp;lt;&amp;lt;32 ))      # 左移右移也支持，但仅限于-4294967296~4294967296之间的数值  
echo $(( 1&amp;amp;3 ))        # &amp;amp;、^、|、~ 这样的位操作亦支持  
(( i=1+2 ))            # 将1+2计算出结果后赋值给i，后续若`echo ${i}`会得到3  
(( i++ ))              # 变量i自增1  
(( i+=3 ))             # 变量i自增3  
# ...                  # 还有很多，不再详列  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进行整数运算的方法还有：&lt;code&gt;expr&lt;/code&gt;、&lt;code&gt;$[]&lt;/code&gt;、&lt;code&gt;let&lt;/code&gt;等&lt;code&gt;shell&lt;/code&gt;等内置命令，也可调用&lt;code&gt;bc&lt;/code&gt;、&lt;code&gt;python&lt;/code&gt;等外部工具进行更复杂的数学运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-字符串&#34;&gt;第二式：字符串&lt;/h2&gt;

&lt;h2 id=&#34;替换&#34;&gt;替换&lt;/h2&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|${string/old/new}|string中第一个old替换为new|&lt;br /&gt;
|${string//old/new}|string中所有old替换为new|&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;i hate hate you&amp;quot;  
[casheywen@ubuntu:~]# echo ${s/hate/love}  
i love hate you  
[casheywen@ubuntu:~]# echo ${s//hate/love}  
i love love you  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;截取子串&#34;&gt;截取子串&lt;/h2&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|${string:n}|string从下标n到结尾的子串|&lt;br /&gt;
|${string:n:m}|string从下标n开始长度为m的子串|&lt;br /&gt;
|${string::m}|string从下标0开始长度为m的子串|&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;0123456789&amp;quot;  
[casheywen@ubuntu:~]# echo ${s:3}  
3456789  
[casheywen@ubuntu:~]# echo ${s::3}  
012  
[casheywen@ubuntu:~]# echo ${s:0:3}  
012  
[casheywen@ubuntu:~]# echo ${s:2:5}  
23456  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通配删除&#34;&gt;通配删除&lt;/h2&gt;

&lt;p&gt;通配删除，即按通配符，删除掉字符串中符合条件的一部分&lt;/p&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|${string#pattern}|string从左到右删除pattern的最小通配|&lt;br /&gt;
|${string##pattern}|string从左到右删除pattern的最大通配|&lt;br /&gt;
|${string%pattern}|string从右到左删除pattern的最小通配|&lt;br /&gt;
|${string%%pattern}|string从右到左删除pattern的最大通配|&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;此处通配规则参考&lt;a href=&#34;#通配符一览表&#34;&gt;通配符一览表&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最小通配和最大通配的区别：&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最小通配：符合通配的最小子串&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最大通配：符合通配的最大子串&lt;br /&gt;
例如string值为&lt;code&gt;/00/01/02/dir&lt;/code&gt;，对于通配&lt;code&gt;/*/&lt;/code&gt;，其最小通配为&lt;code&gt;/00/&lt;/code&gt;，而最大通配&lt;code&gt;/00/01/02/&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;/00/01/02/dir&amp;quot;  
[casheywen@ubuntu:~]# echo ${s#/*/}  
01/02/dir  
[casheywen@ubuntu:~]# echo ${s##/*/}  
dir  
[casheywen@ubuntu:~]#  
[casheywen@ubuntu:~]# s=&amp;quot;abc/cde/efg&amp;quot;  
[casheywen@ubuntu:~]# echo ${s%/*}  
abc/cde  
[casheywen@ubuntu:~]# echo ${s%%/*}  
abc  
[casheywen@ubuntu:~]#  
[casheywen@ubuntu:~]# s=&amp;quot;/00/01/02/dir&amp;quot;  
[casheywen@ubuntu:~]# echo ${s#/*/}  
01/02/dir  
[casheywen@ubuntu:~]# echo ${s##/*/}  
dir  
[casheywen@ubuntu:~]# s=&amp;quot;abc/cde/efg&amp;quot;  
[casheywen@ubuntu:~]# echo ${s%/*}  
abc/cde  
[casheywen@ubuntu:~]# echo ${s%%/*}  
abc  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;小技巧&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;获取文件名：&lt;code&gt;${path##*/}&lt;/code&gt; (相当于&lt;code&gt;basename&lt;/code&gt;命令的功能)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;获取目录名：&lt;code&gt;${path%/*}&lt;/code&gt; (相当于&lt;code&gt;dirname&lt;/code&gt;命令的功能)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;获取后缀名：&lt;code&gt;${path##*.}&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;/root/test/dir/subdir/abc.txt&amp;quot;  
[casheywen@ubuntu:~]# echo ${s##*/}  
abc.txt  
[casheywen@ubuntu:~]# echo ${s%/*}  
/root/test/dir/subdir  
[casheywen@ubuntu:~]# echo ${s##*.}  
txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-数组&#34;&gt;第三式：数组&lt;/h2&gt;

&lt;h2 id=&#34;普通数组&#34;&gt;普通数组&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;a=()         # 空数组  
a=(1 2 3)    # 元素为1,2,3的数组  
echo ${#a[*]}  # 数组长度  
echo ${a[2]}   # 下标为2的元素值（下标从0开始）  
a[1]=0         # 给下标为1的元素赋值  

# 遍历数组  
for i in ${a[*]}  
do  
    echo ${i}  
done  

unset a        # 清空数组  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关联数组&#34;&gt;关联数组&lt;/h2&gt;

&lt;p&gt;关联数组可以用于存储&lt;code&gt;key-value&lt;/code&gt;型的数据，其功能相当于&lt;code&gt;C++&lt;/code&gt;中的&lt;code&gt;map&lt;/code&gt;或&lt;code&gt;python&lt;/code&gt;中的&lt;code&gt;dict&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;declare -A a        # 声明关联数组（必须有此句）  
a=([&amp;quot;apple&amp;quot;]=&amp;quot;a1&amp;quot; [&amp;quot;banana&amp;quot;]=&amp;quot;b2&amp;quot; [&amp;quot;carrot&amp;quot;]=&amp;quot;c3&amp;quot;)   # 初始化关联数组  
echo ${#a[*]}       # 获取元素个数  
echo ${a[&amp;quot;carrot&amp;quot;]} # 获取元素值  
a[&amp;quot;durian&amp;quot;]=&amp;quot;d4&amp;quot;    # 插入或修改元素  
echo ${!a[*]}       # 获取所有的key  
unset a[&amp;quot;banana&amp;quot;]   # 删除元素  

# 遍历数组(仅value)  
for i in ${a[*]}  
do  
    echo ${i}  
done  

# 遍历数组(key和value)  
for key in ${!a[*]}  
do  
	echo &amp;quot;${key} ==&amp;gt; ${a[${key}]}&amp;quot;  
done  

unset a             # 清空数组  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;关联数组需要bash 4.0以上版本才支持，选用需慎重。查看&lt;code&gt;bash&lt;/code&gt;版本用&lt;code&gt;bash --version&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关联数组必须用&lt;code&gt;declare -A&lt;/code&gt;显示声明类型，否则数值会出错。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第四式-将命令执行结果存入变量&#34;&gt;第四式：将命令执行结果存入变量&lt;/h2&gt;

&lt;h2 id=&#34;与&#34;&gt;` `与$( )&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;LINE_CNT=`wc -l test.txt`  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;LINE_CNT=$(wc -l test.txt)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令均可把&lt;code&gt;wc -l test.txt&lt;/code&gt;的结果存入&lt;code&gt;LINE_CNT&lt;/code&gt;变量中&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;` `&lt;/code&gt; 和&lt;code&gt;$( )&lt;/code&gt;都只将命令行标准输出的内容存入变量，如果需要将标准错误内容存入变量，需要用到&lt;a href=&#34;#第五招重定向&#34;&gt;重定向&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;换行符处理&#34;&gt;换行符处理&lt;/h2&gt;

&lt;p&gt;如果命令执行结果有多行内容，存入变量并打印时换行符会丢失：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# cat test.txt  
a  
b  
c  
[casheywen@ubuntu:~]# CONTENT=`cat test.txt`  
[casheywen@ubuntu:~]# echo ${CONTENT}  
a b c  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若需要保留换行符，则在打印时必须加上&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# CONTENT=`cat test.txt`  
[casheywen@ubuntu:~]# echo &amp;quot;${CONTENT}&amp;quot;  
a  
b  
c  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第五招-重定向&#34;&gt;第五招：重定向&lt;/h1&gt;

&lt;h2 id=&#34;标准输入流-标准输出流-标准错误流&#34;&gt;标准输入流、标准输出流、标准错误流&lt;/h2&gt;

&lt;p&gt;|名称|英文缩写|内容|默认绑定位置|文件路径|Shell中代号|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|标准输入流|&lt;code&gt;stdin&lt;/code&gt;|程序读取的用户输入|键盘输入|&lt;code&gt;/dev/stdin&lt;/code&gt;|&lt;code&gt;0&lt;/code&gt;|&lt;br /&gt;
|标准输出流|&lt;code&gt;stdout&lt;/code&gt;|程序的打印的正常信息|终端(&lt;code&gt;terminal&lt;/code&gt;), 即显示器|&lt;code&gt;/dev/stdin&lt;/code&gt;|&lt;code&gt;1&lt;/code&gt;|&lt;br /&gt;
|标准错误流|&lt;code&gt;stderr&lt;/code&gt;|程序的错误信息|终端(&lt;code&gt;terminal&lt;/code&gt;)，, 即显示器|&lt;code&gt;/dev/stderr&lt;/code&gt;|&lt;code&gt;2&lt;/code&gt;|&lt;/p&gt;

&lt;h2 id=&#34;重定向方式一览表&#34;&gt;重定向方式一览表&lt;/h2&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt; file&lt;/code&gt;|把 stdout 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt;&amp;gt; file&lt;/code&gt;|把 stdout 追加到 file|&lt;br /&gt;
|&lt;code&gt;cmd 2&amp;gt; file&lt;/code&gt;|把 stderr 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd 2&amp;gt;&amp;gt; file&lt;/code&gt;|把 stderr 追加到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;amp;&amp;gt; file&lt;/code&gt;|把 stdout 和 stderr 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code&gt;|把 stdout 和 stderr 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt;&amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code&gt;|把 stdout 和 stderr 追加到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;lt;file &amp;gt;file2 cmd&lt;/code&gt;| cmd 以 file 作为 stdin，以 file2 作为 stdout|&lt;br /&gt;
|&lt;code&gt;cat &amp;lt;&amp;gt;file&lt;/code&gt;|以读写的方式打开 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;lt; file cmd&lt;/code&gt;|cmd 命令以 file 文件作为 stdin|&lt;br /&gt;
|&lt;code&gt;cmd &amp;lt;&amp;lt; delimiter Here document&lt;/code&gt;|从 stdin 中读入，直至遇到 delimiter 分界符|&lt;/p&gt;

&lt;h2 id=&#34;第一式-重定向标准输出流-stdout&#34;&gt;第一式：重定向标准输出流(stdout)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;把程序打印的内容输出到文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 以下两种方式都会将`Hello World`写入到hello.txt(若不存在则创建)  
echo &amp;quot;Hello World&amp;quot; &amp;gt; hello.txt   # hello.txt原有的将被覆盖  
echo &amp;quot;Hello World&amp;quot; &amp;gt;&amp;gt; hello.txt  # hello.txt原有内容后追加`Hello World`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二式-重定向标准错误流-stderr&#34;&gt;第二式：重定向标准错误流(stderr)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;把程序的错误信息输出到文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如文件路径中不存在&lt;code&gt;+++&lt;/code&gt;这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls +++  
ls: cannot access +++: No such file or directory  
[casheywen@ubuntu:~]# ls +++ &amp;gt; out.txt  
ls: cannot access +++: No such file or directory  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的&lt;code&gt;ls +++&lt;/code&gt;后输出的内容为标准错误流中的错误信息，所以即使用&lt;code&gt;&amp;gt; out.txt&lt;/code&gt;重定向标准输入，错误信息仍然被打印到了屏幕。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 以下两种方式都会将`ls +++`输出的错误信息输出到err.txt(若不存在则创建)  
ls +++ 2&amp;gt; err.txt    # err.txt原有内容将被覆盖  
ls +++ 2&amp;gt;&amp;gt; err.txt   # err.txt原有内容后追加内容  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-重定向标准输入流-stdin&#34;&gt;第三式：重定向标准输入流(stdin)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 让程序从文件读取输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以默认从标准输入读取表达式，并进行数学计算的命令&lt;code&gt;bc&lt;/code&gt;为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# bc -q  
1+1  
2  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1+1&lt;/code&gt;为键盘输入的内容，&lt;code&gt;2&lt;/code&gt;为&lt;code&gt;bc&lt;/code&gt;命令打印的计算结果&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bc&lt;/code&gt;后的&lt;code&gt;-q&lt;/code&gt;参数用于禁止输出欢迎信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为&lt;code&gt;命令 &amp;lt; 文件路径&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我需要把已经存在文件&lt;code&gt;exp.txt&lt;/code&gt;中的一个表达式输入到&lt;code&gt;bc&lt;/code&gt;中进行计算，可以采用重定向标准输入流的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bc -q &amp;lt; exp.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当&lt;code&gt;exp.txt&lt;/code&gt;中内容为&lt;code&gt;1+1&lt;/code&gt;时，以上语句输出&lt;code&gt;2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;bc&lt;/code&gt;命令本身支持从文件输入，如不使用重定向，也可用&lt;code&gt;bc exp.txt&lt;/code&gt;达到相同效果&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2. 将&lt;a href=&#34;#第四招变量&#34;&gt;变量&lt;/a&gt;中内容作为程序输入&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXP=&amp;quot;1+1&amp;quot;  
bc -q &amp;lt;&amp;lt;&amp;lt; &amp;quot;${EXP}&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以上代码等同于执行&lt;code&gt;bc&lt;/code&gt;并输入&lt;code&gt;1+1&lt;/code&gt;，得到的输出为&lt;code&gt;2&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为&lt;code&gt;命令 &amp;lt;&amp;lt;&amp;lt; 变量内容&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. 将当前shell脚本中的多行内容作为程序的输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如在shell中内嵌多行python代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python &amp;lt;&amp;lt; EOF  
print &#39;hello from python&#39;  
print &#39;hello&#39; + &#39;world&#39;  
EOF  

# 内容中支持shell变量  
MSG=&amp;quot;shell variable&amp;quot;  

python &amp;lt;&amp;lt; EOF  
print &#39;${MSG}&#39;  
EOF  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以上用法可以方便地将某个程序需要的多行输入内容直接包含在当前脚本中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持变量，可以动态地改变多行输入的内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为：&lt;code&gt;命令 &amp;lt;&amp;lt; EOF (换行)...(换行) EOF&lt;/code&gt;，其中的&lt;code&gt;EOF&lt;/code&gt;换成其它字符串也是有效的，如：&lt;code&gt;命令 &amp;lt;&amp;lt; ABC (换行)...(换行) ABC&lt;/code&gt;的，但通用习惯都使用&lt;code&gt;EOF&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第六招-管道&#34;&gt;第六招：管道&lt;/h1&gt;

&lt;h2 id=&#34;第一式-管道的基本功能&#34;&gt;第一式：管道的基本功能&lt;/h2&gt;

&lt;p&gt;管道的写法为 &lt;code&gt;cmd1 | cmd2&lt;/code&gt;，功能是依次执行&lt;code&gt;cmd1&lt;/code&gt;和&lt;code&gt;cmd2&lt;/code&gt;，并将&lt;code&gt;cmd1&lt;/code&gt;的标准输出作为&lt;code&gt;cmd2&lt;/code&gt;的标准输入，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;1+1&amp;quot; | bc  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;echo &amp;quot;1+1&amp;quot;&lt;/code&gt; 会将&lt;code&gt;1+1&lt;/code&gt;输出到标准输出，而管道会将&lt;code&gt;echo&lt;/code&gt;输出的&lt;code&gt;1+1&lt;/code&gt;作为&lt;code&gt;bc&lt;/code&gt;命令的标准输入，这样&lt;code&gt;bc&lt;/code&gt;会读取到&lt;code&gt;1+1&lt;/code&gt;，最终得到计算结果&lt;code&gt;2&lt;/code&gt;打印到屏幕。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;管道可以多级拼接：&lt;code&gt;cmd1 | cmd2 | cmd3 | ...&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;管道的返回值为最后一级命令的返回值&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-管道与while-read组合&#34;&gt;第二式：管道与while、read组合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;LINE_NO=0  
cat test.txt |  
while read LINE  
do  
	(( LINE_NO++ ))  
	echo &amp;quot;${LINE_NO} ${LINE}&amp;quot;  
done  

# echo &amp;quot;${LINE_NO}&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将&lt;code&gt;test.txt&lt;/code&gt;中每一行标上行标后输出。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt;命令用于从标准输入读取一行并赋值给一个或多个变量，如&lt;code&gt;read LINE&lt;/code&gt;会从标准输入读取一行并将整行内容赋值给&lt;code&gt;LINE&lt;/code&gt;变量，&lt;code&gt;read A B&lt;/code&gt;则会从标准输入读入一行并将这行的第1、2列分别赋值给A、B两个变量（分割符默认为空格或tab，可给&lt;code&gt;IFS&lt;/code&gt;赋值来更改分割符）&lt;br /&gt;
&amp;gt; 2. 末尾注释掉的&lt;code&gt;echo &amp;quot;${LINE_NO}&amp;quot;&lt;/code&gt;若执行会输出&lt;code&gt;0&lt;/code&gt;，原因是管道中的&lt;code&gt;while&lt;/code&gt;语句是执行在子进程中的，不会改变父进程中&lt;code&gt;LINE_NO&lt;/code&gt;变量的值&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第三式-管道与xargs组合&#34;&gt;第三式：管道与xargs组合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;find . -type f -name *.log | xargs rm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将当前目录及子目录所有后缀名为&lt;code&gt;.log&lt;/code&gt;的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -type f -name *.log | xargs -i mv {} /data/log  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将当前目录及子目录中所有后缀名为&lt;code&gt;.log&lt;/code&gt;的文件移动到&lt;code&gt;/data/log&lt;/code&gt;中&lt;br /&gt;
&amp;gt; &lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;xargs&lt;/code&gt;可以从标准输入读取内容，以之构建并执行另一个命令行&lt;br /&gt;
&amp;gt;&lt;br /&gt;
&amp;gt;  - &lt;code&gt;xargs&lt;/code&gt;直接接命令名称，则将从标准输入读取的所有内容合并为一行构建命令行并执行&lt;br /&gt;
&amp;gt;  - &lt;code&gt;xargs&lt;/code&gt;加上&lt;code&gt;-i&lt;/code&gt;参数，则会每读取一行就构建并执行一个命令行，构建命令行时会将&lt;code&gt;{}&lt;/code&gt;替换为该行的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# cat test.txt  
a  
b  
c  
[casheywen@ubuntu:~]# cat test.txt | xargs echo rm  
rm a b c  
[casheywen@ubuntu:~]# cat test.txt | xargs -i echo rm {}  
rm a  
rm b  
rm c  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上例展示了&lt;code&gt;xargs&lt;/code&gt;构建命令的原理，如果去掉&lt;code&gt;xargs&lt;/code&gt;后的&lt;code&gt;echo&lt;/code&gt;，则会执行打印出来的命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第七招-通配&#34;&gt;第七招：通配&lt;/h1&gt;

&lt;h2 id=&#34;shell通配的原理&#34;&gt;shell通配的原理&lt;/h2&gt;

&lt;p&gt;如果你的当前目录中有&lt;code&gt;1.txt 2.txt 3.txt&lt;/code&gt;三个文件，那么当你执行&lt;code&gt;ls *.txt&lt;/code&gt;这条命令，&lt;code&gt;shell&lt;/code&gt;究竟为你做了什么？&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;shell&lt;/code&gt;会先读取当前目录，然后按&lt;code&gt;*.txt&lt;/code&gt;的通配条件过滤得到&lt;code&gt;1.txt 2.txt 3.txt&lt;/code&gt;这个文件列表，然后将这个列表作为参数传给&lt;code&gt;ls&lt;/code&gt;，即&lt;code&gt;ls *.txt&lt;/code&gt;相当于&lt;code&gt;ls 1.txt 2.txt 3.txt&lt;/code&gt;，&lt;code&gt;ls&lt;/code&gt;命令本身并不会得到&lt;code&gt;*.txt&lt;/code&gt;这样的参数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：仅当目录中没有符合&lt;code&gt;*.txt&lt;/code&gt;通配的文件，&lt;code&gt;shell&lt;/code&gt;才会将&lt;code&gt;*.txt&lt;/code&gt;这个字符串当作参数直接传给&lt;code&gt;ls&lt;/code&gt;命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以如果需要列出当前目录中所有的&lt;code&gt;txt&lt;/code&gt;文件，我们使用&lt;code&gt;echo *.txt&lt;/code&gt;也同样可以达到目的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls *.txt  
1.txt  2.txt  3.txt  
[casheywen@ubuntu:~]# echo *.txt  
1.txt 2.txt 3.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;对于&lt;code&gt;{ }&lt;/code&gt;通配&lt;code&gt;shell&lt;/code&gt;不会读取目录并过滤获得文件列表。详细请&lt;a href=&#34;#通配符一览表&#34;&gt;参考下文&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;通配符一览表&#34;&gt;通配符一览表&lt;/h2&gt;

&lt;p&gt;|字符|含义|实例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|*|匹配 0 或多个字符|&lt;code&gt;a*b&lt;/code&gt; a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。|&lt;br /&gt;
|?|匹配任意一个字符|&lt;code&gt;a?b&lt;/code&gt; a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。|&lt;br /&gt;
|&lt;code&gt;[list]&lt;/code&gt; |匹配 list 中的任意单一字符|&lt;code&gt;a[xyz]b&lt;/code&gt; a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。|&lt;br /&gt;
|&lt;code&gt;[!list]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[^list]&lt;/code&gt; |匹配 除list 中的任意单一字符|&lt;code&gt;a[!0-9]b&lt;/code&gt; a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。|&lt;br /&gt;
|&lt;code&gt;[c1-c2]&lt;/code&gt;|匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]|&lt;code&gt;a[0-9]b&lt;/code&gt; 0与9之间必须也只能有一个字符 如a0b, a1b&amp;hellip; a9b。|&lt;br /&gt;
|&lt;code&gt;{string1,string2,...}&lt;/code&gt;|枚举sring1或string2(或更多)其一字符串|&lt;code&gt;a{abc,xyz,123}b&lt;/code&gt; 展开成&lt;code&gt;aabcb axyzb a123b&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;{c1..c2}&lt;/code&gt;&lt;br/&gt;&lt;code&gt;{n1..n2}&lt;/code&gt;|枚举c1-c2中所有字符或n1-n2中所有数字|&lt;code&gt;{a..f}&lt;/code&gt;展开成&lt;code&gt;a b c d e f&lt;/code&gt;&lt;br/&gt;&lt;code&gt;a{1..5}&lt;/code&gt; 展开成&lt;code&gt;a1 a2 a3 a4 a5&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;[ ]&lt;/code&gt;的通配都会按&lt;a href=&#34;#shell%E9%80%9A%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86&#34;&gt;读取目录并过滤&lt;/a&gt;的方式展开通配项目&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{ }&lt;/code&gt;则不会有读取目录的过程，它是通过枚举所有符合条件的通配项直接展开的&lt;br /&gt;
&lt;code&gt;
[casheywen@ubuntu:~]# ls  
1.txt  2.txt  3.txt  
[casheywen@ubuntu:~]# echo *.txt  
1.txt 2.txt 3.txt  
[casheywen@ubuntu:~]# echo {1..5}.txt  
1.txt 2.txt 3.txt 4.txt 5.txt  
[casheywen@ubuntu:~]# ls {1..5}.txt  
ls: cannot access 4.txt: No such file or directory  
ls: cannot access 5.txt: No such file or directory  
1.txt  2.txt  3.txt  
&lt;/code&gt;&lt;br /&gt;
由上面的命令可见，&lt;code&gt;*&lt;/code&gt;通配的结果与目录中存在哪些文件有关系，而&lt;code&gt;{ }&lt;/code&gt;的通配结果与目录中存在哪些文件无关。若用&lt;code&gt;{ }&lt;/code&gt;进行通配，则有可能将不存在的文件路径作为命令行参数传给程序。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第一式&#34;&gt;第一式：*&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;用于通配文件名或目录名中某一部分为任意内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm *.log          # 删除当前目录中所有后缀名为.log的文件  
rm */log/*.log    # 删除所有二级log目录中后缀名为.log的文件  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二式&#34;&gt;第二式：[ ]&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt;用于通配文件名或目录名中某个字符为限定范围内或限定范围外的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
rm Program[1-9]*.log  # 删除当前目录中以Program跟着一个1到9的数字开头，并以.log为后缀名的文件  
du -sh /[^udp]*       # 对根目录中所有不以u、d、p开头的文件夹求取总大小  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-1&#34;&gt;第三式：?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;?&lt;/code&gt;用于通配文件名中某处一个任意值的字符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm L????.txt    # 通配一个文件名以L开头，后面跟着4个字符，并以.txt结尾的文件：如LAB01.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第四式&#34;&gt;第四式：{ }&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt;也为通配符，用于通配在它枚举范围内的值，由于它是直接展开的，我们可以将它用于批量创建目录或文件，也可以用于生成序列：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;批量生成目录&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls  
[casheywen@ubuntu:~]# mkdir dir{0..2}{0..2}  
[casheywen@ubuntu:~]# ls  
dir00  dir01  dir02  dir10  dir11  dir12  dir20  dir21  dir22  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生成序列&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt;生成的序列常用于&lt;a href=&#34;#第一式for&#34;&gt;for循环&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for ip in 192.168.234.{1..255}  
do  
    ping ${ip} -w 1 &amp;amp;&amp;gt; /dev/null &amp;amp;&amp;amp; echo ${ip} is Alive  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;以上例子用于查找&lt;code&gt;192.168.234.1~192.168.234.255&lt;/code&gt;整个网段能&lt;code&gt;ping&lt;/code&gt;通的所有&lt;code&gt;ip&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Shell常用招式大全-命令篇</title>
            <link>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%91%BD%E4%BB%A4%E7%AF%87/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%91%BD%E4%BB%A4%E7%AF%87/</guid>
            <description>

&lt;p&gt;继上篇《入门篇》之后，本篇《命令篇》为《Shell常用招式大全》的第二篇教程。&lt;/p&gt;

&lt;p&gt;本篇根据本人的工作经验，总结了Linux下一些常用命令的使用技巧。旨在精而不在全，对于百度一下或&lt;code&gt;man&lt;/code&gt;一下即可知道的使用方法不做详细介绍。&lt;/p&gt;

&lt;p&gt;适合在Linux下用过一些命令，小尝甜头，但仍觉得Shell不是那么称手的读者。&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;第一招-文本处理&#34;&gt;第一招 文本处理&lt;/h1&gt;

&lt;p&gt;无名氏说：编程有两件事，一件是处理数值，另一件是处理字符串。&lt;/p&gt;

&lt;h2 id=&#34;第一式-cut-切割分列&#34;&gt;第一式 cut 切割分列&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;casheywen@ubuntu:~$ cat test.txt  
1 2 3 4 5 6  
a b c d e f g h i  
apple banana pear peach  
casheywen@ubuntu:~$ cat test.txt | cut -f 2 -d &#39; &#39;   # 取出第2列  
2  
b  
banana  
casheywen@ubuntu:~$ cat test.txt | cut -f 2,3 -d &#39; &#39;  # 取出第2,3两列  
2 3  
b c  
banana pear  
casheywen@ubuntu:~$ cat test.txt | cut -f 3- -d &#39; &#39;   # 取出第3到最后一列  
3 4 5 6  
c d e f g h i  
pear peach  
casheywen@ubuntu:~$ cat test.txt | cut -f 3-5 -d &#39; &#39;  # 取出第3~5列  
3 4 5  
c d e  
pear peach  
casheywen@ubuntu:~$ cat test.txt | cut -f 3 --complement -d &#39; &#39;  # 取出除第3列外的所有列  
1 2 4 5 6  
a b d e f g h i  
apple banana peach  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从以上示例大家可以明白，&lt;code&gt;cut&lt;/code&gt;是一个列处理命令，功能上可以代替大多数类似&lt;code&gt;awk &#39;{print $1}&#39;&lt;/code&gt;的效果，写起来很方便。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;cut命令的参数:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 指定选择的列&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 指定分割符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--complement&lt;/code&gt; 反选，指定后会打印不在&lt;code&gt;-f&lt;/code&gt;中的所有列&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;技一-读取配置文件&#34;&gt;技一: 读取配置文件&lt;/h3&gt;

&lt;p&gt;例如有一个格式如下的配置文件 &lt;code&gt;test.conf&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP = 192.168.0.1  
PORT = 12800  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以用如下命令来读取IP字段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;casheywen@ubuntu:~$ cat test.conf | grep -w IP | cut -f 2 -d = | xargs  
192.168.0.1  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>shell中的map使用</title>
            <link>http://blog.pytool.com/post/shell/2017-11-07-shell%E4%B8%AD%E7%9A%84map%E4%BD%BF%E7%94%A8/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/2017-11-07-shell%E4%B8%AD%E7%9A%84map%E4%BD%BF%E7%94%A8/</guid>
            <description>

&lt;p&gt;bash 的版本必须 &amp;gt;= 4.1.2，升级bash：&lt;/p&gt;

&lt;p&gt;declare -A abc&lt;br /&gt;
declare: usage: declare [-afFirtx] [-p] [name[=value] &amp;hellip;]&lt;/p&gt;

&lt;h1 id=&#34;shell中map的定义与使用&#34;&gt;shell中map的定义与使用&lt;/h1&gt;

&lt;p&gt;declare -A 变量名 #切记使用大写的A，不是小写的a&lt;/p&gt;

&lt;p&gt;[root@www ~]# declare -A map=([&amp;ldquo;sunjun&amp;rdquo;]=&amp;ldquo;a&amp;rdquo; [&amp;ldquo;jason&amp;rdquo;]=&amp;ldquo;b&amp;rdquo; [&amp;ldquo;lee&amp;rdquo;]=&amp;ldquo;c&amp;rdquo;) #定义时初始化一些值&lt;br /&gt;
[root@www ~]# echo ${map[@]}        #输出所有values&lt;br /&gt;
a c b&lt;br /&gt;
[root@www ~]# echo ${!map[@]}       #输出所有keys&lt;br /&gt;
sunjun lee jason&lt;/p&gt;

&lt;p&gt;[root@www ~]# map[&amp;ldquo;hello&amp;rdquo;]=123      #向map中添加一个key=value&lt;br /&gt;
[root@www ~]# echo ${map[@]}&lt;br /&gt;
a c b 123&lt;br /&gt;
[root@www ~]# echo ${!map[@]}&lt;br /&gt;
sunjun lee jason hello&lt;br /&gt;
[root@www ~]#&lt;/p&gt;

&lt;h1 id=&#34;shell中的数组&#34;&gt;shell中的数组&lt;/h1&gt;

&lt;p&gt;[root@www ~]# declare -a array=(&amp;ldquo;aa&amp;rdquo; &amp;ldquo;bb&amp;rdquo; &amp;ldquo;cc&amp;rdquo;)     #定义一个数组&lt;br /&gt;
[root@www ~]# echo ${array[@]}      #输出所有元素的值&lt;br /&gt;
aa bb cc&lt;br /&gt;
[root@www ~]# echo ${!array[@]}     #输出所有元素的索引&lt;br /&gt;
0 1 2&lt;/p&gt;

&lt;p&gt;[root@www ~]# array[100]=&amp;ldquo;hello&amp;rdquo;    #指定索引添加一个元素&lt;br /&gt;
[root@www ~]# echo ${array[@]}&lt;br /&gt;
aa bb cc hello&lt;br /&gt;
[root@www ~]# echo ${!array[@]}&lt;br /&gt;
0 1 2 100&lt;br /&gt;
[root@www ~]#&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>shell条件判断</title>
            <link>http://blog.pytool.com/post/shell/2017-11-07-shell%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/2017-11-07-shell%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</guid>
            <description>

&lt;h2 id=&#34;整数比较&#34;&gt;整数比较&lt;/h2&gt;

&lt;p&gt;-eq 等于      if [ &amp;ldquo;$a&amp;rdquo; -eq &amp;ldquo;$b&amp;rdquo; ]&lt;br /&gt;
-ne 不等于    if [ &amp;ldquo;$a&amp;rdquo; -ne &amp;ldquo;$b&amp;rdquo; ]&lt;br /&gt;
-gt 大于      if [ &amp;ldquo;$a&amp;rdquo; -gt &amp;ldquo;$b&amp;rdquo; ]&lt;br /&gt;
-ge 大于等于  if [ &amp;ldquo;$a&amp;rdquo; -ge &amp;ldquo;$b&amp;rdquo; ]&lt;br /&gt;
-lt 小于     if [ &amp;ldquo;$a&amp;rdquo; -lt &amp;ldquo;$b&amp;rdquo; ]&lt;br /&gt;
-le 小于等于  if [ &amp;ldquo;$a&amp;rdquo; -le &amp;ldquo;$b&amp;rdquo; ]&lt;br /&gt;
&amp;lt; 小于（使用 双圆括号）((&amp;ldquo;$a&amp;rdquo; &amp;lt; &amp;ldquo;$b&amp;rdquo;))&lt;br /&gt;
&amp;lt;= 小于等于（使用双圆括号）((&amp;ldquo;$a&amp;rdquo; &amp;lt;= &amp;ldquo;$b&amp;rdquo;))&lt;br /&gt;
&amp;gt; 大于（使用双圆括号）((&amp;ldquo;$a&amp;rdquo; &amp;gt; &amp;ldquo;$b&amp;rdquo;))&lt;br /&gt;
&amp;gt;= 大于等于（使用双圆括号） ((&amp;ldquo;$a&amp;rdquo; &amp;gt;= &amp;ldquo;$b&amp;rdquo;))&lt;/p&gt;

&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;

&lt;h3 id=&#34;等于-if-a-b-注意-在-前后要加上空格&#34;&gt;= 等于  if [ &amp;ldquo;$a&amp;rdquo; = &amp;ldquo;$b&amp;rdquo; ] 注意: 在=前后要加上空格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;   if [ &amp;quot;$a&amp;quot;=&amp;quot;$b&amp;quot; ] 和上面不等价。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;等于-if-a-b-和-同义&#34;&gt;== 等于 if [ &amp;ldquo;$a&amp;rdquo; == &amp;ldquo;$b&amp;rdquo; ] 和 = 同义&lt;/h3&gt;

&lt;p&gt;note == 操作符在 双方括号 和单方括号里的功能是不同的。&lt;/p&gt;

&lt;p&gt;[[ $a == z* ]]   # $a 以 &amp;ldquo;z&amp;rdquo; 开头时为真（模式匹配）&lt;br /&gt;
[[ $a == &amp;ldquo;z&lt;em&gt;&amp;rdquo; ]] # $a 等于 z&lt;/em&gt; 时为真（字符匹配）&lt;/p&gt;

&lt;p&gt;[ $a == z* ]     # 发生文件匹配和字符分割。&lt;br /&gt;
[ &amp;ldquo;$a&amp;rdquo; == &amp;ldquo;z&lt;em&gt;&amp;rdquo; ] # $a 等于 z&lt;/em&gt; 时为真（字符匹配）&lt;/p&gt;

&lt;h3 id=&#34;不等于-if-a-b&#34;&gt;!= 不等于 if [ &amp;ldquo;$a&amp;rdquo; != &amp;ldquo;$b&amp;rdquo; ]&lt;/h3&gt;

&lt;p&gt;在 [[ &amp;hellip; ]] 结构中会进行模式匹配。&lt;/p&gt;

&lt;h3 id=&#34;小于-按照-ascii码-排序&#34;&gt;&amp;lt; 小于，按照 ASCII码 排序。&lt;/h3&gt;

&lt;p&gt;if [[ &amp;ldquo;$a&amp;rdquo; &amp;lt; &amp;ldquo;$b&amp;rdquo; ]]&lt;br /&gt;
if [ &amp;ldquo;$a&amp;rdquo; &amp;lt; &amp;ldquo;$b&amp;rdquo; ]&lt;/p&gt;

&lt;p&gt;注意在 [] 结构里 &amp;lt; 需要被 转义。&lt;/p&gt;

&lt;h3 id=&#34;大于-按照-ascii-码排序&#34;&gt;&amp;gt; 大于，按照 ASCII 码排序。&lt;/h3&gt;

&lt;p&gt;if [[ &amp;ldquo;$a&amp;rdquo; &amp;gt; &amp;ldquo;$b&amp;rdquo; ]]&lt;br /&gt;
if [ &amp;ldquo;$a&amp;rdquo; &amp;gt; &amp;ldquo;$b&amp;rdquo; ]&lt;/p&gt;

&lt;p&gt;注意在 [] 结构里 &amp;gt; 需要被转义。&lt;/p&gt;

&lt;h3 id=&#34;z-字符串为空-即字符串长度为0&#34;&gt;-z 字符串为空，即字符串长度为0。&lt;/h3&gt;

&lt;p&gt;String=&amp;rdquo;   # 长度为0的字符串变量。&lt;/p&gt;

&lt;p&gt;if [ -z &amp;ldquo;$String&amp;rdquo; ]&lt;br /&gt;
then&lt;br /&gt;
  echo &amp;ldquo;\$String is null.&amp;rdquo;&lt;br /&gt;
else&lt;br /&gt;
  echo &amp;ldquo;\$String is NOT null.&amp;rdquo;&lt;br /&gt;
fi     # $String is null.&lt;/p&gt;

&lt;h3 id=&#34;n-字符串非空-null-使用-n-时字符串必须是在括号中且被引用的&#34;&gt;-n 字符串非空（null）使用 -n 时字符串必须是在括号中且被引用的。&lt;/h3&gt;

&lt;p&gt;使用 ! -z 判断未引用的字符串或者直接判断（样例 7-6）通常可行，但是非常危险。判断字符串时一定要引用1。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>shell特殊字符</title>
            <link>http://blog.pytool.com/post/shell/2017-11-07-shell%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/2017-11-07-shell%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</guid>
            <description>&lt;p&gt;Shell特殊字符&lt;/p&gt;

&lt;p&gt;下面来看看Shell特殊字符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;双引号&amp;quot;：用来使Shell无法认出除字符$、`、\之外的任何字符或字符串，也称之为弱引用。  

单引号&#39;：用来使Shell无法认出所有的特殊字符，也称之为强引用。  

反引号`：优先执行当前命令。  

反斜杠\：有两种作用，一种是用来使Shell无法认出其后的字符，使其后的字符失去特殊的含义，如有特殊含义的字符$，也称为转义符。  
另外，如果放在指令前，有取消别名的作用，例如在“\rm/home/yhc/*.log”中，rm指令前加上\，作用是暂时取消别名的功能，将rm指令还原。  

分号； ：允许在一行上放多个命令。  

&amp;amp;     ：将命令放于后台执行，建议带上nohup。  

括号() ：创建成组的命令。  新开shell子进程  

大括号{}：创建命令块。  

&amp;lt;&amp;gt;&amp;amp;    ：重定向。  

*? [] !：表示模式匹配。  

$      ：变量名的开头。  

#      ：表示注释（第一行除外）。  

空格、制表符、换行符：当作空白。  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hugo Shortcode</title>
            <link>http://blog.pytool.com/hugo/hugo_shortcode/</link>
            <pubDate>Thu, 05 Oct 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_shortcode/</guid>
            <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Markdown 语法十分简洁，如果想要插入更加复杂的内容就需要直接使用 HTML 代码，比如通过 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 来自定义图片尺寸，通过 &lt;code&gt;&amp;lt;iframes&amp;gt;&lt;/code&gt; 来插入视频。显然这样做，虽然扩展了 Markdown 文档的表达能力，但却牺牲了 Markdown 语法的简洁性，而且插入的 HTML 代码不利于后续对文档的维护和更新。&lt;/p&gt;

&lt;p&gt;问题的关键在于，Markdown 的简洁性本身就意味着它难以用来书写复杂的内容，尤其是涉及到展示效果的内容。Hugo 提供了 shortcode 来解决这一问题，既使内容保持了 Markdown 的简洁性，又允许创作者在文档中嵌入一些 Markdown 不支持的形式复杂的内容。&lt;/p&gt;

&lt;p&gt;简单来说，shortcode 是一些可以直接插入内容文档中的助记符，在 Hugo 生成网站时，会将这些助记符替换为相应的 HTML 代码片段（严格来说是模板片段）。这样的好处在于，在创作内容时，只要了解这些助记符的用法而不必关心它们是如何实现和转换的。另一方面来看，更新助记符对应的 HTML 片段时，内容文档不会受到影响。接下来将分别介绍：如何在内容文档中使用 shortcode ，Hugo 内置了哪些 shortcode 以及如何自定义 shortcode ？&lt;/p&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;p&gt;Shortcode 语法有些类似 HTML 标记，一个完整的 shortcode 包含以下几个部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{% shorcodename parameters %}}some content for shortcode template{{% /shortcodename %}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;{{% shorcodename parameters %}}&lt;/code&gt; 表示开标记，相应的 &lt;code&gt;{{% /shortcodename %}}&lt;/code&gt; 表示闭标记，闭标记是可选的，同样在开闭标记之间的内容也是可选的。&lt;/p&gt;

&lt;p&gt;开标记中的参数，最终会被传入 shortcode 模板文件中，影响模板的渲染。参数允许以位置参数或命名参数的形式输入（但不能同时传递这两种参数），参数之间用空格间隔，如果参数本身含有空格则需要为其添加双引号。命名参数的格式为 &lt;code&gt;name=&amp;quot;value&amp;quot;&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;除了使用上面的 &lt;code&gt;%&lt;/code&gt; 外，还可以使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 来作为 shortcode 的定界符，比如 &lt;code&gt;{{&amp;lt; gist spf13 7896402 &amp;gt;}}&lt;/code&gt; 。后者跟前者的唯一区别在于，包含在开闭标记之间的内容将不会被 Markdown 引擎处理。&lt;/p&gt;

&lt;p&gt;另外，本文中的许多 shortcode 只是用于显示，并不想要被 Hugo 处理，此时需要在 &lt;code&gt;%&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 定界符内侧添加 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;内置-shortcode&#34;&gt;内置 Shortcode&lt;/h2&gt;

&lt;p&gt;Hugo 预先定义了一些较为常用的 shortcode ，下面介绍如何使用以及在什么情形下使用它们，更详细的用法参见&lt;a href=&#34;https://gohugo.io/content-management/shortcodes/&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;高亮&#34;&gt;高亮&lt;/h3&gt;

&lt;p&gt;用来高亮文档中的代码片段，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; highlight python &amp;gt;}}  
def pt(txt):  
    print(txt)  
{{&amp;lt; /highlight &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;图片&#34;&gt;图片&lt;/h3&gt;

&lt;p&gt;用来扩展 Markdown 中插入图片的语法，该 shortcode 插入的图片支持自定义 CSS 类、添加链接和 caption 等，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; figure src=&amp;quot;/media/spf13.jpg&amp;quot; title=&amp;quot;Steve Francia&amp;quot; link=&amp;quot;&amp;quot; caption=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot; attr=&amp;quot;&amp;quot; attrlink=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档引用&#34;&gt;文档引用&lt;/h3&gt;

&lt;p&gt;根据文档在本地文件系统中的路径，来插入文档的超链接，甚至可以引用文档标题位置，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Neat]({{&amp;lt; ref &amp;quot;blog/neat.md&amp;quot; &amp;gt;}})  
[Who]({{&amp;lt; relref &amp;quot;about.md#who&amp;quot; &amp;gt;}})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数为被引用文档的路径，Hugo 会自动将其替换为被引用文档的永久链接（permalink），&lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;relref&lt;/code&gt; 的不同之处在于，后者给出相对链接，而前者给出完整链接。以上样例的生成结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;/blog/neat&amp;quot;&amp;gt;Neat&amp;lt;/a&amp;gt;  
&amp;lt;a href=&amp;quot;/about/#who:c28654c202e73453784cfd2c5ab356c0&amp;quot;&amp;gt;Who&amp;lt;/a&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;github-代码片段&#34;&gt;GitHub 代码片段&lt;/h3&gt;

&lt;p&gt;用来在文档中插入 GitHub 上创建的代码片段，假设代码片段链接为：&lt;a href=&#34;https://gist.github.com/username/id&#34;&gt;https://gist.github.com/username/id&lt;/a&gt; ，则插入语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; gist username id &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;twitter-推文&#34;&gt;Twitter 推文&lt;/h3&gt;

&lt;p&gt;用来在内容中插入一条 tweet ，推文的链接是这样的： &lt;a href=&#34;https://twitter.com/spf13/status/666616452582129664&#34;&gt;https://twitter.com/spf13/status/666616452582129664&lt;/a&gt; ，插入这条推文的 shortcode 如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; tweet 666616452582129664 &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;youtube-视频&#34;&gt;YouTube 视频&lt;/h3&gt;

&lt;p&gt;用来在内容中插入 YouTube 视频，YouTube 视频资源链接是这样的： &lt;a href=&#34;https://www.youtube.com/watch?v=w7Ft2ymGmfc&#34;&gt;https://www.youtube.com/watch?v=w7Ft2ymGmfc&lt;/a&gt; ，插入该视频的 shortcode 如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; youtube w7Ft2ymGmfc &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者开启自动播放&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; youtube id=&amp;quot;w7Ft2ymGmfc&amp;quot; autoplay=&amp;quot;true&amp;quot; &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vimeo-视频&#34;&gt;Vimeo 视频&lt;/h3&gt;

&lt;p&gt;同插入 YouTube 视频类似，假设资源链接为：&lt;a href=&#34;https://vimeo.com/channels/staffpicks/146022717&#34;&gt;https://vimeo.com/channels/staffpicks/146022717&lt;/a&gt; ，则插入语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; vimeo 146022717 &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;speaker-deck-演示文稿&#34;&gt;Speaker Deck 演示文稿&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/&#34;&gt;Speaker Deck&lt;/a&gt; 是一个允许我们共享演示文稿的地方，我们可以将共享在其上的演示文稿插入到内容文档中，在 Speaker Deck 上点击分享后会生成一段 HTML 代码，假设其中的 &lt;code&gt;data-id=&amp;quot;123456&amp;quot;&lt;/code&gt; ，那么在文档中可以使用如下语法插入该演示文稿&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; speakerdeck 123456 &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;instagram-图片&#34;&gt;Instagram 图片&lt;/h3&gt;

&lt;p&gt;插入 Instagram 上的图片，假设某张图片链接为：&lt;a href=&#34;https://www.instagram.com/p/BMokmydjG-M/&#34;&gt;https://www.instagram.com/p/BMokmydjG-M/&lt;/a&gt; ，则插入该图片的语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; instagram BMokmydjG-M &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; instagram BMokmydjG-M hidecaption &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义-shortcode&#34;&gt;自定义 Shortcode&lt;/h2&gt;

&lt;h3 id=&#34;模板文件位置&#34;&gt;模板文件位置&lt;/h3&gt;

&lt;p&gt;shortcode 的工作机制就是将助记符关联的 HTML 模板片段渲染后插入到文档中。Hugo 支持自定义 shortcode ，需要做的十分简单，只要在模板目录 &lt;code&gt;layouts/shortcodes/&lt;/code&gt; 中创建模板文件即可，模板文件名即为 shortcode 的名称（除去文件名中的扩展名）。&lt;/p&gt;

&lt;p&gt;同时 Hugo 还支持检索主题资源中的 shortcode，因此 shortcode 的查找顺序如下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;/layouts/shortcodes/&amp;lt;SHORTCODE&amp;gt;.html&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/themes/&amp;lt;THEME&amp;gt;/layouts/shortcodes/&amp;lt;SHORTCODE&amp;gt;.html&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;模板文件内容&#34;&gt;模板文件内容&lt;/h3&gt;

&lt;p&gt;shortcode 的模板文件就是普通的 Hugo 模板文件。只不过在 shortcode 模板文件内，可以通过模板变量来访问传入 shortcode 的参数和开闭标记之间的内容。以及其它常规模板变量都可以在 shortcode 模板中访问。&lt;/p&gt;

&lt;h4 id=&#34;访问参数&#34;&gt;访问参数&lt;/h4&gt;

&lt;p&gt;虽然在使用 shortcode 时只可以传入位置和命名参数中的一种，但是在设计 shortcode 模板时却可以考虑接受这两种参数（当然不可能同时接受），为此可以通过模板变量 &lt;code&gt;.IsNamedParams&lt;/code&gt; 来判断，当前参数传入是位置的，还是命名的。&lt;/p&gt;

&lt;p&gt;在模板文件中，位置参数和命名参数都可以通过模板方法 &lt;code&gt;.Get&lt;/code&gt; 来访问：&lt;code&gt;{{ .Get 0 }}&lt;/code&gt; 和 &lt;code&gt;{{ .Get &amp;quot;name&amp;quot; }}&lt;/code&gt; 。或者使用 &lt;code&gt;with&lt;/code&gt; 语法来访问 &lt;code&gt;{{ with .Get &amp;quot;class&amp;quot;}}class=&amp;quot;{{.}}&amp;quot;{{ end }}&lt;/code&gt; 。此外还可以通过模板变量 &lt;code&gt;.Params&lt;/code&gt; 来访问参数。&lt;/p&gt;

&lt;h4 id=&#34;访问内容&#34;&gt;访问内容&lt;/h4&gt;

&lt;p&gt;使用 shortcode 时，位于开闭标记之间的内容，在模板文件中可以通过模板变量 &lt;code&gt;.Inner&lt;/code&gt; 来访问。&lt;/p&gt;

&lt;h4 id=&#34;访问父模板&#34;&gt;访问父模板&lt;/h4&gt;

&lt;p&gt;此外 shortcode 还支持嵌套，比如在内容文档中像下面这样插入 shortcode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; parentshortcode &amp;gt;}}  
{{&amp;lt; childshortcode &amp;gt;}}  
{{&amp;lt; /parentshortcode &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板文件 &lt;code&gt;layouts/shortcodes/childshortcode.html&lt;/code&gt; 中可以通过模板变量 &lt;code&gt;.Parent&lt;/code&gt; 来访问 &lt;code&gt;parendshortcode.html&lt;/code&gt; 的模板环境。&lt;/p&gt;

&lt;p&gt;总之 shortcode 模板文件跟普通的模板文件没有差别，基本就是 HTML 代码跟模板变量的混合体，不过 shortcode 模板除了可以访问常规模板变量外，还可以额外访问几个变量和方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Get 0 }}                    获取位置参数  
{{ .Get &amp;quot;name&amp;quot; }}               获取命名参数  
{{ with .Get &amp;quot;class&amp;quot;}} &amp;lt;p class=&amp;quot;{{.}}&amp;quot;&amp;gt; haha! &amp;lt;/p&amp;gt;{{ end }}  
.Inner                          位于 shortcode 开闭之间的内容  
.Params                         输入的参数列表  
.IsNamedParams                  判断 shortcode 输入的是位置参数还是命名参数  
.Parent                         shortcode 支持继承，该变量表示父 shortcode  
.Page                           所有的页面变量在 shortcode 都可用  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;模板样例&#34;&gt;模板样例&lt;/h3&gt;

&lt;p&gt;年份，模板位置 &lt;code&gt;/layouts/shortcodes/year.html&lt;/code&gt; ，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Page.Now.Year }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;高亮，模板位置 &lt;code&gt;/layouts/shortcodes/highlight.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Get 0 | highlight .Inner  }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片，模板位置 &lt;code&gt;/layouts/shortcodes/figure.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;figure {{ with .Get &amp;quot;class&amp;quot; }}class=&amp;quot;{{.}}&amp;quot;{{ end }}&amp;gt;  
    {{ with .Get &amp;quot;link&amp;quot;}}&amp;lt;a href=&amp;quot;{{.}}&amp;quot;&amp;gt;{{ end }}  
        &amp;lt;img src=&amp;quot;{{ .Get &amp;quot;src&amp;quot; }}&amp;quot; {{ if or (.Get &amp;quot;alt&amp;quot;) (.Get &amp;quot;caption&amp;quot;) }}alt=&amp;quot;{{ with .Get &amp;quot;alt&amp;quot;}}{{.}}{{else}}{{ .Get &amp;quot;caption&amp;quot; }}{{ end }}&amp;quot;{{ end }} /&amp;gt;  
    {{ if .Get &amp;quot;link&amp;quot;}}&amp;lt;/a&amp;gt;{{ end }}  
    {{ if or (or (.Get &amp;quot;title&amp;quot;) (.Get &amp;quot;caption&amp;quot;)) (.Get &amp;quot;attr&amp;quot;)}}  
    &amp;lt;figcaption&amp;gt;{{ if isset .Params &amp;quot;title&amp;quot; }}  
        &amp;lt;h4&amp;gt;{{ .Get &amp;quot;title&amp;quot; }}&amp;lt;/h4&amp;gt;{{ end }}  
        {{ if or (.Get &amp;quot;caption&amp;quot;) (.Get &amp;quot;attr&amp;quot;)}}&amp;lt;p&amp;gt;  
        {{ .Get &amp;quot;caption&amp;quot; }}  
        {{ with .Get &amp;quot;attrlink&amp;quot;}}&amp;lt;a href=&amp;quot;{{.}}&amp;quot;&amp;gt; {{ end }}  
            {{ .Get &amp;quot;attr&amp;quot; }}  
        {{ if .Get &amp;quot;attrlink&amp;quot;}}&amp;lt;/a&amp;gt; {{ end }}  
        &amp;lt;/p&amp;gt; {{ end }}  
    &amp;lt;/figcaption&amp;gt;  
    {{ end }}  
&amp;lt;/figure&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;YouTube 视频，模板位置 &lt;code&gt;/layouts/shortcodes/youtube.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;embed video-player&amp;quot;&amp;gt;  
&amp;lt;iframe class=&amp;quot;youtube-player&amp;quot; type=&amp;quot;text/html&amp;quot; width=&amp;quot;640&amp;quot; height=&amp;quot;385&amp;quot; src=&amp;quot;http://www.youtube.com/embed/{{ index .Params 0 }}&amp;quot; allowfullscreen frameborder=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;  
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
