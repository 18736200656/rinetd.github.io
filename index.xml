<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>时光小栈 on 时光小栈</title>
        <link>http://blog.pytool.com/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Thu, 04 Jan 2018 16:50:24 CST</updated>
        
        <item>
            <title>Diary</title>
            <link>http://blog.pytool.com/diary/</link>
            <pubDate>Thu, 04 Jan 2018 16:50:24 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/diary/</guid>
            <description>&lt;p&gt;1月4日&lt;br /&gt;
今天下雪&lt;/p&gt;

&lt;p&gt;1月5日 周五&lt;br /&gt;
destoon 对search入口封锁了爬虫访问。&lt;code&gt;module/sell/search.inc.php&lt;/code&gt; 注释掉第二句&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Google</title>
            <link>http://blog.pytool.com/seo/google/</link>
            <pubDate>Thu, 04 Jan 2018 09:52:39 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/seo/google/</guid>
            <description>

&lt;h2 id=&#34;seo&#34;&gt;SEO&lt;/h2&gt;

&lt;h3 id=&#34;google&#34;&gt;Google&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.google.com/webmasters/tools/home?hl=zh-CN&#34;&gt;Google Console&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Etcd</title>
            <link>http://blog.pytool.com/post/etcd/docker-etcd/</link>
            <pubDate>Wed, 03 Jan 2018 17:53:25 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/etcd/docker-etcd/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://play.etcd.io/install&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# make sure etcd process has write access to this directory  
# remove this directory if the cluster is new; keep if restarting etcd  
# rm -rf /tmp/etcd/s1  


# to write service file for etcd with Docker  

cat &amp;gt; /tmp/s1.service &amp;lt;&amp;lt;EOF  
[Unit]  
Description=etcd with Docker  
Documentation=https://github.com/coreos/etcd  

[Service]  
Restart=always  
RestartSec=5s  
TimeoutStartSec=0  
LimitNOFILE=40000  

ExecStart=/usr/bin/docker \  
  run \  
  --rm \  
  --net=host \  
  --name etcd-v3.3.0-rc.0 \  
  --volume=/docker/etcd/s1:/etcd-data \  
  gcr.io/etcd-development/etcd:v3.3.0-rc.0 \  
  /usr/local/bin/etcd \  
  --name s1 \  
  --data-dir /etcd-data \  
  --listen-client-urls http://localhost:2379 \  
  --advertise-client-urls http://localhost:2379 \  
  --listen-peer-urls http://localhost:2380 \  
  --initial-advertise-peer-urls http://localhost:2380 \  
  --initial-cluster s1=http://localhost:2380,s2=http://localhost:22380,s3=http://localhost:32380 \  
  --initial-cluster-token tkn \  
  --initial-cluster-state new \  
  --auto-compaction-retention 1  

ExecStop=/usr/bin/docker stop etcd-v3.3.0-rc.0  

[Install]  
WantedBy=multi-user.target  
EOF  

sudo mv /tmp/s1.service /etc/systemd/system/s1.service  


# to start service  
sudo systemctl daemon-reload  
sudo systemctl cat s1.service  
sudo systemctl enable s1.service  
sudo systemctl start s1.service  

# to get logs from service  
sudo systemctl status s1.service -l --no-pager  
sudo journalctl -u s1.service -l --no-pager|less  
sudo journalctl -f -u s1.service  

# to stop service  
sudo systemctl stop s1.service  
sudo systemctl disable s1.service  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;机器环境变量设置&#34;&gt;机器环境变量设置&lt;/h1&gt;

&lt;p&gt;每台机器设置以下环境变量&lt;/p&gt;

&lt;p&gt;export ETCD_VERSION=v3.1.0-alpha.1&lt;br /&gt;
export TOKEN=my-etcd-token&lt;br /&gt;
export CLUSTER_STATE=new&lt;br /&gt;
export NAME_1=etcd-node-0&lt;br /&gt;
export NAME_2=etcd-node-1&lt;br /&gt;
export NAME_3=etcd-node-2&lt;br /&gt;
export HOST_1=192.168.56.101&lt;br /&gt;
export HOST_2=192.168.56.104&lt;br /&gt;
export HOST_3=192.168.56.105&lt;br /&gt;
export CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380&lt;/p&gt;

&lt;p&gt;每个机器安装etcd容器&lt;/p&gt;

&lt;p&gt;进入HOST_1机器，设置环境变量和起容器。&lt;/p&gt;

&lt;p&gt;export THIS_NAME=${NAME_1}&lt;br /&gt;
export THIS_IP=${HOST_1}&lt;/p&gt;

&lt;p&gt;sudo docker run -d &amp;ndash;net=host &amp;ndash;name etcd quay.io/coreos/etcd:${ETCD_VERSION} \&lt;br /&gt;
    /usr/local/bin/etcd \&lt;br /&gt;
    &amp;ndash;data-dir=data.etcd &amp;ndash;name ${THIS_NAME} \&lt;br /&gt;
    &amp;ndash;initial-advertise-peer-urls http://${THIS_IP}:2380 &amp;ndash;listen-peer-urls http://${THIS_IP}:2380 \&lt;br /&gt;
    &amp;ndash;advertise-client-urls http://${THIS_IP}:2379 &amp;ndash;listen-client-urls http://${THIS_IP}:2379 \&lt;br /&gt;
    &amp;ndash;initial-cluster ${CLUSTER} \&lt;br /&gt;
    &amp;ndash;initial-cluster-state ${CLUSTER_STATE} &amp;ndash;initial-cluster-token ${TOKEN}&lt;/p&gt;

&lt;p&gt;进入HOST_2机器，设置环境变量和起容器&lt;/p&gt;

&lt;p&gt;export THIS_NAME=${NAME_2}&lt;br /&gt;
export THIS_IP=${HOST_2}&lt;br /&gt;
sudo docker run &amp;ndash;net=host -d &amp;ndash;name etcd quay.io/coreos/etcd:${ETCD_VERSION} \&lt;br /&gt;
    /usr/local/bin/etcd \&lt;br /&gt;
    &amp;ndash;data-dir=data.etcd &amp;ndash;name ${THIS_NAME} \&lt;br /&gt;
    &amp;ndash;initial-advertise-peer-urls http://${THIS_IP}:2380 &amp;ndash;listen-peer-urls http://${THIS_IP}:2380 \&lt;br /&gt;
    &amp;ndash;advertise-client-urls http://${THIS_IP}:2379 &amp;ndash;listen-client-urls http://${THIS_IP}:2379 \&lt;br /&gt;
    &amp;ndash;initial-cluster ${CLUSTER} \&lt;br /&gt;
    &amp;ndash;initial-cluster-state ${CLUSTER_STATE} &amp;ndash;initial-cluster-token ${TOKEN}&lt;/p&gt;

&lt;p&gt;进入HOST_3机器，设置环境变量和起容器&lt;/p&gt;

&lt;p&gt;export THIS_NAME=${NAME_3}&lt;br /&gt;
export THIS_IP=${HOST_3}&lt;br /&gt;
sudo docker run &amp;ndash;net=host -d &amp;ndash;name etcd quay.io/coreos/etcd:${ETCD_VERSION} \&lt;br /&gt;
    /usr/local/bin/etcd \&lt;br /&gt;
    &amp;ndash;data-dir=data.etcd &amp;ndash;name ${THIS_NAME} \&lt;br /&gt;
    &amp;ndash;initial-advertise-peer-urls http://${THIS_IP}:2380 &amp;ndash;listen-peer-urls http://${THIS_IP}:2380 \&lt;br /&gt;
    &amp;ndash;advertise-client-urls http://${THIS_IP}:2379 &amp;ndash;listen-client-urls http://${THIS_IP}:2379 \&lt;br /&gt;
    &amp;ndash;initial-cluster ${CLUSTER} \&lt;br /&gt;
    &amp;ndash;initial-cluster-state ${CLUSTER_STATE} &amp;ndash;initial-cluster-token ${TOKEN}&lt;/p&gt;

&lt;p&gt;测试集群运行情况：&lt;/p&gt;

&lt;p&gt;docker exec etcd /bin/sh -c &amp;ldquo;export ETCDCTL_API=3 &amp;amp;&amp;amp; /usr/local/bin/etcdctl put foo bar&amp;rdquo;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Prometheus 详解</title>
            <link>http://blog.pytool.com/post/prometheus/prometheus/</link>
            <pubDate>Wed, 03 Jan 2018 17:17:45 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/prometheus/prometheus/</guid>
            <description>

&lt;p&gt;prometheus缺点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单机缺点，单机下存储量有限，根据你的监控量局限你的存储时间。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;内存占用率大，prometheus集成了leveldb，一个能高效插入数据的数据库，在ssd盘下io占用比较高。同时可能会有大量数据堆积内&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;docker运行prometheus&#34;&gt;docker运行prometheus&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;docker run -p 9090:9090 -v /docker/prometheus-data:/prometheus-data prom/prometheus&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;docker run -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml \&lt;br /&gt;
       -v /docker/prometheus-data:/prometheus-data \&lt;br /&gt;
       prom/prometheus&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;访问&lt;a href=&#34;http://192.168.99.100:9090/graph&#34;&gt;http://192.168.99.100:9090/graph&lt;/a&gt;&lt;br /&gt;
计算实例，指标可以从&lt;a href=&#34;http://192.168.99.100:9090/me...中找&#34;&gt;http://192.168.99.100:9090/me...中找&lt;/a&gt;&lt;br /&gt;
prometheus_target_interval_length_seconds{quantile=&amp;ldquo;0.99&amp;rdquo;}&lt;br /&gt;
或者&lt;br /&gt;
count(prometheus_target_interval_length_seconds)&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;怎么使用prometheus监控容器&lt;/p&gt;

&lt;p&gt;prometheus监控不同的目标服务需要实现不同的exporter插件,早期的时候，官方出了container-exporter项目，但是现在项目已经停止。推荐使用谷歌的cAdvisor项目作为prometheus的exporter。cAdvisor作为一个监控单机容器的项目，数据较为全面，但是也有很大的问题，例如io等数据没有等等。结合prometheus后就能在整个集群监控查询容器。举个例子，你有一个项目有3个容器分布在三台机器，你怎么监控整个项目的流量，内存量，负载量的实时数据。这就是prometheus的多维度查询解决的问题，数据从3台机器的cadvisor得到每个容器的数据，它的多维度查询语法就能让你得到你想要的数据。&lt;/p&gt;

&lt;p&gt;这里假设你有10台机器部署了容器需要监控，你在10台机器上分别部署cAdvisor容器&lt;/p&gt;

&lt;p&gt;sudo docker run \&lt;br /&gt;
    &amp;ndash;volume=/:/rootfs:ro \&lt;br /&gt;
    &amp;ndash;volume=/var/run:/var/run:rw \&lt;br /&gt;
    &amp;ndash;volume=/sys:/sys:ro \&lt;br /&gt;
    &amp;ndash;volume=/var/lib/docker/:/var/lib/docker:ro \&lt;br /&gt;
    &amp;ndash;publish=8080:8080 \&lt;br /&gt;
    &amp;ndash;detach=true \&lt;br /&gt;
    &amp;ndash;name=cadvisor \&lt;br /&gt;
    google/cadvisor:latest&lt;/p&gt;

&lt;p&gt;找一台机器部署prometheus服务，这里依然使用容器部署：&lt;/p&gt;

&lt;p&gt;docker run \&lt;br /&gt;
  -p 9090:9090 \&lt;br /&gt;
  &amp;ndash;log-driver none \&lt;br /&gt;
  -v /hdd1/prometheus/etc/:/etc/prometheus/ \&lt;br /&gt;
  -v /hdd1/prometheus/data/:/prometheus/ \&lt;br /&gt;
  -v /etc/localtime:/etc/localtime \&lt;br /&gt;
  &amp;ndash;name prometheus \&lt;br /&gt;
  prom/prometheus&lt;/p&gt;

&lt;p&gt;创建/hdd1/prometheus/etc/prometheus.yml配置文件&lt;/p&gt;

&lt;p&gt;my global config&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  global:  
    scrape_interval:     15s # By default, scrape targets every 15 seconds.  
    evaluation_interval: 15s # By default, scrape targets every 15 seconds.  
    # scrape_timeout is set to the global default (10s).  
    # Attach these labels to any time series or alerts when communicating with  
    # external systems (federation, remote storage, Alertmanager).  
    external_labels:  
        monitor: &#39;container-monitor&#39;  
  # Load and evaluate rules in this file every &#39;evaluation_interval&#39; seconds.  
  rule_files:  
     - &amp;quot;/etc/prometheus/rules/common.rules&amp;quot;  
  # A scrape configuration containing exactly one endpoint to scrape:  
  # Here it&#39;s Prometheus itself.  
  scrape_configs:  
    # The job name is added as a label `job=&amp;lt;job_name&amp;gt;` to any timeseries scraped from this config.  
    - job_name: &#39;container&#39;  
      static_configs:  
      - targets: [&#39;10.12.1.129:9090&#39;,&#39;10.12.1.130:9090&#39;,&#39;10.50.1.92:9090&#39;,&#39;10.50.1.93:9090&#39;,&#39;10.50.1.119:9090&#39;]  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件中 -targets中的端点填写你的实际cadvisor所在的ip和暴露的端口.正确启动后访问ip:9090就能查询数据了哦&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Prometheus智能化报警流程避免邮件轰炸</title>
            <link>http://blog.pytool.com/post/prometheus/prometheus-altermanager/</link>
            <pubDate>Wed, 03 Jan 2018 17:17:45 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/prometheus/prometheus-altermanager/</guid>
            <description></description>
        </item>
        
        <item>
            <title>golang微服务技术栈</title>
            <link>http://blog.pytool.com/post/go/go-micro-stack/</link>
            <pubDate>Wed, 03 Jan 2018 17:15:26 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/go/go-micro-stack/</guid>
            <description>&lt;p&gt;负载均衡：seesaw、caddy&lt;br /&gt;
服务网关：tyk、fabio、vulcand&lt;br /&gt;
进程间通信：RESTful、RPC、自定义&lt;br /&gt;
REST框架：gin、Iris、micro、go-kit、goa&lt;br /&gt;
RPC框架：grpc、thrift、hprose&lt;br /&gt;
服务发现：etcd、consul、serf&lt;br /&gt;
调度系统：kubernetes、docker swarm&lt;br /&gt;
消息队列：NSQ、Nats&lt;br /&gt;
配置管理：etcd、consul、mgmt&lt;br /&gt;
服务监控：open-falcon、prometheus&lt;br /&gt;
CI/CD：Drone&lt;br /&gt;
熔断器：gateway、Hystrix-go&lt;br /&gt;
日志分析：Beats、Heka&lt;br /&gt;
APM（应用性能监控）：appdash、Cloudinsight、opentracing&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>wepack3 url-loader</title>
            <link>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack-url-loader/</link>
            <pubDate>Tue, 12 Dec 2017 15:47:11 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack-url-loader/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module: {  
  rules: [  
    {  
      test: /\.js$/,  
      use: &#39;babel-loader?cacheDirectory&#39;, // 开启 babel-loader 缓存  
      include: [path.resolve(&#39;src&#39;), path.resolve(&#39;test&#39;)],  
      exclude: /node_modules/  
    },  
    {  
      test: /\.(css|scss)$/,  
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]  
    },  
    {  
      test: /\.(png|jpe?g|gif|svg)(\?.*)?$/i,  
      loader: &#39;url-loader&#39;,  
      options: {  
        limit: 10 * 1024,  
        name: &#39;images/[name].[ext]?[hash]&#39;  
      }  
    },  
    {  
      test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,  
      loader: &#39;url-loader&#39;,  
      options: {  
        limit: 10 * 1024,  
        name: &#39;media/[name].[ext]?[hash]&#39;  
      }  
    },  
    {  
      test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,  
      loader: &#39;url-loader&#39;,  
      options: {  
        limit: 10 * 1024,  
        name: &#39;fonts/[name].[ext]?[hash]&#39;  
      }  
    }  
  ]  
},  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module: {  
     rules: [  
         {  
             // 后缀正则  
             test: /\.js$/,  
             // 加载器组  
             use: [  
                 {  
                     loader: &#39;babel-loader&#39;,  
                 },  
                 {  
                     loader: &#39;eslint-loader&#39;,  
                 },  
             ],  
             exclude: /node_modules/,  
         },  
         {  
             test: /\.less$/,  
             use: ExtractTextPlugin.extract({  
                 fallback: &#39;style-loader&#39;,  
                 use: [  
                     &#39;css-loader&#39;,  
                     &#39;postcss-loader&#39;,  
                     &#39;less-loader&#39;,  
                 ],  
             }),  
             exclude: /node_modules/,  
         },  

         {  
             test: /\.(woff|woff2)(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                     options: {  
                         name: &#39;[path][name].[ext]&#39;,  
                         limit: 10240,  
                         mimetype: &#39;application/font-woff&#39;,  
                     }  
                 },  
             ],  
             // loaders: [&#39;url-loader?&amp;amp;limit=102400&amp;amp;mimetype=application/font-woff&#39;],  
         },  
         {  
             test: /\.ttf(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                     options: {  
                         name: &#39;[path][name].[ext]&#39;,  
                         limit: 10240,  
                         mimetype: &#39;application/octet-stream&#39;,  
                     }  
                 },  
             ],  
             // loaders: [&#39;url-loader?name=[path][name].[ext]&amp;amp;limit=1024&amp;amp;mimetype=application/octet-stream&#39;],  
         },  
         {  
             test: /\.eot(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;file-loader&#39;,  
                     options: {  
                         name: &#39;[path][name].[ext]&#39;,  
                     }  
                 },  
             ],  
             // loaders: [&#39;file-loader?name=[path][name].[ext]&#39;],  
         },  
         {  
             test: /\.svg(\?v=\d+\.\d+\.\d+)?$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                 },  
             ],  
             // loaders: [&#39;url-loader?name=[path][name].[ext]&amp;amp;limit=1024&amp;amp;mimetype=image/svg+xml&#39;],  
         },  
         {  
             test: /\.(png|jpg|gif)$/,  
             use: [  
                 {  
                     loader: &#39;url-loader&#39;,  
                 },  
             ],  
             // loaders: [&#39;url-loader?name=[path][name].[ext]?[hash]&amp;amp;limit=204800000&#39;], // 单位bit  
             exclude: /node_modules/,  
         },  
     ],  
 },  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>wepack3 详解</title>
            <link>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack/</link>
            <pubDate>Tue, 12 Dec 2017 15:47:11 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2016-11-09-webpack/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://doc.webpack-china.org/&#34;&gt;webpack3中文文档&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000012068849&#34;&gt;Fis3构建迁移Webpack之路&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/fouber/blog/issues/6&#34;&gt;大公司里怎样开发和部署前端代码&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/webpack-china/awesome-webpack-cn&#34;&gt;awesome-webpack-cn&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000005742122&#34;&gt;webpack进阶之插件篇&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000012356915&#34;&gt;webpack飞行手册 &lt;em&gt;推荐&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.pytool.com/images/webpack.svg&#34; alt=&#34;webpack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;entry：入口，定义要打包的文件&lt;br /&gt;
output：出口，定义打包输出的文件；包括路径，文件名，还可能有运行时的访问路径（publicPath）参数&lt;br /&gt;
module: webpack将所有资源都看做是模块,而模块就需要加载器；&lt;br /&gt;
  loaders: Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。&lt;br /&gt;
plugins：定义以下额外的插件&lt;br /&gt;
resolve：定义能够被打包的文件，文件后缀名&lt;br /&gt;
    extensions: [&amp;ldquo;, &amp;lsquo;.js&amp;rsquo;, &amp;lsquo;.es6&amp;rsquo;]&lt;/p&gt;

&lt;h3 id=&#34;wenbpack-安装失败的原因&#34;&gt;wenbpack 安装失败的原因&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、网络问题    cnpm&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2、权限问题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3、node 版本问题&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==============================================&lt;/p&gt;

&lt;h3 id=&#34;webpack版本问题修改&#34;&gt;webpack版本问题修改&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新项目&lt;br /&gt;
&amp;gt;直接删除node_modules 重新安装 npm install &amp;ndash;save-dev webpack&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;旧项目&lt;br /&gt;
&amp;gt;修改package.json中的版本号   删除node_modules   重新  npm install&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===============================================&lt;/p&gt;

&lt;h3 id=&#34;学习步骤&#34;&gt;学习步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、配置文件webpack.config.js&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2、entery选项（入口配置）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3、output选项（出口配置）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4、多入口、多出口配置&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==================================================&lt;/p&gt;

&lt;h3 id=&#34;基本结构&#34;&gt;基本结构&lt;/h3&gt;

&lt;p&gt;const path=require(&amp;lsquo;path&amp;rsquo;);&lt;br /&gt;
module.export={&lt;br /&gt;
    entry:{&lt;br /&gt;
        entry:&amp;lsquo;文件路径&amp;rsquo;&lt;br /&gt;
    },       入口配置&lt;br /&gt;
    output:{&lt;br /&gt;
        path：path.resolve(__dirname,&amp;lsquo;dist&amp;rsquo;),  node语法相对路径&lt;br /&gt;
        filename:&amp;rsquo;[name].js&amp;rsquo;    //压缩后的文件名&lt;br /&gt;
    },      出口配置&lt;br /&gt;
    module:{},      解读css  图片转换压缩&lt;br /&gt;
    plugins:[]      插件&lt;br /&gt;
    devServer:{}    配置服务&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;======================================================&lt;/p&gt;

&lt;h3 id=&#34;webpack配置服务-热更新技术&#34;&gt;webpack配置服务、热更新技术&lt;/h3&gt;

&lt;p&gt;devServer:{&lt;br /&gt;
    contentBase:path.resolve(__dirname,&amp;lsquo;dist&amp;rsquo;),&lt;br /&gt;
    host:&amp;lsquo;192.168.199.106&amp;rsquo;,           //服务器地址&lt;br /&gt;
    compress:true,                    //服务器是否压缩&lt;br /&gt;
    port:1717                        //服务器端口&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;npm install webpack-dev-server &amp;ndash;save-dev&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;修改package.json&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;script&amp;rdquo;:{&lt;br /&gt;
&amp;ldquo;server&amp;rdquo;:&amp;ldquo;webpack-dev-server&amp;rdquo;&lt;br /&gt;
}&lt;br /&gt;
&amp;gt;起服务  npm run server&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;webpack3.6以上的热更新&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;=========================================================&lt;/p&gt;

&lt;h3 id=&#34;css打包&#34;&gt;css打包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;style-loader      //处理css中URL&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;css-loader        //对标签处理&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;module:{&lt;br /&gt;
        rules:[&lt;br /&gt;
            {&lt;br /&gt;
                test:/.css$/,    //通过正则的方式找到处理的扩展&lt;br /&gt;
                //use:[&amp;lsquo;style-loader&amp;rsquo;,&amp;lsquo;css-loader]&lt;br /&gt;
                //loader&lt;br /&gt;
                //use:[{&lt;br /&gt;
                    loader:&amp;lsquo;style-loader&amp;rsquo;&lt;br /&gt;
                    },{&lt;br /&gt;
                        loader:&amp;lsquo;css-loader&amp;rsquo;&lt;br /&gt;
                }]&lt;br /&gt;
            }&lt;br /&gt;
        ]&lt;br /&gt;
    },&lt;/p&gt;

&lt;p&gt;================================================================&lt;/p&gt;

&lt;h3 id=&#34;js打包&#34;&gt;js打包&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;引入插件 uglify&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;const uglify = require(&amp;lsquo;uglifyjs-webpack-plugin&amp;rsquo;);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;plugins:[&lt;br /&gt;
new uglify()&lt;br /&gt;
]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==================================================================&lt;/p&gt;

&lt;h3 id=&#34;html打包&#34;&gt;html打包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装并引入插件  html-webpack-plugin&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;const htmlPlugin = require(&amp;lsquo;html-webpack-plugin&amp;rsquo;);&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;plugins:[&lt;br /&gt;
new  htmlPlugin({&lt;br /&gt;
    minify:{&lt;br /&gt;
        removeAttributeQuotes:true&lt;br /&gt;
    },&lt;br /&gt;
    hash:true,&lt;br /&gt;
    template:&amp;lsquo;./src/index.html&amp;rsquo;&lt;br /&gt;
})&lt;br /&gt;
]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;template：是要打包的html模版路径和文件名称。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=====================================================================&lt;/p&gt;

&lt;h3 id=&#34;css图片路径问题&#34;&gt;css图片路径问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;module:[{&lt;br /&gt;
rules{&lt;br /&gt;
    test:/.(png|jpg|gif)/,&lt;br /&gt;
    use:[{&lt;br /&gt;
        loader:&amp;lsquo;url-loader&amp;rsquo;,&lt;br /&gt;
        options:{&lt;br /&gt;
            limit:50000&lt;br /&gt;
        }&lt;br /&gt;
    }]&lt;br /&gt;
}&lt;br /&gt;
}]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test:/.(png|jpg|gif)/是匹配图片文件后缀名称。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;use：是指定使用的loader和loader的配置参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;limit：是把小于500000B的文件打成Base64的格式，写入JS。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===============================================================&lt;/p&gt;

&lt;h3 id=&#34;css分离&#34;&gt;css分离&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装插件  extract-text-webpack-plugin&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;引入插件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在插件中声明&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;修改处理css&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;rules:[&lt;br /&gt;
{&lt;br /&gt;
    test:/.css$/,&lt;br /&gt;
    use:extractTextPlugin.extract({&lt;br /&gt;
        fallback:&amp;lsquo;style-loader&amp;rsquo;,&lt;br /&gt;
        use:&amp;lsquo;css-loader&amp;rsquo;&lt;br /&gt;
    })&lt;br /&gt;
}]&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===================================================================&lt;/p&gt;

&lt;h3 id=&#34;处理html中的图片&#34;&gt;处理html中的图片&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装插件  html-withimg-loader&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;配置插件&lt;br /&gt;
&amp;gt;{&lt;br /&gt;
test:/.(html|htm)$/i,&lt;br /&gt;
use:[&amp;lsquo;html-withimg-loader&amp;rsquo;]&lt;br /&gt;
}&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;====================================================================&lt;/p&gt;

&lt;h3 id=&#34;自动补全css前缀&#34;&gt;自动补全css前缀&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装插件  postcss-loader   autoprefixer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建postcss.config.js&lt;br /&gt;
&amp;gt;module.exports={&lt;br /&gt;
plugins:[&lt;br /&gt;
    require(&amp;lsquo;auotprefixer&amp;rsquo;)&lt;br /&gt;
]&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写loader&lt;br /&gt;
&amp;gt;{&lt;br /&gt;
test: /.css$/,&lt;br /&gt;
use: extractTextPlugin.extract({&lt;br /&gt;
    fallback: &amp;lsquo;style-loader&amp;rsquo;,&lt;br /&gt;
    use: [&lt;br /&gt;
        { loader: &amp;lsquo;css-loader&amp;rsquo;, options: { importLoaders: 1 } },&lt;br /&gt;
        &amp;lsquo;postcss-loader&amp;rsquo;&lt;br /&gt;
    ]&lt;br /&gt;
})&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;git@github.com:heavenswen/webpack-page.git&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//编译状态  
const Env = process.env.NODE_ENV === &#39;production&#39;  
const { join, resolve } = require(&#39;path&#39;)  
const webpack = require(&#39;webpack&#39;)  
const glob = require(&#39;glob&#39;)  
// const ImageminPlugin = require(&#39;imagemin-webpack-plugin&#39;).default;  
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)  
const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)  
const CommonsChunkPlugin = require(&#39;webpack/lib/optimize/CommonsChunkPlugin&#39;)  
const LiveReloadPlugin = require(&#39;webpack-livereload-plugin&#39;)  
const ROOT = process.cwd();  // 根目录  
// 通过允许您并行转换多个文件， HappyPack使Webpack构建更快。  
const HappyPack = require(&#39;happypack&#39;);  
const HappyThreadPool = HappyPack.ThreadPool({ size: (Env ? 10 : 4) });  
const release = Env ? &#39;/&#39; : &#39;/&#39;//域名文件夹  
//页面对应路口  
const entries = {}  
//入口对象集  
const chunks = []  
//页面list  
const pagesList = []  
//logo  
const favicon = &amp;quot;./src/assets/img/logo.png&amp;quot;  
// 页面模版  
const entryHtml = []  

//页面模版  
glob.sync(&amp;quot;./src/pages/**/*.{ejs,html}&amp;quot;).forEach(path =&amp;gt; {  
  //HtmlWebpackPlugin 不支持 .html 编译 ejs 用.ejs  
  let filename = path.split(&#39;./src/pages/&#39;)[1]  

  //入口js文件名  
  let chunk = path.split(&#39;./src/pages/&#39;)[1].split(/\.(ejs|html)/)[0]  
  //设置产出路径  
  chunk = &#39;js/&#39; + chunk  
  // 入口js路径  
  let js = path  

  //js路径  
  js = js.replace(/\/pages/ig, &#39;/entry&#39;);  
  js = js.replace(/\.(ejs|html)/gi, &#39;.js&#39;);  
  entries[chunk] = js  
  //入口js名称名称  
  chunks.push(chunk)  

  filename = filename.replace(/\.ejs/ig, &#39;.html&#39;)  
  //获得所有页面  
  pagesList.push(filename)  
  let htmlConf = {  
    filename: filename,//文件名  
    //模版位置  
    template: path,  
    inject: &#39;body&#39;,  
    favicon: favicon,  
    hash: Env,  
    env: Env,//HtmlWebpackPlugin.options.env 非打包时的处理  
    list: pagesList,//页面地址  
    chunks: [&#39;vendors&#39;, chunk] //chunk  
  }  

  //保存配置  
  entryHtml.push(htmlConf)  

})  

const config = {  
  entry: entries,  
  output: {  
    path: resolve(__dirname, &#39;./dist&#39;),  
    filename: &#39;[name].js&#39;,  
    publicPath: release  
  },  
  resolve: {  
    //路径检索  
    extensions: [&#39;.js&#39;, &#39;.vue&#39;],  
    alias: {  
      //资源  
      assets: join(__dirname, &#39;/src/assets&#39;),  
      //组件  
      components: join(__dirname, &#39;/src/components&#39;),  
      //视图  
      views: join(__dirname, &#39;/src/views&#39;),  
      root: join(__dirname, &#39;node_modules&#39;)  

    }  
  },  
  module: {  
    //忽略以下js  
    noParse: /node_modules\/(jquey|zepto|moment|chart\.js)/,  
    rules: [  
      {  
        test: /\.vue$/,  
        use: &#39;vue-loader&#39;  
      },  
      {  
        test: /\.js$/,  
        use: [{  
          loader: &#39;babel-loader?id=js&#39;,  
          options: {  
            //es6  
            presets: [&#39;es2015&#39;]  
          }  
        }],  
        exclude: /node_modules/  
      },  
      {  
        //编译sass  
        test: /\.(scss|sass)$/,  
        use: ExtractTextPlugin.extract({  
          fallback: &#39;style-loader?id=style&#39;,  
          use: [{  
            loader: &#39;css-loader?id=style&#39;,  
            options: {  
              //压缩css  
              minimize: Env  
            }  
          }, &#39;postcss-loader?id=style&#39;, &#39;sass-loader?id=style&#39;],  
        })  

      },  
      {  
        test: /\.css$/,  
        use: ExtractTextPlugin.extract({  
          fallback: &#39;style-loader?id=style&#39;,  
          use: [{  
            loader: &#39;css-loader?id=style&#39;,  
            options: {  
              //压缩css  
              minimize: Env  
            }  
          }, &#39;postcss-loader?id=style&#39;],  
        })  
      },  

      {  
        //修改html img路径  
        test: /\.html$/,  
        use: [{  
          loader: &#39;html-loader&#39;,  
          options: {  
            root: resolve(__dirname, &#39;src&#39;),  
            attrs: [&#39;img:src&#39;, &#39;img:data-src&#39;, &#39;img:data-background&#39;, &#39;link:href&#39;]  
          }  
        }]  
      },  
      {  
        test: /\.(png|jpg|jpeg|gif|svg|svgz)(\?.+)?$/,  
        exclude: /favicon\.(png|ico)$/,//除外  
        loaders: [  
          &#39;url-loader?limit=1000&amp;amp;outputPath=assets/img/&amp;amp;name=[name].[ext]?[hash]&#39;,  
          {  
            //图片压缩  
            loader: &#39;image-webpack-loader&#39;,  
            options: {  
              gifsicle: {  
                interlaced: false,  
              },  
              optipng: {  
                optimizationLevel: 1,  
              },  
              pngquant: {  
                quality: &#39;65-90&#39;,  
                speed: 4  
              },  
              mozjpeg: {  
                progressive: true,  
                quality: 65  
              }  
            }  
          }  
        ]  
      },  
      {  
        //文字资源  
        test: /\.(eot|ttf|woff|woff2)(\?.+)?$/,  
        use: [{  
          loader: &#39;url-loader&#39;,  
          options: {  
            limit: 1000,  
            name: &amp;quot;[name].[ext]?[hash]&amp;quot;,  
            outputPath: &amp;quot;assets/fonts/&amp;quot;,//产出目录  
          }  
        }]  
      },  
      {  
        //资源  
        test: /\.(apk|docx|doc|exe)(\?.+)?$/,  
        use: [{  
          loader: &#39;file-loader&#39;,  
          options: {  
            name: &amp;quot;[name].[ext]?[hash]&amp;quot;,  
            outputPath: &amp;quot;assets/file/&amp;quot;,//产出目录  
          }  
        }]  
      }  
    ]  
  },  
  plugins: [  
    //会跟 webpack-dev-server 冲突，导致js修改时找不到修改对象  
    // new LiveReloadPlugin({  
    // }),  
    new HappyPack({  
      id: &#39;js&#39;,  
      // @see https://github.com/amireh/happypack  
      threadPool: HappyThreadPool,  
      loaders: [&#39;babel-loader&#39;]  
    }),  
    new HappyPack({  
      id: &#39;styles&#39;,  
      threadPool: HappyThreadPool,  
      loaders: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]  
    }),  
    //获取公用模块生成js  
    new CommonsChunkPlugin({  
      name: &#39;vendors&#39;,  
      filename: &#39;assets/js/vendors.js?[hash]&#39;,  
      chunks: chunks,  
      minChunks: chunks.length  
    }),  
    //提取公用模块生成css  
    new ExtractTextPlugin({  
      filename: (getPath) =&amp;gt; {  
        //获得地址  
        let name = getPath(&#39;[name]&#39;)  

        if (!name.match(/vendors/ig)) {  
          let arr = name.split(&#39;/&#39;)  
          name = arr[arr.length - 1]//获得文件名  
        }  
        return &#39;assets/css/&#39; + name + &#39;.css&#39;;  
      },  
      allChunks: true  
    }),  
    //webpack3.0  
    new webpack.optimize.ModuleConcatenationPlugin()  
  ],  
  devServer: {  
    contentBase: [  
      join(ROOT, &#39;src/&#39;)  
    ],  
    port: 8010,  
    //启动路由功能  
    //historyApiFallback: false,  
    // noInfo: true,  
    hot: false,  
    //真实地址 可以用局域访问  
    disableHostCheck: true,  
    //允许其他电脑访问  
    host: &#39;0.0.0.0&#39;,  
  },  
  devtool: &#39;#eval-source-map&#39;  
}  


//页面模版  
entryHtml.forEach(function (v) {  
  config.plugins.push(new HtmlWebpackPlugin(v));  
});  

module.exports = config  

if (process.env.NODE_ENV === &#39;production&#39;) {  
  module.exports.devtool = &#39;#source-map&#39;  
  // http://vue-loader.vuejs.org/en/workflow/production.html  
  module.exports.plugins = (module.exports.plugins || []).concat([  
    new webpack.DefinePlugin({  
      &#39;process.env&#39;: {  
        NODE_ENV: &#39;&amp;quot;production&amp;quot;&#39;  
      }  
    }),  
    //压缩单元  
    new webpack.optimize.UglifyJsPlugin({  
      // 最紧凑的输出  
      beautify: false,  
      // 删除所有的注释  
      comments: false,  
      compress: {  
        // 在UglifyJs删除没有用到的代码时不输出警告  
        warnings: false,  
        // 删除所有的 `console` 语句  
        // 还可以兼容ie浏览器  
        drop_console: true,  
        // 内嵌定义了但是只用到一次的变量  
        collapse_vars: true,  
        // 提取出出现多次但是没有定义成变量去引用的静态值  
        reduce_vars: true,  
      }  
    }),  

  ])  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var path = require(&#39;path&#39;);  
var fs = require(&#39;fs&#39;);  
var webpack = require(&#39;webpack&#39;);  
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);  
var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);  
var FriendlyErrorsWebpackPlugin = require(&#39;friendly-errors-webpack-plugin&#39;);  

console.log(&#39;NODE_ENV&#39;,process.env.NODE_ENV);  

const extractCSS = new ExtractTextPlugin(&#39;css/[name]-one.css&#39;);  
const extractLESS = new ExtractTextPlugin(&#39;css/[name]-two.css&#39;);  
const extractSASS = new ExtractTextPlugin(&#39;css/[name]-three.css&#39;);  

var config = {  
    entry: {  
        main: [  
            // &#39;babel-polyfill&#39;,  
            &#39;webpack-hot-middleware/client?path=/__webpack_hmr&amp;amp;timeout=20000&amp;amp;reload=true&#39;,  
            &#39;webpack/hot/dev-server&#39;,  
            path.resolve(__dirname, &#39;src/main.js&#39;),  
            path.resolve(__dirname, &#39;src/index.js&#39;)  
        ],  
        verdor: [  
            path.resolve(__dirname, &#39;src/verdor/verdor.js&#39;),  
        ]  
    },  
    // entry: path.resolve(__filename, &#39;../src/main.js&#39;),  
    output: {  
        path: path.resolve(__filename, &#39;../dist&#39;),  
        publicPath: &#39;/&#39;,  
        filename: &#39;[name].[hash:8].bundle.js&#39;,  
        // webpack 允许你根据文件内容生成哈希值，只要用 [chunkhash] 替换 [hash] 就可以了  
        // 不要在开发环境下使用 [chunkhash]，因为这会增加编译时间。将开发和生产模式的配置分开，并在开发模式中使用 [name].js 的文件名， 在生产模式中使用 [name].[chunkhash].js 文件名。  
        //    publicPath: &#39;/&#39;,  
        //    chunkFilename: &#39;[id].[chunkhash].js&#39;  
    },  
    // 生成.map文件  
    // devtool: &#39;source-map&#39;,  
    module: {  
        rules: [  
            // 加载JSON文件 使用json-loader webpack1  
            // wenpack2 + ,json-loader 不再需要手动添加  
            // [官方: 是为了消除 webpack、 node.js 和 browserify 之间的环境差异。 https://github.com/webpack/webpack/issues/3363]  
            // {  
            //     test: /\.json$/,  
            //     use: &#39;json-loader&#39;  
            // },  

            // 处理 .json5结尾的文件  
            {  
                test: /\.json5$/,  
                use: &#39;json5-loader&#39;  
            },  
            // {  
            //     test: /\.css$/,  
            //     // 使用①生成的css文件 插入到html中  
            //     // use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]  
            //     // 使用②ExtractTextPlugin 生成style.css文件  
            //     // 在主入口文件中import  
            //     use: ExtractCSS.extract([  
            //         &#39;css-loader&#39;,  
            //         // &#39;px2rem2-loader&#39;,  
            //         &#39;postcss-loader&#39;,  
            //     ]),  
            // }  

            // 使用postcss方式， css 插入到DOM形式 ， 支持热更新  
            // {  
            //     test: /\.css$/,  
            //     use: [ &#39;style-loader&#39;, &#39;css-loader&#39;,  &#39;postcss-loader&#39; ]  
            // },  
            {  
                test: /\.less$/,  
                use: extractLESS.extract({  
                    fallback: [&#39;style-loader&#39;],  
                    use: [  
                        &#39;css-loader&#39;,  
                        &#39;postcss-loader&#39;,  
                        &#39;less-loader&#39;  
                    ]  
                })  
            },  
            {  
                test: /\.scss$/,  
                use: extractSASS.extract({  
                    fallback: [&#39;style-loader&#39;],  
                    use: [  
                        &#39;css-loader&#39;,  
                        &#39;postcss-loader&#39;,  
                        &#39;sass-loader&#39;  
                    ]  
                })  
            },  
            // ExtractTextPlugin 提取了样式出来， 官方说No Hot Module Replacement。  
            // https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/webpack-1/README.md  
            {  
                test: /\.css$/,  
                use: extractCSS.extract({  
                    fallback: [&#39;style-loader&#39;],  
                    use: [  
                        &#39;css-loader&#39;,  
                        &#39;postcss-loader&#39;  
                    ]  
                })  
            },  
            {  
                test: /\.js(x)*$/,  
                exclude: /node_modules/,  
                loader: &#39;babel-loader&#39;  
            },  
            {  
                test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,  
                loader: &#39;url-loader&#39;,  
                options: {  
                    limit: 8000,  
                    name: &#39;image/[name].[hash:7].[ext]&#39;  
                }  
            },  
            {  
                test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,  
                loader: &#39;url-loader&#39;,  
                options: {  
                    limit: 8000,  
                    name: &#39;font/[name].[hash:7].[ext]&#39;  
                }  
            },  
            // 手写一个简单的webpack loader  
            // 处理 .huangyb 后缀的文件  
            {  
                test: /\.huangyb$/,  
                loader: &#39;huangyb-loader&#39;  
            }  
        ]  
    },  
    plugins: [  
        // 生成html文件，里面的JS文件 src 地址自动添加hash  
        new HtmlWebpackPlugin({  
            title: &#39;huangyb&#39;,  
            favicon: &#39;./src/image/logoNew.gif&#39;,  
            filename: &#39;index.html&#39;,  
            minify:{  
                removeComments: true, // 删除注释  
                collapseWhitespace: true // 删除空格  
            }  
        }),  
        // CSS生成单独的文件  
        // new ExtractTextPlugin({  
        //     filename: &#39;css/[name][hash:8].css&#39;,  
        //     allChunks: true,  
        //     disable: false  
        // })  

        extractCSS,  
        extractLESS,  
        extractSASS,  

        // 用来跳过编译时出错的代码并记录，使编译后运行时的包不会发生错误  
        // * webpack3 NoEmitOnErrorsPlugin 已经 取代webpack 2 的 NoErrorsPlugin  
        new webpack.NoEmitOnErrorsPlugin(),  
        new FriendlyErrorsWebpackPlugin(), // 终端显示  

        new webpack.optimize.CommonsChunkPlugin({ // 提取公用JS代码插件  
            names: [&#39;vendor&#39;],  
            // ( 公共chunk(commnons chunk) 的名称)  
            filename: &#39;commons.js&#39;,  
            // ( 公共chunk 的文件名)  
            minChunks: 3  
            // (模块必须被3个 入口chunk 共享)  
            // CommonsChunkPlugin 可以通过传参minChunks来控制你希望重复出现几次的module 被提取出来打包。  
            // 也就是说你自己可以控制当一个模块被引入几次可以被打包到共用的chunk中，还可以规定如果这个公共模块小于一个值 minSize，  
            // 就不被提取出来这些都可以帮助你控制你想要的粒度。当你改的不是公共模块的代码，理论上webpack 打包的时候本来就不会影响其他代码。  
            // chunks: [&#39;pageA&#39;, &#39;pageB&#39;],  
            // (只使用这些 入口chunk)  
        }),  

        // OccurrenceOrderPlugin 现在默认启用，并已重命名（在 webpack 1 中为 OccurenceOrderPlugin）。 因此，请确保从您的配置中删除该插件：  
        // OccurrenceOrderPlugin is now on by default  
        // new webpack.optimize.OccurrenceOrderPlugin(),  
        new webpack.HotModuleReplacementPlugin()  
    ]  
    // resolve: {  
    //     alias: {  
    //         huangImg: path.resolve(__dirname, &#39;src/image/&#39;)  
    //     }  
    // }  
}  

module.exports = config;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*  
 * @Author: ignaciozhu  
 * @Date: 2017-05-03 16:32:21  
 * @Last Modified by: ignaciozhu  
 * @Last Modified time: 2017-06-02 11:50:06  
 */  
//配置本地反向代理文件夹所在路径  
const DIST = &#39;../../../ya/client_html/branch/nginx-1.10.1/&#39;;  
const path = require(&#39;path&#39;)  
const webpack = require(&#39;webpack&#39;)  
const HtmlWebpackPlugin = require(&amp;quot;html-webpack-plugin&amp;quot;) //自动生成一个html 引入打包之后的js  
const ExtractTextPlugin = require(&amp;quot;extract-text-webpack-plugin&amp;quot;) //默认打包css 这些全部在js 里面  用这个可以分离出来 单独生成css文件  //生产环节会用到  
const OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;) //打包完成自动打开浏览器  
const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;) //拷贝文件  当有第三方依赖可以copy到打包文件夹中  
const autoprefixer = require(&#39;autoprefixer&#39;) //自动加前缀  
const CptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;) //压缩css  
const ImageminPlugin = require(&#39;imagemin-webpack-plugin&#39;).default //压缩图片  
const { BundleAnalyzerPlugin } = require(&#39;webpack-bundle-analyzer&#39;) //生成打包图  
const UglifyJSPlugin = require(&#39;uglifyjs-webpack-plugin&#39;); //webpack3 单独分离出来了这个压缩的  

const { host, dev_port } = require(&amp;quot;./config&amp;quot;)  
const { delhttp } = require(&#39;./server/utils/method.js&#39;)  

module.exports = (env) =&amp;gt; {  
  //env 是npm script 运行webpack时传进来的  判断是否是开发环境  
  const mode = (env &amp;amp;&amp;amp; env.mode) || &amp;quot;DEV&amp;quot;  

  const options = {  
      //开发工具  
      devtool: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;source-map&amp;quot; : false,  

      //开发服务器  
      devServer: {  
        contentBase: path.resolve(__dirname, &amp;quot;dist&amp;quot;), //静态资源根目录  
        compress: true, //压缩  
        port: dev_port, //端口  
        host: delhttp(host),  
        hot: true, //热更新  
        inline: true, //iframe 模式  
        historyApiFallback: true, //浏览器 history  
        stats: { //统计  
          color: true, //输出有颜色的信息  
          errors: true, //显示错误信息  
          version: true, //显示版本号  
          warnings: true, //显示警告  
          progress: true, //显示进度,  
          timings: true, //显示时间  
        }  
      },  

      //入口  
      entry: mode === &amp;quot;DEV&amp;quot; ? [  
        &amp;quot;react-hot-loader/patch&amp;quot;, //热更新  
        `webpack-dev-server/client?${host}:${dev_port}`,  
        &amp;quot;webpack/hot/only-dev-server&amp;quot;,  
        path.resolve(__dirname, &amp;quot;src/index.js&amp;quot;),  
      ] : {  
        app: path.resolve(__dirname, &amp;quot;src/index.js&amp;quot;),  
        // vendor:[&#39;react&#39;]  
      },  

      //打包输出  
      output: {  
        path: path.resolve(__dirname, DIST + &amp;quot;dist&amp;quot;), ///myblog  
        filename: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;js/[name].js&amp;quot; : &amp;quot;./js/[name].[chunkhash:8].js&amp;quot;,  
        chunkFilename: mode === &amp;quot;DEV&amp;quot; ? &amp;quot;js/[name]Chunk.js&amp;quot; : &amp;quot;./js/[name]Chunk.[chunkhash:8].js&amp;quot;,  
        publicPath: mode === &amp;quot;DEV&amp;quot; ? `${host}:${dev_port}/` : &amp;quot;/&amp;quot; //myblog/  
      },  

      //模块加载器  
      module: {  
        rules: [{  
          test: /\.js[x]?$/,  
          use: [{  
            loader: &amp;quot;babel-loader&amp;quot;  
          }],  
          exclude: &amp;quot;/node_modules/&amp;quot;,  
          use: [  
            // {loader:&#39;react-hot-loader&#39;},  
            {  
              loader: &amp;quot;babel-loader&amp;quot;,  
              options: {  
                //按需加载模块，antd...  
                plugins: [  
                  [&amp;quot;import&amp;quot;, [{  
                    &amp;quot;libraryName&amp;quot;: &amp;quot;antd&amp;quot;,  
                    &amp;quot;libraryDirectory&amp;quot;: &amp;quot;lib&amp;quot;,  
                    &amp;quot;style&amp;quot;: true  
                  }, {  
                    &amp;quot;libraryName&amp;quot;: &amp;quot;antd-mobile&amp;quot;,  
                    &amp;quot;libraryDirectory&amp;quot;: &amp;quot;component&amp;quot;,  
                  }, ]],  
                  // &amp;quot;transform-decorators-legacy&amp;quot;,  
                  // &amp;quot;transform-class-properties&amp;quot;  
                ]  
              }  
            },  
          ],  
          include: [path.resolve(&amp;quot;src&amp;quot;)] //只遍历src目录下的  
        }, {  
          test: /\.less$/,  
          use: mode === &amp;quot;DEV&amp;quot; //开发环境 css打包到js中  
            ? [  
              { loader: &amp;quot;style-loader&amp;quot; }, //loader 倒序执行  先执行 less-laoder  
              { loader: &amp;quot;css-loader&amp;quot;, options: { minimize: false, sourceMap: true } },  
              { loader: &amp;quot;postcss-loader&amp;quot; }, //自动加前缀  
              { loader: &amp;quot;less-loader&amp;quot;, options: { sourceMap: true } }  
            ] : ExtractTextPlugin.extract({ //生产环境 把css单独分离出来  
              fallback: &amp;quot;style-loader&amp;quot;,  
              use: [  
                &amp;quot;css-loader&amp;quot;,  
                &amp;quot;postcss-loader&amp;quot;, {  
                  loader: &amp;quot;less-loader&amp;quot;,  
                  options: {  
                    sourceMap: false,  
                  },  
                },  
              ],  
            })  
        }, {  
          test: /\.css$/,  
          use: mode === &amp;quot;DEV&amp;quot; ? [  
            { loader: &amp;quot;style-loader&amp;quot; }, //loader 倒序执行  先执行 less-laoder  
            { loader: &amp;quot;css-loader&amp;quot;, options: { minimize: false, sourceMap: true } },  
            { loader: &amp;quot;postcss-loader&amp;quot; }  
          ] : ExtractTextPlugin.extract({  
            fallback: &amp;quot;style-loader&amp;quot;,  
            use: [  
              &amp;quot;css-loader&amp;quot;,  
              &amp;quot;postcss-loader&amp;quot;, {  
                loader: &amp;quot;less-loader&amp;quot;,  
                options: {  
                  sourceMap: false  
                },  
              },  
            ],  
          })  
        }, {  
          test: /\.(jpg|jpeg|png|gif|cur|ico)$/,  
          use: [{  
            loader: &#39;file-loader&#39;,  
            options: {  
              name: &amp;quot;images/[name][hash:8].[ext]&amp;quot; //遇到图片  生成一个images文件夹  名字.后缀的图片  
            }  
          }]  
        }, {  
          test: /\.(eot|ttf|svg|woff|woff2)$/,  
          use: [{  
            loader: &amp;quot;file-loader&amp;quot;,  
            options: {  
              name: &amp;quot;fonts/[name][hash:8].[ext]&amp;quot;,  
            },  
          }, ],  
        }, ]  
      },  

      //自动补全后缀  
      resolve: {  
        enforceExtension: false, //2.0 后 不能写 extensions :[&amp;quot;&amp;quot;]  
        extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.json&#39;], //比如 test.js   可以写成 require(&#39;test&#39;)  
        alias: {  
          // Support React Native Web  
          // https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/  
          &#39;react-native&#39;: &#39;react-native-web&#39;,  
          components: path.resolve(__dirname) + &#39;/src/common/components&#39;,  
          /* container: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/container&#39;,  
           images: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/images&#39;,  
           pages: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/pages&#39;,  
           utils: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/utils&#39;,  
           data: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/server/data&#39;,  
           actions: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/actions&#39;,  
           reducers: path.resolve(__dirname, &#39;..&#39;) + &#39;/src/common/reducers&#39;,*/  
        },  
        modules: [  
          path.resolve(&amp;quot;src&amp;quot;), //比如 src/app/components/xx  可以写成 app/components/xx  
          path.resolve(&amp;quot;.&amp;quot;),  
          path.resolve(&amp;quot;src/shared&amp;quot;),  
          &amp;quot;node_modules&amp;quot;,  
        ],  
      },  

      //插件  
      plugins: []  
    }  
    //根据开发环境不同  concat 不同的插件  
  if (mode === &amp;quot;DEV&amp;quot;) {  
    options.plugins = options.plugins.concat([  
      new webpack.NamedModulesPlugin(), //打印更具可读性模块名称在浏览器控制台  
      new webpack.NoEmitOnErrorsPlugin(), //错误不打断  
      new webpack.DefinePlugin({ //调试  
        __DEBUG__: true,  
      }),  
      new webpack.HotModuleReplacementPlugin(), //热加载插件  
      /*      new OpenBrowserPlugin({ //编译完成打开浏览器  
              url: `${host}:${dev_port}`  
            })*/  
    ])  
  } else {  
    options.plugins = options.plugins.concat([  
      // new BundleAnalyzerPlugin(),     //生成打包图  
      // //webpackv3.0新增 作用域提升 默认是闭包式打包 浏览器执行速度变慢  
      // //开启这个去掉模块的包裹函数,体积更小  
      // new webpack.optimize.ModuleConcatenationPlugin(),  
      new webpack.DefinePlugin({  
        &amp;quot;process.env.NODE_ENV&amp;quot;: JSON.stringify(&amp;quot;production&amp;quot;),  
        __DEBUG__: false,  
      }),  
      new UglifyJSPlugin({ //压缩  
        output: {  
          comments: false //移除所有注释  
        },  
        compress: {  
          warnings: false  
        }  
      }),  
      new ExtractTextPlugin({ // 将打包文件中的css分离成一个单独的css文件  
        filename: &#39;css/app.[contenthash:8].css&#39;,  
        allChunks: true  
      }),  
      //[1]  
      //找到所有node_modules的依赖包  分离出来  
      // /axios/ 没有用到的模块  
      new webpack.optimize.CommonsChunkPlugin({  
        name: &amp;quot;app&amp;quot;,  
        async: &amp;quot;common-in-lazy&amp;quot;,  
        children: true,  
        minChunks: ({ resource } = {}) =&amp;gt; (  
          resource &amp;amp;&amp;amp;  
          resource.includes(&#39;node_modules&#39;) &amp;amp;&amp;amp;  
          /axios/.test(resource)  
        )  
      }),  
      // [2]  
      //找到模块次数使用两次的  分离出来  
      //单独打成used-twice.js 减少包的体积  
      /**  
       * 升级到 v2.6 貌似async不起作用  article admin detail 都使用了但是moment都打包进了对应的chunk文件  
       * 导致文件增大了600kb  
       * 经过github上的提问 各路大神的帮助下  解决了上面这个问题 需要设置name!!!!!!!!!!!  
       */  
      new webpack.optimize.CommonsChunkPlugin({  
        name: &amp;quot;app&amp;quot;,  
        children: true,  
        async: &#39;used-twice&#39;,  
        minChunks: (module, count) =&amp;gt; (  
          count &amp;gt;= 2  
        ),  
      }),  
      //[3]  
      //[1][2][3] 是按需加载 大幅减少打包js体积的关键  
      //遍历node_modules目录 以.js结尾 一道vender chunk  
      //自动化分离第三方依赖  
      new webpack.optimize.CommonsChunkPlugin({  
        name: &#39;app&#39;,  
        filename: &amp;quot;js/common.[chunkhash:8].js&amp;quot;,  
        minChunks: ({ resource }) =&amp;gt; (  
          resource &amp;amp;&amp;amp;  
          resource.indexOf(&#39;node_modules&#39;) &amp;gt;= 0 &amp;amp;&amp;amp;  
          resource.match(/\.js$/)  
        )  
      }),  
      new webpack.LoaderOptionsPlugin({ //laoder最小化  
        minimize: true  
      }),  
      //图片压缩没用。。。什么鬼  
      new ImageminPlugin({  
        // disable:false,  
        test: /\.(jpe?g|png|gif|svg)$/i,  
        optipng: {  
          optimizationLevel: 7  
        }  
      }),  
      new CptimizeCssAssetsPlugin({ //压缩css  与 ExtractTextPlugin 配合使用  
        cssProcessor: require(&#39;cssnano&#39;),  
        cssProcessorOptions: { discardComments: { removeAll: true } }, //移除所有注释  
        canPrint: true //是否向控制台打印消息  
      })  
    ])  
  }  
  options.plugins.push(  
    new HtmlWebpackPlugin({  
      title: &amp;quot;西溪泊岸共享&amp;quot;,  
      filename: &amp;quot;index.html&amp;quot;, //自动把打包的js文件引入进去  
      template: path.resolve(__dirname, &amp;quot;src/index.html&amp;quot;), //模板文件  
      hash: true, //添加hash码  
      inject: true //注射所有资源到 body元素的底部     &amp;quot;head&amp;quot; &amp;quot;body&amp;quot; true false  &amp;quot;body&amp;quot; == true  
    })  
  )  
  return options  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>MySQL性能优化最佳实践 - 12 MySQL性能优化的最佳20&#43;条经验</title>
            <link>http://blog.pytool.com/post/db/mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/12-mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
            <pubDate>Tue, 05 Dec 2017 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/db/mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/12-mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
            <description>

&lt;p&gt;本章有部分内容与《&lt;a href=&#34;http://blog.pytool.com/2017/11/09/mysql/MySQL-性能优化最佳实践课程学习/10-MySQL-性能优化最佳实践/&#34;&gt;MySQL性能优化最佳实践 - 10 MySQL写出高效SQL&lt;/a&gt;》互为补充。&lt;/p&gt;

&lt;h2 id=&#34;从程序员的角度优化&#34;&gt;从程序员的角度优化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数据库的操作越来越成为整个应的的性能瓶颈，这点对于WEB应用尤其明显。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关于数据库性能，这不只是DBA才需要担心的事，更是程序员需要去关注的事情。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当设计表结构和操作数据库（DML操作）时，需要注意数据操作的性能。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;为查询缓存优化你的查询&#34;&gt;为查询缓存优化你的查询&lt;/h3&gt;

&lt;p&gt;大多数的MySQL服务器都开启了查询缓存&lt;/p&gt;

&lt;h3 id=&#34;explain-你的select-查询&#34;&gt;EXPLAIN 你的SELECT 查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的等等。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当我们为group_id字段加上索引后：我们可以看到，前一个结果显示搜索了7883 行，而后一个只是搜索了两个表的9 和16 行。查看rows列可以让我们找到潜在的性能问题。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;  

&lt;h3 id=&#34;当只要一行数据时使用limit-1&#34;&gt;当只要一行数据时使用LIMIT 1&lt;/h3&gt;

&lt;h3 id=&#34;为搜索字段建索引&#34;&gt;为搜索字段建索引&lt;/h3&gt;

&lt;h3 id=&#34;在join表的时候使用相当类型的例-并将其索引&#34;&gt;在Join表的时候使用相当类型的例，并将其索引&lt;/h3&gt;

&lt;h3 id=&#34;千万不要order-by-rand&#34;&gt;千万不要ORDER BY RAND()&lt;/h3&gt;

&lt;h3 id=&#34;避免select&#34;&gt;避免SELECT *&lt;/h3&gt;

&lt;h3 id=&#34;永远为每张表设置一个id&#34;&gt;永远为每张表设置一个ID&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;就算是你users 表有一个主键叫“email”的字段，你也别让它成为主键。使用VARCHAR类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用enum-而不是varchar&#34;&gt;使用ENUM 而不是VARCHAR&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ENUM 类型是非常快和紧凑的。在实际上，其保存的是TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM 而不是VARCHAR。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个VARCHAR 字段时，这个建议会告诉你把其改成ENUM类型。使用PROCEDURE ANALYSE() 你可以得到相关的建议。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;从procedure-analyse-取得建议&#34;&gt;从PROCEDURE ANALYSE() 取得建议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;PROCEDURE ANALYSE()会让MySQL帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;例如，如果你创建了一个INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成MEDIUMINT 。或是你使用了一个VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成ENUM的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在phpmyadmin里，你可以在查看表时，点击“Propose table structure” 来查看这些建议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;尽可能的使用not-null&#34;&gt;尽可能的使用NOT NULL&lt;/h3&gt;

&lt;h3 id=&#34;prepared-statements&#34;&gt;Prepared Statements&lt;/h3&gt;

&lt;h3 id=&#34;无缓冲的查询&#34;&gt;无缓冲的查询&lt;/h3&gt;

&lt;h3 id=&#34;把ip地址存成unsigned-int&#34;&gt;把IP地址存成UNSIGNED INT&lt;/h3&gt;

&lt;h3 id=&#34;固定长度的表会更快&#34;&gt;固定长度的表会更快&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果表中的所有字段都是“固定长度”的，整个表会被认为是“static” 或“fixed-length”。例如，表中没有如下类型的字段：VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL引擎会用另一种方法来处理。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;垂直分割&#34;&gt;垂直分割&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;示例二：你有一个叫“last_login”的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;拆分大的delete-或insert-语句&#34;&gt;拆分大的DELETE 或INSERT 语句&lt;/h3&gt;

&lt;h3 id=&#34;越小的列会越快&#34;&gt;越小的列会越快&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;参看MySQL 的文档Storage Requirements 查看所有的数据类型。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用INT 来做主键，使用MEDIUMINT, SMALLINT 或是更小的TINYINT 会更经济一些。如果你不需要记录时间，使用DATE 要比DATETIME 好得多。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;选择正确的存储引擎&#34;&gt;选择正确的存储引擎&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在MySQL 中有两个存储引擎MyISAM和InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB还是MyISAM?》讨论和这个事情。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;MyISAM适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM对于SELECT COUNT(*) 这类的计算是超快无比的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;InnoDB的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比MyISAM还慢。他是它支持“行锁”，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如事务。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用一个对象关系映射器-object-relational-mapper&#34;&gt;使用一个对象关系映射器（Object Relational Mapper）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用ORM (Object Relational&lt;br /&gt;
Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ORM 的最重要的是“LazyLoading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;小心-永久链接&#34;&gt;小心“永久链接”&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的MySQL 链接。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;而且，Apache运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>MySQL性能优化最佳实践 - 10 MySQL写出高效SQL</title>
            <link>http://blog.pytool.com/post/db/mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/10-mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
            <pubDate>Thu, 09 Nov 2017 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/db/mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/10-mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
            <description>

&lt;h2 id=&#34;mysql设计标准&#34;&gt;MySQL设计标准&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;数据库命名规范、统一，如vip_xxxx&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;表一旦设计好，字段只允许增加，不允许减少(drop column)&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;统一使用INNODB存储引擎，UTF8编码（整个数据库的编码统一为&lt;code&gt;utf8_general_ci&lt;/code&gt;，为此不需要建立表的DDL上加上&lt;code&gt;CHARACTER SET COLLATE utf8_general_ci）&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;需在设计阶段考虑如果访问量非常大，且不做&lt;code&gt;scale out(横向扩展)&lt;/code&gt;表拆分的话，需读写分离，但读写分离注意主从复制有延迟的可能性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;禁用&lt;/font&gt;&lt;/strong&gt;stored procedure(包括存储过程，函数，触发器)，容易将业务逻辑和DB耦合在一起，并且MySQL的存储过程、触发器、函数中存在一定的bug&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;禁止使用&lt;/font&gt;&lt;/strong&gt;&lt;code&gt;UUID()&lt;/code&gt;，&lt;code&gt;USER()&lt;/code&gt;这样的&lt;code&gt;MYSQL INSIDE&lt;/code&gt;函数，对于复制来说是很危险的，会导致主备数据不一致，重要的是会严重影响mysql性能&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;表必须有主键，建议统一由&lt;code&gt;auto_increment&lt;/code&gt;字段生成整型，不建议使用组合主键， &lt;strong&gt;&lt;font color=red&gt;另外&lt;code&gt;auto_increment&lt;/code&gt;主键字段只作为虚拟主键，不建议与业务数据处理有关联关系，如果把控不好，会有问题&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;库名、表名、字段名、索引名必须使用小写字母&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;多表join写SQL的时候，一定要给每个字段指定表名做前缀&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果应用使用的是长连接，应用必须具有自动重连的机制。但需避免每执行一个SQL去检查一次DB可用性&lt;br /&gt;
&lt;!-- more --&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果应用使用的是长连接，应用应该具有连接的TIMEOUT检查机制，及时回收长时间没有使用的连接，TIMEOUNT时间一般建议为20min&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE，DECIMAL类型具有更高的精度和更小的范围，它适合于财务和货币计算，如金额等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;表名、列名必须有注释（必须加上&lt;code&gt;COMMENT &#39;&amp;lt;字段扼要解说&amp;gt;&#39;&lt;/code&gt;），表结构变更须由库表OWNER所在团队发起&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SQL语句必须采用&lt;code&gt;PreparedStatement&lt;/code&gt;技术，可以提升性能并且避免SQL注入，如果编程语言不支持&lt;code&gt;PreparedStatement&lt;/code&gt;技术，需要做好特殊字符过滤，如不要前后有空串等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;尽可能不要使用TEXT、BLOB、CHAR字段类型，请使用&lt;code&gt;VARCHAR(N)&lt;/code&gt;，N表示的是字符数不是字节数，比如&lt;code&gt;VARCHAR(255)&lt;/code&gt;，可以最大存储255个汉字，需要根据实际宽度来设置N，&lt;strong&gt;&lt;font color=red&gt;请注意同一表中，所有VARCHAR字段的长度加起来，不能大于65535&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每张表数据量建议控制在千万级别行以下，为此设计阶段需要考虑数据的归档&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果字段只有&lt;code&gt;ture or false&lt;/code&gt;，请使用tinyint(数值范围-128～127)，如果模块分类：1订单/2商品；删除标示：0正常/1删除&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4个字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每个字段的默认值不能用NULL，禁止&lt;code&gt;default NULL&lt;/code&gt;，数据类型用&lt;code&gt;default 0&lt;/code&gt;，字符类型用&lt;code&gt;default &#39;&#39;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;关键业务数据表，建议用&lt;code&gt;create_time&lt;/code&gt;和&lt;code&gt;last_update_time&lt;/code&gt;，方便后期数据分析，如订单表，库存表&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;关键业务数据表，如订单表、用户信息表，钱包支付信息等，禁止硬删除，必须软删除，加上&lt;code&gt;is_deleted&lt;/code&gt;字段，标注这条记录的状态&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;避免使用&lt;/font&gt;&lt;/strong&gt;&lt;code&gt;select col1,col2 from table where id in (select col from table) 这样的子查询&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;需要多表join的字段(&lt;strong&gt;&lt;font color=red&gt;尽量避免多于两表join&lt;/font&gt;&lt;/strong&gt;)，数据类型保持一致&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;加字段禁止使用after，因为不能确定全局代码里面是否都采用了类似&lt;code&gt;insert into table(col,col,col...) values ....&lt;/code&gt;，若中间插一个字段，就会导致数据偏移的问题，影响可大可小，同样&lt;code&gt;select *&lt;/code&gt;的也可能会影响数值的偏移&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;font color=red&gt;生产环境中，MySQL忽略大小写，配置了&lt;code&gt;lower_case_table_names=1&lt;/code&gt;&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;select语句只获取需要的字段，禁止使用select * from语句，这是有效防止新增字段对应用逻辑的影响，还能减少对性能的影响&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;INSERT语句必须显式的指明字段名称，不使用INSERT INTO table values()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;禁止在where子句中对字段施加函数，如to_date(add_time)&amp;gt;xxxxx，应改为add_time&amp;gt;=unix_timestamp(date_add(str_to_date(&amp;lsquo;20171109&amp;rsquo;,&amp;lsquo;%Y%m%d&amp;rsquo;),interval-29 day))&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;where条件中必须使用合适的类型，避免MySOL进行隐式类型转化，如ISENDED=1，字段类型是tinyint，则不能写成ISENDED=&amp;lsquo;1&amp;rsquo;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应用程序里的SQL语句，禁止一切DDL操作，如有特殊需要需与DBA协商，同意后方可使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;避免在SQL语句进行数学运算或函数运算，容易将业务逻辑和DB耦合在一起&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;INSERT语句使用batch提交&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;INNODB表避免使用count(*)操作，计数统计实时要求较强可以使用memcache或redis，非实时统计可以使用单独统计表，定时更新&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用%前缀模糊查询将不走索引，例如LIKE &amp;lsquo;%weibo&amp;rsquo;，不建议使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;避免多余的排序，使用group by时，默认会进行排序，当不需要排序时，可以使用order by null&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不鼓励在数据库里排序，行数小的，建议放在应用服务上排序&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;事务的处理标准&#34;&gt;事务的处理标准&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;一个事务，处理的行数不能超过1000 rows/s，超出会导致主从复制延迟的问题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;禁止一些框架或定制化的底层类等使用&lt;code&gt;set autocommit=0;&lt;/code&gt;、&lt;code&gt;set autocommit=1;&lt;/code&gt;这样控制事务，应该由程序把控，需要时&lt;code&gt;begin;&lt;/code&gt;，操作完后及时&lt;code&gt;commit;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;索引使用标准&#34;&gt;索引使用标准&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;非唯一索引建议使用&lt;code&gt;idx_表缩写名称_字段缩写名称&lt;/code&gt;进行命名&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;唯一索引建议使用&lt;code&gt;uniq_表缩写名称_字段缩写名称&lt;/code&gt;进行命名&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;索引名称必须使用小写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;唯一键不和主键重复&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;索引字段的顺序需要考虑字段去重之后的个数，个数多的放在前面，就是数据分布&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用EXPLAIN判断SQL语句是否合理的使用索引，尽量避免extra列出现：&lt;code&gt;Using File Sort&lt;/code&gt;，&lt;code&gt;Using Temporary&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;UPDATE、DELETE语句需要根据WHERE条件添加索引&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;合理创建联合索引（避免冗余），&lt;code&gt;(a,b,c)&lt;/code&gt;相当于&lt;code&gt;(a)&lt;/code&gt;、&lt;code&gt;(a,b)&lt;/code&gt;、&lt;code&gt;(a,b,c)&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;合理利用覆盖索引（三星索引），如&lt;code&gt;select emain,uid from user_email where uid=xx&lt;/code&gt;，如果uid不是主键，适当时候可以添加&lt;code&gt;(uid,email)&lt;/code&gt;覆盖索引，以获得性能提升&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;约束设计&#34;&gt;约束设计&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;主键的内容不能被修改&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;禁用外键约束，外键约束一般不在数据库上创建，只表达一个逻辑的概念，由程序控制&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;unique约束命名&lt;code&gt;UK_列名&lt;/code&gt;，check约束命名&lt;code&gt;CK_列名&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;怎么写出高效sql&#34;&gt;怎么写出高效SQL&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;清晰无误的了知业务需求&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;满足业务需求，不做无用功&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;知道表数据量和索引基本情况&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;知道完成SQL需要扫描的数据量级&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SQL执行计划OK？SQL性能达到要求？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;调整索引和SQL，优化SQL&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;关于in子查询&#34;&gt;关于IN子查询&lt;/h2&gt;

&lt;p&gt;IN子查询容易导致问题，禁止使用，需改成join&lt;br /&gt;
1. in子查询包含group by，外部查询的值传不到in子查询中，会导致in子查询效率低下&lt;br /&gt;
2. 外部查询传入到in子查询中的值没法利用索引时，会导致in子查询效率低下&lt;br /&gt;
3. in子查询总是返回单个值时，用=，=和in处理机制不同&lt;br /&gt;
4. 多个filter类子查询，一般在SQL后面的先执行&lt;/p&gt;

&lt;h2 id=&#34;选择正确的驱动表&#34;&gt;选择正确的驱动表&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;多表关联查询，选择正确驱动表是最重要一步,好的开始是成功的一半&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;驱动表不一定是小表；表大，但过滤条件很强，能快速减少关联中间结果也可以选为驱动表&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;access vs filter&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关联字段需建索引&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;作业&#34;&gt;作业&lt;/h2&gt;

&lt;h3 id=&#34;为什么使用prepared-statement能提高性能&#34;&gt;为什么使用prepared statement能提高性能？&lt;/h3&gt;

&lt;p&gt;Statement主要用于执行静态SQL语句，即内容固定不变的SQL语句。Statement每执行一次都要对传入的SQL语句编译一次，效率较差。&lt;/p&gt;

&lt;p&gt;PreparedStatement是Statement的子类，表示预编译的SQL语句的对象。在使用PreparedStatement对象执行SQL命令时，命令被数据库编译和解析，并放入命令缓冲区。缓冲区中的预编译SQL命令可以重复使用。&lt;/p&gt;

&lt;p&gt;使用PreparedStatement时，SQL语句已提前编译，三种常用方法&lt;code&gt;execute&lt;/code&gt;、&lt;code&gt;executeQuery&lt;/code&gt;和&lt;code&gt;executeUpdate&lt;/code&gt;已被更改，以使之不再需要参数。PreparedStatement 实例包含已事先编译的SQL语句，SQL语句可有一个或多个IN参数，IN参数的值在SQL语句创建时未被指定。该语句为每个IN留一个问号（“？”）作为占位符。 每个问号的值必须在该语句执行之前，通过适当的setInt或者setString 等方法提供。由于 PreparedStatement 对象已预编译过，所以其执行速度要快于Statement 对象。因此，多次执行的 SQL 语句经常创建为PreparedStatement 对象，以提高效率。&lt;/p&gt;

&lt;p&gt;PreparedStatement的另外一个好处就是预防sql注入攻击。对JDBC而言，SQL注入攻击对PreparedStatement无效，因为PreparedStatement不允许在插入参数时改变SQL语句的逻辑结构。&lt;/p&gt;

&lt;h3 id=&#34;mysql优化的一般步骤是什么-举个例子详细说明&#34;&gt;MySql优化的一般步骤是什么？举个例子详细说明。&lt;/h3&gt;

&lt;h4 id=&#34;通过-show-status-命令了解各种sql的执行效率&#34;&gt;通过&lt;code&gt;show status&lt;/code&gt;命令了解各种sql的执行效率&lt;/h4&gt;

&lt;p&gt;通过SHOW STATUS可以提供服务器状态信息，也可以使用mysqladmin extended-status命令获得。SHOW STATUS可以根据需要显示session级别的统计结果和global级别的统计结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;# 以下几个参数对Myisam和Innodb存储引擎都计数  
Com_select  执行select操作的次数，一次查询只累加1  
Com_insert  执行insert操作的次数，对于批量插入的insert操作，只累加一次  
Com_update  执行update操作的次数  
Com_delete　执行delete操作的次数  

# 以下几个参数是针对Innodb存储引擎计数的，累加的算法也略有不同  
Innodb_rows_read　   select查询返回的行数  
Innodb_rows_inserted 执行insert操作插入的行数  
Innodb_rows_updated  执行update操作更新的行数  
Innodb_rows_deleted　执行delete操作删除的行数  

# 以下几个参数便于了解数据库的基本情况  
Connections  试图连接Mysql服务器的次数  
Uptime　     服务器工作时间  
Slow_queries 慢查询的次数  

# 对于事务型的应用，通过Com_commit和Com_rollback可以了解事务提交和回滚的情况  
# 对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;定位执行效率较低的sql语句&#34;&gt;定位执行效率较低的SQL语句&lt;/h4&gt;

&lt;p&gt;可以通过以下两种方式定位执行效率较低的SQL语句：&lt;br /&gt;
1. 可以通过慢查询日志定位那些执行效率较低的sql语句，用&lt;code&gt;--log-slow-queries[=file_name]&lt;/code&gt;选项启动时，mysqld写一个包含所有执行时间超过&lt;code&gt;long_query_time&lt;/code&gt;秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。&lt;br /&gt;
2. 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用&lt;code&gt;show processlist&lt;/code&gt;命令查看当前MySQL在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看SQL执行情况，同时对一些锁表操作进行优化&lt;/p&gt;

&lt;h4 id=&#34;通过explain分析低效率的sql语句的执行情况&#34;&gt;通过explain分析低效率的SQL语句的执行情况&lt;/h4&gt;

&lt;p&gt;通过以上步骤查询到效率低的SQL后，可以通过explain或者desc获取MySQL如何执行SELECT语句的信息，包括select语句执行过程表如何连接和连接的次序。&lt;br /&gt;
执行计划说明：&lt;br /&gt;
&amp;gt;select_type：select类型&lt;br /&gt;
&amp;gt;table：输出结果集的表&lt;br /&gt;
&amp;gt;type：表示表的连接类型&lt;br /&gt;
&amp;gt;　　1. 当表中仅有一行是type的值为system是最佳的连接类型；&lt;br /&gt;
&amp;gt;　　2. 当select操作中使用索引进行表连接时type的值为ref；&lt;br /&gt;
&amp;gt;　　3. 当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。&lt;br /&gt;
&amp;gt;possible_keys：表示查询时,可以使用的索引列.&lt;br /&gt;
&amp;gt;key：表示使用的索引&lt;br /&gt;
&amp;gt;key_len：索引长度&lt;br /&gt;
&amp;gt;rows：扫描范围&lt;br /&gt;
&amp;gt;Extra：执行情况的说明和描述&lt;/p&gt;

&lt;h4 id=&#34;确定问题-并采取相应的优化措施&#34;&gt;确定问题，并采取相应的优化措施&lt;/h4&gt;

&lt;p&gt;确认问题出现的原因后，可以根据情况采取相应的措施，进行优化提高执行的效率。 示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;mysql&amp;gt; explain select e.emp_no,e.first_name,e.last_name,e.hire_date,d.dept_no from employees e,dept_emp d  
       where d.emp_no=e.emp_no and d.dept_no=&#39;d005&#39;;  
+----+-------------+-------+--------+---------------+---------+---------+--------------------+--------+-------------+  
| id | select_type | table | type   | possible_keys | key     | key_len | ref                | rows   | Extra       |  
+----+-------------+-------+--------+---------------+---------+---------+--------------------+--------+-------------+  
|  1 | SIMPLE      | d     | ALL    | NULL          | NULL    | NULL    | NULL               | 331290 | Using where |  
|  1 | SIMPLE      | e     | eq_ref | PRIMARY       | PRIMARY | 4       | employees.d.emp_no |      1 | NULL        |  
+----+-------------+-------+--------+---------------+---------+---------+--------------------+--------+-------------+  

# 这个例子，对表dept_emp全表扫描，效果不理想，对d表的dept_no字段创建了索引，查询需要扫描的行数明显较少  
create index idx_dept_emp_dn on dept_emp(dept_no);  

mysql&amp;gt; explain select e.emp_no,e.first_name,e.last_name,e.hire_date,d.dept_no from employees e,dept_emp d  
       where d.emp_no=e.emp_no and d.dept_no=&#39;d005&#39;;  
+----+-------------+-------+--------+-----------------+-----------------+---------+--------------------+--------+-----------------------+  
| id | select_type | table | type   | possible_keys   | key             | key_len | ref                | rows   | Extra                 |  
+----+-------------+-------+--------+-----------------+-----------------+---------+--------------------+--------+-----------------------+  
|  1 | SIMPLE      | d     | ref    | idx_dept_emp_dn | idx_dept_emp_dn | 12      | const              | 164256 | Using index condition |  
|  1 | SIMPLE      | e     | eq_ref | PRIMARY         | PRIMARY         | 4       | employees.d.emp_no |      1 | NULL                  |  
+----+-------------+-------+--------+-----------------+-----------------+---------+--------------------+--------+-----------------------+  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql-这该死的-in-子查询-如下sql怎么优化-in-子查询&#34;&gt;MySQL 这该死的 “IN (子查询)”，如下SQL怎么优化 “in(子查询)”？&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;# 优化前  
SELECT s1 FROM t1 WHERE s1 IN (SELECT s1 FROM t2 WHERE id = 1);  

# 优化后  
SELECT s1 from t1 a,(SELECT s1 FROM t2 WHERE id = 1) b where a.s1=b.s1;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;# 这是一个简单的示例，每1000个语句为一批插入提交，它避免了SQL注入和内存不足的问题  
# 插入到数据库使用批处理上万条记录，有可能产生的OutOfMemoryError  
import java.sql.Connection;  
import java.sql.PreparedStatement;  
...  
String sql = &amp;quot;insert into employee (name, city, phone) values (?, ?, ?)&amp;quot;;  
Connection connection = new getConnection();  
PreparedStatement ps = connection.prepareStatement(sql);  
final int batchSize = 1000;  
int count = 0;  
for (Employee employee: employees) {  
    ps.setString(1, employee.getName());  
    ps.setString(2, employee.getCity());  
    ps.setString(3, employee.getPhone());  
    ps.addBatch();  
    if(++count % batchSize == 0) {  
        ps.executeBatch();  
    }  
}  
ps.executeBatch(); // insert remaining records  
ps.close();  
connection.close();  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>MySQL性能优化最佳实践 - 11 MySQL锁优化分析</title>
            <link>http://blog.pytool.com/post/db/mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/11-mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
            <pubDate>Thu, 09 Nov 2017 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/db/mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/11-mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
            <description>

&lt;h2 id=&#34;不同索引加锁顺序的问题-模拟重现死锁&#34;&gt;不同索引加锁顺序的问题，模拟重现死锁&lt;/h2&gt;

&lt;p&gt;走索引的SQL语句，会涉及两把锁，在特定场景下就会产生交差锁等待&lt;/p&gt;

&lt;h3 id=&#34;测试表结构及相关语句&#34;&gt;测试表结构及相关语句&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;mysql&amp;gt; show create table employees\G;  
*************************** 1. row ***************************  
       Table: employees  
Create Table: CREATE TABLE `employees` (  
  `emp_no` int(11) NOT NULL,  
  `birth_date` date NOT NULL,  
  `first_name` varchar(14) NOT NULL,  
  `last_name` varchar(16) NOT NULL,  
  `gender` enum(&#39;M&#39;,&#39;F&#39;) NOT NULL,  
  `hire_date` date NOT NULL,  
  `base_salaries` decimal(8,2) NOT NULL,  
  `id` int(11) NOT NULL AUTO_INCREMENT,  
  PRIMARY KEY (`id`),  
  KEY `idx_emp_hire` (`hire_date`),  
  KEY `idx_emp_no` (`emp_no`)  
) ENGINE=InnoDB AUTO_INCREMENT=300151 DEFAULT CHARSET=utf8  

alter table employees drop primary key;  
create index idx_emp_no on employees(emp_no);  
alter table employees add id int;  
alter table employees change id id int not null auto_increment primary key;  
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;  

&lt;h3 id=&#34;模拟重现死锁&#34;&gt;模拟重现死锁&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;# 打开两个会话  
# 1. 会话1  
mysql&amp;gt; start transaction;  
mysql&amp;gt; select * from employees where emp_no=99075 for update;  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  
| emp_no | birth_date | first_name | last_name | gender | hire_date  | base_salaries | id    |  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  
|  99075 | 1961-08-14 | Filipp     | Covnot    | M      | 1999-01-02 |          0.00 | 89075 |  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  

mysql&amp;gt; explain select * from employees where emp_no=99075;  
+----+-------------+-----------+------+---------------+------------+---------+-------+------+-------+  
| id | select_type | table     | type | possible_keys | key        | key_len | ref   | rows | Extra |  
+----+-------------+-----------+------+---------------+------------+---------+-------+------+-------+  
|  1 | SIMPLE      | employees | ref  | idx_emp_no    | idx_emp_no | 4       | const |    1 | NULL  |  
+----+-------------+-----------+------+---------------+------------+---------+-------+------+-------+  

# 2. 会话2  
mysql&amp;gt; start transaction;  
mysql&amp;gt; select * from employees where emp_no=108961 for update;  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  
| emp_no | birth_date | first_name | last_name | gender | hire_date  | base_salaries | id    |  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  
| 108961 | 1962-11-13 | Jianhua    | Piveteau  | F      | 1999-01-02 |       1000.00 | 98961 |  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  

# 3. 会话1  
mysql&amp;gt; update employees set base_salaries=base_salaries+1000 where emp_no=108961;  
## 这时会产生锁等待，新开一个会话可以查看锁的状态  
mysql&amp;gt; select * from information_schema.innodb_locks;  
+--------------------+-------------+-----------+-----------+-------------------------+------------+------------+-----------+----------+---------------+  
| lock_id            | lock_trx_id | lock_mode | lock_type | lock_table              | lock_index | lock_space | lock_page | lock_rec | lock_data     |  
+--------------------+-------------+-----------+-----------+-------------------------+------------+------------+-----------+----------+---------------+  
| 26909:208:1522:918 | 26909       | X         | RECORD    | `employees`.`employees` | idx_emp_no |        208 |      1522 |      918 | 108961, 98961 |  
| 26910:208:1522:918 | 26910       | X         | RECORD    | `employees`.`employees` | idx_emp_no |        208 |      1522 |      918 | 108961, 98961 |  
+--------------------+-------------+-----------+-----------+-------------------------+------------+------------+-----------+----------+---------------+  

# 4. 会话2  
mysql&amp;gt; update employees set base_salaries=base_salaries+1000 where emp_no=99075;  
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction  
## 产生死锁  

# 5. 会话1  
mysql&amp;gt; update employees set base_salaries=base_salaries+1000 where emp_no=108961;  
Query OK, 1 row affected (29.87 sec)  
Rows matched: 1  Changed: 1  Warnings: 0  
## 解锁，update语句执行成功  
mysql&amp;gt; select * from employees where emp_no=108961;  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  
| emp_no | birth_date | first_name | last_name | gender | hire_date  | base_salaries | id    |  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  
| 108961 | 1962-11-13 | Jianhua    | Piveteau  | F      | 1999-01-02 |       2000.00 | 98961 |  
+--------+------------+------------+-----------+--------+------------+---------------+-------+  

# 6. 在新开会话中查看最后一次死锁信息  
mysql&amp;gt; show engine innodb status\G;  
*************************** 1. row ***************************  
  Type: InnoDB  
  Name:  
Status:  
....  

------------------------  
LATEST DETECTED DEADLOCK  
------------------------  
2017-11-21 16:46:52 7fc588cb9700  
*** (1) TRANSACTION:  
TRANSACTION 26909, ACTIVE 71 sec starting index read  
mysql tables in use 1, locked 1  
LOCK WAIT 4 lock struct(s), heap size 1184, 3 row lock(s)  
MySQL thread id 157583, OS thread handle 0x7fc588c78700, query id 2221313 localhost root updating  
update employees set base_salaries=base_salaries+1000 where emp_no=108961  
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:  
RECORD LOCKS space id 208 page no 1522 n bits 1272 index `idx_emp_no` of table `employees`.`employees` trx id 26909 lock_mode X locks rec but not gap waiting  
Record lock, heap no 918 PHYSICAL RECORD: n_fields 2; compact format; info bits 0  
 0: len 4; hex 8001a9a1; asc     ;;  
 1: len 4; hex 80018291; asc     ;;  

*** (2) TRANSACTION:  
TRANSACTION 26910, ACTIVE 32 sec starting index read  
mysql tables in use 1, locked 1  
4 lock struct(s), heap size 1184, 3 row lock(s)  
MySQL thread id 157584, OS thread handle 0x7fc588cb9700, query id 2221315 localhost root updating  
update employees set base_salaries=base_salaries+1000 where emp_no=99075  
*** (2) HOLDS THE LOCK(S):  
RECORD LOCKS space id 208 page no 1522 n bits 1272 index `idx_emp_no` of table `employees`.`employees` trx id 26910 lock_mode X locks rec but not gap  
Record lock, heap no 918 PHYSICAL RECORD: n_fields 2; compact format; info bits 0  
 0: len 4; hex 8001a9a1; asc     ;;  
 1: len 4; hex 80018291; asc     ;;  

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:  
RECORD LOCKS space id 208 page no 1514 n bits 1272 index `idx_emp_no` of table `employees`.`employees` trx id 26910 lock_mode X locks rec but not gap waiting  
Record lock, heap no 656 PHYSICAL RECORD: n_fields 2; compact format; info bits 0  
 0: len 4; hex 80018303; asc     ;;  
 1: len 4; hex 80015bf3; asc   [ ;;  
......  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tms死锁分析和处理-模拟重现死锁&#34;&gt;TMS死锁分析和处理，模拟重现死锁&lt;/h2&gt;

&lt;p&gt;重现死锁&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;show variables like &#39;%isolation%&#39;;  
+---------------+-----------------+  
| Variable_name | Value           |  
+---------------+-----------------+  
| tx_isolation  | REPEATABLE-READ |  
+---------------+-----------------+  

show variables like &#39;%lock_wait%&#39;;  
+--------------------------+----------+  
| Variable_name            | Value    |  
+--------------------------+----------+  
| innodb_lock_wait_timeout | 20       |  
| lock_wait_timeout        | 31536000 |  
+--------------------------+----------+  

show variables like &#39;%autocommit%&#39;;  
+---------------+-------+  
| Variable_name | Value |  
+---------------+-------+  
| autocommit    | OFF   |  
+---------------+-------+  

# 会话1  
use lyj  
create table t2 (  
    a int not null default 0,  
    b int default null,  
    primary key (a));  

insert into t2 (a,b) values(2,2);  
insert into t2 (a,b) values(3,3);  
insert into t2 (a,b) values(4,4);  
commit;  
select * from t2;  
+---+------+  
| a | b    |  
+---+------+  
| 2 |    2 |  
| 3 |    3 |  
| 4 |    4 |  
+---+------+  

# 下面为了方便区分，将提示符加上时间显示  
## 启动mysql时添加 --prompt=&amp;quot;\\u@\\h:\\d \\r:\\m:\\s&amp;gt; &amp;quot;  
root@localhost:lyj 10:35:42&amp;gt; insert into t2 (a,b) values(5,5);  
Query OK, 1 row affected (0.00 sec)  

# 会话2  
root@localhost:lyj 10:35:37&amp;gt; use lyj  
Database changed  
root@localhost:lyj 10:36:30&amp;gt; select * from t2;  
+---+------+  
| a | b    |  
+---+------+  
| 2 |    2 |  
| 3 |    3 |  
| 4 |    4 |  
+---+------+  

## 这时有锁等待  
root@localhost:lyj 06:07:24&amp;gt; delete from t2 where b=2;  
## 查看锁信息  
select * from information_schema.innodb_locks;  
+---------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+  
| lock_id       | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |  
+---------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+  
| 29509:211:3:5 | 29509       | X         | RECORD    | `lyj`.`t2` | PRIMARY    |        211 |         3 |        5 | 5         |  
| 29504:211:3:5 | 29504       | X         | RECORD    | `lyj`.`t2` | PRIMARY    |        211 |         3 |        5 | 5         |  
+---------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+  

# 会话1  
root@localhost:lyj 06:07:32&amp;gt;insert into t2 (a,b) values(6,6);  
Query OK, 1 row affected (0.00 sec)  

root@localhost:lyj 06:08:13&amp;gt;insert into t2 (a,b) values(1,1);  
Query OK, 1 row affected (0.00 sec)  

# 会话2，刚才的等待出现死锁错误  
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;死锁分析：在RR事务隔离级别下，由于DELETE没有用主键或者唯一索引，和INSERT形成死锁，无法避免。&lt;br /&gt;
处理办法：将事务隔离级别修改为RC，或才在RR事务隔离级别，将&lt;code&gt;innodb_locks_unsafe_for_binlog&lt;/code&gt;设置为&lt;code&gt;on&lt;/code&gt;也可以。&lt;/p&gt;

&lt;h2 id=&#34;mysql如何避免死锁&#34;&gt;MySQL如何避免死锁&lt;/h2&gt;

&lt;h3 id=&#34;注意程序的逻辑-最重要&#34;&gt;注意程序的逻辑（最重要）&lt;/h3&gt;

&lt;p&gt;根本的原因是程序逻辑的顺序，最常见的是交差更新&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;Transaction 1: 更新表A -&amp;gt; 更新表B  
Transaction 2: 更新表B -&amp;gt; 更新表A  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这类问题要从程序上避免，所有的更新需要按照一定顺序&lt;/p&gt;

&lt;h3 id=&#34;保持事务的轻量&#34;&gt;保持事务的轻量&lt;/h3&gt;

&lt;p&gt;越是轻量的事务，占有越少的锁资源，这样发生死锁的几率就越小&lt;br /&gt;
1. 提高运行速度，避免使用子查询，尽量使用主键等&lt;br /&gt;
2. 尽量快提交事务，减少持有锁的时间&lt;/p&gt;

&lt;p&gt;死锁是数据库对事务的保护机制，一旦发生死锁，mysql会选择相对小的事务(undo较少的)进行回滚。死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个或两个以上的session加锁的顺序不一致。分析MySQ每条SQL的加锁规则、顺序，检查多个并发SQL间是否存在相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Makefile 详解</title>
            <link>http://blog.pytool.com/post/shell/makefile/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/makefile/</guid>
            <description>

&lt;h2 id=&#34;基本原则&#34;&gt;基本原则&lt;/h2&gt;

&lt;p&gt;.PYTHON伪目标总是不如其它文件“新”，因此它总是被执行。&lt;br /&gt;
@   使命令在被执行前不被回显。&lt;br /&gt;
–   使任何命令行的任何非零退出状态都被忽略。&lt;br /&gt;
+   使命令行可以通过指定 -n、-q 或 -t 选项来执行。&lt;/p&gt;

&lt;h2 id=&#34;模式变量&#34;&gt;模式变量 %&lt;/h2&gt;

&lt;p&gt;argets定义了一系列的目标文件，可以有通配符。是目标的一个集合。&lt;br /&gt;
target-parrtern是指明了targets的模式，也就是的目标集模式。&lt;br /&gt;
prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。&lt;/p&gt;

&lt;p&gt;这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。&lt;br /&gt;
如果我们的&lt;target-parrtern&gt;定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”，意思是对&lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-parrtern&gt;模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。&lt;/p&gt;

&lt;p&gt;所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。&lt;/p&gt;

&lt;p&gt;看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;objects = foo.o bar.o  
all: $(objects)  
$(objects):  
%.o: %.c  
  $(CC) -c $(CFLAGS) $&amp;lt; -o $@  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，&lt;br /&gt;
也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。&lt;br /&gt;
而命令中的“$&amp;lt;”和“$@”则是自动化变量，“$&amp;lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ｍakefile&#34;&gt;foo.o : foo.c  
  $(CC) -c $(CFLAGS) foo.c -o foo.o  
bar.o : bar.c  
  $(CC) -c $(CFLAGS) bar.c -o bar.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：&lt;/p&gt;

&lt;p&gt;files = foo.elc bar.o lose.o&lt;/p&gt;

&lt;p&gt;$(filter %.o,$(files)): %.o: %.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       $(CC) -c $(CFLAGS) $&amp;lt; -o $@  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(filter %.elc,$(files)): %.elc: %.el&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       emacs -f batch-byte-compile $&amp;lt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。&lt;/p&gt;

&lt;h2 id=&#34;自动变量&#34;&gt;自动变量 $&lt;/h2&gt;

&lt;p&gt;$@          &amp;ndash;代表目标文件(target)&lt;br /&gt;
$^          &amp;ndash;代表所有的依赖文件(components)&lt;br /&gt;
$&amp;lt;          &amp;ndash;代表第一个依赖文件(components中最左边的那个)。&lt;/p&gt;

&lt;p&gt;要生成目标 &amp;hellip; : 生成目标所需的依赖 &amp;hellip;&lt;br /&gt;
    command #必须要以[Tab]键开始&lt;/p&gt;

&lt;p&gt;export&lt;unexport&gt; 传递变量到下级 Makefile 中&lt;/p&gt;

&lt;p&gt;$@&lt;br /&gt;
表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，&amp;rdquo;$@&amp;ldquo;就是匹配于&lt;br /&gt;
目标中模式定义的集合。&lt;br /&gt;
  $% 仅匹配目标文件&lt;br /&gt;
仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是&amp;rdquo;foo.a&lt;br /&gt;
(bar.o)&amp;ldquo;，那么，&amp;rdquo;$%&amp;ldquo;就是&amp;rdquo;bar.o&amp;rdquo;，&amp;rdquo;$@&amp;ldquo;就是&amp;rdquo;foo.a&amp;rdquo;。如果目标不是函数库文件（Unix&lt;br /&gt;
下是[.a]，Windows 下是[.lib]），那么，其值为空。&lt;br /&gt;
  $&amp;lt;&lt;br /&gt;
依赖目标中的第一个目标名字。如果依赖目标是以模式（ 即&amp;rdquo;%&amp;ldquo;）定义的，那么&amp;rdquo;$&amp;lt;&amp;ldquo;将&lt;br /&gt;
是符合模式的一系列的文件集。注意，其是一个一个取出来的。&lt;br /&gt;
  $? 依赖的集合(只提取比目标新的)&lt;br /&gt;
所有比目标新的依赖目标的集合。以空格分隔。&lt;br /&gt;
  $^ 依赖的集合(去重)&lt;br /&gt;
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量&lt;br /&gt;
会去除重复的依赖目标，只保留一份。&lt;br /&gt;
  $+ 依赖的集合(不去重)&lt;br /&gt;
这个变量很像&amp;rdquo;$^&amp;ldquo;，也是所有依赖目标的集合。只是它不去除重复的依赖目标。&lt;br /&gt;
  $* 去除后缀名(不推荐使用)&lt;br /&gt;
这个变量表示目标模式中&amp;rdquo;%&amp;ldquo;及其之前的部分。如果目标是&amp;rdquo;dir/a.foo.b&amp;rdquo;，并且目标的&lt;br /&gt;
模式是&amp;rdquo;a.%.b&amp;rdquo;，那么，&amp;rdquo;$&lt;em&gt;&amp;ldquo;的值就是&amp;rdquo;dir/a.foo&amp;rdquo;。这个变量对于构造有关联的文件名是比&lt;br /&gt;
较有较。如果目标中没有模式的定义，那么&amp;rdquo;$&lt;/em&gt;&amp;ldquo;也就不能被推导出，但是，如果目标文件的&lt;br /&gt;
后缀是 make 所识别的，那么&amp;rdquo;$&lt;em&gt;&amp;ldquo;就是除了后缀的那一部分。例如：如果目标是&amp;rdquo;foo.c&amp;rdquo;，因&lt;br /&gt;
为&amp;rdquo;.c&amp;rdquo;是 make 所能识别的后缀名，所以，&amp;rdquo;$&lt;/em&gt;&amp;ldquo;的值就是&amp;rdquo;foo&amp;rdquo;。这个特性是 GNU make 的，&lt;/p&gt;

&lt;p&gt;很有可能不兼容于其它版本的 make，所以，你应该尽量避免使用&amp;rdquo;$&lt;em&gt;&amp;ldquo;，除非是在隐含规则&lt;br /&gt;
或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么&amp;rdquo;$&lt;/em&gt;&amp;ldquo;就是空值。&lt;/p&gt;

&lt;p&gt;在Makefile中写shell代码有点诡异，和不同的shell语法不太一样，如果不了解，看Makefile会莫名其妙。下面总结了一些。&lt;/p&gt;

&lt;h2 id=&#34;makefile和shell&#34;&gt;Makefile和Shell&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Makefile本质上来讲也是shell脚本，即每条command都是shell进程，运行完shell进程都会退出&lt;br /&gt;
&lt;code&gt;Makefile  
test:  
gcc -c main.c -o main.o  
gcc -c a.c -o a.o  
&lt;/code&gt;&lt;br /&gt;
这样输入make test，结果相当于两个进程，都退出了。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;等价于在shell下输命令一样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;my_test:  
  cd /home;mkdir test  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里make my_test，结果相当于一个进程。当前目录是/root 而&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;own_test:  
  cd /home  
  mkdir test  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;make own_test&lt;/code&gt;，相当于两个进程，&lt;br /&gt;
第一个进程是cd /home,运行完回到了/root。这时再运行第二个shell命令就会在/root下创建一个test目录.(makefile中的shell进程命令，跟直接在shell输的命令相同，但是它都会结束本身，即exit)&lt;/p&gt;

&lt;h2 id=&#34;makefile-中变量赋值&#34;&gt;Makefile 中变量赋值&lt;/h2&gt;

&lt;p&gt;1：尽在Makefile文件的目标项冒号后的另起一行的代码才是shell代码。&lt;/p&gt;

&lt;p&gt;第一种方式：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xx = xx1&lt;/code&gt;         // 这里时makefile代码&lt;/p&gt;

&lt;p&gt;第二种方式：&lt;br /&gt;
yy：xx = xx2       // 这是是makefile代码，makefile允许变量赋值时，&amp;rsquo;=&amp;lsquo;号两边留空格  ？？？？？？可以吗&lt;/p&gt;

&lt;p&gt;第三种方式：&lt;br /&gt;
yy：&lt;br /&gt;
   xx=xx3         // 只有这里是shell代码 ，shell不允许‘=’号两边有空格哦。&lt;br /&gt;
yy:&lt;br /&gt;
   xx= xx3        // 只有这里是shell代码 ，shell不允许‘=’号两边有空格哦。&lt;/p&gt;

&lt;p&gt;注意此时xx的值是&amp;rdquo; xx3&amp;rdquo;，多了一个空格&lt;/p&gt;

&lt;p&gt;有一个例外：&lt;br /&gt;
xx=$(shell 这里的代码也是shell代码)&lt;/p&gt;

&lt;h2 id=&#34;变量传递&#34;&gt;变量传递&lt;/h2&gt;

&lt;p&gt;2：Makefile中的shell，每一行是一个进程，不同行之间变量值不能传递。所以，Makefile中的shell不管多长也要写在一行。&lt;br /&gt;
eg：&lt;/p&gt;

&lt;p&gt;SUBDIR=src example&lt;/p&gt;

&lt;p&gt;all:&lt;/p&gt;

&lt;p&gt;@for subdir in $(SUBDIR); /      // 这里往下是一行shell&lt;/p&gt;

&lt;p&gt;do/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   echo &amp;quot;building &amp;quot; $$subdir; /  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;done&lt;/p&gt;

&lt;h2 id=&#34;变量引用-ｍakefile变量-shell的变量&#34;&gt;变量引用 Ｍakefile变量$ shell的变量$$&lt;/h2&gt;

&lt;p&gt;3：Makefile中的变量以$开头，使用$(VAR)或${VAR}来引用变量的定义。 所以，为了避免和shell的变量冲突，shell的变量以$$开头&lt;/p&gt;

&lt;p&gt;注意：Makefile中在对一些简单变量的引用，我们也可以不使用“（）”和“{}”来标记变量名，而直接使用“$x”的格式来实现，此种用法仅限于变量名为单字符的情况。另外自动化变量也使用这种格式。对于一般多字符变量的引用必须使用括号了标记，否则make将把变量名的首字母作为作为变量而不是整个字符串（“$PATH”在Makefile中实际上是“$(P)ATH”）。这一点和shell中变量的引用方式不同。shell中变量的引用可以是“${xx}”或者“$xx”格式。但在Makefile中多字符变量名的引用只能是“$(xx)”或者“${xx}”格式。&lt;/p&gt;

&lt;p&gt;eg1：从当前目录路径中提取出 /application 或 /base_class 之前的部分&lt;br /&gt;
PROJECT_ROOT_DIR = $(shell pwd | awk -F&amp;rsquo;/application|/base_class&amp;rsquo; &amp;lsquo;{print $$1}&amp;rsquo;)&lt;br /&gt;
eg2：上例中$$subdir就是shell中的变量， 而$(SUBDIR)是Makefile的中的变量&lt;/p&gt;

&lt;h2 id=&#34;变量输出-隐藏自身的输出-出错继续运行&#34;&gt;变量输出 @隐藏自身的输出 - 出错继续运行&lt;/h2&gt;

&lt;p&gt;如果make执行的命令前面加了@字符，则不显示命令本身而只显示它的结果; Android中会定义某个变量等于@，例如 hide:= @&lt;br /&gt;
通常make执行的命令如果出错（该命令的退出状态非0）就立刻终止，不再执行后续命令，但如果命令前面加了-号，即使这条命令出错，make也会继续执行后续命令。&lt;br /&gt;
通常rm命令和mkdir命令前面要加-号，因为rm要删除的文件可能不存在，mkdir要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。&lt;/p&gt;

&lt;p&gt;1、在Makefile中只能在target中调用Shell脚本，其他地方是不能输出的。比如如下代码就是没有任何输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VAR=&amp;quot;Hello&amp;quot;  
echo &amp;quot;$(VAR)&amp;quot;  

all:  
  .....  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码任何时候都不会输出，没有在target内，如果上述代码改为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VAR=&amp;quot;Hello&amp;quot;  

all:  
   echo &amp;quot;$(VAR)&amp;quot;  
   .....  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码，在make all的时候将会执行echo命令。&lt;/p&gt;

&lt;p&gt;最后打印结果是:&lt;br /&gt;
echo &amp;ldquo;&amp;ldquo;Hello&amp;rdquo;&amp;rdquo;&lt;br /&gt;
&amp;ldquo;Hello&amp;rdquo;&lt;/p&gt;

&lt;p&gt;2、在Makefile中执行shell命令，一行创建一个进程来执行。这也是为什么很多Makefile中有很多行的末尾都是“;  \”，以此来保证代码是一行而不是多行，这样Makefile可以在一个进程中执行，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SUBDIR=src example  
all:  
   @for subdir in $(SUBDIR); \  
   do\  
       echo &amp;quot;building &amp;quot;; \  
   done  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述可以看出for循环中每行都是以”; \”结尾的。&lt;/p&gt;

&lt;p&gt;3、Makefile中所有以$打头的单词都会被解释成Makefile中的变量。如果你需要调用shell中的变量（或者正则表达式中锚定句位$），都需要加两个$符号（$$）。实例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=&amp;quot;/data/&amp;quot;  

all:  
   echo ${PATH}/*Makefile中变量，即&amp;quot;/data&amp;quot;*/  
   echo $$PATH /*shell中的变量*/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子中的第一个${PATH}引用的是Makefile中的变量，而不是shell中的PATH环境变量，后者引用的事Shell中的PATH环境变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;以上三点的是Makefile调用shell应该注意的地方，写Makefile一定要注意。  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Shell常用招式大全-入门篇</title>
            <link>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</guid>
            <description>

&lt;p&gt;采用source 而不是bash 命令 可以将环境变量传递过去&lt;/p&gt;

&lt;p&gt;本教程分为入门篇，命令篇和实战篇，结合平时工作中使用Shell的经验编写。以实例为主，侧重于应用，总结了一些实用的技巧。&lt;/p&gt;

&lt;p&gt;以下为本教程的《入门篇》，适于初学者快速入门以及老手查缺补漏。&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;第一招-helloworld&#34;&gt;第一招 HelloWorld&lt;/h1&gt;

&lt;h2 id=&#34;第一式-echo&#34;&gt;第一式：echo&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;Hello World&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;echo -n &amp;quot;Hello World&amp;quot;    # 不带换行  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;echo -e &#39;\e[0;33;1mHello\e[0m World&#39;   # 带颜色的玩法  
echo -e &#39;\e[0;33;4mHello\e[0m World&#39;   # 带颜色+下划线  
echo -e &#39;\e[0;33;5mHello\e[0m World&#39;   # 带颜色+闪烁  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式为 &lt;code&gt;\e[背景色;前景色;高亮格式m&lt;/code&gt;，请阅读&lt;a href=&#34;http://blog.chinaunix.net/uid-15007890-id-3152717.html&#34;&gt;详细文档&lt;/a&gt;后使用正确的姿势进行装逼。&lt;/p&gt;

&lt;h1 id=&#34;第二招-判断&#34;&gt;第二招 判断&lt;/h1&gt;

&lt;h2 id=&#34;第一式-if&#34;&gt;第一式：if&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;if true  
then  
    echo &amp;quot;Hello World&amp;quot;  
else  
	echo &amp;quot;Bug&amp;quot;  
fi  

if false  
then  
    echo &amp;quot;Hello World&amp;quot;  
elif true  
then  
    echo &amp;quot;Bug&amp;quot;  
else  
	echo &amp;quot;Bee&amp;quot;  
fi  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;判断原理&#34;&gt;判断原理&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;elif&lt;/code&gt;会执行它后面跟着的命令，然后看返回值是否为&lt;code&gt;0&lt;/code&gt;，如果为&lt;code&gt;0&lt;/code&gt;则执行&lt;code&gt;then&lt;/code&gt;下面的语句块，否则执行&lt;code&gt;else&lt;/code&gt;下面的语句块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]$ true  
[casheywen@ubuntu:~]$ echo $?  
0  
[casheywen@ubuntu:~]$ false  
[casheywen@ubuntu:~]$ echo $?  
1  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;事实上也为一个命令，&lt;code&gt;true&lt;/code&gt;的返回码必为&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;false&lt;/code&gt;的返回码必为&lt;code&gt;1&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt;为&lt;code&gt;shell&lt;/code&gt;内置变量，用于存放上一个命令的返回码&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-test-和&#34;&gt;第二式：test、[ ] 和 [[ ]]&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;test&lt;/code&gt;、&lt;code&gt;[ ]&lt;/code&gt;、&lt;code&gt;[[ ]]&lt;/code&gt;实际上都是&lt;code&gt;shell&lt;/code&gt;中的命令，执行之后会返回&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;，而这几个命令与&lt;code&gt;if&lt;/code&gt;相结合可以达到我们所需要的许多判断功能，例如测试字符串是否为空的三种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s=&amp;quot;&amp;quot;  
if [ -z ${s} ]  
then  
    echo &amp;quot;empty&amp;quot;  
fi  

if [[ -z ${s} ]]  
then  
    echo &amp;quot;empty&amp;quot;  
fi  

if test -z ${s}  
then  
    echo &amp;quot;empty&amp;quot;  
fi  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上，&lt;code&gt;if&lt;/code&gt;后的&lt;code&gt;[  ]&lt;/code&gt;、&lt;code&gt;[[  ]]&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;命令都是可以单独执行的，而根据&lt;code&gt;if&lt;/code&gt;的&lt;a href=&#34;#判断原理&#34;&gt;判断原理&lt;/a&gt;，后续执行哪个分支也是由&lt;code&gt;[  ]&lt;/code&gt;、&lt;code&gt;[[  ]]&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;的返回值来决定的，以下是单独执行它们的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]$ s=&amp;quot;&amp;quot;  
[casheywen@ubuntu:~]$ [ -z &amp;quot;${s}&amp;quot; ]  
[casheywen@ubuntu:~]$ echo $?  
0  
[casheywen@ubuntu:~]$ s=&amp;quot;abc&amp;quot;  
[casheywen@ubuntu:~]$ test -z &amp;quot;${s}&amp;quot;  
[casheywen@ubuntu:~]$ echo $?  
1  
[casheywen@ubuntu:~]$ s=&amp;quot;123&amp;quot;  
[casheywen@ubuntu:~]$ [[ 100 -lt ${s} ]]  
[casheywen@ubuntu:~]$ echo $?  
0  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在性能方面&lt;code&gt;[ ]&lt;/code&gt;和&lt;code&gt;test&lt;/code&gt;性能基本相同，&lt;code&gt;[[ ]]&lt;/code&gt;性能是最高的，为前两者的&lt;code&gt;5&lt;/code&gt;倍左右（以&lt;code&gt;-d&lt;/code&gt;运算符测试），所以建议尽量使用&lt;code&gt;[[ ]]&lt;/code&gt;提高脚本性能。&lt;/p&gt;

&lt;h2 id=&#34;文件测试&#34;&gt;文件测试&lt;/h2&gt;

&lt;p&gt;|运算符|描述|示例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|-e filename|如果 filename 存在，则为真     |[ -e /var/log/syslog ]|&lt;br /&gt;
|-d filename|如果 filename 为目录，则为真   |[ -d /tmp/mydir ]|&lt;br /&gt;
|-f filename|如果 filename 为常规文件，则为真|[ -f /usr/bin/grep ]|&lt;br /&gt;
|-L filename|如果 filename 为符号链接，则为真|[ -L /usr/bin/grep ]|&lt;br /&gt;
|-r filename|如果 filename 可读，则为真     |[ -r /var/log/syslog ]|&lt;br /&gt;
|-w filename|如果 filename 可写，则为真     |[ -w /var/mytmp.txt ]|&lt;br /&gt;
|-x filename|如果 filename 可执行，则为真   |[ -x /usr/bin/grep ]|&lt;br /&gt;
|filename1 -nt filename2|如果 filename1 比 filename2 新，则为真|[ /tmp/install/etc/services -nt /etc/services ]|&lt;br /&gt;
|filename1 -ot filename2|如果 filename1 比 filename2 旧，则为真|[ /boot/bzImage -ot arch/i386/boot/bzImage ]|&lt;/p&gt;

&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;

&lt;p&gt;|运算符|描述|示例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|-z string|如果 string 长度为零，则为真|&lt;code&gt;[ -z &amp;quot;${myvar}&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|-n string|如果 string 长度非零，则为真|&lt;code&gt;[ -n &amp;quot;${myvar}&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|string1 = string2|如果 string1 与 string2 相同，则为真|&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; = &amp;quot;abc&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|string1 != string2|如果 string1 与 string2 不同，则为真|&lt;code&gt;[ &amp;quot;${myvar}&amp;quot; != &amp;quot;abc&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|string1 &amp;lt; string|如果 string1 小于 string2，则为真 | &lt;code&gt;[ &amp;quot;${myvar}&amp;quot; \&amp;lt; &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[[ &amp;quot;${myvar}&amp;quot; &amp;lt; &amp;quot;abc&amp;quot; ]]&lt;/code&gt; |&lt;br /&gt;
|string1 &amp;gt; string|如果 string1 大于 string2，则为真 | &lt;code&gt;[ &amp;quot;${myvar}&amp;quot; \&amp;gt; &amp;quot;abc&amp;quot; ]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[[ &amp;quot;${myvar}&amp;quot; &amp;gt; &amp;quot;abc&amp;quot; ]]&lt;/code&gt;|&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在字符串两边加上&amp;rdquo;&amp;ldquo;防止出错&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;是字符串比较，不要错用成整数比较&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果是在&lt;code&gt;[ ]&lt;/code&gt;中使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;，需要将它们写成&lt;code&gt;\&amp;lt;&lt;/code&gt;和&lt;code&gt;\&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;整数比较&#34;&gt;整数比较&lt;/h2&gt;

&lt;p&gt;|运算符|描述|示例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|num1 -eq num2|等于|[ 3 -eq $mynum ]|&lt;br /&gt;
|num1 -ne num2|不等于|[ 3 -ne $mynum ]|&lt;br /&gt;
|num1 -lt num2|小于|[ 3 -lt $mynum ]|&lt;br /&gt;
|num1 -le num2|小于或等于|[ 3 -le $mynum ]|&lt;br /&gt;
|num1 -ge num2|大于或等于|[ 3 -ge $mynum ]|&lt;/p&gt;

&lt;h2 id=&#34;第三式&#34;&gt;第三式：&amp;amp;&amp;amp;、||&lt;/h2&gt;

&lt;p&gt;|&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;可以用来对两个判断语句求与|&lt;br /&gt;
|&amp;mdash;|&lt;br /&gt;
|&lt;code&gt;if [ -n &amp;quot;abc&amp;quot; ] &amp;amp;&amp;amp; [ -n &amp;quot;aa&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; ]] &amp;amp;&amp;amp; [[ -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if test -n &amp;quot;abc&amp;quot; &amp;amp;&amp;amp; test -n &amp;quot;aa&amp;quot;&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; &amp;amp;&amp;amp; -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;只有&lt;code&gt;[[ ]]&lt;/code&gt;才允许把&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;写在里面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;|&lt;code&gt;\|\|&lt;/code&gt;可以用来对两个判断语句求或|&lt;br /&gt;
|&amp;mdash;|&lt;br /&gt;
|&lt;code&gt;if [ -n &amp;quot;abc&amp;quot; ] \|\| [ -n &amp;quot;aa&amp;quot; ]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; ]] \|\| [[ -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if test -n &amp;quot;abc&amp;quot; \|\| test -n &amp;quot;aa&amp;quot;&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;if [[ -n &amp;quot;abc&amp;quot; \|\| -n &amp;quot;aa&amp;quot; ]]&lt;/code&gt;|&lt;br /&gt;
&amp;gt; &lt;strong&gt;注：&lt;/strong&gt;只有&lt;code&gt;[[ ]]&lt;/code&gt;才允许把&lt;code&gt;||&lt;/code&gt;写在里面&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小技巧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;还可以用来拼接命令，达到按前一个命令成功与否来决定是否执行后一个命令的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /data &amp;amp;&amp;amp; ls         # 当`cd /data`返回0(即成功)时才执行后面的`ls`  
cd /data || cd /root   # 当`cd /data`返回非0(即失败)时才执行后面的`cd /root`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第三招-循环&#34;&gt;第三招：循环&lt;/h1&gt;

&lt;h2 id=&#34;第一式-for&#34;&gt;第一式：for&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;for i in {1..100}  
do  
    echo ${i}  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{1..100}&lt;/code&gt;属于&lt;a href=&#34;#第五招通配&#34;&gt;通配&lt;/a&gt;的一种写法，展开会是&lt;code&gt;1 2 3 ... 100&lt;/code&gt;（1~100以空格隔开）这样的字串。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;code&gt;for i in 1 2 3;&lt;/code&gt;这样的语句，&lt;code&gt;for&lt;/code&gt;会将&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;依次赋值于&lt;code&gt;i&lt;/code&gt;进行循环，而对于&lt;a href=&#34;#第五招通配&#34;&gt;通配&lt;/a&gt;的情况，&lt;code&gt;for&lt;/code&gt;则会将通配展开后将里面的每一项依次赋值于&lt;code&gt;i&lt;/code&gt;进行循环。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;for i in `seq 100`  
do  
    echo ${i}  
done  

for i in `seq 1 2 100`  
do  
    echo ${i}  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;seq&lt;/code&gt;本身为一个命令，用于输出数字组成的序列，如&lt;code&gt;seq 100&lt;/code&gt;会生成并输出&lt;code&gt;1 2 3 ... 100&lt;/code&gt;（1~100以换行符隔开）这样的序列，而&lt;code&gt;seq 1 2 100&lt;/code&gt;则会生成并输出&lt;code&gt;1 3 5 ... 99&lt;/code&gt;（以1开始，2为公差的等差数列中小于100的项，以换行符隔开）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;反引号(`)之间的命令会被执行，其输出结果会转换成一个&lt;a href=&#34;#第五式将命令执行结果存入变量&#34;&gt;变量&lt;/a&gt;，故上面的&lt;code&gt;for in&lt;/code&gt;会依次取出&lt;code&gt;seq&lt;/code&gt;的执行结果赋值于&lt;code&gt;i&lt;/code&gt;进行循环。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;for ((i = 0; i &amp;lt; 100; i++))  
do  
    echo ${i}  
done  

for ((i = 0; i &amp;lt; 100; i+= 2))  
do  
    echo ${i}  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上与C语言式的&lt;code&gt;for&lt;/code&gt;循环语法基本相同，区别在于双重括号：&lt;code&gt;(( ))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-while-until&#34;&gt;第二式：while、until&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;i=0  
while [[ ${i} -lt 100 ]]  
do  
    echo ${i}  
    ((i++))  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;i=0  
until [[ ${i} -ge 100 ]]  
do  
    echo ${i}  
    ((i++))  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;until&lt;/code&gt;的判断原理与&lt;code&gt;if&lt;/code&gt;是类似的，它会执行并它后面跟着的命令，不同点在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;是后面语句返回值为&lt;code&gt;0&lt;/code&gt;，则执行循环中的语句块，否则跳出循环;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;until&lt;/code&gt;则是后面语句返回值非&lt;code&gt;0&lt;/code&gt;，则执行循环中的语句块，否则跳出循环。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第四招-变量&#34;&gt;第四招：变量&lt;/h1&gt;

&lt;h2 id=&#34;第一式-整数&#34;&gt;第一式：整数&lt;/h2&gt;

&lt;h2 id=&#34;整数的运算&#34;&gt;整数的运算&lt;/h2&gt;

&lt;p&gt;方法较多，此处只列举最浅显易懂，并且效率最高的办法——直接将符合C语言语法的表达式放到&lt;code&gt;(( ))&lt;/code&gt;中即可达到对整数的计算目的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $(( 1+1 ))        # 最简单的1+1  
echo $(( (1+2)*3/4 ))  # 表达式中还可以带括号  
echo $(( 1&amp;lt;&amp;lt;32 ))      # 左移右移也支持，但仅限于-4294967296~4294967296之间的数值  
echo $(( 1&amp;amp;3 ))        # &amp;amp;、^、|、~ 这样的位操作亦支持  
(( i=1+2 ))            # 将1+2计算出结果后赋值给i，后续若`echo ${i}`会得到3  
(( i++ ))              # 变量i自增1  
(( i+=3 ))             # 变量i自增3  
# ...                  # 还有很多，不再详列  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进行整数运算的方法还有：&lt;code&gt;expr&lt;/code&gt;、&lt;code&gt;$[]&lt;/code&gt;、&lt;code&gt;let&lt;/code&gt;等&lt;code&gt;shell&lt;/code&gt;等内置命令，也可调用&lt;code&gt;bc&lt;/code&gt;、&lt;code&gt;python&lt;/code&gt;等外部工具进行更复杂的数学运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-字符串&#34;&gt;第二式：字符串&lt;/h2&gt;

&lt;h2 id=&#34;替换&#34;&gt;替换&lt;/h2&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|${string/old/new}|string中第一个old替换为new|&lt;br /&gt;
|${string//old/new}|string中所有old替换为new|&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;i hate hate you&amp;quot;  
[casheywen@ubuntu:~]# echo ${s/hate/love}  
i love hate you  
[casheywen@ubuntu:~]# echo ${s//hate/love}  
i love love you  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;截取子串&#34;&gt;截取子串&lt;/h2&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|${string:n}|string从下标n到结尾的子串|&lt;br /&gt;
|${string:n:m}|string从下标n开始长度为m的子串|&lt;br /&gt;
|${string::m}|string从下标0开始长度为m的子串|&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;0123456789&amp;quot;  
[casheywen@ubuntu:~]# echo ${s:3}  
3456789  
[casheywen@ubuntu:~]# echo ${s::3}  
012  
[casheywen@ubuntu:~]# echo ${s:0:3}  
012  
[casheywen@ubuntu:~]# echo ${s:2:5}  
23456  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通配删除&#34;&gt;通配删除&lt;/h2&gt;

&lt;p&gt;通配删除，即按通配符，删除掉字符串中符合条件的一部分&lt;/p&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|${string#pattern}|string从左到右删除pattern的最小通配|&lt;br /&gt;
|${string##pattern}|string从左到右删除pattern的最大通配|&lt;br /&gt;
|${string%pattern}|string从右到左删除pattern的最小通配|&lt;br /&gt;
|${string%%pattern}|string从右到左删除pattern的最大通配|&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;此处通配规则参考&lt;a href=&#34;#通配符一览表&#34;&gt;通配符一览表&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最小通配和最大通配的区别：&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最小通配：符合通配的最小子串&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最大通配：符合通配的最大子串&lt;br /&gt;
例如string值为&lt;code&gt;/00/01/02/dir&lt;/code&gt;，对于通配&lt;code&gt;/*/&lt;/code&gt;，其最小通配为&lt;code&gt;/00/&lt;/code&gt;，而最大通配&lt;code&gt;/00/01/02/&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;/00/01/02/dir&amp;quot;  
[casheywen@ubuntu:~]# echo ${s#/*/}  
01/02/dir  
[casheywen@ubuntu:~]# echo ${s##/*/}  
dir  
[casheywen@ubuntu:~]#  
[casheywen@ubuntu:~]# s=&amp;quot;abc/cde/efg&amp;quot;  
[casheywen@ubuntu:~]# echo ${s%/*}  
abc/cde  
[casheywen@ubuntu:~]# echo ${s%%/*}  
abc  
[casheywen@ubuntu:~]#  
[casheywen@ubuntu:~]# s=&amp;quot;/00/01/02/dir&amp;quot;  
[casheywen@ubuntu:~]# echo ${s#/*/}  
01/02/dir  
[casheywen@ubuntu:~]# echo ${s##/*/}  
dir  
[casheywen@ubuntu:~]# s=&amp;quot;abc/cde/efg&amp;quot;  
[casheywen@ubuntu:~]# echo ${s%/*}  
abc/cde  
[casheywen@ubuntu:~]# echo ${s%%/*}  
abc  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;小技巧&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;获取文件名：&lt;code&gt;${path##*/}&lt;/code&gt; (相当于&lt;code&gt;basename&lt;/code&gt;命令的功能)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;获取目录名：&lt;code&gt;${path%/*}&lt;/code&gt; (相当于&lt;code&gt;dirname&lt;/code&gt;命令的功能)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;获取后缀名：&lt;code&gt;${path##*.}&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# s=&amp;quot;/root/test/dir/subdir/abc.txt&amp;quot;  
[casheywen@ubuntu:~]# echo ${s##*/}  
abc.txt  
[casheywen@ubuntu:~]# echo ${s%/*}  
/root/test/dir/subdir  
[casheywen@ubuntu:~]# echo ${s##*.}  
txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-数组&#34;&gt;第三式：数组&lt;/h2&gt;

&lt;h2 id=&#34;普通数组&#34;&gt;普通数组&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;a=()         # 空数组  
a=(1 2 3)    # 元素为1,2,3的数组  
echo ${#a[*]}  # 数组长度  
echo ${a[2]}   # 下标为2的元素值（下标从0开始）  
a[1]=0         # 给下标为1的元素赋值  

# 遍历数组  
for i in ${a[*]}  
do  
    echo ${i}  
done  

unset a        # 清空数组  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关联数组&#34;&gt;关联数组&lt;/h2&gt;

&lt;p&gt;关联数组可以用于存储&lt;code&gt;key-value&lt;/code&gt;型的数据，其功能相当于&lt;code&gt;C++&lt;/code&gt;中的&lt;code&gt;map&lt;/code&gt;或&lt;code&gt;python&lt;/code&gt;中的&lt;code&gt;dict&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;declare -A a        # 声明关联数组（必须有此句）  
a=([&amp;quot;apple&amp;quot;]=&amp;quot;a1&amp;quot; [&amp;quot;banana&amp;quot;]=&amp;quot;b2&amp;quot; [&amp;quot;carrot&amp;quot;]=&amp;quot;c3&amp;quot;)   # 初始化关联数组  
echo ${#a[*]}       # 获取元素个数  
echo ${a[&amp;quot;carrot&amp;quot;]} # 获取元素值  
a[&amp;quot;durian&amp;quot;]=&amp;quot;d4&amp;quot;    # 插入或修改元素  
echo ${!a[*]}       # 获取所有的key  
unset a[&amp;quot;banana&amp;quot;]   # 删除元素  

# 遍历数组(仅value)  
for i in ${a[*]}  
do  
    echo ${i}  
done  

# 遍历数组(key和value)  
for key in ${!a[*]}  
do  
	echo &amp;quot;${key} ==&amp;gt; ${a[${key}]}&amp;quot;  
done  

unset a             # 清空数组  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;关联数组需要bash 4.0以上版本才支持，选用需慎重。查看&lt;code&gt;bash&lt;/code&gt;版本用&lt;code&gt;bash --version&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关联数组必须用&lt;code&gt;declare -A&lt;/code&gt;显示声明类型，否则数值会出错。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第四式-将命令执行结果存入变量&#34;&gt;第四式：将命令执行结果存入变量&lt;/h2&gt;

&lt;h2 id=&#34;与&#34;&gt;` `与$( )&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;LINE_CNT=`wc -l test.txt`  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;LINE_CNT=$(wc -l test.txt)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令均可把&lt;code&gt;wc -l test.txt&lt;/code&gt;的结果存入&lt;code&gt;LINE_CNT&lt;/code&gt;变量中&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;` `&lt;/code&gt; 和&lt;code&gt;$( )&lt;/code&gt;都只将命令行标准输出的内容存入变量，如果需要将标准错误内容存入变量，需要用到&lt;a href=&#34;#第五招重定向&#34;&gt;重定向&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;换行符处理&#34;&gt;换行符处理&lt;/h2&gt;

&lt;p&gt;如果命令执行结果有多行内容，存入变量并打印时换行符会丢失：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# cat test.txt  
a  
b  
c  
[casheywen@ubuntu:~]# CONTENT=`cat test.txt`  
[casheywen@ubuntu:~]# echo ${CONTENT}  
a b c  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若需要保留换行符，则在打印时必须加上&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# CONTENT=`cat test.txt`  
[casheywen@ubuntu:~]# echo &amp;quot;${CONTENT}&amp;quot;  
a  
b  
c  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第五招-重定向&#34;&gt;第五招：重定向&lt;/h1&gt;

&lt;h2 id=&#34;标准输入流-标准输出流-标准错误流&#34;&gt;标准输入流、标准输出流、标准错误流&lt;/h2&gt;

&lt;p&gt;|名称|英文缩写|内容|默认绑定位置|文件路径|Shell中代号|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|标准输入流|&lt;code&gt;stdin&lt;/code&gt;|程序读取的用户输入|键盘输入|&lt;code&gt;/dev/stdin&lt;/code&gt;|&lt;code&gt;0&lt;/code&gt;|&lt;br /&gt;
|标准输出流|&lt;code&gt;stdout&lt;/code&gt;|程序的打印的正常信息|终端(&lt;code&gt;terminal&lt;/code&gt;), 即显示器|&lt;code&gt;/dev/stdin&lt;/code&gt;|&lt;code&gt;1&lt;/code&gt;|&lt;br /&gt;
|标准错误流|&lt;code&gt;stderr&lt;/code&gt;|程序的错误信息|终端(&lt;code&gt;terminal&lt;/code&gt;)，, 即显示器|&lt;code&gt;/dev/stderr&lt;/code&gt;|&lt;code&gt;2&lt;/code&gt;|&lt;/p&gt;

&lt;h2 id=&#34;重定向方式一览表&#34;&gt;重定向方式一览表&lt;/h2&gt;

&lt;p&gt;|操作|含义|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt; file&lt;/code&gt;|把 stdout 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt;&amp;gt; file&lt;/code&gt;|把 stdout 追加到 file|&lt;br /&gt;
|&lt;code&gt;cmd 2&amp;gt; file&lt;/code&gt;|把 stderr 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd 2&amp;gt;&amp;gt; file&lt;/code&gt;|把 stderr 追加到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;amp;&amp;gt; file&lt;/code&gt;|把 stdout 和 stderr 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code&gt;|把 stdout 和 stderr 重定向到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;gt;&amp;gt; file 2&amp;gt;&amp;amp;1&lt;/code&gt;|把 stdout 和 stderr 追加到 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;lt;file &amp;gt;file2 cmd&lt;/code&gt;| cmd 以 file 作为 stdin，以 file2 作为 stdout|&lt;br /&gt;
|&lt;code&gt;cat &amp;lt;&amp;gt;file&lt;/code&gt;|以读写的方式打开 file|&lt;br /&gt;
|&lt;code&gt;cmd &amp;lt; file cmd&lt;/code&gt;|cmd 命令以 file 文件作为 stdin|&lt;br /&gt;
|&lt;code&gt;cmd &amp;lt;&amp;lt; delimiter Here document&lt;/code&gt;|从 stdin 中读入，直至遇到 delimiter 分界符|&lt;/p&gt;

&lt;h2 id=&#34;第一式-重定向标准输出流-stdout&#34;&gt;第一式：重定向标准输出流(stdout)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;把程序打印的内容输出到文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 以下两种方式都会将`Hello World`写入到hello.txt(若不存在则创建)  
echo &amp;quot;Hello World&amp;quot; &amp;gt; hello.txt   # hello.txt原有的将被覆盖  
echo &amp;quot;Hello World&amp;quot; &amp;gt;&amp;gt; hello.txt  # hello.txt原有内容后追加`Hello World`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二式-重定向标准错误流-stderr&#34;&gt;第二式：重定向标准错误流(stderr)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;把程序的错误信息输出到文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如文件路径中不存在&lt;code&gt;+++&lt;/code&gt;这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls +++  
ls: cannot access +++: No such file or directory  
[casheywen@ubuntu:~]# ls +++ &amp;gt; out.txt  
ls: cannot access +++: No such file or directory  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的&lt;code&gt;ls +++&lt;/code&gt;后输出的内容为标准错误流中的错误信息，所以即使用&lt;code&gt;&amp;gt; out.txt&lt;/code&gt;重定向标准输入，错误信息仍然被打印到了屏幕。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 以下两种方式都会将`ls +++`输出的错误信息输出到err.txt(若不存在则创建)  
ls +++ 2&amp;gt; err.txt    # err.txt原有内容将被覆盖  
ls +++ 2&amp;gt;&amp;gt; err.txt   # err.txt原有内容后追加内容  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-重定向标准输入流-stdin&#34;&gt;第三式：重定向标准输入流(stdin)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 让程序从文件读取输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以默认从标准输入读取表达式，并进行数学计算的命令&lt;code&gt;bc&lt;/code&gt;为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# bc -q  
1+1  
2  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1+1&lt;/code&gt;为键盘输入的内容，&lt;code&gt;2&lt;/code&gt;为&lt;code&gt;bc&lt;/code&gt;命令打印的计算结果&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bc&lt;/code&gt;后的&lt;code&gt;-q&lt;/code&gt;参数用于禁止输出欢迎信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为&lt;code&gt;命令 &amp;lt; 文件路径&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我需要把已经存在文件&lt;code&gt;exp.txt&lt;/code&gt;中的一个表达式输入到&lt;code&gt;bc&lt;/code&gt;中进行计算，可以采用重定向标准输入流的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bc -q &amp;lt; exp.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当&lt;code&gt;exp.txt&lt;/code&gt;中内容为&lt;code&gt;1+1&lt;/code&gt;时，以上语句输出&lt;code&gt;2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;bc&lt;/code&gt;命令本身支持从文件输入，如不使用重定向，也可用&lt;code&gt;bc exp.txt&lt;/code&gt;达到相同效果&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2. 将&lt;a href=&#34;#第四招变量&#34;&gt;变量&lt;/a&gt;中内容作为程序输入&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EXP=&amp;quot;1+1&amp;quot;  
bc -q &amp;lt;&amp;lt;&amp;lt; &amp;quot;${EXP}&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以上代码等同于执行&lt;code&gt;bc&lt;/code&gt;并输入&lt;code&gt;1+1&lt;/code&gt;，得到的输出为&lt;code&gt;2&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为&lt;code&gt;命令 &amp;lt;&amp;lt;&amp;lt; 变量内容&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. 将当前shell脚本中的多行内容作为程序的输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如在shell中内嵌多行python代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python &amp;lt;&amp;lt; EOF  
print &#39;hello from python&#39;  
print &#39;hello&#39; + &#39;world&#39;  
EOF  

# 内容中支持shell变量  
MSG=&amp;quot;shell variable&amp;quot;  

python &amp;lt;&amp;lt; EOF  
print &#39;${MSG}&#39;  
EOF  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以上用法可以方便地将某个程序需要的多行输入内容直接包含在当前脚本中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持变量，可以动态地改变多行输入的内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;以上重定向方法格式为：&lt;code&gt;命令 &amp;lt;&amp;lt; EOF (换行)...(换行) EOF&lt;/code&gt;，其中的&lt;code&gt;EOF&lt;/code&gt;换成其它字符串也是有效的，如：&lt;code&gt;命令 &amp;lt;&amp;lt; ABC (换行)...(换行) ABC&lt;/code&gt;的，但通用习惯都使用&lt;code&gt;EOF&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第六招-管道&#34;&gt;第六招：管道&lt;/h1&gt;

&lt;h2 id=&#34;第一式-管道的基本功能&#34;&gt;第一式：管道的基本功能&lt;/h2&gt;

&lt;p&gt;管道的写法为 &lt;code&gt;cmd1 | cmd2&lt;/code&gt;，功能是依次执行&lt;code&gt;cmd1&lt;/code&gt;和&lt;code&gt;cmd2&lt;/code&gt;，并将&lt;code&gt;cmd1&lt;/code&gt;的标准输出作为&lt;code&gt;cmd2&lt;/code&gt;的标准输入，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;1+1&amp;quot; | bc  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;echo &amp;quot;1+1&amp;quot;&lt;/code&gt; 会将&lt;code&gt;1+1&lt;/code&gt;输出到标准输出，而管道会将&lt;code&gt;echo&lt;/code&gt;输出的&lt;code&gt;1+1&lt;/code&gt;作为&lt;code&gt;bc&lt;/code&gt;命令的标准输入，这样&lt;code&gt;bc&lt;/code&gt;会读取到&lt;code&gt;1+1&lt;/code&gt;，最终得到计算结果&lt;code&gt;2&lt;/code&gt;打印到屏幕。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;管道可以多级拼接：&lt;code&gt;cmd1 | cmd2 | cmd3 | ...&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;管道的返回值为最后一级命令的返回值&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二式-管道与while-read组合&#34;&gt;第二式：管道与while、read组合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;LINE_NO=0  
cat test.txt |  
while read LINE  
do  
	(( LINE_NO++ ))  
	echo &amp;quot;${LINE_NO} ${LINE}&amp;quot;  
done  

# echo &amp;quot;${LINE_NO}&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将&lt;code&gt;test.txt&lt;/code&gt;中每一行标上行标后输出。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt;命令用于从标准输入读取一行并赋值给一个或多个变量，如&lt;code&gt;read LINE&lt;/code&gt;会从标准输入读取一行并将整行内容赋值给&lt;code&gt;LINE&lt;/code&gt;变量，&lt;code&gt;read A B&lt;/code&gt;则会从标准输入读入一行并将这行的第1、2列分别赋值给A、B两个变量（分割符默认为空格或tab，可给&lt;code&gt;IFS&lt;/code&gt;赋值来更改分割符）&lt;br /&gt;
&amp;gt; 2. 末尾注释掉的&lt;code&gt;echo &amp;quot;${LINE_NO}&amp;quot;&lt;/code&gt;若执行会输出&lt;code&gt;0&lt;/code&gt;，原因是管道中的&lt;code&gt;while&lt;/code&gt;语句是执行在子进程中的，不会改变父进程中&lt;code&gt;LINE_NO&lt;/code&gt;变量的值&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第三式-管道与xargs组合&#34;&gt;第三式：管道与xargs组合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;find . -type f -name *.log | xargs rm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将当前目录及子目录所有后缀名为&lt;code&gt;.log&lt;/code&gt;的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -type f -name *.log | xargs -i mv {} /data/log  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以将当前目录及子目录中所有后缀名为&lt;code&gt;.log&lt;/code&gt;的文件移动到&lt;code&gt;/data/log&lt;/code&gt;中&lt;br /&gt;
&amp;gt; &lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;xargs&lt;/code&gt;可以从标准输入读取内容，以之构建并执行另一个命令行&lt;br /&gt;
&amp;gt;&lt;br /&gt;
&amp;gt;  - &lt;code&gt;xargs&lt;/code&gt;直接接命令名称，则将从标准输入读取的所有内容合并为一行构建命令行并执行&lt;br /&gt;
&amp;gt;  - &lt;code&gt;xargs&lt;/code&gt;加上&lt;code&gt;-i&lt;/code&gt;参数，则会每读取一行就构建并执行一个命令行，构建命令行时会将&lt;code&gt;{}&lt;/code&gt;替换为该行的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# cat test.txt  
a  
b  
c  
[casheywen@ubuntu:~]# cat test.txt | xargs echo rm  
rm a b c  
[casheywen@ubuntu:~]# cat test.txt | xargs -i echo rm {}  
rm a  
rm b  
rm c  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上例展示了&lt;code&gt;xargs&lt;/code&gt;构建命令的原理，如果去掉&lt;code&gt;xargs&lt;/code&gt;后的&lt;code&gt;echo&lt;/code&gt;，则会执行打印出来的命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;第七招-通配&#34;&gt;第七招：通配&lt;/h1&gt;

&lt;h2 id=&#34;shell通配的原理&#34;&gt;shell通配的原理&lt;/h2&gt;

&lt;p&gt;如果你的当前目录中有&lt;code&gt;1.txt 2.txt 3.txt&lt;/code&gt;三个文件，那么当你执行&lt;code&gt;ls *.txt&lt;/code&gt;这条命令，&lt;code&gt;shell&lt;/code&gt;究竟为你做了什么？&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;shell&lt;/code&gt;会先读取当前目录，然后按&lt;code&gt;*.txt&lt;/code&gt;的通配条件过滤得到&lt;code&gt;1.txt 2.txt 3.txt&lt;/code&gt;这个文件列表，然后将这个列表作为参数传给&lt;code&gt;ls&lt;/code&gt;，即&lt;code&gt;ls *.txt&lt;/code&gt;相当于&lt;code&gt;ls 1.txt 2.txt 3.txt&lt;/code&gt;，&lt;code&gt;ls&lt;/code&gt;命令本身并不会得到&lt;code&gt;*.txt&lt;/code&gt;这样的参数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：仅当目录中没有符合&lt;code&gt;*.txt&lt;/code&gt;通配的文件，&lt;code&gt;shell&lt;/code&gt;才会将&lt;code&gt;*.txt&lt;/code&gt;这个字符串当作参数直接传给&lt;code&gt;ls&lt;/code&gt;命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以如果需要列出当前目录中所有的&lt;code&gt;txt&lt;/code&gt;文件，我们使用&lt;code&gt;echo *.txt&lt;/code&gt;也同样可以达到目的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls *.txt  
1.txt  2.txt  3.txt  
[casheywen@ubuntu:~]# echo *.txt  
1.txt 2.txt 3.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;对于&lt;code&gt;{ }&lt;/code&gt;通配&lt;code&gt;shell&lt;/code&gt;不会读取目录并过滤获得文件列表。详细请&lt;a href=&#34;#通配符一览表&#34;&gt;参考下文&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;通配符一览表&#34;&gt;通配符一览表&lt;/h2&gt;

&lt;p&gt;|字符|含义|实例|&lt;br /&gt;
|&amp;mdash;|&amp;mdash;|&amp;mdash;|&lt;br /&gt;
|*|匹配 0 或多个字符|&lt;code&gt;a*b&lt;/code&gt; a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。|&lt;br /&gt;
|?|匹配任意一个字符|&lt;code&gt;a?b&lt;/code&gt; a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。|&lt;br /&gt;
|&lt;code&gt;[list]&lt;/code&gt; |匹配 list 中的任意单一字符|&lt;code&gt;a[xyz]b&lt;/code&gt; a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。|&lt;br /&gt;
|&lt;code&gt;[!list]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;[^list]&lt;/code&gt; |匹配 除list 中的任意单一字符|&lt;code&gt;a[!0-9]b&lt;/code&gt; a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。|&lt;br /&gt;
|&lt;code&gt;[c1-c2]&lt;/code&gt;|匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]|&lt;code&gt;a[0-9]b&lt;/code&gt; 0与9之间必须也只能有一个字符 如a0b, a1b&amp;hellip; a9b。|&lt;br /&gt;
|&lt;code&gt;{string1,string2,...}&lt;/code&gt;|枚举sring1或string2(或更多)其一字符串|&lt;code&gt;a{abc,xyz,123}b&lt;/code&gt; 展开成&lt;code&gt;aabcb axyzb a123b&lt;/code&gt;|&lt;br /&gt;
|&lt;code&gt;{c1..c2}&lt;/code&gt;&lt;br/&gt;&lt;code&gt;{n1..n2}&lt;/code&gt;|枚举c1-c2中所有字符或n1-n2中所有数字|&lt;code&gt;{a..f}&lt;/code&gt;展开成&lt;code&gt;a b c d e f&lt;/code&gt;&lt;br/&gt;&lt;code&gt;a{1..5}&lt;/code&gt; 展开成&lt;code&gt;a1 a2 a3 a4 a5&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;[ ]&lt;/code&gt;的通配都会按&lt;a href=&#34;#shell%E9%80%9A%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86&#34;&gt;读取目录并过滤&lt;/a&gt;的方式展开通配项目&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{ }&lt;/code&gt;则不会有读取目录的过程，它是通过枚举所有符合条件的通配项直接展开的&lt;br /&gt;
&lt;code&gt;
[casheywen@ubuntu:~]# ls  
1.txt  2.txt  3.txt  
[casheywen@ubuntu:~]# echo *.txt  
1.txt 2.txt 3.txt  
[casheywen@ubuntu:~]# echo {1..5}.txt  
1.txt 2.txt 3.txt 4.txt 5.txt  
[casheywen@ubuntu:~]# ls {1..5}.txt  
ls: cannot access 4.txt: No such file or directory  
ls: cannot access 5.txt: No such file or directory  
1.txt  2.txt  3.txt  
&lt;/code&gt;&lt;br /&gt;
由上面的命令可见，&lt;code&gt;*&lt;/code&gt;通配的结果与目录中存在哪些文件有关系，而&lt;code&gt;{ }&lt;/code&gt;的通配结果与目录中存在哪些文件无关。若用&lt;code&gt;{ }&lt;/code&gt;进行通配，则有可能将不存在的文件路径作为命令行参数传给程序。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第一式&#34;&gt;第一式：*&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;用于通配文件名或目录名中某一部分为任意内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm *.log          # 删除当前目录中所有后缀名为.log的文件  
rm */log/*.log    # 删除所有二级log目录中后缀名为.log的文件  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二式&#34;&gt;第二式：[ ]&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt;用于通配文件名或目录名中某个字符为限定范围内或限定范围外的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
rm Program[1-9]*.log  # 删除当前目录中以Program跟着一个1到9的数字开头，并以.log为后缀名的文件  
du -sh /[^udp]*       # 对根目录中所有不以u、d、p开头的文件夹求取总大小  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三式-1&#34;&gt;第三式：?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;?&lt;/code&gt;用于通配文件名中某处一个任意值的字符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm L????.txt    # 通配一个文件名以L开头，后面跟着4个字符，并以.txt结尾的文件：如LAB01.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第四式&#34;&gt;第四式：{ }&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt;也为通配符，用于通配在它枚举范围内的值，由于它是直接展开的，我们可以将它用于批量创建目录或文件，也可以用于生成序列：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;批量生成目录&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[casheywen@ubuntu:~]# ls  
[casheywen@ubuntu:~]# mkdir dir{0..2}{0..2}  
[casheywen@ubuntu:~]# ls  
dir00  dir01  dir02  dir10  dir11  dir12  dir20  dir21  dir22  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;生成序列&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt;生成的序列常用于&lt;a href=&#34;#第一式for&#34;&gt;for循环&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for ip in 192.168.234.{1..255}  
do  
    ping ${ip} -w 1 &amp;amp;&amp;gt; /dev/null &amp;amp;&amp;amp; echo ${ip} is Alive  
done  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;以上例子用于查找&lt;code&gt;192.168.234.1~192.168.234.255&lt;/code&gt;整个网段能&lt;code&gt;ping&lt;/code&gt;通的所有&lt;code&gt;ip&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Shell常用招式大全-命令篇</title>
            <link>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%91%BD%E4%BB%A4%E7%AF%87/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%91%BD%E4%BB%A4%E7%AF%87/</guid>
            <description>

&lt;p&gt;继上篇《入门篇》之后，本篇《命令篇》为《Shell常用招式大全》的第二篇教程。&lt;/p&gt;

&lt;p&gt;本篇根据本人的工作经验，总结了Linux下一些常用命令的使用技巧。旨在精而不在全，对于百度一下或&lt;code&gt;man&lt;/code&gt;一下即可知道的使用方法不做详细介绍。&lt;/p&gt;

&lt;p&gt;适合在Linux下用过一些命令，小尝甜头，但仍觉得Shell不是那么称手的读者。&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;第一招-文本处理&#34;&gt;第一招 文本处理&lt;/h1&gt;

&lt;p&gt;无名氏说：编程有两件事，一件是处理数值，另一件是处理字符串。&lt;/p&gt;

&lt;h2 id=&#34;第一式-cut-切割分列&#34;&gt;第一式 cut 切割分列&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;casheywen@ubuntu:~$ cat test.txt  
1 2 3 4 5 6  
a b c d e f g h i  
apple banana pear peach  
casheywen@ubuntu:~$ cat test.txt | cut -f 2 -d &#39; &#39;   # 取出第2列  
2  
b  
banana  
casheywen@ubuntu:~$ cat test.txt | cut -f 2,3 -d &#39; &#39;  # 取出第2,3两列  
2 3  
b c  
banana pear  
casheywen@ubuntu:~$ cat test.txt | cut -f 3- -d &#39; &#39;   # 取出第3到最后一列  
3 4 5 6  
c d e f g h i  
pear peach  
casheywen@ubuntu:~$ cat test.txt | cut -f 3-5 -d &#39; &#39;  # 取出第3~5列  
3 4 5  
c d e  
pear peach  
casheywen@ubuntu:~$ cat test.txt | cut -f 3 --complement -d &#39; &#39;  # 取出除第3列外的所有列  
1 2 4 5 6  
a b d e f g h i  
apple banana peach  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从以上示例大家可以明白，&lt;code&gt;cut&lt;/code&gt;是一个列处理命令，功能上可以代替大多数类似&lt;code&gt;awk &#39;{print $1}&#39;&lt;/code&gt;的效果，写起来很方便。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;cut命令的参数:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 指定选择的列&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 指定分割符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--complement&lt;/code&gt; 反选，指定后会打印不在&lt;code&gt;-f&lt;/code&gt;中的所有列&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;技一-读取配置文件&#34;&gt;技一: 读取配置文件&lt;/h3&gt;

&lt;p&gt;例如有一个格式如下的配置文件 &lt;code&gt;test.conf&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP = 192.168.0.1  
PORT = 12800  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以用如下命令来读取IP字段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;casheywen@ubuntu:~$ cat test.conf | grep -w IP | cut -f 2 -d = | xargs  
192.168.0.1  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>shell中的map使用</title>
            <link>http://blog.pytool.com/post/shell/2017-11-07-shell%E4%B8%AD%E7%9A%84map%E4%BD%BF%E7%94%A8/</link>
            <pubDate>Tue, 07 Nov 2017 14:55:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/post/shell/2017-11-07-shell%E4%B8%AD%E7%9A%84map%E4%BD%BF%E7%94%A8/</guid>
            <description>

&lt;p&gt;bash 的版本必须 &amp;gt;= 4.1.2，升级bash：&lt;/p&gt;

&lt;p&gt;declare -A abc&lt;br /&gt;
declare: usage: declare [-afFirtx] [-p] [name[=value] &amp;hellip;]&lt;/p&gt;

&lt;h1 id=&#34;shell中map的定义与使用&#34;&gt;shell中map的定义与使用&lt;/h1&gt;

&lt;p&gt;declare -A 变量名 #切记使用大写的A，不是小写的a&lt;/p&gt;

&lt;p&gt;[root@www ~]# declare -A map=([&amp;ldquo;sunjun&amp;rdquo;]=&amp;ldquo;a&amp;rdquo; [&amp;ldquo;jason&amp;rdquo;]=&amp;ldquo;b&amp;rdquo; [&amp;ldquo;lee&amp;rdquo;]=&amp;ldquo;c&amp;rdquo;) #定义时初始化一些值&lt;br /&gt;
[root@www ~]# echo ${map[@]}        #输出所有values&lt;br /&gt;
a c b&lt;br /&gt;
[root@www ~]# echo ${!map[@]}       #输出所有keys&lt;br /&gt;
sunjun lee jason&lt;/p&gt;

&lt;p&gt;[root@www ~]# map[&amp;ldquo;hello&amp;rdquo;]=123      #向map中添加一个key=value&lt;br /&gt;
[root@www ~]# echo ${map[@]}&lt;br /&gt;
a c b 123&lt;br /&gt;
[root@www ~]# echo ${!map[@]}&lt;br /&gt;
sunjun lee jason hello&lt;br /&gt;
[root@www ~]#&lt;/p&gt;

&lt;h1 id=&#34;shell中的数组&#34;&gt;shell中的数组&lt;/h1&gt;

&lt;p&gt;[root@www ~]# declare -a array=(&amp;ldquo;aa&amp;rdquo; &amp;ldquo;bb&amp;rdquo; &amp;ldquo;cc&amp;rdquo;)     #定义一个数组&lt;br /&gt;
[root@www ~]# echo ${array[@]}      #输出所有元素的值&lt;br /&gt;
aa bb cc&lt;br /&gt;
[root@www ~]# echo ${!array[@]}     #输出所有元素的索引&lt;br /&gt;
0 1 2&lt;/p&gt;

&lt;p&gt;[root@www ~]# array[100]=&amp;ldquo;hello&amp;rdquo;    #指定索引添加一个元素&lt;br /&gt;
[root@www ~]# echo ${array[@]}&lt;br /&gt;
aa bb cc hello&lt;br /&gt;
[root@www ~]# echo ${!array[@]}&lt;br /&gt;
0 1 2 100&lt;br /&gt;
[root@www ~]#&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
