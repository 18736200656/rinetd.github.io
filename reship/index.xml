<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Reships on 时光小栈</title>
        <link>//blog.pytool.com/reship/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Fri, 01 Jan 2016 00:00:00 UTC</updated>
        
        <item>
            <title>CLNDR.js中文文档</title>
            <link>//blog.pytool.com/reship/2014-05-08-clndr.js-doc/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2014-05-08-clndr.js-doc/</guid>
            <description>&lt;p&gt;CLNDR 是一个jQuery日历插件。由于缺少真正动态的前端日历插件，无奈之下，创作了CLNDR。&lt;/p&gt;

&lt;p&gt;查看demo: &lt;a href=&#34;kylestetz.github.io/CLNDR/&#34; target=&#34;_blank&#34;&gt;kylestetz.github.io/CLNDR/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;依赖&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;使用Bower&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;结合Angular使用&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;引言：标签由你来定&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;days&lt;/code&gt; 数组&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;传入你的事件&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;多天事件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;限制和Datepickers&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回实例/API&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Template Requirements&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;配置&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;模板渲染引擎&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;国际化&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Underscore 模板定界符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;IE 兼容问题&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##下载&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开发环境 ~ &lt;a href=&#34;https://raw.github.com/kylestetz/CLNDR/master/src/clndr.js&#34; target=&#34;_blank&#34;&gt;clndr.js&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;生产环境 ~ &lt;a href=&#34;https://raw.github.com/kylestetz/CLNDR/master/clndr.min.js&#34; target=&#34;_blank&#34;&gt;clndr.min.js&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##依赖&lt;br /&gt;
CLNDR依赖jQuery和Moment.js。默认情况下，CLNDR尝试使用Underscore 的&lt;code&gt;_.template()&lt;/code&gt;函数，不过，如果你指定了自定义的渲染函数（下文有介绍），Underscore就不必要了。&lt;/p&gt;

&lt;p&gt;因为和Underscore的API一致，&lt;a href=&#34;http://lodash.com/&#34; target=&#34;_blank&#34;&gt;Lo-Dash&lt;/a&gt;的&lt;code&gt;_.template()&lt;/code&gt;函数也能正常工作。可以用Lo-Dash代替underscore。&lt;/p&gt;

&lt;p&gt;###使用Bower&lt;br /&gt;
你可以通过Bower安装CLNDR：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install clndr  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下没有安装Underscore。这允许你使用任何想用的渲染引擎。如果你想通过underscore使用默认的模板选项，安装underscore即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install underscore  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###结合Angular使用&lt;br /&gt;
如果你想把CLNDR集成到一个使用Angular的站点，通过指令&lt;a href=&#34;https://github.com/10KB/angular-clndr&#34; target=&#34;_blank&#34;&gt;angular-clndr&lt;/a&gt;开始.&lt;/p&gt;

&lt;p&gt;##引言：标签由你来定&lt;br /&gt;
有很多美妙的并且功能强大的日历模块，它们有个相同的问题就是：它们给你定义了标签（和一堆js）,你不得不work with and style。这导致了很多的hacking, pushing, pulling,和烦人的‘为什们我不能做我想要的’场景&lt;/p&gt;

&lt;p&gt;CLNDR不产生标签（好吧，它是有一些默认标签，但这不是一码事）。相反，CLNDR要求你创建template，它会给你的模板提供一系列对象，只需几行代码，这些对象就可以让你做出你想要的。&lt;/p&gt;

&lt;p&gt;###&lt;code&gt;days&lt;/code&gt; 数组&lt;br /&gt;
下面是一个典型的CLNDR模板。由控制部分和网格部分组成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;clndr-controls&amp;quot;&amp;gt;  
  &amp;lt;div class=&amp;quot;clndr-previous-button&amp;quot;&amp;gt;&amp;amp;lsaquo;&amp;lt;/div&amp;gt;  
  &amp;lt;div class=&amp;quot;month&amp;quot;&amp;gt;&amp;lt;%= month %&amp;gt;&amp;lt;/div&amp;gt;  
  &amp;lt;div class=&amp;quot;clndr-next-button&amp;quot;&amp;gt;&amp;amp;rsaquo;&amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;  
&amp;lt;div class=&amp;quot;clndr-grid&amp;quot;&amp;gt;  
  &amp;lt;div class=&amp;quot;days-of-the-week&amp;quot;&amp;gt;  
    &amp;lt;% _.each(daysOfTheWeek, function(day) { %&amp;gt;  
      &amp;lt;div class=&amp;quot;header-day&amp;quot;&amp;gt;&amp;lt;%= day %&amp;gt;&amp;lt;/div&amp;gt;  
    &amp;lt;% }); %&amp;gt;  
    &amp;lt;div class=&amp;quot;days&amp;quot;&amp;gt;  
      &amp;lt;% _.each(days, function(day) { %&amp;gt;  
        &amp;lt;div class=&amp;quot;&amp;lt;%= day.classes %&amp;gt;&amp;quot;&amp;gt;&amp;lt;%= day.day %&amp;gt;&amp;lt;/div&amp;gt;  
      &amp;lt;% }); %&amp;gt;  
    &amp;lt;/div&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;days&lt;/code&gt; 数组包含着做一个日历所需的绝大部分信息，它的结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{  
  day: 5,  
  classes: &amp;quot;day&amp;quot;,  
  events: [],  
  date: moment(&amp;quot;2013-05-29&amp;quot;)  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过它可以快速的创建出日历网格。&lt;code&gt;days.classes&lt;/code&gt;会根据不同的情形包含额外的类名：如果某个日期是今天，则会包含&lt;code&gt;today&lt;/code&gt;类。&lt;code&gt;event&lt;/code&gt;类也是同样，如果某天带有事件，则会包含&lt;code&gt;event&lt;/code&gt;类&lt;/p&gt;

&lt;p&gt;###传入你的事件&lt;br /&gt;
CLNDR接受对象数组格式的事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;events = [  
  { date: &amp;quot;YYYY-MM-DD or some other ISO Date format&amp;quot;, and: &amp;quot;anything else&amp;quot; }  
]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CLNDR会遍历事件数组，查找&lt;code&gt;date&lt;/code&gt;属性，除非你指定了，否则它将使用&lt;code&gt;dateParameter&lt;/code&gt;选项。在你的模板中，&lt;code&gt;days&lt;/code&gt;数组会自动包含这些事件对象。查看demo，看看events如何填充&lt;code&gt;days&lt;/code&gt;数组。&lt;/p&gt;

&lt;p&gt;##使用&lt;br /&gt;
CLNDR依赖underscore.js 和moment.js(除非你使用了另外的渲染引擎，那样的话underscore就不需要了)。确保在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签里引入clndr.js之前引入这些依赖，当然别忘了jQuery。&lt;/p&gt;

&lt;p&gt;最少代码如下（CLNDR包含一个默认的模板）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;.parent-element&#39;).clndr();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的可配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;.parent-element&#39;).clndr({  

  // 模板可以保存在script标签里。&amp;lt;script type=&amp;quot;text/template&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  
  // 或者以字符串形式引入  
  template: clndrTemplate,  

  // 设置一周的开始，0为周日开始，1为周一开始，默认是周日。  
  weekOffset: 0,  

  // 设置初始的月份，值为日期字符串或者moment对象  
  startWithMonth: &amp;quot;YYYY-MM-DD&amp;quot; or moment(),  

  // 设置星期的缩写，如果你设置moment.js为不同的语言，它会自动推断。  
  // 如果因为某些原因，不能正常推断，用它手动设置。  
  // 这个数组必须以周日开始（结合weekOffset使用可以改变成以周一开始）  
  daysOfTheWeek: [&#39;D&#39;, &#39;L&#39;, &#39;M&#39;, &#39;M&#39;, &#39;J&#39;, &#39;V&#39;, &#39;S&#39;],  

  // CLNDR会寻找目标类名来绑定事件  
  // 下面是默认的：  
  targets: {  
    nextButton: &#39;clndr-next-button&#39;,  
    previousButton: &#39;clndr-previous-button&#39;,  
    nextYearButton: &#39;clndr-next-year-button&#39;,  
    previousYearButton: &#39;clndr-previous-year-button&#39;,  
    todayButton: &#39;clndr-today-button&#39;,  
    day: &#39;day&#39;,  
    empty: &#39;empty&#39;  
  },  
  // 点击事件的回调函数! 在所有的回调函数中， `this` 指向clndr实例  
  clickEvents: {  
    // fired whenever a calendar box is clicked.  
    // returns a &#39;target&#39; object containing the DOM element, any events,  
    // and the date as a moment.js object.  
    click: function(target){ },  
    // 用户点击下个月时触发  
    // 返回一个设置为下个月的moment对象  
    nextMonth: function(month){ },  
    // 用户点击上个月时触发  
    // 返回一个设置为上个月的moment对象  
    previousMonth: function(month){ },  
    // 用户点击明年时触发  
    // 返回一个设置为明年当前月的moment对象  
    nextYear: function(month) { },  
    // 用户点击去年时触发  
    // 返回一个设置为去年当前月的moment对象  
    previousYear: function(month) { },  
    // 点击导致月份发生变化时触发  
    // 返回一个设置为正确月份的moment对象  
    onMonthChange: function(month) { },  
    // fires any time the year changes as a result of a click action.  
    // if onMonthChange is also set, it is fired BEFORE onYearChange.  
    // returns a moment.js object set to the correct month and year.  
    //点击导致年份变化时触发，如果同时设置了onMonthChange，那么它将先于onYearChange触发，返回一个设置为正确年月的moment对象。  
    onYearChange: function(month) { },  
    // fired when a user goes to the current month &amp;amp; year.  
    // returns a moment.js object set to the correct month.  
    //当用户回到当前年月时触发，返回一个设置为正确月份的moment对象  
    today: function(month){ }  
  },  

  // this is called only once after clndr has been initialized and rendered.  
  // use this to bind custom event handlers that don&#39;t need to be re-attached  
  // every time the month changes (most event handlers fall in this category).  
  // hint: this.element refers to the parent element that holds the clndr,  
  // and is a great place to attach handlers that don&#39;t get tossed out every  
  // time the clndr is re-rendered.  
  //该方法只会在clndr初始化并且渲染完成后调用一次，用它来绑定自定义事件处理器（适用于那些当月份变化时不用重新绑定的事件处理器，大部分事件处理器都属于这一类），提示：this.element 引用承载clndr的父元素，这是一个绑定事件的好地方，因为它不会再clndr重新渲染时被销毁。  
  ready: function() { },  
  // a callback when the calendar is done rendering.  
  // This is a good place to bind custom event handlers  
  // (also see the &#39;ready&#39; option above).  
  //当clndr渲染完成时的回调函数。同样是用来绑定自定义事件处理器。  
  doneRendering: function(){ },  

  // 事件对象的数组  
  events: [],  
  // if you&#39;re supplying an events array, dateParameter points to the  
  // field in your event object containing a date string.  
  // It&#39;s set to &#39;date&#39; by default.  
  //如果你提供了一个事件数组，dateParameter指向了你事件对象里包含时间的域，默认是date  
  dateParameter: &#39;date&#39;,  
  // show the numbers of days in months adjacent to the current month  
  // (and populate them with their events). defaults to true.  
  // CLNDR can accept events lasting more than one day!  
  // just pass in the multiDayEvents option and specify what the start and  
  // end fields are called within your event objects. See the example file  
  // for a working instance of this.  
  multiDayEvents: {  
    startDate: &#39;startDate&#39;,  
    endDate: &#39;endDate&#39;  
  },  

  // show the dates of days in months adjacent to the current month.  
  // defaults to true.  
  showAdjacentMonths: true,  
  // when days from adjacent months are clicked, switch the current month.  
  // fires nextMonth/previousMonth/onMonthChange click callbacks. defaults to false.  
  adjacentDaysChangeMonth: false,  
  // always make the calendar six rows tall (42 days) so that every month has a  
  // consistent height. defaults to &#39;false&#39;.  
  forceSixRows: false,  

  // anything you want access to in your template  
  extras: { }  

  // if you want to use a different templating language, here&#39;s your ticket.  
  // Precompile your template (before you call clndr),  
  // pass the data from the render function into your template,  
  // and return the result. The result must be a string containing valid markup.  
  // The keyword &#39;this&#39; is set to the clndr instance  
  // in case you need access to any other properties.  
  // More under &#39;Template Rendering Engine&#39; below.  
  render: function(data){  
    return &#39;&amp;lt;div class=&amp;quot;html data as a string&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;;  
  },  

  // if you want to prevent the user from navigating the calendar outside  
  // of a certain date range (e.g. if you are making a datepicker), specify  
  // either the startDate, endDate, or both in the constraints option. You  
  // can change these while the calendar is on the page... See documentation  
  // below for more on this!  
  constraints: {  
    startDate: &#39;2017-12-22&#39;,  
    endDate: &#39;2018-01-09&#39;  
  }  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在你的模板里，你可以使用的变量如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// day-of-the-week 缩写的数组,  
// shifted as requested using the weekOffset parameter.  
daysOfTheWeek: [&#39;S&#39;, &#39;M&#39;, &#39;T&#39;, etc...]  
// the number of 7-block calendar rows,  
// in the event that you want to do some looping with it  
numberOfRows: 5  
// the days object, documented in more detail above  
days: [ { day, classes, id, events, date } ]  
// the month name- don&#39;t forget that you can do things like  
// month.substring(0, 1) and month.toLowerCase() in your template  
month: &amp;quot;May&amp;quot;  
// the year that the calendar is currently focused on  
year: &amp;quot;2013&amp;quot;  
// all of the events happening this month  
eventsThisMonth: [ ],  
// all of the events happening last month  
eventsLastMonth: [ ],  
// all of the events happening next month  
eventsNextMonth: [ ],  
// anything you passed into the &#39;extras&#39; property when creating the clndr  
extras: { }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###多日事件&lt;br /&gt;
CLNDR现在可以接受持续多天的时间。你只需告诉它如何得到事件的开始和结束日期。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var lotsOfEvents = [  
  { start: &#39;2013-11-04&#39;, end: &#39;2013-11-08&#39;, title: &#39;Monday to Friday Event&#39; },  
  { start: &#39;2013-11-15&#39;, end: &#39;2013-11-20&#39;, title: &#39;Another Long Event&#39; }  
];  

$(&#39;#calendar&#39;).clndr({  
  events: lotsOfEvents,  
  multiDayEvents: {  
    startDate: &#39;start&#39;,  
    endDate: &#39;end&#39;  
  }  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##配置&lt;br /&gt;
###模板渲染引擎&lt;br /&gt;
###国际化&lt;br /&gt;
Clndr对国际化支持的程度与Moment.js是一致的。&lt;br /&gt;
###Underscore模板定界符&lt;br /&gt;
如果你不喜欢&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt;风格的定界符，你可以正则表达式的形式给Underscore.js提供替代方案。&lt;br /&gt;
&lt;strong&gt;interpolate&lt;/strong&gt;：输出字符串(默认是&lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt;)&lt;br /&gt;
&lt;strong&gt;escape&lt;/strong&gt;：用来escaping html (默认是&lt;code&gt;&amp;lt;%- %&amp;gt;&lt;/code&gt;)&lt;br /&gt;
&lt;strong&gt;evaluate&lt;/strong&gt;：用来执行javascript(默认是&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;)&lt;br /&gt;
如果你更习惯Jinja2/Twig/Nunjucks风格的定界符，只需在实例化你的clndr之前先调用下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// switch to Jinja2/Twig/Nunjucks-style delimiters  
_.templateSettings = {  
  interpolate: /\{\{(.+?)\}\}/g,  
  escape: /\{\{\-(.+?)\}\}/g,  
  evaluate: /\{\%(.+?)\%\}/g  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###IE兼容问题&lt;br /&gt;
如果你打算支持IE8或更低，你需要注意版本问题。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>CSS 测试</title>
            <link>//blog.pytool.com/reship/2015-03-05-css-test/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-03-05-css-test/</guid>
            <description>&lt;p&gt;&lt;strong&gt;预备知识&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;grunt&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PhantomJS&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CasperJS&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们要谈的不是TDD，而是一种CSS测试的形式，叫做Visual Regression Testing，使得我们可以从视觉上比较网站正确的版本(baseline)和开发版本(new)。过程很简单，就是给网页进行快照，然后比较像素来寻找区别。&lt;/p&gt;

&lt;p&gt;##测试工具&lt;br /&gt;
我们将使用PhantomCSS进行测试。它是三个工具的强大结合：&lt;br /&gt;
1.PhantomJS&lt;br /&gt;
2.CasperJS&lt;br /&gt;
3.ResembleJS&lt;/p&gt;

&lt;p&gt;同时，我们想把整个过程自动化，所以会把PhantomCSS集成到Grunt。&lt;/p&gt;

&lt;p&gt;##搭建grunt&lt;br /&gt;
首先引入Anselm的Grunt PhantomCSS 项目到我们的Grunt项目中。因为它还没有NPM命名空间，所以只能直接从github上pull 下来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i --save-dev git://github.com/anselmh/grunt-phantomcss.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改Gruntfile.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.loadNpmTasks(&#39;grunt-phantomcss&#39;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续修改Gruntfile.js，对PhantomCSS进行一些配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phantomcss: {  
        options: {  
          mismatchTolerance: 0.05,  
          screenshots: &#39;baselines&#39;,  
          results: &#39;results&#39;,  
          viewportSize: [1280, 800],  
          },  
          src: [  
             &#39;phantomcss.js&#39;  
          ]  
      },  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;稍微解释下：&lt;br /&gt;
- misMatchTolerance：&lt;br /&gt;
- screenshots:保存baseline图片的文件夹&lt;br /&gt;
- results:比较结束后，结果会放到这个文件夹&lt;br /&gt;
- viewportSize:&lt;br /&gt;
- src:测试文件的路径，相对于gruntfile&lt;/p&gt;

&lt;p&gt;##测试文件&lt;br /&gt;
接下来，在我们的测试文件phantomcss.js文件中，就可以使用Casper.js了。PhantomCSS会启动一个PhantomJS浏览器，然后通过Casper.js进行各种导航和所需操作。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;casper.start(&#39;http://localhost:9001/cta-link.html&#39;)  
.then(function() {  
  phantomcss.screenshot(&#39;.cta-link&#39;, &#39;cta-link&#39;);  
})  
.then(function() {  
  this.mouse.move(&#39;.cta-button&#39;);  
  phantomcss.screenshot(&#39;.cta-link&#39;, &#39;cta-link-hover&#39;);  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##作比较&lt;br /&gt;
有了baseline的图片后，我们就可以不断地运行测试了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>DESIGNER&#39;S GUIDE TO DPI</title>
            <link>//blog.pytool.com/reship/2015-01-20-designers_guide_to_dpi/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-01-20-designers_guide_to_dpi/</guid>
            <description>

&lt;h1 id=&#34;designer-s-guide-to-dpi&#34;&gt;DESIGNER&amp;rsquo;S GUIDE TO DPI&lt;/h1&gt;

&lt;p&gt;===================&lt;/p&gt;

&lt;h5 id=&#34;原文地址-http-sebastien-gabriel-com-designers-guide-to-dpi-home&#34;&gt;&lt;a href=&#34;http://sebastien-gabriel.com/designers-guide-to-dpi/home&#34; target=&#34;_blank&#34;&gt;原文地址&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id=&#34;翻译-00-悦-http-weibo-com-u-1850506467&#34;&gt;&lt;a href=&#34;http://weibo.com/u/1850506467&#34; target=&#34;_blank&#34;&gt;翻译：00_悦&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;原创翻译，有不当的地方欢迎指出。转载请指明出处。谢谢！&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本文是为“初学者”或者作为从一开始就想要学习更多跨DPI和跨平台设计知识的中级设计师准备的序言读物。&lt;br /&gt;
没有复杂的计算和不可分析的图表，只是按照划分直截了当地将内容呈献给读者，便于读者理解或是直接运用到设计过程中。&lt;/p&gt;

&lt;p&gt;作者&lt;a href=&#34;http://sebastien-gabriel.com/&#34; target=&#34;_blank&#34;&gt;Sebastien Gabriel&lt;/a&gt;：&lt;br /&gt;
如果你发现有错误的地方，需要了解更多细节或者有任何问题或建议，请联系sgabriel.contact@gmail.com&lt;br /&gt;
&lt;a href=&#34;https://twitter.com/KounterB&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt;, &lt;a href=&#34;https://plus.google.com/+sebastiengabriel/posts&#34; target=&#34;_blank&#34;&gt;G+&lt;/a&gt; 或者 &lt;a href=&#34;https://www.facebook.com/sebastien.gabriel&#34; target=&#34;_blank&#34;&gt;Facebook&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是dpi-ppi&#34;&gt;什么是DPI、PPI&lt;/h3&gt;

&lt;p&gt;DPI(Dots Per Inch)是测量空间点密度的单位，最初应用于打印技术中，它表示每英寸能打印上的墨滴数量。较小的DPI会产生不清晰的图片。&lt;/p&gt;

&lt;p&gt;后来DPI的概念也被应用到了计算机屏幕上，计算机屏幕一般采用PPI（Pixels Per Inch）来表示一英寸屏幕上显示的像素点的数量，现在DPI也被引入。&lt;/p&gt;

&lt;p&gt;安装Windows操作系统的电脑屏幕PPI的初始值是96，Mac的初始值是72，虽然这个值从80年代起就不是很准确了。&lt;br /&gt;
一般来说，非retina桌面（包括Mac）的PPI的取值区间在72-120之间，因为这个取值区间能够确保你的作品在任何地方都能保持大致相同的比例。&lt;/p&gt;

&lt;p&gt;这里有一个应用实例：&lt;br /&gt;
27寸Mac影院显示屏的PPI是109，这表示在每英寸的屏幕上显示了109个像素点。斜角长是25.7英寸（65cm），实际屏幕的宽度大概是23.5英寸，23.5 * 109约等于2560，因此原始屏幕分辨率就是2560 * 1440px。&lt;/p&gt;

&lt;p&gt;*我知道 23.5 * 109不是恰好等于2560.实际上是23. 486238532英寸。要是用每厘米的像素点计算，会更加准确，但是这里你知道就行。&lt;br /&gt;
 &lt;img src=&#34;http://p6.qhimg.com/t01d984e4a0201a471d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;影响&#34;&gt;影响&lt;/h3&gt;

&lt;p&gt;在屏幕上设计一个前面我们讨论过的109*109px的蓝色正方形。&lt;/p&gt;

&lt;p&gt;这个正方形在1*1英寸的屏幕上有一个初始的物理尺寸，但是如果用户的PPI是72，蓝色正方形就会显得更大。因为PPI是72时，屏幕需要大约1英寸半的尺寸来展示109px的蓝色正方形。模拟效果如下图所示：&lt;br /&gt;
 &lt;img src=&#34;http://p7.qhimg.com/t012f8cfd2c30bd7176.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;附加：&lt;br /&gt;
不考虑颜色和分辨率差异，因为每个人看到的设计都是不同的。你应该力求达到平衡，满足大多数的用户的需求就可以了。不要期待用户拥有和你一样好的屏幕。&lt;/p&gt;

&lt;h3 id=&#34;屏幕分辨率-原始分辨率&#34;&gt;屏幕分辨率（原始分辨率）&lt;/h3&gt;

&lt;p&gt;屏幕分辨率对用户如何理解设计有很大的影响。幸运的是，自从LCD显示器代替了CRT，现在的用户更趋向于使用原始分辨率，它保证了好的屏幕尺寸或者说PPI比例。&lt;/p&gt;

&lt;p&gt;分辨率定义了屏幕上显示的像素数量（比如：27寸的显示器分辨率是 2560 * 1440px，2560是宽，1440是高）。在了解了PPI之后，我们就知道它不是一个测量物理大小的单位。你可以有一个 2560 * 1440屏幕，它能跟墙一般大，也可以跟脑袋一般小。&lt;/p&gt;

&lt;p&gt;如今的LCD显示器有分辨率初始值或者原始分辨率来确定屏幕上展示像素点的数量。它和过去的CRT显示器稍有不同，这里就不赘述了。&lt;/p&gt;

&lt;p&gt;一个27寸的影院显示屏，原始分辨率为2560*1440px，PPI为109。如果减小分辨率，元素将会显示得更大，因为有23.5英寸的水平宽度需要数量远远不够的像素点来填满。&lt;br /&gt;
 &lt;img src=&#34;http://p1.qhimg.com/t017330cee08d7a3a19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如例子所示，屏幕的原始分辨率是2560*1440px。如果分辨率减小，像素点还是被展示在PPI为109的屏幕上。你的操作系统会自动拉伸所有元素来填补间隙，使得整个屏幕被填满。GPU/CPU会捕获所有像素点并且使用新的比例重新计算他们。&lt;/p&gt;

&lt;p&gt;如果想要设置27寸屏幕分辨率为1280*720（之前宽的一半，高的一半），GPU会让一个像素点变成原来的2倍大来填充屏幕，那么结果就是会变得模糊。在分辨率为原来一半的时候，因为有简单分频器的存在可能看着还算可以。但是如果使用原来的1/3或者3/4，最终会以小数点结束，就不能等分一个像素点了。我们来看下面的例子：&lt;br /&gt;
 &lt;img src=&#34;http://p7.qhimg.com/t0186ffe5be906661ed.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;思考后面的例子：在原始分辨率的屏幕上画一条1px的线，然后设置分辨率为50%。为了填满屏幕，CPU需要制造150%的视觉效果，所有像素点都要乘以1.5，1*1.5=1.5，但是因为不能有半个像素点，这就使得填充周围的像素点的颜色只有一部分，便产生了模糊。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p4.qhimg.com/t0133bc14835137ddeb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这就是为什么当你想要改变一台Retina Macbook Pro的分辨率的时候，系统会展示下面的窗口来让你知道（下面的屏幕截图）这个分辨率会“看着像”1280*800px，它采用用户的分辨率经验来表达尺寸比例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p9.qhimg.com/t014194747764b5522f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这些描述带有浓重的主观色彩，因为它用像素分辨率作为衡量物理尺寸的单位，虽然不够严谨，但至少他们觉得是对的。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
如果你希望你的设计精确到像素，那么最好不要改变原始分辨率。你也许觉得使用小的比例会更舒服，但是当涉及到像素点时，这样会影响精确性。有些时候，用户会把调整分辨率当作在控制屏幕（特别是桌面）美观程度的方式，这样虽然会让设计看起来不太好，但是可以满足用户对易读性的需求。&lt;/p&gt;

&lt;h3 id=&#34;什么是4k&#34;&gt;什么是4K&lt;/h3&gt;

&lt;p&gt;你也许听到过很多次4K，它在最近非常流行。在了解它是什么之前，我们需要先弄明白“HD”的含义。&lt;/p&gt;

&lt;p&gt;需要事先声明的是，本文是简化版本，所以这里只考虑最常见的分辨率。HD有不同的类别。&lt;/p&gt;

&lt;p&gt;它适用于从1280*720px或720p开始的720水平的任何分辨率。一些地方也将这个分辨率SD叫做标清。&lt;/p&gt;

&lt;p&gt;全高清适用于1920*1080px的屏幕。大多数的TV以及越来越多的高端手机（Galaxy SIV, HTC one, Sony Xperia Z, Nexus5）都是这个分辨率。&lt;/p&gt;

&lt;p&gt;4K始于3840*2160像素，它也叫做Quad HD，被称为UHD超高清。简而言之，你可以放4个1080p的像素点在4K的屏幕上。&lt;/p&gt;

&lt;p&gt;另外一个4K的分辨率是4096*2160，这个稍微大一点，一般用在投影仪和大画幅相机上。&lt;br /&gt;
 &lt;img src=&#34;http://p1.qhimg.com/t01e33ca7765ae9206c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;computer如果我外接一个4k的显示器到电脑会发生什么呢&#34;&gt;computer如果我外接一个4k的显示器到电脑会发生什么呢？&lt;/h4&gt;

&lt;p&gt;最新的OS不再参照4K的比例，这意味着给Chromebook或者macbook外接一个4K显示器，将会使用最高的DPI。假如这样，200%或者@2x，按照正常比例展示就会看起来很好但是有点小。&lt;/p&gt;

&lt;p&gt;假设的例子：如果你外接一个12寸4k屏幕到12寸高清屏幕（2x）的电脑，所有东西都会显得小了两倍。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
- 4k就是四倍全高清。&lt;br /&gt;
- 如果现在的OS掌握了4k但是又不按照比例来，这说明现在还没有特定的4k资源。&lt;br /&gt;
- 如今没有手机或者平板电脑使用4k.&lt;/p&gt;

&lt;h3 id=&#34;显示器赫兹&#34;&gt;显示器赫兹&lt;/h3&gt;

&lt;p&gt;稍微从PPI和屏幕分辨率中休息一下，来看个小知识。你可能注意到在屏幕设置中靠近分辨率的地方有显示器的Hz值，它和PPI没什么关系，显示器赫兹或者刷新频率是显示器每秒展示固定图像或者帧的速度单位，比如一个60 Hz的显示器每秒可以显示60帧，同样，一个120 Hz的显示器每秒可以显示120帧。&lt;/p&gt;

&lt;p&gt;在UI环境中，显示器赫兹(Hz)决定了动画的流畅和精细程度，大多数的屏幕都是60Hz。而每秒显示的帧数依赖于设备处理图像的能力，像在Atari 2600使用120Hz屏幕就没有太大的用处。&lt;/p&gt;

&lt;p&gt;下面这个例子，可以帮助大家更好地理解。T-rex同时在60Hz和120Hz的屏幕上以完全相等的步伐快速从A点到B点，60fps的屏幕上展示了9帧动画，而在相同时间内120fps的屏幕展示了2倍帧数，并且动画在120Hz屏幕上会显得更加流畅。&lt;br /&gt;
 &lt;img src=&#34;http://p5.qhimg.com/t0193d410318c839943.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
也许有人会说，每秒显示60帧以上人眼是无法识别的，这是错误的。&lt;/p&gt;

&lt;h3 id=&#34;what-is-a-retina-display什么是视网膜显示屏&#34;&gt;What is a retina display什么是视网膜显示屏&lt;/h3&gt;

&lt;p&gt;“Retina（视网膜）显示屏”是Apple公司在发布iPhone 4时引入的。之所以叫做Retina是因为设备的PPI非常高以至于人的视网膜也不能在屏幕上分辨出像素点来。&lt;/p&gt;

&lt;p&gt;这个说法在现在的设备的屏幕范围内是正确的，但是随着屏幕越来越好，我们的眼睛也会被训练得足够感知像素点，特别是圆形的UI元素。&lt;/p&gt;

&lt;p&gt;从技术的角度来讲，他们做的就是在完全相同的物理大小上展示比原来高和宽多一倍的像素点。&lt;/p&gt;

&lt;p&gt;iPhone 3G/S是3.5英寸的斜角，分辨率为480*320px，PPI为163。&lt;br /&gt;
iPhone 4/S是3.5英寸的斜角，分辨率为960*640px，PPI为326。&lt;br /&gt;
 &lt;img src=&#34;http://p3.qhimg.com/t010e06da3608c18896.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;事实证明正好是两倍的关系，同样的物理大小，屏幕上的元素却有两倍的清晰度，因为他们有两倍的像素点。1个标准的像素＝4个Retina像素，像素的四倍。&lt;/p&gt;

&lt;p&gt;思考下面的例子，在复杂设计中如何直接应用：&lt;br /&gt;
 &lt;img src=&#34;http://p1.qhimg.com/t0194e590e2849b5b98.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图注：在第三方设备上很难模拟出来自不同设备的不同图片质量，如上图所示，Retina的音乐播放器虽然与iPhone 4的音乐播放器有相同的物理空间，但图片质量看上去比iPhone 4好了两倍并且更清晰。如果大家想在本地进行验证，我会提供免费的演示事例源码，供大家&lt;a href=&#34;http://sebastien-gabriel.com/freebies/Grey-UI.zip&#34; target=&#34;_blank&#34;&gt;下载&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为“Retina”显示屏的命名归Apple公司所有，所以其他公司使用“HI-DPI”或者“超大像素sp33d显示器”（我将注册这个）或者其他的来表示。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
使用Apple的产品是熟悉DPI换算，理解分辨率、PPI、物理尺寸比例之间差异的极佳方式，因为你只需要考虑一个像素比。&lt;/p&gt;

&lt;h3 id=&#34;什么是像素比&#34;&gt;什么是像素比&lt;/h3&gt;

&lt;p&gt;当你的设计需要在不同PPI下转换时，像素比就是你的救星。当你知道像素比后，就不需要再考虑设备的详细规格了。&lt;/p&gt;

&lt;p&gt;以iPhone 3G和4为例，相同物理大小上iPhone4的像素点是3G两倍，因此像素比就是2，这表示只需要用你的资源乘以2，就可以兼容4G的分辨率了。&lt;/p&gt;

&lt;p&gt;让我们先创建一个44*44px的iOS上被推荐的touch按钮（我后面会介绍），定义为典型按钮“Jim”。&lt;br /&gt;
为了让Jim在iPhone 4上看起来更好，需要创建一个它两倍大小的版本。下面就是我们做的。&lt;br /&gt;
 &lt;img src=&#34;http://p6.qhimg.com/t015c3321519d59ab50.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;很简单。现在的Jim，一个是标准PPI（iPhone 3）的Jim.png版本，一个是200%PPI（iPhone 4）的Jim@2x.png版本。&lt;/p&gt;

&lt;p&gt;现在你也许会问，“等等啊！我很确定还有其他的像素比，不止这两个。”有，这是一个噩梦。好吧，也许不是噩梦，但是我很肯定你宁愿花一天时间熨袜子也不想处理无数的像素比。幸好这也没有你想象的那么严重，我们后面再说。&lt;/p&gt;

&lt;p&gt;让我们先说说单位，因为现在比起像素，你更需要单位来规范多DPI设计。这就是DP和PT起作用的地方。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
对于每一个你正在做的设计，像素比都是需要知道的。像素比把屏幕大小和PPI结合起来，让人们更理解它们。&lt;/p&gt;

&lt;h3 id=&#34;什么是dp-pt-sp&#34;&gt;什么是DP、PT、SP&lt;/h3&gt;

&lt;p&gt;DP或PT是测量单位，你可以用来规范你的各种设备和多DPI的app模型。&lt;br /&gt;
DP(Dip)表示独立于设备的像素点，PT表示点。DP用在Android上，PT用在Apple上，但是他们本质上是相同的。&lt;/p&gt;

&lt;p&gt;简而言之，它能定义独立于设备的像素比的大小，这会包含在不同角色（如设计师和工程师）之间的讨论规则中。&lt;/p&gt;

&lt;p&gt;继续说前面“Jim”按钮的例子。&lt;br /&gt;
Jim在标准的非Retina屏幕上宽度为44px，在Retina屏幕上是88px。从技术上给Jim添加20px的padding，在Retina上padding是40px。但是，当你基于非Retina屏幕设计时计算Retina的像素值并没什么意义。&lt;/p&gt;

&lt;p&gt;因此我们需要做的就是以标准的100%非Retina比例作为一切设计的基础。&lt;br /&gt;
 &lt;img src=&#34;http://p1.qhimg.com/t01bb605a90f390b670.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这种情况下，Jim的大小就是44*44DP（PT），padding为20DP（PT）。你可以在任何PPI上执行你的规范，Jim仍然是44*44dp/pt.&lt;/p&gt;

&lt;p&gt;Android和iOS会调整自身大小适应屏幕并且使用正确的像素比来进行换算，这就是为什么我发现使用屏幕的原始的PPI设计会更简单。&lt;/p&gt;

&lt;p&gt;SP和DP、PT从用途上来讲是不同的，但是工作方式相同。SP表示与比例无关的像素，通常用来定义字体大小，SP受用户Android设备字体设置的影响。作为一个设计师，为任何事物定义SP就像定义DP，最好基于清晰的1x的比例（以16sp为例，它是非常便于阅读的字体大小）。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
始终使用分辨率或者非比例的值作为规范。屏幕尺寸、分辨率种类越多，它就越重要。&lt;/p&gt;

&lt;h3 id=&#34;ppi配置&#34;&gt;PPI配置&lt;/h3&gt;

&lt;p&gt;现在，你已经知道PPI、Retina、像素比是什么了，接下来我们要讨论的是 “如果我在设计工具里改变PPI配置，会发生什么呢？”&lt;/p&gt;

&lt;p&gt;如果你问自己这个问题，那就表示你对设计软件比较熟悉。&lt;/p&gt;

&lt;p&gt;任何非打印的设计使用像素大小不用考虑原始PPI配置。&lt;/p&gt;

&lt;p&gt;软件PPI配置是打印的一个传统。如果你只是做web设计，PPI对位图大小没有影响。&lt;/p&gt;

&lt;p&gt;这就是我们使用像素比而不直接用PPI值的原因。你的画布和图像总是会被被软件按照对应的像素比换算成像素点。&lt;/p&gt;

&lt;p&gt;这里有个例子。你可以在允许配置PPI值的软件（比如Photoshop）里面进行试验。我在Photoshop上画了两个80*80px的正方形和16pt的文本，一个配置的PPI值是72，另一个是144。&lt;br /&gt;
 &lt;img src=&#34;http://p9.qhimg.com/t018f6f9525c1771e9e.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p4.qhimg.com/t01087a71195fdfa064.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如你所见，文本变大了，准确点说是两倍大，然而正方形还保持不变，原因就是Photoshop按照PPI值放大了pt值，结果在PPI值变为两倍的情况下文本大小增加为原来两倍。而用像素定义的蓝色正方形，保持了原来大小。像素就是一个像素点，不管PPI怎么配置它会一直保持一个像素。造成这个差异的是用来显示它的屏幕的PPI值。&lt;/p&gt;

&lt;p&gt;我们需要记住的是在做数字化设计的时候，PPI只会影响你对设计的感知、你的工作流和以pt为单位的图案例如字体。如果你在工作资源文件里包含了各种PPI配置，程序就会根据接收到的文件的PPI比例在不同的文件里调整转移视觉的大小，这会成为一个需要解决的问题。&lt;/p&gt;

&lt;p&gt;那么，解决方案是什么呢？就是坚持使用PPI（对于1x设计，最好控制在72-120之间）。我个人使用72PPI，因为这是Photoshop的默认配置，我的同事也是。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
- PPI配置对输出到web上的设计毫无影响。&lt;br /&gt;
- PPI配置只对基于PPI独立计量（比如PT）产生的图案有影响。&lt;br /&gt;
- 像素是任何数字化设计的度量单位&lt;br /&gt;
- 保持像素比以及设计的目标，而不是PPI&lt;br /&gt;
- 在进行数字化设计时使用实际的PPI配置，你会感受到它在目标设备上的样子（以1x的web/桌面设计72-120ppi为例）。&lt;br /&gt;
- 在你的文件中自始至终保持相同的PPI配置&lt;/p&gt;

&lt;p&gt;关于这个的额外趣味阅读&lt;a href=&#34;http://graphicdesign.stackexchange.com/questions/13777/is-it-mandatory-to-keep-72-dpi-for-web-design-what-if-i-create-in-200dpi&#34; target=&#34;_blank&#34;&gt;StackExchange post&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;ios上的ppi处理&#34;&gt;iOS上的PPI处理&lt;/h3&gt;

&lt;p&gt;是时候钻研下特定平台的设计了。&lt;/p&gt;

&lt;p&gt;让我们花点时间看看2014年年初时的iOS设备。&lt;br /&gt;
从屏幕大小和DPI的角度来看，iOS有两种类型的手机设备和两种类型的笔记本/台式电脑屏幕。&lt;/p&gt;

&lt;p&gt;对于手机，有iPhone和iPad。&lt;br /&gt;
在手机分类中，有过去的3GS（iOS6依旧支持）和更高版本，其中只有iPhone 3GS是非Retina。iPhone 5以及后来的都用了和iPhone 4/4s有相同DPI的更好的屏幕。让我们来看看下面的列表：&lt;br /&gt;
 &lt;img src=&#34;http://p8.qhimg.com/t01d8b37a500f0dd582.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2014年9月Apple宣布，现在又有2个新类别的iPhone：iPhone 6和iPhone 6 Plus。&lt;/p&gt;

&lt;p&gt;iPhone 6比5要大一点（0.7英寸左右），但是PPI相同。iPhone 6 Plus由于它的尺寸，5.5英寸，产生了iOS上新的像素比，@3x。&lt;br /&gt;
 &lt;img src=&#34;http://p5.qhimg.com/t014db279ea03d1b599.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;相较于其他iPhone，iPhone 6 Plus控制展示比较特殊的是：视觉效果降频。&lt;/p&gt;

&lt;p&gt;以为iPhone 6设计为例，设计的画布为1334*750px，手机上就呈现1334*750的物理像素。当为iPhone 6 Plus时，手机的分辨率小于渲染的图像，因此你设计的分辨率为2208*1242px，展示时降频为1920*1080px。如下图：&lt;br /&gt;
 &lt;img src=&#34;http://p4.qhimg.com/t01087a71195fdfa064.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;物理分辨率比渲染分辨率小15%，会造成一些细节问题，比如半像素使得精细的地方变模糊。分辨率如此高也是很微妙的，除非你近距离观察。因此，在2208*1242px的画布上设计，需要注意设计中真正精细的地方，像是分隔符。模拟如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p0.qhimg.com/t019069429098a7c63b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&#34;http://www.paintcodeapp.com/&#34; target=&#34;_blank&#34;&gt;Paintcode&lt;/a&gt;的说明，看看他们专门的页面。&lt;a href=&#34;http://www.paintcodeapp.com/news/iphone-6-screens-demystified&#34; target=&#34;_blank&#34;&gt;点击查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在iPod touch分类中，iPod第四代出来的时候使用的是iOS6和非Retina。iPod第五代以及后面的都使用Retina屏幕并且兼容iOS7，它的屏幕大小与iPhone 5相同。&lt;/p&gt;

&lt;p&gt;最后说说iPad。除了iPad 第一代，其余的都用的是iOS7，同时只有iPad2和iPad mini是非Retina屏幕。从设计的角度来看，iPad mini只是普通的iPad（一样的PPI屏幕），但是物理体积更小，也就是说它们拥有相同的分辨率，只是大小从9.7英寸减小到了7.9英寸。保持同样的比例，便会相应地增大像素点的密度，你的虚拟资源就会显得更小了。&lt;br /&gt;
 &lt;img src=&#34;http://p7.qhimg.com/t01f87bde23a62d810f.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
 &lt;img src=&#34;http://p4.qhimg.com/t017d8b32db776d9977.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至于台式机和笔记本，我们不会全面讨论Apple提供的各种尺寸的屏幕。在今天，Apple提供的几乎都是1x像素比的Retina屏幕（Macbook，Macbook Air，旧版Macbook Pros，台式机显示器），Retina只应用于13和15寸的Macbook Pro。iPad和iPhone像素比是2x。为台式机设计与手机设计不同的是，你需要以相同方式设计来覆盖这两种不同类别的屏幕。&lt;/p&gt;

&lt;p&gt;当只使用一种像素比时，基于iOS和OSX的设计是非常简单的。我建议开始设计时先用基础的PPI（例如，100%/1x）然后增加到2x并在2x的屏幕上校验你的设计并且生成2x的资源。当你熟悉在1x和2x之间切换设计后，就能够直接在2x上进行设计了，低分辨率时资源更小。如果你正在为Retina屏幕设计的话（Macbook Pro），这就特别有用。&lt;/p&gt;

&lt;h4 id=&#34;引入资源-chrome为例&#34;&gt;引入资源，chrome为例&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://p4.qhimg.com/t016679f7780642640c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，每次请求资源需要传送两张图片。非Retina下图片名为name.png，Retina的图片增加到@2x命名为@2x.png，这是iOS开发约定的命名规范。&lt;/p&gt;

&lt;p&gt;如果你创建了一个图片只用在iPad上，我们在.@2x后面加上~iPad，这仅仅只是chrome的约定。对需要的资源都这样处理，不要只用一个版本的资源来覆盖所有DPI。&lt;/p&gt;

&lt;p&gt;附加, iOS规则集:&lt;br /&gt;
- @2x的资源必须始终是1x资源的两倍。&lt;br /&gt;
- Retina资源加上@2x.&lt;br /&gt;
- 始终创建100%和200%比例的图片。&lt;br /&gt;
- 1x和2x的资源始终要保持名字相同。&lt;br /&gt;
- 在100%比例下开始设计，然后做乘法。&lt;br /&gt;
- 传递.png格式的图片。&lt;br /&gt;
- 使用pt创建规范而不是px。&lt;/p&gt;

&lt;h3 id=&#34;android上的ppi处理&#34;&gt;Android上的PPI处理&lt;/h3&gt;

&lt;p&gt;Android平台的设备种类比iOS多，因为任何OEM都可以生产设备并且几乎没有比例的限制，然后加上自己版本号。结果就是生产出几乎无限制的屏幕大小和DPI种类，电话和平板电脑一样大，或者电话和平板电脑一样小的情况比比皆是。为此，你的设计总是需要做适配。&lt;/p&gt;

&lt;p&gt;在这个部分，我们将采用不同于iOS的方法，我们先来讨论下像素比和DPI分类。&lt;/p&gt;

&lt;p&gt;Android设备可以分为两类：手机和平板电脑。这两种设备又可以按照不同DPI分为：ldpi、mdpi、 tvdpi、 hdpi、 xhdpi、 xxhdpi和xxxhdpi。&lt;/p&gt;

&lt;p&gt;幸好，有些比其他使用得更加频繁，有些甚至已经弃用了。&lt;/p&gt;

&lt;p&gt;首先我们要找到等价于iOS上1x的基础单位。在Android上，这个基础单位就是MDPI。&lt;/p&gt;

&lt;p&gt;让我们看看下面列表的像素比。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p6.qhimg.com/t01b9522b73325c38f5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;是的，很多，而且还没有完，还有一个落下了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p6.qhimg.com/t0105727e95b0cd8847.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，目前正在使用的DPI有4个：MDPI, HDPI, XHDPI和XXHDPI。&lt;br /&gt;
LDPI是过时的DPI，现在已经不再使用，TVDPI是TV UI的特殊例子，在2012年版的Nexus 7中短暂使用过，在手机和平板电脑的使用中没有考虑的必要。尽管如此，TVDPI的像素比（1.33x）还是被用在一些安卓系统的设备上，像是LG G手表，我们后面来讨论这个。&lt;/p&gt;

&lt;p&gt;让我们结合带着各自DPI的Android手机和平板电脑全面客观地看待事物。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p3.qhimg.com/t019ea0bf889b12539b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p4.qhimg.com/t01751a57134c9f0f8e.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p5.qhimg.com/t011c20633b40ce7a5c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p6.qhimg.com/t01b0ce546071a09191.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p5.qhimg.com/t010810bc954c96fed0.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p5.qhimg.com/t0195c735b96953cb0f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p6.qhimg.com/t01581b7ba47c168785.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;也许在现在这个时候有一个设备使用XXXHDPI的实际app资源，但也不是很常见。如果你能用额外时间生产XXXHDPI资源，你的app便不会过时。&lt;/p&gt;

&lt;h4 id=&#34;引入资源-chrome为例-1&#34;&gt;引入资源，chrome为例&lt;/h4&gt;

&lt;p&gt;每次请求资源都需要传递一组4张图片，从MDPI到XXHDPI，无需考虑LDPI。注意，在下面的chrome版本中，TVDPI的输入在这个例子里的5张图片里也很清楚。&lt;/p&gt;

&lt;p&gt;和iOS一样，我建议把100%或者1x的像素比作为你设计的基础，这会让设计在适配其他像素比的时候容易一点，特别是在像素比为1.33和1.5的安卓系统上。&lt;/p&gt;

&lt;p&gt;看看下面安卓上chrome的返回按钮的例子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p7.qhimg.com/t01fc3e2b9d8c0bba19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DPI后面跟着的建议名称不是安卓官方指南强制要求的，这是我们为资源取名的方式，因为现在有限的设计工具很难给每个资源定义一个路径。&lt;br /&gt;
考虑到一个资源有时有上百个资源文件，站在设计师的角度来说这是使输出过程不那么痛苦以及避免重命名错误的一个途径。资源在资源仓库里面的存储方式是有结构的，参考后面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;drawable-mdpi/asset.png&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;drawable-hdpi/asset.png&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;etc&amp;hellip;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如你所见，资源被截成了32*32dp的正方形，Android像素比也会是小数。当用1.33或者1.5乘以一个数的时候，最后的结果很有可能就是小数。在这种情况下你需要通过四舍五入来让数字变得有效。在这个例子中，32*1.33=42.56所以四舍五入之后是43px。&lt;/p&gt;

&lt;p&gt;你需要注意以像素为单位的元素，比如笔画。你需要确保你的笔画既不是1px宽也不是2px同时也不像屏幕分辨率部分描述的那样模糊。&lt;/p&gt;

&lt;p&gt;附加, Android规则集:&lt;br /&gt;
- Android有7种不同的DPI，你需要关注其中的4个：mdpi,hdpi,xhdpi,xxhdpi，如果希望你的app面向未来，可以关注XXXHDPI。&lt;br /&gt;
- MDPI是基础的DPI或者1x像素比&lt;br /&gt;
- Android使用dp代替pt当作参数规格，但是他们是一样的。&lt;br /&gt;
- 用你最好的判断来处理小数像素比。&lt;br /&gt;
- 传递.png格式图片。&lt;br /&gt;
- 确保检验命名约定，与执行负责人共同完成输出进程。&lt;/p&gt;

&lt;h3 id=&#34;mac-chrome-os上的ppi&#34;&gt;Mac、Chrome OS上的PPI&lt;/h3&gt;

&lt;p&gt;Mac（OSX）和Chrome OS在处理PPI方面是十分相似的。&lt;br /&gt;
两个OS都支持常规的PPI（100%）和hi-res/retina PPI(200%)。像iPhone和iPad，就只有2x像素比。&lt;/p&gt;

&lt;p&gt;即使大多数的用户都使用Mac和Chrome OS，但是也有用户会在低分辨率的设备上使用，我强烈建议将你的app面向未来的高端屏幕。面向未来对于ChromeOS意味着为Web-app或者网站创建hi-res资源，那绝不是浪费时间。当前有3种笔记本处理PPI，13寸、15寸Macbook pro以及Chromebook Pixel。除此之外，Chromebook Pixel还处理了touch。&lt;br /&gt;
 &lt;img src=&#34;http://p1.qhimg.com/t0132d677167e0a7b0a.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;引入资源-chrome为例-2&#34;&gt;引入资源，chrome为例&lt;/h4&gt;

&lt;p&gt;Chrome的工具栏按钮资源就是相似性最好的例子。我们在两个平台上使用完全相同按钮，即使代码不同，视觉上也是一样的。看下面这个chrome菜单按钮的例子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p8.qhimg.com/t018854ad3e583920fa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
- Chrome OS和OSX像素比相同，都是2.&lt;br /&gt;
- Chrome OS高分辨率展示也处理touch。&lt;/p&gt;

&lt;h3 id=&#34;可拉伸资源&#34;&gt;可拉伸资源&lt;/h3&gt;

&lt;p&gt;不管你的app是在桌面或者手机上。你通常都会引入可拉伸资源。&lt;/p&gt;

&lt;p&gt;可拉伸资源的建立会使代码在没有减少渲染的情况下比实际需要的多。&lt;/p&gt;

&lt;p&gt;他们与可重复资源即使有的时候展示结果一样，工作方式也是不同的。&lt;/p&gt;

&lt;p&gt;看看下面这个Chrome的例子。iOS上的工具栏在整个屏幕上只用了一个在x轴上平铺的超细资源。&lt;br /&gt;
 &lt;img src=&#34;http://p7.qhimg.com/t01c2c12f816ca25710.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在这种方式已经过时了，让我们来看看不同平台如何处理可拉伸资源。&lt;/p&gt;

&lt;h4 id=&#34;ios上的可拉伸资源&#34;&gt;iOS上的可拉伸资源&lt;/h4&gt;

&lt;p&gt;对iOS的设计师来说这个很简单，因为拉伸在代码里面定义比资源片段或者标记方式好。所有需要做的就是提供一个基础图片，如果你自己还没有实现这个，可以将你的资源规范定义为水平或者竖直可扩展，或者两者均可。看看下面这个iOS上Chrome的默认按钮的例子。&lt;br /&gt;
 &lt;img src=&#34;http://p1.qhimg.com/t01979f8b5178c966b1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;android上的可拉伸资源&#34;&gt;Android上的可拉伸资源&lt;/h4&gt;

&lt;p&gt;Android有和iOS不一样的处理可拉伸资源的方式，它更依赖设计师一点。&lt;/p&gt;

&lt;p&gt;在这个平台你将采用九宫格，这些辅助线包括了4条围绕资源本身的线。他们必须被当作资源的一部分来传递片段/图片，用它来准确的呈现视觉规格。&lt;/p&gt;

&lt;p&gt;他们定义了两个区域：可拉伸区域和填充区域。一旦定义好，代码就只会拉伸可拉伸区域，并把内容放在你定义的填充区域。&lt;/p&gt;

&lt;p&gt;看看下面的例子，就是你前面看到的Chrome默认按钮的Android版本。为了演示，我把他放大了。&lt;br /&gt;
 &lt;img src=&#34;http://p3.qhimg.com/t01bdbfac545ddd1676.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如你所见，这个九宫格是一组4条纯白色的bar。他们在任何DPI下都是宽1px，这是代码表示的。可拉伸区域不包括圆角因为圆角不能平铺开（否则看起来很难看）。在这个例子中，我们给按钮添加了规格允许范围内10dp的padding。.9也需要平铺并且截断部分要100%透明。如果不这样，他就不能正常工作，需要修改。&lt;br /&gt;
 &lt;img src=&#34;http://p9.qhimg.com/t0140cadf16b1150f8c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用九宫格要求在名称后面加上.9，和在iOS资源上添加@2x的方式一样。重命名按钮的例子如下：&lt;br /&gt;
 &lt;img src=&#34;http://p8.qhimg.com/t018175915339ea2559.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在你需要非常注意你的资源大小。如果我在演示中放大了它，你就需要通过减小它的尺寸到一个最小限度来优化资源，如后面所示。保持了圆角的原样，但是将可拉伸和内容区域减小到最小限度。&lt;br /&gt;
 &lt;img src=&#34;http://p9.qhimg.com/t01e011a923d9a0abde.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是九宫格的标记不会和设计重叠，并且资源切割是合理的。.9需要尽可能靠近资源并不与之重叠，试着不内置padding。前面的例子因为阴影而内置了padding。&lt;/p&gt;

&lt;p&gt;九宫格不会代替你导出每种DPI的资源。它需要在每个资源版本都实行。&lt;/p&gt;

&lt;p&gt;最后一点，.9可以有许多可拉伸区域（上面和左边），虽然我没有经常遇到这样的情况，但它也是很值得尝试的。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
总是采取最好的解决方案来实现设计，特别是桌面设计。图片越多，app就会变得越沉重。追踪和更新资源也变得困难。九宫格应该使用在命名有规范、组织结构良好的资源中。&lt;/p&gt;

&lt;h3 id=&#34;touch和触摸目标&#34;&gt;Touch和触摸目标&lt;/h3&gt;

&lt;p&gt;首先需要知道的是做触屏相关的准备和DPI一点关系也没有。但是当涉及到设计UI或者创建资源，弄清楚触屏和DPI的关系就很重要。&lt;/p&gt;

&lt;p&gt;选择触屏或者非触屏很大程度上取决于app的适用范围，它被部署在哪里以及希望得到怎样的用户体验。&lt;br /&gt;
我们可以简单地将他们分为：非触屏的桌面应用和手机app。&lt;/p&gt;

&lt;h4 id=&#34;台式机-非触屏&#34;&gt;台式机, 非触屏&lt;/h4&gt;

&lt;p&gt;直到2005年，触屏才开始出现在计算机技术中。&lt;br /&gt;
我们使用鼠标和键盘，它们能够非常准确的操作UI。鼠标光标的精度是1pt，也就是说理论上你可以创建一个能让任何人点击的1*1pt的按钮。&lt;/p&gt;

&lt;p&gt;请看下面图解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p2.qhimg.com/t01a051035a88230838.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是个Chrome OS光标的20x版本。&lt;br /&gt;
红色区域是能在UI上触发一个事件的实际区域，十分准确。&lt;br /&gt;
你知道我的标题。什么是不准确的呢？手指。&lt;/p&gt;

&lt;p&gt;那么如何为触屏设计呢？最好的办法就是让所有东西变得更大。&lt;/p&gt;

&lt;h4 id=&#34;手指大小&#34;&gt;手指大小&lt;/h4&gt;

&lt;p&gt;这里有交互中最常用到的两根手指（食指和大拇指）的平均大小，这代表了触摸区域和被手指遮挡了的区域。实际的触摸区域（例如，你手指接触屏幕的那部分）当然会小一点并且更准确，除非你把你的手指压在屏幕上。&lt;/p&gt;

&lt;p&gt;在设计触屏的时候，放大触摸目标的尺寸比低估更安全。&lt;br /&gt;
 &lt;img src=&#34;http://p7.qhimg.com/t013e3530d6b282ed34.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;如何将此应用到我的设计流程&#34;&gt;如何将此应用到我的设计流程&lt;/h4&gt;

&lt;p&gt;如我们已经看到的，在像素世界英寸或者厘米并不是一个好的计量方法，即使是像素也不是真正好的计量方法。所以你怎么确保你的设计是可被触摸的呢？&lt;/p&gt;

&lt;p&gt;我虽然讲了很多理论知识，但是更重要的是自己试着在目标设备/台式机上设计。&lt;br /&gt;
但是为了避免浪费更多时间，有一些基础的像素的大小使用起来是比较安全的，并且被推荐使用在每个OS上。&lt;/p&gt;

&lt;h4 id=&#34;各平台推荐的触屏目标&#34;&gt;各平台推荐的触屏目标&lt;/h4&gt;

&lt;p&gt;需要注意的是，这些大小都是为了方便，都不是现实生活中的测量单位，他们依赖于OEM和各厂商遵守这个指南来生产屏幕，使之保持大小、dpi比例一致。&lt;br /&gt;
 &lt;img src=&#34;http://p0.qhimg.com/t01c88e94570896ac2c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如你看到的，每个OS都有一系列自己的推荐规范，但是都在48pt左右。Windows的规格是包含了padding的，所以我把它加到这里。&lt;/p&gt;

&lt;p&gt;尺寸的不同是源于不同的因素。&lt;br /&gt;
Apple可以控制它的硬件，因此知道触屏的质量并且能够控制这个确切的比例，它可以触摸更小的目标，另外，本身的物理尺寸也更小。&lt;/p&gt;

&lt;p&gt;另一方面，Android和Windows有不同的OEM，都各自生产自己的硬件，有更大的触摸目标会更“安全”。他们的UI更加无规范（特别是Windows），物理尺寸也越来越大了。&lt;/p&gt;

&lt;h4 id=&#34;chrome为例&#34;&gt;chrome为例&lt;/h4&gt;

&lt;p&gt;这是在Chrome上的应用，编码使触摸目标呈蓝色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://p4.qhimg.com/t01b2f9ac819657391d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如你所见，两个平台上工具栏都是被推荐的触摸目标的高度。可视范围在iOS和Android上分别是44*44pt和48*48pt的正方形，这不仅使得UI在大小方面和其他OS保持一致，而且也能让与用户交互的部分都保持最小的规格。&lt;/p&gt;

&lt;h4 id=&#34;windows-8以及chrome-os&#34;&gt;Windows 8以及Chrome OS&lt;/h4&gt;

&lt;p&gt;Windows 8和Chrome OS都支持触屏和非触屏的接口。如果你在为Windows 8 设计app，我强烈建议按照它们&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/windows/apps/hh465326.aspx&#34; target=&#34;_blank&#34;&gt;guidelines for touch targets&lt;/a&gt;来做。&lt;/p&gt;

&lt;p&gt;Chrome OS准则目前尚未发布，但是Pixel使用问题不大。因为所有Chrome OS的app都是基于web开发，我的建议是按照触屏设计并且遵照&lt;a href=&#34;http://developer.android.com/design/style/metrics-grids.html&#34; target=&#34;_blank&#34;&gt;Android touch targets guidelines&lt;/a&gt;来进行开发。&lt;/p&gt;

&lt;h4 id=&#34;web-混合设备和未来&#34;&gt;web，混合设备和未来&lt;/h4&gt;

&lt;p&gt;如果你在为手机设计，触屏是不二选择。如果你在设计桌面应用，参照非触屏。这听起来很简单但是在混合设备兴起的时候很容易被忽略，。&lt;/p&gt;

&lt;p&gt;混合设备是一种既支持触屏又支持非触屏的设备。Chromebook Pixel，Surface Pro和Lenovo Yoga就是很好的例子。&lt;br /&gt;
在这样的情况下，我们该做什么呢？没有简单的答案，但是我会首先给一个答案，触屏方向，因为那是未来的发展趋势。&lt;br /&gt;
如果你为web或者其他相关的设计，首先考虑触屏。&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
- 移动和触屏设计几乎是未来发展趋势。&lt;br /&gt;
- 参考每个OS上建议的触摸目标。这能帮助你更好地设计并让你的产品在OS中保持一致。触摸目标有参考价值，但是不代表你需要不折不扣地遵守，同时你也需要根据经验判断。&lt;/p&gt;

&lt;h3 id=&#34;设计软件&#34;&gt;设计软件&lt;/h3&gt;

&lt;p&gt;软件不能制造设计师，但是在完成任务时选择使用正确的软件可以提高效率，更快完成工作。软件“诀窍”不应该是你唯一的技能，但是学习和操作正确的工具可以帮助你产生灵感。&lt;/p&gt;

&lt;p&gt;当涉及到在设计界面处理DPI变化，不同的软件采用不同方式。在特定任务中有些软件比其他的更好。下面是最常见的：&lt;br /&gt;
 &lt;img src=&#34;http://p7.qhimg.com/t01b4545887e75d546d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;photoshop&#34;&gt;Photoshop&lt;/h4&gt;

&lt;p&gt;界面设计工具之母。也许也是如今使用最广泛的工具。关于它的资源、教程、文章数不胜数，Photoshop几乎几乎贯穿界面设计的每一个阶段。&lt;/p&gt;

&lt;p&gt;正如其名，软件最开始的目的并不是界面设计而是图像或者位图处理。随时间推移以及界面设计的产生，设计师们再次使用起来。部分人是因为他们以前就用并且是那时仅有的能够把事情做得足够好的软件。&lt;/p&gt;

&lt;p&gt;在今天，Photoshop是主要的位图编辑工具，也是UI设计中使用最广泛的软件。数十年的积累使得它成为学习和使用比较困难的软件。作为软件中的瑞士军刀，你可以用来做任何事，但是并不总是最有效的。&lt;/p&gt;

&lt;p&gt;因为最初是基于位图的，所以Photoshop十分依赖DPI，下面描述的是与之相反的Illustrator和Sketch。&lt;/p&gt;

&lt;h4 id=&#34;illustrator&#34;&gt;Illustrator&lt;/h4&gt;

&lt;p&gt;Illustrator的矢量是基于同级的。顾名思义，它重点在插画，但是也可以作为界面设计工具。&lt;/p&gt;

&lt;p&gt;Illustrator也很适合平面设计，因此它的界面，颜色管理，缩放，标尺和单位首先就吸引你，只需要一些补丁就会更便于使用。和Photoshop一样，他也是一款很强大的工具，同时也需要付出努力去学习。&lt;/p&gt;

&lt;p&gt;和Photoshop不同的是，它是独立于DPI的，因为它依赖矢量图。与点阵图或者光栅图相反，图像生成采用矢量图，依靠数学公式计算，以编程方式重新调节大小并且不会损失图片质量。&lt;/p&gt;

&lt;p&gt;了解栅格化和矢量化图片的不同是建立可扩展视觉设计和资源的关键。&lt;/p&gt;

&lt;p&gt;如果你想学习使用Illustrator来进行web/界面设计，我推荐你阅读&lt;a href=&#34;https://twitter.com/@janoskoos&#34; target=&#34;_blank&#34;&gt;@janoskoos&lt;/a&gt;的&lt;a href=&#34;https://medium.com/@janoskoos/my-vector-workflow-dd1357d28d7c&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;My vector workflow&amp;rdquo;&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;sketch-3-0&#34;&gt;Sketch 3.0&lt;/h4&gt;

&lt;p&gt;与Photoshop和Illustrator比起来，Sketch还很年轻。虽然只产生了四年，但它在UI设计行业里面引起了巨大的反响。因为从一开始，Sketch的目标就是供界面和UX设计师使用，没有Photoshop和Illustrator的历史积累，Sketch把自己定位成针对小众用户——界面设计师的一款完美的调整工具。&lt;/p&gt;

&lt;p&gt;Sketch适合快速设计框架以及复杂的视觉设计。它像Illustrator一样是完全基于矢量的，简单轻量化同时还拥有美观的UI。它结合了铜版纸使用方便和灵活的资源生成系统，让它成为跨DPI、跨平台设计最快的工具。最近发布的3.0版本也是可以用来替代Photoshop的产品。&lt;/p&gt;

&lt;p&gt;但是也有不足的地方，Sketch是小团队开发的，而且出来得比较晚。尽管它的团队能够积极响应需求的变化，但是也没有Adobe（Photoshop和Illustrator）公司这样的规模。在位图编辑时，Sketch只能满足（设计时）最低的需求，但是Photoshop的功能就更加全面。同时，因为它的年轻，在源文件、教程和社区方面在数量上也远少于Photoshop，不过，社区用户都很积极上进。&lt;/p&gt;

&lt;p&gt;另外私人方面，从8年前我就是是Photoshop的用户，但是最近我把我设计中的最重要部分切换到了Sketch3.0。这不是对质量的判断，Photoshop仍然是一个好软件，只是Sketch3.0更加适合我。&lt;/p&gt;

&lt;p&gt;如果你想了解更多关于我的特别的经验，建议你阅读我的&lt;a href=&#34;https://medium.com/@KounterB/a-month-with-sketch-3-68c443fe5041&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;A month with Sketch 3.0 &amp;ldquo;&lt;/a&gt;或者&lt;a href=&#34;https://medium.com/@KounterB/sketch-tutorial_01-b76271a095e3&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;Sketch tutorial_01&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;想要了解更深入以及矢量是如何在sketch工作的？去看&lt;a href=&#34;https://twitter.com/@pnowelldesign&#34; target=&#34;_blank&#34;&gt;@pnowelldesign&lt;/a&gt;的文章 &lt;a href=&#34;https://medium.com/sketch-app/harnessing-vector-awesomeness-in-sketch-3c9621408138&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;Harnessing vector awesomeness in Sketch&amp;rdquo;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;附加:&lt;br /&gt;
并没有完美的工具但是有最适合你的。如果你有足够的时间和钱，我建议你都试试，然后再决定。&lt;/p&gt;

&lt;h3 id=&#34;文档和资源&#34;&gt;文档和资源&lt;/h3&gt;

&lt;p&gt;这篇指南只是一个介绍，真正开始做的时候能学到更多。如果你想要了解更多或者获取我们讨论的主题相关的更详细的内容，可以点击下面的链接：&lt;/p&gt;

&lt;h4 id=&#34;平台文档&#34;&gt;平台文档&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/design/index.html&#34; target=&#34;_blank&#34;&gt;Android UI guidelines&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&#34;http://www.google.com/design/spec/material-design/introduction.html&#34; target=&#34;_blank&#34;&gt;Google Material guidelines&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/userexperience/conceptual/MobileHIG/index.html&#34; target=&#34;_blank&#34;&gt;iOS7 UI guidelines&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/windows/apps/hh465424.aspx&#34; target=&#34;_blank&#34;&gt;Windows UI guidelines&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&#34;https://developers.google.com/web/fundamentals/principles/&#34; target=&#34;_blank&#34;&gt;Google dev Principles of site design&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;速查表和模板&#34;&gt;速查表和模板&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://www.paintcodeapp.com/news/iphone-6-screens-demystified&#34; target=&#34;_blank&#34;&gt;iPhone 6 Screens Demystified&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions&#34; target=&#34;_blank&#34;&gt;Ultimate guide to iphone resolutions&lt;/a&gt; by &lt;a href=&#34;http://www.paintcodeapp.com/&#34; target=&#34;_blank&#34;&gt;PaintCodeApp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://screensiz.es/phone&#34; target=&#34;_blank&#34;&gt;Screen sizes, ratio and PPI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ivomynttinen.com/blog/the-ios-7-design-cheat-sheet/&#34; target=&#34;_blank&#34;&gt;iOS7 designer cheat sheet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/design/index.html&#34; target=&#34;_blank&#34;&gt;iOS7 design resource&lt;/a&gt; (requires Apple account)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://appicontemplate.com/&#34; target=&#34;_blank&#34;&gt;App icons template, Android and iOS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bjango.com/articles/&#34; target=&#34;_blank&#34;&gt;Bjango blog&lt;/a&gt; (A design article gold mine)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.teehanlax.com/tools/ipad/&#34; target=&#34;_blank&#34;&gt;iPhone GUI and iPad GUI(.psd)&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/teehanlax&#34; target=&#34;_blank&#34;&gt;@teehanlax&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;工具&#34;&gt;工具&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://density.brdrck.me/&#34; target=&#34;_blank&#34;&gt;Density converter&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/brdrck&#34; target=&#34;_blank&#34;&gt;@brdrck&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dribbble.com/shots/1237570-Asset-Creation-Process?list=searches&#34; target=&#34;_blank&#34;&gt;Android asset generation&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/brdrck&#34; target=&#34;_blank&#34;&gt;@brdrck&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.androiddesign.tips/&#34; target=&#34;_blank&#34;&gt;Android design tips&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/destroywerk&#34; target=&#34;_blank&#34;&gt;@destroywerk&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/BPScott&#34; target=&#34;_blank&#34;&gt;@BPScott&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch&#34; target=&#34;_blank&#34;&gt;9patch creation in Android&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/romannurik&#34; target=&#34;_blank&#34;&gt;@romannurik&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://romannurik.github.io/AndroidAssetStudio/index.html&#34; target=&#34;_blank&#34;&gt;Android asset studio&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/romannurik&#34; target=&#34;_blank&#34;&gt;@romannurik&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;更多文章&#34;&gt;更多文章&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brandbuilderwebsites.com/blog/2012/03/29/device-independent-pixel-formula-for-mobile-devices/&#34; target=&#34;_blank&#34;&gt;Device independent pixel formula for Mobile devices&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://reviews.cnet.com/8301-33199_7-57364224-221/what-is-4k-uhd-next-generation-resolution-explained/&#34; target=&#34;_blank&#34;&gt;More information about 4K by Cnet.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://uxdesign.smashingmagazine.com/2012/02/21/finger-friendly-design-ideal-mobile-touchscreen-target-sizes/&#34; target=&#34;_blank&#34;&gt;More informations about touch targets by Smashing Mag&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://rustyshelf.org/2014/07/08/the-android-screen-fragmentation-myth/&#34; target=&#34;_blank&#34;&gt;The Android Screen Fragmentation Myth&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;103.245.222.133&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>HTML 标签</title>
            <link>//blog.pytool.com/reship/2015-09-17-sematic-html/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-09-17-sematic-html/</guid>
            <description>

&lt;h2 id=&#34;基础元素&#34;&gt;基础元素&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;html&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;文档元数据&#34;&gt;文档元数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;:用来指定文档中所有相对路径的基础路径。一个文档只能包含一个&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;:指明当前文档和外部文档的关系。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;:用来表示其它 文档元数据标签 不能表示的元数据。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;资源：&lt;br /&gt;
- &lt;a href=&#34;http://www.w3.org/TR/html5/links.html&#34; target=&#34;_blank&#34;&gt;http://www.w3.org/TR/html5/links.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;内容块&#34;&gt;内容块&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt;:给最近的祖先元素&lt;article&gt; 或 &lt;body&gt; 提供联系信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;:表示自包含的内容，可单独发布，重用。可以是论坛帖子，文章，博客或是其它独立的内容。通常会包含一个 &lt;h1&gt;-&lt;h6&gt; 作为子元素&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;:代表最近的父级区块内容的页脚，用来展示作者、版权、相关文档链接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;:描述最近的父级区块，一组介绍性描述或导航信息。通常包含h1-h6&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;h1&amp;gt;...&amp;lt;h6&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;hgroup&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;:通常包含h1-h6&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;文本内容&#34;&gt;文本内容&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dl-dt-dd&lt;/code&gt;:表示键值对，名词和解释&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ul-ol-li&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;:表示预格式化(已排版)的内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt;:文档的主内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;figure&amp;gt;&lt;/code&gt;:自包含内容，通常带有标题 figcaption 。通常是插图、图表、照片、代码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;figcaption&amp;gt;&lt;/code&gt;:通常是图表标题、图例、代码说明&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;inline-text-semantics&#34;&gt;inline text semantics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;:缩写。其title属性的含义为所缩写的全称&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;dfn&amp;gt;&lt;/code&gt;:展示术语的定义。最近的父级块必须包含dfn元素指定的术语的定义。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;:引述元素（Citation Element）。引述的作品（书、文章、电影、歌曲、节目等）的标题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt;: quote element。cite属性表示来源URL。短引用使用q，不需要分段。长引用使用&lt;blockquote&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;kbd&amp;gt;&lt;/code&gt;: Keyboard Input Element 。用户输入内容/按键&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;samp&amp;gt;&lt;/code&gt;:计算机输出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;:用于技术名词 / 外文短语 / 虚构人物&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;:表示侧重点的强调&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;:表示某种需要引起注意却又没有其他额外语义的内容。用于：摘要中的关键词 / 评介中的产品名称 / 文章的开篇内容&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;:表示内容的重要性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;small&amp;gt;&lt;/code&gt;:用于：免责声明 / 许可证声明 / 注意事项&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;u&amp;gt;&lt;/code&gt;:表示用非文本进行的标注的内容。中文专名 / 拼写检查的错误内容&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;s&amp;gt;&lt;/code&gt;:表示不再准确或不再相关的内容&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;mark&amp;gt;&lt;/code&gt;:在引用的文字中使用，表示在当前文档中需要引起注意但原文中并没有强调的含义 (eg. 对一篇文章的分析中对原文的标注);表示与用户当前的行为相关的内容 (eg. 高亮显示搜索关键词)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;sub&amp;gt;&amp;lt;sup&amp;gt;&lt;/code&gt;: Subscript Element &amp;amp;&amp;amp; Superscript Element&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;ruby&amp;gt;&amp;lt;rp&amp;gt;&amp;lt;rt&amp;gt;&amp;lt;rtc&amp;gt;&lt;/code&gt;:注音标识&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt;:表示数学表达式或编程上下文中的变量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;wbr&amp;gt;&lt;/code&gt;:Word Break Opportunity。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;bdi&amp;gt;&amp;lt;bdo&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;data&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;图片和多媒体&#34;&gt;图片和多媒体&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;picture&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;map&amp;gt;&amp;lt;area&amp;gt;&lt;/code&gt;:图片热点&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;:音频&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;:视频&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;:为多媒体元素指定文本轨。格式为.vvt 文件 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Web_Video_Text_Tracks_Format&#34; target=&#34;_blank&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Web_Video_Text_Tracks_Format&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt;:表示所在多媒体元素的可替代资源&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;嵌入内容&#34;&gt;嵌入内容&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;:外部应用或可交互内容的整合入口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;:通用外部资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt;:为 object 元素传递的参数&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;脚本&#34;&gt;脚本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;标记更改&#34;&gt;标记更改&lt;/h2&gt;

&lt;p&gt;表示对当前文档内容进行的增添与删改,用来记录文档的编辑历史:&lt;/p&gt;

&lt;p&gt;cite 属性指向对某个修改的说明文档的 URL&lt;/p&gt;

&lt;p&gt;datetime 属性表示了修改发生的时间 (取值规范)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;ins&amp;gt;&lt;/code&gt;: Inserted Text&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt;:表示所处的 table 的标题，通常是表格的第一个子元素。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;th&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;col&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;colgroup&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;表单&#34;&gt;表单&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt;:可以和其它控件关联起来，通过for 属性或是将其它控件包裹起来&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;datalist&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;fieldset&amp;gt;&lt;/code&gt;:分组控件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;legend&amp;gt;&lt;/code&gt;:fieldset 的标题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;output&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;progress&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;meter&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;interactive-elements&#34;&gt;interactive elements&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;details&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;menu&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;menuitem&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;summary&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;web-components&#34;&gt;Web Components&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;element&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;shadow&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;资源：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/TR/components-intro/&#34; target=&#34;_blank&#34;&gt;http://www.w3.org/TR/components-intro/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;废弃元素&#34;&gt;废弃元素&lt;/h2&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTML/Element&#34; target=&#34;_blank&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTML/Element&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Handlebars.js 基础</title>
            <link>//blog.pytool.com/reship/2015-03-12-handlebarsjs-intro/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-03-12-handlebarsjs-intro/</guid>
            <description>

&lt;p&gt;Handlebars.js 是Mustache 模板语言的一个扩展。Handlebar.js 和Mustache都是logicless模板语言，目的是保持视图和逻辑分开。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.handlebarsjs.com&#34; target=&#34;_blank&#34;&gt;Handlebars.js 文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##使用&lt;/p&gt;

&lt;p&gt;大体上，Handlerbars.js的语法是Mustache的超集。基本语法可以查看&lt;a href=&#34;https://github.com/zicai/zicai.github.com/blob/master/_posts/2015-03-08-mustache-intro.md&#34; target=&#34;_blank&#34;&gt;Mustache manpage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;拿到模板以后，用&lt;code&gt;Handlebars.compile&lt;/code&gt;方法将模板编译成一个函数。生成的这个函数接收一个context参数，它会被用来渲染模板。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var source = &amp;quot;&amp;lt;p&amp;gt;Hello, my name is {{name}}. I am from {{hometown}}. I have &amp;quot; +  
             &amp;quot;{{kids.length}} kids:&amp;lt;/p&amp;gt;&amp;quot; +  
             &amp;quot;&amp;lt;ul&amp;gt;{{#kids}}&amp;lt;li&amp;gt;{{name}} is {{age}}&amp;lt;/li&amp;gt;{{/kids}}&amp;lt;/ul&amp;gt;&amp;quot;;  
var template = Handlebars.compile(source);  

var data = { &amp;quot;name&amp;quot;: &amp;quot;Alan&amp;quot;, &amp;quot;hometown&amp;quot;: &amp;quot;Somewhere, TX&amp;quot;,  
             &amp;quot;kids&amp;quot;: [{&amp;quot;name&amp;quot;: &amp;quot;Jimmy&amp;quot;, &amp;quot;age&amp;quot;: &amp;quot;12&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;Sally&amp;quot;, &amp;quot;age&amp;quot;: &amp;quot;4&amp;quot;}]};  
var result = template(data);  

// Would render:  
// &amp;lt;p&amp;gt;Hello, my name is Alan. I am from Somewhere, TX. I have 2 kids:&amp;lt;/p&amp;gt;  
// &amp;lt;ul&amp;gt;  
//   &amp;lt;li&amp;gt;Jimmy is 12&amp;lt;/li&amp;gt;  
//   &amp;lt;li&amp;gt;Sally is 4&amp;lt;/li&amp;gt;  
// &amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##注册 Helpers&lt;/p&gt;

&lt;p&gt;你可以注册helpers，Handlebars会在渲染模板过程中使用它们。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Handlebars.registerHelper(&#39;link_to&#39;, function() {  
  return new Handlebars.SafeString(&amp;quot;&amp;lt;a href=&#39;&amp;quot; + Handlebars.Utils.escapeExpression(this.url) + &amp;quot;&#39;&amp;gt;&amp;quot; + Handlebars.Utils.escapeExpression(this.body) + &amp;quot;&amp;lt;/a&amp;gt;&amp;quot;);  
});  

var context = { posts: [{url: &amp;quot;/hello-world&amp;quot;, body: &amp;quot;Hello World!&amp;quot;}] };  
var source = &amp;quot;&amp;lt;ul&amp;gt;{{#posts}}&amp;lt;li&amp;gt;{{link_to}}&amp;lt;/li&amp;gt;{{/posts}}&amp;lt;/ul&amp;gt;&amp;quot;  

var template = Handlebars.compile(source);  
template(context);  

// Would render:  
//  
// &amp;lt;ul&amp;gt;  
//   &amp;lt;li&amp;gt;&amp;lt;a href=&#39;//blog.pytool.com/hello-world&#39;&amp;gt;Hello World!&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
// &amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helpers 优先级高于context中定义的fields,要想获取被helper掩盖的field，可以使用path reference。在上例中，如果在&lt;code&gt;context&lt;/code&gt;对象中有一个叫做&lt;code&gt;link_to&lt;/code&gt;的field,可以用下面方式引用它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{./link_to}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##转义&lt;/p&gt;

&lt;p&gt;默认情况下，&lt;code&gt;{{expression}}&lt;/code&gt;语法会转义它的内容。避免遭到服务器传来的恶意JSON数据导致的XSS攻击。&lt;/p&gt;

&lt;p&gt;要想明确不转义内容，使用&lt;code&gt;{{{}}}&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;handlebars-js-与-mustache-的不同&#34;&gt;Handlebars.js 与 Mustache 的不同&lt;/h2&gt;

&lt;p&gt;为了更加容易的编写模板，Handlebars.js添加了一些额外的功能，也修改了一些partial的工作方式。&lt;/p&gt;

&lt;h3 id=&#34;paths&#34;&gt;Paths&lt;/h3&gt;

&lt;p&gt;Handlebars.js支持一个扩展的表达式语法，我们称为paths。paths 由普通的表达式和&lt;code&gt;.&lt;/code&gt;组成。path使你不仅可以显示当前context的数据，还可以显示当前context的祖先和后代的context的数据。&lt;/p&gt;

&lt;p&gt;要显示后代context的数据，使用&lt;code&gt;.&lt;/code&gt;字符。假设数据结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var data = {&amp;quot;person&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;Alan&amp;quot; }, &amp;quot;company&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;Rad, Inc.&amp;quot; } };  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在top-level context可以用下面的表达式显示person&amp;rsquo;s name：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{person.name}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用&lt;code&gt;../&lt;/code&gt;后退。假设你已经进入了person对象，仍然可以通过表达式&lt;code&gt;{{../company.name}}&lt;/code&gt;来显示company&amp;rsquo;s name，所以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{#with person}}{{name}} - {{../company.name}}{{/with}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would render:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Alan - Rad, Inc.  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;strings&#34;&gt;Strings&lt;/h3&gt;

&lt;p&gt;在调用helper时，可以传递paths或者strings 作为参数，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Handlebars.registerHelper(&#39;link_to&#39;, function(title, options) {  
  return &amp;quot;&amp;lt;a href=&#39;//blog.pytool.com/posts&amp;quot; + this.url + &amp;quot;&#39;&amp;gt;&amp;quot; + title + &amp;quot;!&amp;lt;/a&amp;gt;&amp;quot;  
});  

var context = { posts: [{url: &amp;quot;/hello-world&amp;quot;, body: &amp;quot;Hello World!&amp;quot;}] };  
var source = &#39;&amp;lt;ul&amp;gt;{{#posts}}&amp;lt;li&amp;gt;{{{link_to &amp;quot;Post&amp;quot;}}}&amp;lt;/li&amp;gt;{{/posts}}&amp;lt;/ul&amp;gt;&#39;  

var template = Handlebars.compile(source);  
template(context);  

// Would render:  
//  
// &amp;lt;ul&amp;gt;  
//   &amp;lt;li&amp;gt;&amp;lt;a href=&#39;//blog.pytool.com/posts/hello-world&#39;&amp;gt;Post!&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
// &amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;block-helpers&#34;&gt;Block Helpers&lt;/h3&gt;

&lt;p&gt;Block expressions allow you to define helpers that will invoke a section of your template with a different context than the current.&lt;br /&gt;
Handlebars.js 增加了定义block helpers的能力。block helpers 是可以在模板任意地方调用的函数。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var source = &amp;quot;&amp;lt;ul&amp;gt;{{#people}}&amp;lt;li&amp;gt;{{#link}}{{name}}{{/link}}&amp;lt;/li&amp;gt;{{/people}}&amp;lt;/ul&amp;gt;&amp;quot;;  
Handlebars.registerHelper(&#39;link&#39;, function(options) {  
  return &#39;&amp;lt;a href=&amp;quot;/people/&#39; + this.id + &#39;&amp;quot;&amp;gt;&#39; + options.fn(this) + &#39;&amp;lt;/a&amp;gt;&#39;;  
});  
var template = Handlebars.compile(source);  

var data = { &amp;quot;people&amp;quot;: [  
    { &amp;quot;name&amp;quot;: &amp;quot;Alan&amp;quot;, &amp;quot;id&amp;quot;: 1 },  
    { &amp;quot;name&amp;quot;: &amp;quot;Yehuda&amp;quot;, &amp;quot;id&amp;quot;: 2 }  
  ]};  
template(data);  

// Should render:  
// &amp;lt;ul&amp;gt;  
//   &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/people/1&amp;quot;&amp;gt;Alan&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
//   &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/people/2&amp;quot;&amp;gt;Yehuda&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
// &amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever the block helper is called it is given one or more parameters,&lt;br /&gt;
any arguments that are passed into the helper in the call, and an &lt;code&gt;options&lt;/code&gt;&lt;br /&gt;
object containing the &lt;code&gt;fn&lt;/code&gt; function which executes the block&amp;rsquo;s child.&lt;br /&gt;
The block&amp;rsquo;s current context may be accessed through &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Block helpers 的语法和mustache sections 语法一样，但是不要把它们弄混。Sections根据输入值的不同，类似于&lt;code&gt;each&lt;/code&gt;或是&lt;code&gt;with&lt;/code&gt;语句，而helpers是一段代码，你可以做任何你想做的操作。&lt;/p&gt;

&lt;h3 id=&#34;partials&#34;&gt;Partials&lt;/h3&gt;

&lt;p&gt;你可以注册额外的模板作为partial，当Handlebars遇到&lt;code&gt;{{&amp;gt; partialName}}&lt;/code&gt;时就会使用。Partials既可以是一个模板字符串，也可以是一个编译后的模板函数。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var source = &amp;quot;&amp;lt;ul&amp;gt;{{#people}}&amp;lt;li&amp;gt;{{&amp;gt; link}}&amp;lt;/li&amp;gt;{{/people}}&amp;lt;/ul&amp;gt;&amp;quot;;  

Handlebars.registerPartial(&#39;link&#39;, &#39;&amp;lt;a href=&amp;quot;/people/{{id}}&amp;quot;&amp;gt;{{name}}&amp;lt;/a&amp;gt;&#39;)  
var template = Handlebars.compile(source);  

var data = { &amp;quot;people&amp;quot;: [  
    { &amp;quot;name&amp;quot;: &amp;quot;Alan&amp;quot;, &amp;quot;id&amp;quot;: 1 },  
    { &amp;quot;name&amp;quot;: &amp;quot;Yehuda&amp;quot;, &amp;quot;id&amp;quot;: 2 }  
  ]};  

template(data);  

// Should render:  
// &amp;lt;ul&amp;gt;  
//   &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/people/1&amp;quot;&amp;gt;Alan&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
//   &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/people/2&amp;quot;&amp;gt;Yehuda&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
// &amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;comments&#34;&gt;Comments&lt;/h3&gt;

&lt;p&gt;可以用下面的语法在模板中添加注释：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{{! This is a comment }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想让注释出现在最终输出，可以使用html 注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;  
    {{! This comment will not end up in the output }}  
    &amp;lt;!-- This comment will show up in the output --&amp;gt;  
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compatibility&#34;&gt;Compatibility&lt;/h3&gt;

&lt;p&gt;有一小部分Mustache行为，Handlebars没有实现&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认情况下，Handlebars没有遵循Mustache的递归查询。要想启用这个功能，必须设置compile time &lt;code&gt;compat&lt;/code&gt;。你要清楚，开启这个flag会导致性能下降。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不支持Mustache-style lambdas。Handlebars提供了自己的lambda解决方案：以helpers的形式。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不支持变更定界符&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;预编译模板&#34;&gt;预编译模板&lt;/h2&gt;

&lt;p&gt;为了速度更快，Handlebars允许预编译模板，然后以javascript代码形式引入。&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;预编译脚本可以通过npm安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g handlebars  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;pre&gt;  
Precompile handlebar templates.  
Usage: handlebars template...  

Options:  
  -a, --amd            Create an AMD format function (allows loading with RequireJS)          [boolean]  
  -f, --output         Output File                                                            [string]  
  -k, --known          Known helpers                                                          [string]  
  -o, --knownOnly      Known helpers only                                                     [boolean]  
  -m, --min            Minimize output                                                        [boolean]  
  -s, --simple         Output template function only.                                         [boolean]  
  -r, --root           Template root. Base value that will be stripped from template names.   [string]  
  -c, --commonjs       Exports CommonJS style, path to Handlebars module                      [string]  
  -h, --handlebarPath  Path to handlebar.js (only valid for amd-style)                        [string]  
  -n, --namespace      Template namespace                                                     [string]  
  -p, --partial        Compiling a partial template                                           [boolean]  
  -d, --data           Include data when compiling                                            [boolean]  
  -e, --extension      Template extension.                                                    [string]  
  -b, --bom            Removes the BOM (Byte Order Mark) from the beginning of the templates. [boolean]  
&lt;/pre&gt;  

&lt;p&gt;If using the precompiler&amp;rsquo;s normal mode, the resulting templates will be&lt;br /&gt;
stored to the &lt;code&gt;Handlebars.templates&lt;/code&gt; object using the relative template&lt;br /&gt;
name sans the extension. These templates may be executed in the same&lt;br /&gt;
manner as templates.&lt;/p&gt;

&lt;p&gt;If using the simple mode the precompiler will generate a single&lt;br /&gt;
javascript method. To execute this method it must be passed to&lt;br /&gt;
the &lt;code&gt;Handlebars.template&lt;/code&gt; method and the resulting object may be used as normal.&lt;/p&gt;

&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Rather than using the full &lt;em&gt;handlebars.js&lt;/em&gt; library, implementations that&lt;br /&gt;
do not need to compile templates at runtime may include &lt;em&gt;handlebars.runtime.js&lt;/em&gt;&lt;br /&gt;
whose min+gzip size is approximately 1k.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If a helper is known to exist in the target environment they may be defined&lt;br /&gt;
using the &lt;code&gt;--known name&lt;/code&gt; argument may be used to optimize accesses to these&lt;br /&gt;
helpers for size and speed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;When all helpers are known in advance the &lt;code&gt;--knownOnly&lt;/code&gt; argument may be used&lt;br /&gt;
to optimize all block helper references.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Implementations that do not use &lt;code&gt;@data&lt;/code&gt; variables can improve performance of&lt;br /&gt;
iteration centric templates by specifying &lt;code&gt;{data: false}&lt;/code&gt; in the compiler options.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;supported-environments&#34;&gt;Supported Environments&lt;/h2&gt;

&lt;p&gt;Handlebars has been designed to work in any ECMAScript 3 environment. This includes&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node.js&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Chrome&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Firefox&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Safari 5+&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Opera 11+&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;IE 6+&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Older versions and other runtimes are likely to work but have not been formally&lt;br /&gt;
tested. The compiler requires &lt;code&gt;JSON.stringify&lt;/code&gt; to be implemented natively or via a polyfill. If using the precompiler this is not necessary.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://saucelabs.com/u/handlebars&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://saucelabs.com/browser-matrix/handlebars.svg&#34; alt=&#34;Selenium Test Status&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;external-resources&#34;&gt;External Resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/2287070&#34; target=&#34;_blank&#34;&gt;Gist about Synchronous and asynchronous loading of external handlebars templates&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Moment.js 2.6中文文档</title>
            <link>//blog.pytool.com/reship/2014-05-07-moment.js-2.6-doc/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2014-05-07-moment.js-2.6-doc/</guid>
            <description>

&lt;p&gt;文档地址：&lt;a href=&#34;http://momentjs.com/docs/&#34; target=&#34;_blank&#34;&gt;http://momentjs.com/docs/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-在哪使用&#34;&gt;1. 在哪使用&lt;/h2&gt;

&lt;p&gt;浏览器或者Node.JS&lt;br /&gt;
###Node.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install moment  

var moment = require(&#39;moment&#39;);  
moment().format();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###浏览器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;moment.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  
&amp;lt;script&amp;gt;  
    moment().format();  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Bower&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install --save momentjs  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-parse&#34;&gt;2. Parse&lt;/h2&gt;

&lt;h3 id=&#34;2-1-now&#34;&gt;2.1 Now&lt;/h3&gt;

&lt;p&gt;想要得到当前日期和时间，只需调用 &lt;code&gt;moment()&lt;/code&gt; ，无需参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var now = moment()  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-通过时间字符串创建&#34;&gt;2.2 通过时间字符串创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment(string)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有浏览器都支持ISO-8601 时间格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;2013-02-08&amp;quot;  
&amp;quot;2013-02-08T09&amp;quot;  
&amp;quot;2013-02-08 09&amp;quot;  
&amp;quot;2013-02-08T09:30&amp;quot;  
&amp;quot;2013-02-08 09:30&amp;quot;  
&amp;quot;2013-02-08T09:30:26&amp;quot;  
&amp;quot;2013-02-08 09:30:26&amp;quot;  
&amp;quot;2013-02-08T09:30:26.123&amp;quot;  
&amp;quot;2013-02-08 09:30:26.123&amp;quot;  
&amp;quot;2013-02-08T09:30:26 Z&amp;quot;  
&amp;quot;2013-02-08 09:30:26 Z&amp;quot;  
&amp;quot;2013-W06-5&amp;quot;  
&amp;quot;2013-W06-5T09&amp;quot;  
&amp;quot;2013-W06-5 09&amp;quot;  
&amp;quot;2013-W06-5T09:30&amp;quot;  
&amp;quot;2013-W06-5 09:30&amp;quot;  
&amp;quot;2013-W06-5T09:30:26&amp;quot;  
&amp;quot;2013-W06-5 09:30:26&amp;quot;  
&amp;quot;2013-W06-5T09:30:26.123&amp;quot;  
&amp;quot;2013-W06-5 09:30:26.123&amp;quot;  
&amp;quot;2013-W06-5T09:30:26 Z&amp;quot;  
&amp;quot;2013-W06-5 09:30:26 Z&amp;quot;  
&amp;quot;2013-039&amp;quot;  
&amp;quot;2013-039T09&amp;quot;  
&amp;quot;2013-039 09&amp;quot;  
&amp;quot;2013-039T09:30&amp;quot;  
&amp;quot;2013-039 09:30&amp;quot;  
&amp;quot;2013-039T09:30:26&amp;quot;  
&amp;quot;2013-039 09:30:26&amp;quot;  
&amp;quot;2013-039T09:30:26.123&amp;quot;  
&amp;quot;2013-039 09:30:26.123&amp;quot;  
&amp;quot;2013-039T09:30:26 Z&amp;quot;  
&amp;quot;2013-039 09:30:26 Z&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果字符串参数不能匹配任何一种格式，并且不能被&lt;code&gt;Date.parse&lt;/code&gt;转换，那么&lt;code&gt;moment#isValid&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment(&#39;not a real date&#39;).isValid(); //false  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-通过字符串-格式创建&#34;&gt;2.3 通过字符串+格式创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment(String, String);  
moment(String, String, String);  
moment(String, String, Boolean);  
moment(String, String, String, Boolean);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-通过字符串数组-格式创建&#34;&gt;2.4 通过字符串数组+格式创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment(String, String[], String, Boolean);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-通过对象创建&#34;&gt;2.5 通过对象创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment({unit: value, ...});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment({hour: 15, minute: 10});  
moment({y: 2010, M: 3, d: 5, h: 15, m: 10, s: 3, ms: 123});  
moment({year: 2010, month: 3, day: 5, hour: 15, minute: 10, second: 3, millisecond: 123});  
moment({years: 2010, months: 3, days: 5, hours: 15, minutes: 10, seconds: 3, milliseconds: 123});  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-6-通过-unix-offset-miliseconds-创建&#34;&gt;2.6 通过 Unix Offset(miliseconds)创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment(Number);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var day =moment(1318781876406);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-7-通过unix-timestamp-seconds-创建&#34;&gt;2.7 通过Unix Timestamp(seconds)创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.unix(Number)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var day = moment.unix(1318781876);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-7-通过date-对象创建&#34;&gt;2.7 通过Date 对象创建&lt;/h3&gt;

&lt;h3 id=&#34;2-8-通过数组创建&#34;&gt;2.8 通过数组创建&lt;/h3&gt;

&lt;h3 id=&#34;2-9-通过asp-net-json-date-创建&#34;&gt;2.9 通过Asp.net JSON Date 创建&lt;/h3&gt;

&lt;h2 id=&#34;3-moment-clone&#34;&gt;3 Moment Clone&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;moment(Moment);  
或者moment#clone  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-utc&#34;&gt;4 UTC&lt;/h2&gt;

&lt;p&gt;默认情况下，moment以本地时间来显示和转换时间&lt;br /&gt;
如果你想以UTC来转换或显示时间，你可以使用moment.utc()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment.utc();  
moment.utc(Number);  
moment.utc(Number[]);  
moment.utc(String);  
moment.utc(String, String);  
moment.utc(String, String[]);  
moment.utc(String, String, String);  
moment.utc(Moment);  
moment.utc(Date);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-parsezone&#34;&gt;5 parseZone&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;moment.parseZone(String)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-验证&#34;&gt;6 验证&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;moment().isValid();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-默认时间&#34;&gt;7 默认时间&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;moment(&amp;quot;15&amp;quot;, &amp;quot;hh&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以仅指定某些时间单位来创建一个moment对象，未指定的单位则取当前日期默认值，时间为0&lt;/p&gt;

&lt;h2 id=&#34;8-get-set&#34;&gt;8 Get+Set&lt;/h2&gt;

&lt;p&gt;没有参数调用为getter,有参数调用为setter&lt;br /&gt;
为了方便起见，单数和复数形式的函数名均存在&lt;/p&gt;

&lt;h3 id=&#34;8-1-millisecond&#34;&gt;8.1 Millisecond&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().millisecond(Number);  
moment().millisecond(); // Number  
moment().milliseconds(Number);  
moment().milliseconds(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接受参数范围0&amp;ndash;999，如果超出，将会增加seconds&lt;/p&gt;

&lt;h3 id=&#34;8-2-second&#34;&gt;8.2 Second&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().second(Number);  
moment().second(); // Number  
moment().seconds(Number);  
moment().seconds(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接受参数范围0&amp;ndash;59，如果超出，将会增加minutes&lt;/p&gt;

&lt;h3 id=&#34;8-3-minute&#34;&gt;8.3 Minute&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().minute(Number);  
moment().minute(); // Number  
moment().minutes(Number);  
moment().minutes(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接受参数范围0&amp;ndash;59，如果超出，将会增加hours&lt;/p&gt;

&lt;h3 id=&#34;8-4-hour&#34;&gt;8.4 Hour&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().hour(Number);  
moment().hour(); // Number  
moment().hours(Number);  
moment().hours(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接受参数范围0&amp;ndash;23，如果超出，将会增加day&lt;/p&gt;

&lt;h3 id=&#34;8-5-date-of-month&#34;&gt;8.5 Date of Month&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().date(Number);  
moment().date(); // Number  
moment().dates(Number);  
moment().dates(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数接受范围1&amp;ndash;31，如果超出，将会增加months&lt;br /&gt;
注意：Moment#date 用来设置date of month，而Moment#day 用来设置day of week&lt;/p&gt;

&lt;h3 id=&#34;8-6-day-of-week&#34;&gt;8.6 Day of week&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().day(Number|String);  
moment().day(); // Number  
moment().days(Number|String);  
moment().days(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sunday as 0 and Saturday as 6.如果超出，则变到下一周&lt;br /&gt;
也可以使用 week name,例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment().day(&amp;quot;Sunday&amp;quot;);  
moment().day(&amp;quot;Monday&amp;quot;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-7-day-of-week-locale-aware&#34;&gt;8.7 Day of Week (Locale Aware)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().weekday(Number);  
moment().weekday(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据区域设置gets或者sets day of week&lt;/p&gt;

&lt;h3 id=&#34;8-9-iso-day-of-week&#34;&gt;8.9 ISO Day of Week&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().isoWeekday(Number);  
moment().isoWeekday(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gets or sets the ISO day of the week with 1 being Monday and 7 being Sunday.&lt;/p&gt;

&lt;h3 id=&#34;8-10-day-of-year&#34;&gt;8.10 Day of Year&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().dayOfYear(Number);  
moment().dayOfYear(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接收参数范围 1&amp;ndash;366，如果超出，则进入下一年&lt;/p&gt;

&lt;h3 id=&#34;8-11-week-of-year&#34;&gt;8.11 Week of Year&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().week(Number);  
moment().week(); // Number  
moment().weeks(Number);  
moment().weeks(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-12-week-of-year-iso&#34;&gt;8.12 Week of Year (ISO)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().isoWeek(Number);  
moment().isoWeek(); // Number  
moment().isoWeeks(Number);  
moment().isoWeeks(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当设置week of year 时，day of week 将被保留&lt;/p&gt;

&lt;h3 id=&#34;8-13-month&#34;&gt;8.13 Month&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().month(Number|String);  
moment().month(); // Number  
moment().months(Number|String);  
moment().months(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数接受范围0&amp;ndash;11,如果超出，会进入下一年。&lt;br /&gt;
注意：月份是zero indexed,即 一月是0&lt;br /&gt;
同样支持month name,例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment().month(&amp;quot;January&amp;quot;);  
moment().month(&amp;quot;Feb&amp;quot;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-14-quarter&#34;&gt;8.14 Quarter&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().quarter(); // Number  
moment().quarter(Number);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数接受范围1&amp;ndash;4&lt;/p&gt;

&lt;h3 id=&#34;8-15-year&#34;&gt;8.15 Year&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().year(Number);  
moment().year(); // Number  
moment().years(Number);  
moment().years(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接受参数范围-270,000&amp;mdash;270,000&lt;/p&gt;

&lt;h3 id=&#34;8-16-week-year&#34;&gt;8.16 week Year&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().weekYear(Number);  
moment().weekYear(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-17-week-year-iso&#34;&gt;8.17 week year (iso)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().isoWeekYear(Number);  
moment().isoWeekYear(); // Number  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-18-weeks-in-year-iso&#34;&gt;8.18 weeks in year(iso)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().isoWeeksInYear();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-19-get&#34;&gt;8.19 Get&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().get(&#39;year&#39;);  
moment().get(&#39;month&#39;);  // 0 to 11  
moment().get(&#39;date&#39;);  
moment().get(&#39;hour&#39;);  
moment().get(&#39;minute&#39;);  
moment().get(&#39;second&#39;);  
moment().get(&#39;millisecond&#39;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment().get(unit) === moment()[unit]()  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Units 是大小写敏感，支持复数和缩写 year (years, y), month (months, M), date (dates, D), hour (hours, h), minute (minutes, m), second (seconds, s), millisecond (milliseconds, ms)&lt;/p&gt;

&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;

&lt;h2 id=&#34;9-操作&#34;&gt;9 操作&lt;/h2&gt;

&lt;h3 id=&#34;9-1-add&#34;&gt;9.1 Add&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().add(String, Number);  
moment().add(Number, String); // 2.0.0  
moment().add(Duration); // 1.6.0  
moment().add(Object);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-2-subtract&#34;&gt;9.2 Subtract&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().subtract(String, Number);  
moment().subtract(Number, String); // 2.0.0  
moment().subtract(Duration); // 1.6.0  
moment().subtract(Object);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-3-start-of-time&#34;&gt;9.3 start of time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().startOf(String);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-4-end-of-time&#34;&gt;9.4 end of time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().endOf(String);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-5-maximum&#34;&gt;9.5 Maximum&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().max(Moment|String|Number|Date|Array);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;限制一个moment的最大值&lt;/p&gt;

&lt;h3 id=&#34;9-6-minimum&#34;&gt;9.6 Minimum&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().min(Moment|String|Number|Date|Array);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-7-local&#34;&gt;9.7 Local&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().local();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-8-utc&#34;&gt;9.8 UTC&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().utc()  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-9-timezone-offset&#34;&gt;9.9 Timezone Offset&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().zone();  
moment().zone(Number|String);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;10-display&#34;&gt;10 Display&lt;/h2&gt;

&lt;h3 id=&#34;10-1-format&#34;&gt;10.1 Format&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().format();  
moment().format(String);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-2-time-from-now&#34;&gt;10.2 Time from now&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().fromNow();  
moment().fromNow(Boolean);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-3-time-from-x&#34;&gt;10.3 Time from x&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().from(Moment|String|Number|Date|Array);  
moment().from(Moment|String|Number|Date|Array, Boolean);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-4-calendar-time&#34;&gt;10.4 Calendar Time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().calendar();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-5-difference&#34;&gt;10.5 Difference&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().diff(Moment|String|Number|Date|Array);  
moment().diff(Moment|String|Number|Date|Array, String);  
moment().diff(Moment|String|Number|Date|Array, String, Boolean);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要得到两个moment的时间差millseconds，使用moment#diff&lt;br /&gt;
也可以得到另一个单位时间差，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = moment([2007, 0, 29]);  
var b = moment([2007, 0, 28]);  
a.diff(b, &#39;days&#39;) // 1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能会得到负值&lt;/p&gt;

&lt;h3 id=&#34;10-6-unix-offset-milliseconds&#34;&gt;10.6 Unix Offset（milliseconds）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.valueof();  
+moment();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-7-unix-timestamp-seconds&#34;&gt;10.7 Unix Timestamp(seconds)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().unix()  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-8-days-in-month&#34;&gt;10.8 Days in Month&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().daysInMonth();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-9-得到javascript-date-对象&#34;&gt;10.9 得到javascript Date 对象&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.toDate();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-10-得到数组&#34;&gt;10.10 得到数组&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().toArray()  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-11-得到json&#34;&gt;10.11 得到JSON&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().toJSON();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-12-得到iso-8601-字符串&#34;&gt;10.12 得到ISO 8601 字符串&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().toISOString();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-查询&#34;&gt;11 查询&lt;/h2&gt;

&lt;h3 id=&#34;11-1-is-before&#34;&gt;11.1 Is Before&lt;/h3&gt;

&lt;h3 id=&#34;11-2-is-same&#34;&gt;11.2 Is Same&lt;/h3&gt;

&lt;h3 id=&#34;11-3-is-after&#34;&gt;11.3 Is After&lt;/h3&gt;

&lt;h3 id=&#34;11-4-is-leap-year&#34;&gt;11.4 Is Leap Year&lt;/h3&gt;

&lt;h3 id=&#34;11-5-is-daylight-saving-time&#34;&gt;11.5 Is Daylight Saving Time&lt;/h3&gt;

&lt;h3 id=&#34;11-6-is-a-moment&#34;&gt;11.6 Is a Moment&lt;/h3&gt;

&lt;h2 id=&#34;12-i18n&#34;&gt;12 i18n&lt;/h2&gt;

&lt;p&gt;你可以加载多种语言，并轻松地切换&lt;/p&gt;

&lt;h3 id=&#34;12-1-changing-language-globally&#34;&gt;12.1 Changing language globally&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.lang(String);  
moment.lang(String[]);  
moment.lang(String, Object);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;moment默认情况下为英语，如果你想切换到其他语言，你可以先把其他语言加载进Moment.js 待用。把键值对赋值给moment.lang，就可以加载语言。&lt;br /&gt;
一旦你加载了一种语言，它成为活动语言，想要换语言，只需调用moment.call&lt;/p&gt;

&lt;h3 id=&#34;12-2-changing-language-locally&#34;&gt;12.2 Changing language locally&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment().lang(String);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12-3-在浏览器里加载语言&#34;&gt;12.3 在浏览器里加载语言&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.lang(String, Object);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：目录是/min/lang/&lt;/p&gt;

&lt;h3 id=&#34;12-4-查看当前语言&#34;&gt;12.4 查看当前语言&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.lang();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12-5-listing-the-months-and-weekdays-of-the-current-moment-js-language&#34;&gt;12.5 Listing the months and weekdays of the current Moment.js language&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.months()  
moment.monthsShort()  
moment.weekdays()  
moment.weekdaysShort()  
moment.weekdaysMin()  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-自定义&#34;&gt;13 自定义&lt;/h2&gt;

&lt;p&gt;Moment.js 可以非常轻松地自定义。通常，你应该自定义语言。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment.lang(&#39;en-my-settings&#39;, {  
    // customizations.  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，你也可以覆盖已存在的语言&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment.lang(&#39;en&#39;, {  
    // customizations  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有被设置的选项，将继承英语设置&lt;/p&gt;

&lt;h3 id=&#34;13-1-month-names&#34;&gt;13.1 Month Names&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.lang(&#39;en&#39;, {  
    months : String[]  
});  
moment.lang(&#39;en&#39;, {  
    months : Function  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;13-2-month-abbreviations&#34;&gt;13.2 Month Abbreviations&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.lang(&#39;en&#39;, {  
    monthsShort : String[]  
});  
moment.lang(&#39;en&#39;, {  
    monthsShort : Function  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;13-3-weekday-names&#34;&gt;13.3 Weekday Names&lt;/h3&gt;

&lt;h3 id=&#34;13-4-weekday-abbreviations&#34;&gt;13.4 Weekday Abbreviations&lt;/h3&gt;

&lt;h3 id=&#34;13-5-minimal-weekday-abbreviations&#34;&gt;13.5 Minimal Weekday Abbreviations&lt;/h3&gt;

&lt;h3 id=&#34;13-6-long-date-formats&#34;&gt;13.6 Long Date Formats&lt;/h3&gt;

&lt;h3 id=&#34;13-7-relative-time&#34;&gt;13.7 Relative Time&lt;/h3&gt;

&lt;h2 id=&#34;14-durations&#34;&gt;14 Durations&lt;/h2&gt;

&lt;h3 id=&#34;14-1-创建&#34;&gt;14.1 创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration(Number, String);  
moment.duration(Number);  
moment.duration(Object);  
moment.duration(String);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认单位是 milliseconds&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment.duration(100); // 100 milliseconds  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以加上单位&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moment.duration(2, &#39;seconds&#39;);  
moment.duration(2, &#39;minutes&#39;);  
moment.duration(2, &#39;hours&#39;);  
moment.duration(2, &#39;days&#39;);  
moment.duration(2, &#39;weeks&#39;);  
moment.duration(2, &#39;months&#39;);  
moment.duration(2, &#39;years&#39;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-2-humanize&#34;&gt;14.2 Humanize&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration().humanize();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-3-milliseconds&#34;&gt;14.3 Milliseconds&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration().milliseconds();  
moment.duration().asMilliseconds();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-4-seconds&#34;&gt;14.4 Seconds&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration().seconds();  
moment.duration().asSeconds();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-5-minutes&#34;&gt;14.5 Minutes&lt;/h3&gt;

&lt;h3 id=&#34;14-6-hours&#34;&gt;14.6 Hours&lt;/h3&gt;

&lt;h3 id=&#34;14-7-days&#34;&gt;14.7 Days&lt;/h3&gt;

&lt;h3 id=&#34;14-8-months&#34;&gt;14.8 Months&lt;/h3&gt;

&lt;h3 id=&#34;14-9-years&#34;&gt;14.9 Years&lt;/h3&gt;

&lt;h3 id=&#34;14-10-add-time&#34;&gt;14.10 Add Time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration().add(Number, String);  
moment.duration().add(Number);  
moment.duration().add(Duration);  
moment.duration().add(Object);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-11-subtract-time&#34;&gt;14.11 Subtract Time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration().subtract(Number, String);  
moment.duration().subtract(Number);  
moment.duration().subtract(Duration);  
moment.duration().subtract(Object);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-12-as-unit-of-time&#34;&gt;14.12 As Unit of Time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration().as(string);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Duration#as(&amp;lsquo;x&amp;rsquo;)用来替换 Duration#asX&lt;/p&gt;

&lt;h3 id=&#34;14-13-get-unit-of-time&#34;&gt;14.13 Get unit of Time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;moment.duration().get(string);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Duration#get(&amp;lsquo;x&amp;rsquo;)用来替换 Duration#x()&lt;/p&gt;

&lt;h3 id=&#34;utilities&#34;&gt;Utilities&lt;/h3&gt;
</description>
        </item>
        
        <item>
            <title>coffeescript</title>
            <link>//blog.pytool.com/reship/2015-04-18-coffeescript/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-04-18-coffeescript/</guid>
            <description>&lt;p&gt;功能array comprehensions, prototype aliases and classes&lt;br /&gt;
##语法&lt;br /&gt;
没有分号。使用缩进来代替花括号。&lt;/p&gt;

&lt;p&gt;###注释&lt;br /&gt;
注释格式与ruby一致，以井号开头&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A comment  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;支持多行注释，多行注释会添加到生成的javascript中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;###  
	A multiline comment  
###  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###变量与作用域&lt;br /&gt;
编译时，CoffeeScript使用一个匿名函数把所有脚本都包裹起来，将其限定在局部作用域中，并且为所有的变量赋值前自动添加var。&lt;/p&gt;

&lt;p&gt;可以通过下面的方式创建全局变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports = this  
exports.MyVariable = &amp;quot;foo-bar&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###数组和对象&lt;br /&gt;
花括号可以省略，分割用的逗号可以通过换行省略。中括号不能省略。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object1 = {one: 1, two: 2}  

# Without braces  
object2 = one: 1, two: 2  

# Using new lines instead of commas  
object3 =  
  one: 1  
  two: 2  

song = [&amp;quot;do&amp;quot;, &amp;quot;re&amp;quot;, &amp;quot;mi&amp;quot;, &amp;quot;fa&amp;quot;, &amp;quot;so&amp;quot;]  

bitlist = [  
  1, 0, 1  
  0, 0, 1  
  1, 1, 0  
]  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###函数&lt;br /&gt;
函数通过一组可选的圆括号包裹的参数, 一个箭头, 一个函数体来定义. 一个空的函数像是这样:  &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;br /&gt;
。函数可以是一行，也可以是多行。函数的最后一个表达式回作为隐式的返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;square=(x) -&amp;gt; x*x  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####参数默认值&lt;br /&gt;
一些函数函数参数会有默认值, 当传入的参数的不存在 (null 或者 undefined) 时会被使用.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fill = (container, liquid = &amp;quot;coffee&amp;quot;) -&amp;gt;  
  &amp;quot;Filling the #{container} with #{liquid}...&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####变参&lt;br /&gt;
使用&lt;code&gt;...&lt;/code&gt;表示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sum = (nums...) -&amp;gt;  
  result = 0  
  nums.forEach (n) -&amp;gt; result += n  
  result  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nums 不是一个arguments 对象，而是一个真数组。&lt;/p&gt;

&lt;p&gt;####函数调用&lt;br /&gt;
无参数调用函数时需要加括号。如果函数被至少一个参数跟着的话，coffeescript会自动调用这个函数。&lt;/p&gt;

&lt;p&gt;####函数上下文&lt;br /&gt;
使用胖箭头&lt;code&gt;=&amp;gt;&lt;/code&gt;，可以确保函数的上下文绑定为当前的上下文。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.clickHandler = -&amp;gt; alert &amp;quot;clicked&amp;quot;  
element.addEventListener &amp;quot;click&amp;quot;, (e) =&amp;gt; this.clickHandler(e)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种绑定的思想与jQuery的 &lt;code&gt;proxy()&lt;/code&gt;或者ES5&amp;rsquo;s的&lt;code&gt;bind()&lt;/code&gt;函数是类似的概念。&lt;/p&gt;

&lt;p&gt;###流程控制&lt;br /&gt;
if/else 表达式可以不用圆括号和花括号就写出来. 就像函数和其他块级表达式那样, 多行的条件可以通过缩进来表明.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if happy and knowsIt  
  clapsHands()  
  chaChaCha()  
else if  
  showIt()  
else  
  bongbong()  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;coffeescript支持一项ruby特性，在if语句之前使用前缀表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mood = greatlyImproved if singing  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;unless 是if的否定&lt;/p&gt;

&lt;p&gt;####三元表达式&lt;br /&gt;
CoffeeScript 里不存在直白的三元表达式. — 你只要在一行内使用普通的 if 语句。在单行if语句中必须使用then关键字，这样coffeescript才能知道执行体从哪里开始。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;date = if friday then sue else jill  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####存在操作符&lt;br /&gt;
CoffeeScript存在操作符?只会在变量为null或者undefined的时候会返回真，与Ruby的nil?类似。&lt;/p&gt;

&lt;p&gt;###操作符和别名&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;coffeescript&lt;/th&gt;
&lt;th&gt;javascript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;is&lt;/td&gt;
&lt;td&gt;===&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isnt&lt;/td&gt;
&lt;td&gt;!==&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;true,yes,on&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;false,no,off&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;@,this&lt;/td&gt;
&lt;td&gt;this&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;of&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;no js equivalent&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;::&lt;/td&gt;
&lt;td&gt;prototype&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;###字符串插值&lt;/p&gt;

&lt;p&gt;在双引号的字符串中可以包含#{}标记，用来插入表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;favourite_color = &amp;quot;Blue. No, yel...&amp;quot;  
question = &amp;quot;Bridgekeeper: What... is your favourite color?  
            Galahad: #{favourite_color}  
            Bridgekeeper: Wrong!  
            &amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;允许多行字符串，无需&lt;code&gt;+&lt;/code&gt;&lt;br /&gt;
###循环和列表解析&lt;/p&gt;

&lt;p&gt;JavaScript中的数组迭代使用一种相当古老的语法，看上去更像一个类似于C之类的老语言，而不是现代的面向对象的语言。ES5引入forEach()函数来稍微改善了下这种情况，但是这样的话每次迭代都需要调用一次函数，因此运行速度会变慢。再一次，CoffeeScript给出一种漂亮的语法拯救了我们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for name in [&amp;quot;Roger&amp;quot;, &amp;quot;Roderick&amp;quot;, &amp;quot;Brian&amp;quot;]  
  alert &amp;quot;Release #{name}&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要知道当前迭代索引的话，只需要再多传一个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for name, i in [&amp;quot;Roger the pickpocket&amp;quot;, &amp;quot;Roderick the robber&amp;quot;]  
  alert &amp;quot;#{i} - Release #{name}&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用前缀的形式你可以一行代码完成迭代。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;release prisoner for prisoner in [&amp;quot;Roger&amp;quot;, &amp;quot;Roderick&amp;quot;, &amp;quot;Brian&amp;quot;]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就如Python的推导式一样，你可以过滤它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prisoners = [&amp;quot;Roger&amp;quot;, &amp;quot;Roderick&amp;quot;, &amp;quot;Brian&amp;quot;]  
release prisoner for prisoner in prisoners when prisoner[0] is &amp;quot;R&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以使用推导式来迭代对象的全部属性，不过要使用of代替in关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;names = sam: seaborn, donna: moss  
alert(&amp;quot;#{first} #{last}&amp;quot;) for first, last of names  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唯一CoffeeScript暴露出来的底层循环语法是while循环。它与原JavaScript中while循环的行为差不多，只是包含了已添加的优点，它能返回一个结果数组。看起来像Array.prototype.map()函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num = 6  
minstrel = while num -= 1  
  num + &amp;quot; Brave Sir Robin ran away&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>javascript 数组循环</title>
            <link>//blog.pytool.com/reship/2015-04-30-javascript-array-loop/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-04-30-javascript-array-loop/</guid>
            <description>&lt;p&gt;原文地址：&lt;a href=&#34;http://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript&#34; target=&#34;_blank&#34;&gt;http://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##数组&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用forEach(ES5+)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用for&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用for-in&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用for-of (隐式的使用iterator)(ES6+)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;显式的使用iterator&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###使用forEach 和相关的&lt;/p&gt;

&lt;p&gt;如果你的浏览器支持ECMAScript5，可以直接用forEach&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a=[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;d&amp;quot;];  
a.forEach(function(entry){  
    console.log(entry);  
})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;forEach 接受一个迭代函数，和一个可选的值，在迭代函数中作为this。迭代函数可以接受三个参数：每一个输入的值，输入值的位置，和数组的引用。&lt;/p&gt;

&lt;p&gt;forEach 的好处是在循环里无需自己声明index 和value，它们以迭代函数的参数形式提供。&lt;/p&gt;

&lt;p&gt;如果你大可不必担心性能，详情：&lt;a href=&#34;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&#34; target=&#34;_blank&#34;&gt;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ES5还提供了好几个方便操作数组的函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;every 当迭代函数第一次返回falsey值的时候停止循环&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;some  当迭代函数第一次返回truthy值的时候停止循环&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;filter    创建一个新的数组，包含那些在迭代函数中返回true的元素，去掉了返回false 的元素&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;map   创建了一个新的数组，由迭代函数返回值组成&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;reduce&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;reduceRight&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###使用简单的for循环&lt;br /&gt;
有时候最古老的方式就是最好的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var index;  
var a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];  

for(index=0;index&amp;lt;a.length;++index){  
    console.log(a[index]);  
}  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果再循环中数组的长度不会变，而且关注性能的话，可以写的稍微复杂一些：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var index,len;  
var a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]  
for (index=0;len=a.length;index&amp;lt;len;++)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###正确的使用for-in&lt;/p&gt;

&lt;p&gt;别人可能会告诉你使用for-in ,但&lt;a href=&#34;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&#34; target=&#34;_blank&#34;&gt;for-in 并不是用来做这项工作的&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;for-in 用来循环对象的可枚举的属性，而不是数组。但是，还是很有用的，尤其是sparse array，但是需要你做好安全检查。&lt;/p&gt;

&lt;p&gt;###使用 for-of&lt;/p&gt;

&lt;p&gt;ES6 给javascript添加了iterators。使用iterators最简单的方式就是使用for-of 语句。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var val;  
var a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];  
for(val of a){  
	console.log(val)  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;底层，它使用了iterator&lt;/p&gt;

&lt;p&gt;###显式的使用iterator&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];  
var it=a.values();  
var entry;  
while(!(entry=it.next()).done){  
	console.log(entry.value);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Array-like Object&lt;/p&gt;

&lt;p&gt;还有一些类数组对象，他们有length属性，和properties with numeric names，例如NodeList 实例，arguments 对象。该如何循环它的内容呢？&lt;/p&gt;

&lt;p&gt;###使用forEach（ES5+）&lt;/p&gt;

&lt;p&gt;假设你想在Node的childNodes 属性上使用forEach，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Array.prototype.forEach.call(node.childNodes,function(child){  
	//do something whth child  
})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你要频繁使用，可以保存一个引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var forEach=Array.prototype.forEach;  

forEach.call(node.childNodes,function(child){  
	//do something  
})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###使用for循环&lt;br /&gt;
###正确的使用for-in&lt;br /&gt;
也要做和数组一样的安全检查&lt;br /&gt;
###使用for-of(ES6)&lt;br /&gt;
###显式的使用iterator&lt;/p&gt;

&lt;p&gt;###创建一个真数组&lt;br /&gt;
把类数组对象转换成真数组。利用数组的slice方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var trueArray=Array.prototype.slice.call(arrayLikeObject,0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var divs = Array.prototype.slice.call(document.querySelectorAll(&amp;quot;div&amp;quot;), 0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Caveat for host-provided objects&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>selenium-IDE</title>
            <link>//blog.pytool.com/reship/2015-03-06-selenium-ide/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-03-06-selenium-ide/</guid>
            <description>&lt;p&gt;##简介&lt;br /&gt;
##安装&lt;br /&gt;
##打开IDE&lt;br /&gt;
##IDE功能&lt;br /&gt;
###菜单栏&lt;br /&gt;
test suite 是一套test case。&lt;/p&gt;

&lt;p&gt;###工具条&lt;br /&gt;
###test case 面板&lt;br /&gt;
###log/reference/ui-element/rollup&lt;br /&gt;
##创建Test case&lt;br /&gt;
###录制&lt;br /&gt;
需要注意的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要想记录&lt;code&gt;type&lt;/code&gt;命令需要在页面某处点击一下&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;点击一个连接通常被录制为&lt;code&gt;click&lt;/code&gt;，通常情况下你需要将其变成&lt;code&gt;clickAndWait&lt;/code&gt;，这是为了暂停测试用例直到新页面加载完成。否则，测试用例会在页面加载完成之前继续运行，这会导致不可预料的错误。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###添加断言和验证&lt;/p&gt;

&lt;p&gt;###编辑&lt;br /&gt;
##运行Test case&lt;br /&gt;
双击某条命令，会单独运行该命令。&lt;br /&gt;
##使用Base URL 在不同域名下运行测试用例&lt;br /&gt;
##Selenium 命令——&amp;rdquo;Selenese&amp;rdquo;&lt;br /&gt;
通过Selenese你可以测试标签是否存在，测试指定内容，测试损坏的链接，输入框，下拉列表，提交表单，表格数据。还有窗口大小，鼠标位置，alert，Ajax,弹框，事件处理等等。&lt;/p&gt;

&lt;p&gt;selenium命令可以分为三类&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Actions。如果一个Action 失败，或者有错误，当前测试用例会失败。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Accessors。检查应用的状态，并将结果存到变量中。例如：&lt;code&gt;storeTitle&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Assertions。Assertions可以在三种模式下使用：assert,verify和waitFor。例如你可以&lt;code&gt;assertText&lt;/code&gt;,&lt;code&gt;verifyText&lt;/code&gt;,&lt;code&gt;waitForText&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##脚本语法&lt;br /&gt;
##常用命令&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;open&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;click/clickAndWait&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;verifyTitle/assertTitle&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;verifyTextPresent&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;verifyElementPresent&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;verifyText 验证文本及对应的标签存在于网页中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;verifyTable&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;waitForPageToLoad 暂停执行直到新页面加载完。会被clickAndWait自动调用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;waitForElementPresent&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##验证页面元素&lt;/p&gt;

&lt;p&gt;##Assertion 还是 Verification&lt;br /&gt;
选择Assert还是verify可以归结为如何方便的管理失败用例。&lt;/p&gt;

&lt;p&gt;一个Assert会使当前测试失败并终止当前test case，而一个verify会使当前测试失败但会继续执行当前test case。&lt;/p&gt;

&lt;p&gt;最好是以合乎逻辑的顺序分组你的测试命令，每一组以一个assert开始，后面跟着一个或多个verify。&lt;/p&gt;

&lt;p&gt;###verify TextPresent&lt;br /&gt;
&lt;code&gt;TextPresent&lt;/code&gt;命令用来验证指定文本是否在页面中存在。它接受一个参数：要验证的文本。当你只关心文本是否出现时可以用这条命令，但当你关心文本出现的位置时，不要用这条命令。&lt;/p&gt;

&lt;p&gt;###verifyElementPresent&lt;br /&gt;
&lt;code&gt;verifyElementPresent&lt;/code&gt;用来验证指定标签是否在页面中存在。只验证标签，而不是其内容。通常用来检查图片是否存在。&lt;/p&gt;

&lt;p&gt;###verifyText&lt;br /&gt;
&lt;code&gt;verifyText&lt;/code&gt;用来验证标签以及内容是否存在。&lt;/p&gt;

&lt;p&gt;##定位元素&lt;br /&gt;
location strategy 为locatorType=location。locatorType 有好多种，如下：&lt;br /&gt;
###根据Identifier定位&lt;/p&gt;

&lt;p&gt;这是最常用的也是默认使用的locatorType。根据ID定位时，会返回第一个匹配的元素。如果没有匹配的，那么返回第一个name属性值匹配该id的元素.&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
 &amp;lt;body&amp;gt;  
  &amp;lt;form id=&amp;quot;loginForm&amp;quot;&amp;gt;  
   &amp;lt;input name=&amp;quot;username&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;  
   &amp;lt;input name=&amp;quot;password&amp;quot; type=&amp;quot;password&amp;quot; /&amp;gt;  
   &amp;lt;input name=&amp;quot;continue&amp;quot; type=&amp;quot;submit&amp;quot; value=&amp;quot;Login&amp;quot; /&amp;gt;  
  &amp;lt;/form&amp;gt;  
 &amp;lt;/body&amp;gt;  
&amp;lt;html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;identifier=loginForm (3)&lt;br /&gt;
identifier=password (5)&lt;br /&gt;
identifier=continue (6)&lt;br /&gt;
continue (6)&lt;br /&gt;
由于identifier类型的locator是默认使用的，所以前三个的‘identifier=’不是必须的，可以写成第四个&lt;/p&gt;

&lt;p&gt;####根据ID定位&lt;br /&gt;
id=loginForm&lt;br /&gt;
####根据name定位&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;html&amp;gt;  
  &amp;lt;body&amp;gt;  
   &amp;lt;form id=&amp;quot;loginForm&amp;quot;&amp;gt;  
    &amp;lt;input name=&amp;quot;username&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;  
    &amp;lt;input name=&amp;quot;password&amp;quot; type=&amp;quot;password&amp;quot; /&amp;gt;  
    &amp;lt;input name=&amp;quot;continue&amp;quot; type=&amp;quot;submit&amp;quot; value=&amp;quot;Login&amp;quot; /&amp;gt;  
    &amp;lt;input name=&amp;quot;continue&amp;quot; type=&amp;quot;button&amp;quot; value=&amp;quot;Clear&amp;quot; /&amp;gt;  
   &amp;lt;/form&amp;gt;  
 &amp;lt;/body&amp;gt;  
 &amp;lt;html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当有多个元素拥有相同name时，你可以使用过滤器，默认的过滤器是value(匹配value值)&lt;/p&gt;

&lt;p&gt;name=username (4)&lt;br /&gt;
name=continue value=Clear (7)&lt;br /&gt;
name=continue Clear (7)&lt;br /&gt;
name=continue type=button (7)&lt;/p&gt;

&lt;p&gt;注意：上面提到的三种定位方式都不会涉及到标签层级结构。而xpath和Dom 两种定位方式会涉及到标签的层级&lt;/p&gt;

&lt;p&gt;####根据Xpath定位&lt;br /&gt;
因为只有xpath locator以&amp;rsquo;//&amp;lsquo;开头，所以当使用xpath locator时，不需要xpath=&lt;/p&gt;

&lt;p&gt;有用的插件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xpath checker&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;firebug&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;####根据链接内容定位超链接&lt;br /&gt;
如果两个链接内容相同，则返回第一个。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
 &amp;lt;body&amp;gt;  
  &amp;lt;p&amp;gt;Are you sure you want to do this?&amp;lt;/p&amp;gt;  
  &amp;lt;a href=&amp;quot;continue.html&amp;quot;&amp;gt;Continue&amp;lt;/a&amp;gt;  
  &amp;lt;a href=&amp;quot;cancel.html&amp;quot;&amp;gt;Cancel&amp;lt;/a&amp;gt;  
&amp;lt;/body&amp;gt;  
&amp;lt;html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;link=Continue (4)&lt;br /&gt;
link=Cancel (5)&lt;/p&gt;

&lt;p&gt;####根据DOM定位&lt;br /&gt;
因为只有Dom locator以&amp;rsquo;document&amp;rsquo;开始，所以当使用Dom locator时，不需要dom=&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
  &amp;lt;body&amp;gt;  
   &amp;lt;form id=&amp;quot;loginForm&amp;quot;&amp;gt;  
    &amp;lt;input name=&amp;quot;username&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;  
    &amp;lt;input name=&amp;quot;password&amp;quot; type=&amp;quot;password&amp;quot; /&amp;gt;  
    &amp;lt;input name=&amp;quot;continue&amp;quot; type=&amp;quot;submit&amp;quot; value=&amp;quot;Login&amp;quot; /&amp;gt;  
    &amp;lt;input name=&amp;quot;continue&amp;quot; type=&amp;quot;button&amp;quot; value=&amp;quot;Clear&amp;quot; /&amp;gt;  
   &amp;lt;/form&amp;gt;  
 &amp;lt;/body&amp;gt;  
 &amp;lt;html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dom=document.getElementById(&amp;lsquo;loginForm&amp;rsquo;) (3)&lt;br /&gt;
dom=document.forms&lt;a href=&#34;3&#34; target=&#34;_blank&#34;&gt;&amp;lsquo;loginForm&amp;rsquo;&lt;/a&gt;&lt;br /&gt;
dom=document.forms&lt;a href=&#34;3&#34; target=&#34;_blank&#34;&gt;0&lt;/a&gt;&lt;br /&gt;
document.forms[0].username (4)&lt;br /&gt;
document.forms[0].elements&lt;a href=&#34;4&#34; target=&#34;_blank&#34;&gt;&amp;lsquo;username&amp;rsquo;&lt;/a&gt;&lt;br /&gt;
document.forms[0].elements&lt;a href=&#34;4&#34; target=&#34;_blank&#34;&gt;0&lt;/a&gt;&lt;br /&gt;
document.forms[0].elements&lt;a href=&#34;7&#34; target=&#34;_blank&#34;&gt;3&lt;/a&gt;&lt;br /&gt;
####根据css定位&lt;br /&gt;
大多数selenium用户建议使用css locator，因为它比xpath快。&lt;/p&gt;

&lt;p&gt;##匹配文本模式&lt;br /&gt;
##&amp;lsquo;AndWait&amp;rsquo;命令&lt;br /&gt;
需要注意的是：如果你用了一个AndWait命令，而对应的action并没有触发navigation/refresh，你的测试会失败。这是因为当没有任何navigation或refresh的时候，selenium会触发AndWait的timeout，然后抛出一个timeout exception&lt;br /&gt;
##在ajax应用中使用waitFor命令&lt;br /&gt;
在ajax应用中，页面不会刷新。使用&lt;code&gt;andWait&lt;/code&gt;命令就不起作用了，因为页面没有刷新。通过暂停测试运行一定时间也不是最好的方法，因为响应的时间可长可短，会导致测试失败。最好的方法应该是在一定时间内等待需要的元素，当发现需要的元素时继续执行测试。&lt;/p&gt;

&lt;p&gt;这就需要&lt;code&gt;waitFor&lt;/code&gt;命令，比如&lt;code&gt;waitForElementPresent&lt;/code&gt;或&lt;code&gt;waitForVisible&lt;/code&gt;,这些命令每秒检查一次需要的状态，一旦状态满足，就继续执行。&lt;/p&gt;

&lt;p&gt;##流程控制&lt;br /&gt;
Selenese本身是不支持条件语句和循环语句的。当你需要流程控制的时候，有三种选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;列表项&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##保存命令、selenium变量&lt;br /&gt;
&lt;code&gt;store&lt;/code&gt;是最基本的用来保存值的命令。&lt;br /&gt;
使用的时候用${变量名}&lt;br /&gt;
其它常用store命令&lt;br /&gt;
storeElementPresent 对应verifyElementPresent。它保存一个布尔值，根据对应的元素是否存在。&lt;br /&gt;
storeText对应verifyText&lt;br /&gt;
storeEval 接受一段脚本作为参数。把脚本的运行结果保存到变量里。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>underscore学习</title>
            <link>//blog.pytool.com/reship/2015-05-01-underscore/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-05-01-underscore/</guid>
            <description>&lt;p&gt;##集合&lt;/p&gt;

&lt;p&gt;Note: Collection functions work on arrays, objects, and array-like objects such as arguments, NodeList and similar. But it works by duck-typing, so avoid passing objects with a numeric length property. It&amp;rsquo;s also good to note that an each loop cannot be broken out of — to break, use _.find instead.&lt;/p&gt;

&lt;p&gt;###遍历&lt;br /&gt;
each&lt;br /&gt;
map&lt;br /&gt;
pluck&lt;br /&gt;
invoke&lt;br /&gt;
###查找&lt;br /&gt;
find&lt;/p&gt;

&lt;p&gt;where&lt;br /&gt;
findWhere&lt;/p&gt;

&lt;p&gt;###过滤&lt;br /&gt;
filter&lt;br /&gt;
reject&lt;br /&gt;
partition&lt;br /&gt;
###判定&lt;br /&gt;
every&lt;br /&gt;
some&lt;br /&gt;
contains&lt;/p&gt;

&lt;p&gt;###随机&lt;br /&gt;
shuffle&lt;br /&gt;
sample&lt;/p&gt;

&lt;p&gt;###其它&lt;/p&gt;

&lt;p&gt;reduce&lt;br /&gt;
reduceRight&lt;br /&gt;
max&lt;br /&gt;
min&lt;br /&gt;
size&lt;/p&gt;

&lt;p&gt;sortBy&lt;br /&gt;
groupBy&lt;br /&gt;
indexBy&lt;br /&gt;
countBy&lt;br /&gt;
toArray&lt;/p&gt;

&lt;p&gt;##数组&lt;/p&gt;

&lt;p&gt;###去掉数组中部分元素&lt;br /&gt;
without&lt;br /&gt;
difference&lt;br /&gt;
compact&lt;br /&gt;
uniq&lt;br /&gt;
###返回指定位置元素&lt;br /&gt;
first&lt;br /&gt;
initial&lt;br /&gt;
last&lt;br /&gt;
rest&lt;br /&gt;
###多数组操作&lt;br /&gt;
union&lt;br /&gt;
intersection&lt;br /&gt;
difference&lt;br /&gt;
zip&lt;br /&gt;
unzip&lt;br /&gt;
###数组转对象&lt;br /&gt;
object&lt;/p&gt;

&lt;p&gt;###查找索引&lt;br /&gt;
indexOf&lt;br /&gt;
lastIndexOf&lt;br /&gt;
sortedIndex&lt;br /&gt;
findIndex&lt;br /&gt;
findLastIndex&lt;/p&gt;

&lt;p&gt;###创建数组&lt;br /&gt;
range&lt;br /&gt;
###其它&lt;br /&gt;
flatten&lt;/p&gt;

&lt;p&gt;###数组变对象&lt;/p&gt;

&lt;p&gt;##对象&lt;br /&gt;
###获取属性&lt;br /&gt;
keys&lt;br /&gt;
allKeys&lt;br /&gt;
findkey&lt;br /&gt;
has&lt;br /&gt;
###获取属性值&lt;br /&gt;
values&lt;br /&gt;
property&lt;br /&gt;
propertyOf&lt;br /&gt;
###转换属性值&lt;br /&gt;
mapObject&lt;br /&gt;
###键值对换&lt;br /&gt;
invert&lt;br /&gt;
###对象变数组&lt;br /&gt;
pairs&lt;br /&gt;
###获取对象所有方法&lt;br /&gt;
functions&lt;/p&gt;

&lt;p&gt;###扩展对象&lt;br /&gt;
extend&lt;br /&gt;
extendOwn&lt;br /&gt;
###精简对象&lt;br /&gt;
pick&lt;br /&gt;
omit&lt;/p&gt;

&lt;p&gt;###判断&lt;br /&gt;
matcher&lt;br /&gt;
isEqual&lt;br /&gt;
isMatch&lt;br /&gt;
isEmpty&lt;br /&gt;
isFinite&lt;/p&gt;

&lt;p&gt;###判断数据类型&lt;br /&gt;
isElement&lt;br /&gt;
isArray&lt;br /&gt;
isObject&lt;br /&gt;
isArguments&lt;br /&gt;
isFunction&lt;br /&gt;
isString&lt;br /&gt;
isNumber&lt;br /&gt;
isBoolean&lt;br /&gt;
isDate&lt;br /&gt;
isRegExp&lt;br /&gt;
isError&lt;br /&gt;
isNaN&lt;br /&gt;
isNull&lt;br /&gt;
isUndefined&lt;/p&gt;

&lt;p&gt;###其它&lt;br /&gt;
defaults&lt;br /&gt;
clone&lt;br /&gt;
tap&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>【译】CSS实现响应式全屏背景图</title>
            <link>//blog.pytool.com/reship/2015-01-07-responsive-background-image/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-01-07-responsive-background-image/</guid>
            <description>

&lt;p&gt;当前很流行的一种网页形式就是满屏大图，本文将用最简单的方式实现该效果。用到了CSS 属性&lt;code&gt;background-size&lt;/code&gt; ,无需javascript。&lt;/p&gt;

&lt;p&gt;先看&lt;a href=&#34;http://cdn.sixrevisions.com/0431-01_responsive_background_image_demo/responsive-full-background-image-demo.html&#34; target=&#34;_blank&#34;&gt;demo&lt;/a&gt;，打开后，调整浏览器窗口大小，观察背景图的变化。&lt;/p&gt;

&lt;p&gt;如果在你的项目中也需要这样的效果，那么你就来对地方了。&lt;/p&gt;

&lt;p&gt;##核心概念&lt;br /&gt;
- 使用&lt;code&gt;background-size&lt;/code&gt; 属性，填充整个viewport&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当css属性`background-size` 值为`cover`时，浏览器会自动按比例缩放背景图的宽和高，直到大于或等于viewport的宽和高  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用媒体查询为移动设备提供更小尺寸的背景图&lt;/p&gt;

&lt;p&gt;为什么要给移动设备提供小尺寸背景图呢？在demo中，我们看到的背景图的实际尺寸为5498px * 3615px，使用这么大尺寸图片的目的是满足绝大多数宽屏显示器，并且不会显示模糊，而代价就是1.7MB的图片体积。&lt;/p&gt;

&lt;p&gt;但是在移动设备上没有必要使用这么大的图片，同时大图还会导致加载变慢，尤其是在移动网络下。&lt;/p&gt;

&lt;p&gt;需要说明的是：为移动设备提供小背景图对该技术方案来说是可选的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##实践&lt;br /&gt;
- HTML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;!doctype html&amp;gt;  
    &amp;lt;html&amp;gt;  
    &amp;lt;body&amp;gt;  
        ...Your content goes here...  
    &amp;lt;/body&amp;gt;  
    &amp;lt;/html&amp;gt;  

后面我们会给`body`标签指定背景图，这样背景图就可以填充整个浏览器viewport了。  

其实，该方案对所有的块级容器都可以生效。如果你的块级容器的宽高是动态的，那么背景图将自动伸缩，充满整个容器。  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CSS&lt;/p&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;标签的样式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body {  
/* 加载背景图 */  
background-image: url(images/background-photo.jpg);  

/* 背景图垂直、水平均居中 */  
background-position: center center;  

/* 背景图不平铺 */  
background-repeat: no-repeat;  

/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */  
background-attachment: fixed;  

/* 让背景图基于容器大小伸缩 */  
background-size: cover;  

/* 设置背景颜色，背景图加载过程中会显示背景色 */  
background-color: #464646;  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面最重要的一条就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;background-size: cover;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样浏览器就会按比例缩放背景图直至背景图宽高不小于容器的宽高（在上面的例子中，就是&lt;code&gt;body&lt;/code&gt;标签）。&lt;/p&gt;

&lt;p&gt;这里需要注意的一点就是：如果背景图小于&lt;code&gt;body&lt;/code&gt;标签的尺寸（例如在高分辨率显示器上，或页面内容特别多时），浏览器会拉伸图片。我们都知道，当把一个图片拉伸时，图片会变模糊。&lt;/p&gt;

&lt;p&gt;因此，在选择背景图时，要特别注意尺寸。为了照顾到大尺寸屏幕，demo里用的图片尺寸为5498px * 3615px 。&lt;/p&gt;

&lt;p&gt;同时，为了让背景图始终相对于viewport居中，我们声明了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;background-position: center center;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的规则会把背景图缩放的原点定位到viewport的中心。&lt;/p&gt;

&lt;p&gt;接下来我们需要解决的问题是：当内容的高度大于viewport的高度时，会出现滚动条。我们希望背景图始终相对于viewport固定，即使用户滚动时也是一样。&lt;/p&gt;

&lt;p&gt;解决办法就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;background-attachment: fixed;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;可选-使用媒体查询应对小屏幕&#34;&gt;(可选)使用媒体查询应对小屏幕&lt;/h2&gt;

&lt;p&gt;为了应对小屏幕，我用photoshop将背景图按比例缩放到768px * 505px，然后通过smush.it 压缩图片体积。这样就将图片体积从1741KB降到114KB，节省了93%。&lt;/p&gt;

&lt;p&gt;下面是媒体查询的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media only screen and (max-width: 767px) {  
  body {  
    background-image: url(images/background-photo-mobile-devices.jpg);  
  }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的媒体查询将&lt;code&gt;max-width: 767px&lt;/code&gt; 设为断点，也就是说当浏览器viewport大于767px时，会使用大背景图，反之使用小背景图。&lt;/p&gt;

&lt;p&gt;使用上面媒体查询不利的一面是，如果你把浏览器窗口从1200px缩小到640px(反之亦然)，你会看到一个短暂的闪烁，因为小背景图或大背景图正在加载。&lt;/p&gt;

&lt;p&gt;译文到此结束。原文地址&lt;a href=&#34;http://sixrevisions.com/css/responsive-background-image/&#34; target=&#34;_blank&#34;&gt;http://sixrevisions.com/css/responsive-background-image/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ps:&lt;br /&gt;
由于IE8及其以前的浏览器不支持&lt;code&gt;background-size:cover&lt;/code&gt;(&lt;a href=&#34;http://caniuse.com/#search=background-size&#34; target=&#34;_blank&#34;&gt;查看兼容性&lt;/a&gt;),所以要支持这些老古董，还需要多做一些。&lt;/p&gt;

&lt;p&gt;要让IE8支持&lt;code&gt;background-size&lt;/code&gt;,可以用&lt;a href=&#34;https://github.com/louisremi/background-size-polyfill&#34; target=&#34;_blank&#34;&gt;background-size-polyfill&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>【译】走向Retina Web</title>
            <link>//blog.pytool.com/reship/2015-01-11-towards-a-retina-web/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-01-11-towards-a-retina-web/</guid>
            <description>&lt;p&gt;在深入细节之前，有必要先明确一些关键性概念。&lt;/p&gt;

&lt;p&gt;##Device Pixels(设备像素)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/device-pixels.png&#34; alt=&#34;物理像素&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一个设备像素（或者称为物理像素）是显示器上最小的物理显示单元。在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。&lt;/p&gt;

&lt;p&gt;###Screen density(屏幕密度)&lt;/p&gt;

&lt;p&gt;屏幕密度指的是单位面积里物理像素的数量，通常以PPI(pixels per inch)为单位。苹果公司为它的双倍屏幕密度的显示器（double-density displays）创造了一个新词“Retina”，声称在正常的观看距离下，人眼无法在Retina显示器上分辨出单独的像素。&lt;/p&gt;

&lt;p&gt;##CSS Pixels&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/css-pixels.png&#34; alt=&#34;CSS Pixels&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CSS pixel是浏览器使用的抽象单位，用来精确的、统一的绘制网页内容。通常，CSS pixels被称为与设备无关的像素（DIPs,device-independent pixels）。在标准密度显示器（standard-density displays）上，1 CSS pixel对应一个物理像素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div height=&amp;quot;200&amp;quot; width=&amp;quot;300&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在标准密度显示器上，上面的&lt;code&gt;div&lt;/code&gt;会占据200 * 300 个物理像素。而在Retina显示器上，为了保持相同的物理大小，上面的&lt;code&gt;div&lt;/code&gt;需要用400 * 600 个物理像素来渲染，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/css-device-pixels.png&#34; alt=&#34;On a Retina display, four times as many device pixels are on the same physical surface&#34; /&gt;&lt;/p&gt;

&lt;p&gt;物理像素与CSS pixel 的比率可以通过媒体查询的&lt;code&gt;device-pixel-ratio&lt;/code&gt;来检测（&lt;a href=&#34;http://caniuse.com/#search=device-pixel-ratio&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;device-pixel-ratio&lt;/code&gt;兼容性&lt;/a&gt;）。也可以通过javascript的&lt;code&gt;window.devicePixelRatio&lt;/code&gt;来获取该比率。&lt;/p&gt;

&lt;p&gt;##Bitmap Pixels（位图像素）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/bitmap-pixels.png&#34; alt=&#34;位图像素&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一个位图像素是栅格图像（也就是位图，png、jpg、gif等等）最小的数据单元。每一个位图像素都包含着该如何显示自己的信息，例如显示位置、颜色值等。一些图片格式还包含额外的数据，例如透明度。&lt;/p&gt;

&lt;p&gt;除了自身的分辨率外，图片在网页上还有一个抽象的尺寸，通过CSS pixels来定义。浏览器在渲染的过程中，会根据图片的CSS高度和宽度来压缩或是拉伸图片。&lt;/p&gt;

&lt;p&gt;当一个位图以原尺寸展示在标准密度显示器上时，一位图像素对应一个物理像素，就是无失真显示。而在Retina显示器上，为了保证同样的物理尺寸，需要用四倍的像素来展示，但由于单个位图像素已经无法再进一步分割，只能就近取色，导致图片变虚。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/css-device-bitmap-pixels.png&#34; alt=&#34;Each bitmap pixel gets multiplied by four to fill the same physical surface on a Retina display.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;##解决方案&lt;/p&gt;

&lt;p&gt;下面的每一种方案都是权衡性能、实现难度、跨浏览器兼容性等之后的结果。你需要根据实际情况进行选择。&lt;/p&gt;

&lt;p&gt;##方案一：通过HTML 和 CSS 控制大小&lt;/p&gt;

&lt;p&gt;最直接的方式就是通过CSS或者HTML将图片尺寸减半。例如，要提供一个200 * 300像素的图片（这里指的是CSS pixels）,你需要上传一张尺寸为400 * 600像素的图片到服务器，然后通过CSS属性或者HTML属性将其缩小50%。在标准密度显示器上，显示结果就是一张只有原图像素总数四分之一的图片，这个过程通常被称为downsampling。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/downsampling.png&#34; alt=&#34;A CSS-sized image gets its dimensions halved during the rendering process.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在Retina显示器上，将会用四倍的物理像素数来渲染同一张图片，这样每一个物理像素就对应一个位图像素，从而图片的每一个像素都得到展现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/html-sizing.png&#34; alt=&#34;CSS-sized images regain their full-detail glory on Retina displays.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过下面几种技术可以实现上面的解决方案：&lt;/p&gt;

&lt;p&gt;###通过HTML&lt;/p&gt;

&lt;p&gt;最简单的方式就是使用&lt;code&gt;img&lt;/code&gt;标签的&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;height&lt;/code&gt;属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;example@2x.png&amp;quot; width=&amp;quot;200&amp;quot; height=&amp;quot;300&amp;quot; /&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要说明：虽然指定图片高度是可选的，但是声明高度的好处是，浏览器会在图片加载之前预留出相应的位置，这就避免了图片加载完成后页面布局发生变化。&lt;/p&gt;

&lt;p&gt;###通过javascript&lt;/p&gt;

&lt;p&gt;利用jQuery，可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).load(function() {  
  var images = $(&#39;img&#39;);  
    images.each(function(i) {  
      $(this).width($(this).width() / 2);  
    });  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###通过CSS（SCSS）&lt;/p&gt;

&lt;p&gt;如果你想把有关样式的代码都放到css里的话，那么最常见的方法就是使用HTML元素的背景替换&lt;code&gt;img&lt;/code&gt;标签，然后指定&lt;code&gt;background-size&lt;/code&gt;属性。你可以明确指定背景图片的宽度和高度，或者是在指定了HTML元素的宽高的前提下使用&lt;code&gt;background-size: contain&lt;/code&gt;。需要注意的是IE7、8不支持&lt;code&gt;background-size&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.image {  
  background-image: url(example@2x.png);  
  background-size: 200px 300px;  
  /* 或者是用 background-size: contain; */  
  height: 300px;  
  width: 200px;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以通过&lt;code&gt;:before&lt;/code&gt;或者&lt;code&gt;:after&lt;/code&gt;伪元素来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.image-container:before {  
  background-image: url(example@2x.png);  
  background-size: 200px 300px;  
  content:&#39;&#39;;  
  display: block;  
  height: 300px;  
  width: 200px;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该技术对CSS sprite同样适用，因为&lt;code&gt;background-position&lt;/code&gt;指定的值是相对于CSS 大小的（在这里就是 200px * 300px）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.icon {  
  background-image: url(example@2x.png);  
  background-size: 200px 300px;  
  height: 25px;  
  width: 25px;  
  &amp;amp;.trash {  
    background-position: 25px 0;  
  }  
  &amp;amp;.edit {  
    background-position: 25px 25px;  
  }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方案一的优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;容易实现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;跨浏览器兼容&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;方案一的不足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非Retina设备需要下载Retina资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在标准密度屏幕上Downsampled的图片可能会丢失一些锐利度&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;IE7、8不支持&lt;code&gt;background-size&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##方案二：查询像素密度&lt;br /&gt;
应对Retina最流行的方式应该就是通过查询像素密度，然后针对不同密度提供不同的资源。该方案可以用CSS或javascript来实现。&lt;/p&gt;

&lt;p&gt;###通过CSS媒体查询&lt;br /&gt;
大多数浏览器都以私有前缀实现了&lt;code&gt;device-pixel-ratio&lt;/code&gt;，以及它的俩兄弟&lt;code&gt;min-device-pixel-ratio&lt;/code&gt; 和 &lt;code&gt;max-device-pixel-ratio&lt;/code&gt;。媒体查询再结合&lt;code&gt;background-image&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.icon {  
  background-image: url(example.png);  
  background-size: 200px 300px;  
  height: 300px;  
  width: 200px;  
}  

@media only screen and (-Webkit-min-device-pixel-ratio: 1.5),  
only screen and (-moz-min-device-pixel-ratio: 1.5),  
only screen and (-o-min-device-pixel-ratio: 3/2),  
only screen and (min-device-pixel-ratio: 1.5) {  
  .icon {  
    background-image: url(example@2x.png);  
  }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用的比率是1.5而不是2，这样该媒体查询还可以覆盖一些非苹果设备。&lt;/p&gt;

&lt;p&gt;CSS媒体查询优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设备只需下载相匹配的资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;跨浏览器兼容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;像素级精确控制&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CSS媒体查询不足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代码冗长，尤其是大网站&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;把应该由&lt;code&gt;img&lt;/code&gt;标签展示的图片转化为背景图片属于语义错误。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###通过javascript&lt;/p&gt;

&lt;p&gt;像素密度可以通过javascript的&lt;code&gt;window.devicePixelRatio&lt;/code&gt;来查询(注意：不是所有浏览器都支持&lt;code&gt;devicePixelRatio&lt;/code&gt;)。一旦检测到高密度显示器，你就可以用高质量图片替换普通图片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function(){  
  if (window.devicePixelRatio &amp;gt; 1) {  
    var lowresImages = $(&#39;img&#39;);  
    images.each(function(i) {  
      var lowres = $(this).attr(&#39;src&#39;);  
      var highres = lowres.replace(&amp;quot;.&amp;quot;, &amp;quot;@2x.&amp;quot;);  
      $(this).attr(&#39;src&#39;, highres);  
    });  
  }  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://retinajs.com/&#34; target=&#34;_blank&#34;&gt;Retina.js&lt;/a&gt;是一个js插件，原理类似，但是有一些额外功能，例如：忽略外部图片等等。&lt;/p&gt;

&lt;p&gt;通过javascript查询的优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;容易实现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;非Retina设备无需下载大尺寸图片&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;像素级精确控制&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过javascript查询的不足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Retina设备不得不下载标准图片和高质量图片&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;图片替换的过程会被用户看到&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;有一些浏览器不支持（例如IE和火狐）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##方案三：SVG(Scalable Vector Graphics)&lt;br /&gt;
由于位图本身固有的性质，不可能无限制的缩放。而恰恰这是矢量图的优势所在。&lt;/p&gt;

&lt;p&gt;浏览器对svg的&lt;a href=&#34;http://caniuse.com/#search=svg&#34; target=&#34;_blank&#34;&gt;兼容程度&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用svg资源最直接的方式就是通过&lt;code&gt;img&lt;/code&gt;标签或者CSS &lt;code&gt;background-image&lt;/code&gt; 或者&lt;code&gt;content:url()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;example.svg&amp;quot; width=&amp;quot;200&amp;quot; height=&amp;quot;300&amp;quot; /&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是通过CSS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 使用 background-image */  
.image {  
  background-image: url(example.svg);  
  background-size: 200px 300px;  
  height: 200px;  
  width: 300px;  
}  

/* 使用 content:url() */  
.image-container:before {  
  content: url(example.svg);  
  /* width 和 height 对 content:url() 不起作用 */  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用svg不仅可以节约宝贵的带宽资源，还可以使你的图片资源更容易维护。&lt;/p&gt;

&lt;p&gt;如果你需要支持IE7、8或是Android 2.x，那么你还需要一个fallback 方案：用对应的PNG资源替换SVG图片。通过&lt;a href=&#34;http://modernizr.com/docs/#features-misc&#34; target=&#34;_blank&#34;&gt;Modernizr&lt;/a&gt; 来做，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.image {  
  background-image: url(example.png);  
  background-size: 200px 300px;  
}  
.svg {  
  .image {  
    background-image: url(example.svg);  
  }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过html实现类似的fallback方案：给&lt;code&gt;img&lt;/code&gt;标签添加自定义&lt;code&gt;data&lt;/code&gt;属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;example.svg&amp;quot; data-png-fallback=&amp;quot;example.png&amp;quot; /&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，剩下的就交给jQuery和Modernizr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function(){  
  if(!Modernizr.svg) {  
    var images = $(&#39;img[data-png-fallback]&#39;);  
    images.each(function(i) {  
      $(this).attr(&#39;src&#39;, $(this).data(&#39;png-fallback&#39;));  
    });  
  }  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过html实现的fallback方案缺点就是：不支持svg的浏览器也会下载svg资源。&lt;/p&gt;

&lt;p&gt;方案三的优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有设备用同一套资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;容易维护&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应对未来的变化：可以无限缩放&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;方案三的不足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于anti-aliasing，所以不能精确到像素&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不适合复杂的的图像，因为图片体积会非常大&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;IE7、8以及早期android没有原生支持svg&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##方案四：Icon Fonts&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.mediatemple.netdna-cdn.com/wp-content/uploads/2012/07/icon-fonts.png&#34; alt=&#34;Icon Fonts&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Twitter的 bootstrap使Icon Fonts 更加的流行，该技术是通过&lt;code&gt;@font-face&lt;/code&gt;引入基于icon的字体来代替位图icon，这样icon就不再受分辨率影响。用纯色icon代替字母的web Fonts，可以用CSS来调整样式，就像网页里其它文本一样。&lt;/p&gt;

&lt;p&gt;你可以通过&lt;a href=&#34;http://fontello.com/&#34; target=&#34;_blank&#34;&gt;Fontello&lt;/a&gt;, &lt;a href=&#34;https://github.com/fontello/font-builder&#34; target=&#34;_blank&#34;&gt;Font Builder&lt;/a&gt; 和&lt;a href=&#34;http://www.webdesignerdepot.com/2012/01/how-to-make-your-own-icon-Webfont/&#34; target=&#34;_blank&#34;&gt;Inkscape&lt;/a&gt;来制作自己的font。&lt;/p&gt;

&lt;p&gt;网页中使用icon fonts 最常见的方式是给特定的HTML元素(通常是&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;)赋予&lt;code&gt;.icon&lt;/code&gt; 或&lt;code&gt;.glyph&lt;/code&gt; class,然后使用icon对应的字符作为内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&amp;quot;icon&amp;quot;&amp;gt;a&amp;lt;/span&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;@font-face&lt;/code&gt;引入了自定义font后，用下面的方式使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.icon {  
  font-family: &#39;My Icon Font&#39;;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种方式是使用&lt;code&gt;:before&lt;/code&gt;伪元素和&lt;code&gt;content&lt;/code&gt;属性，每个icon对应一个class：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&amp;quot;glyph-heart&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[class^=&amp;quot;glyph-&amp;quot;]:before {  
  font-family: &#39;My Icon Font&#39;;  
}  
.glyph-heart:before {  
  content: &#39;h&#39;;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方案四的优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应对未来的变化：可以无限制缩放&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;跨浏览器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;比图片资源更灵活：可以用在placeholder文本里以及其他form元素中&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;方案四的不足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于anti-aliasing，所以不能精确到像素&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;比较难维护：修改一个icon就需要重新生成整个font&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;依赖语义错误的标签（除非是用&lt;code&gt;:before&lt;/code&gt; 或&lt;code&gt;:after&lt;/code&gt;伪元素）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Favicons&lt;br /&gt;
Favicons也获得了它应有的关注度，越来越多的应用于浏览器之外，用作网站或应用的图标。&lt;br /&gt;
要想适配Retina，需要导出两版.ico文件，16 * 16像素 和 32 * 32像素。&lt;/p&gt;

&lt;p&gt;##一睹未来&lt;br /&gt;
除了上面提到的几种技术，还有一些技术值得关注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-Webkit-image-set&lt;/code&gt;用来提供多版本背景图&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.image {  
  background-image: -Webkit-image-set(url(example.png) 1x, url(example@2x.png) 2x);  
  background-size: 200px 300px;  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/scottjehl/picturefill&#34; target=&#34;_blank&#34;&gt;Picturefill&lt;/a&gt;是一个html+js解决方案，大量使用&lt;code&gt;data&lt;/code&gt;属性和媒体查询，来给不同的媒体上下文提供不同的图片。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div data-picture&amp;gt;  
    &amp;lt;div data-src=&amp;quot;example.png&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;  
    &amp;lt;div data-src=&amp;quot;example@2x.png&amp;quot; data-media=&amp;quot;(min-device-pixel-ratio: 1.5)&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;  
&amp;lt;!-- Fallback content for non-JS browsers --&amp;gt;  
&amp;lt;noscript&amp;gt;  
    &amp;lt;img src=&amp;quot;example.png&amp;quot; &amp;gt;  
&amp;lt;/noscript&amp;gt;  
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;http://www.smashingmagazine.com/2012/08/20/towards-retina-web/&#34; target=&#34;_blank&#34;&gt;http://www.smashingmagazine.com/2012/08/20/towards-retina-web/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ps:虽然原文发表于2012/08/20，但对于不知该如何应对Retina的前端来说，信息量还是非常大的。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用 SVG</title>
            <link>//blog.pytool.com/reship/2015-05-20-using-svg/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-05-20-using-svg/</guid>
            <description>

&lt;h2 id=&#34;为什么使用svg&#34;&gt;为什么使用SVG&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;体积小&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;缩放不失真(除非非常小)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在retina显示很好&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;制作svg&#34;&gt;制作SVG&lt;/h2&gt;

&lt;p&gt;Adobe illustrator&lt;/p&gt;

&lt;h2 id=&#34;以-img-方式使用svg&#34;&gt;以&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;方式使用SVG&lt;/h2&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;kiwi.svg&amp;quot; alt=&amp;quot;Kiwi standing on oval&amp;quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;浏览器支持&#34;&gt;浏览器支持&lt;/h3&gt;

&lt;p&gt;参见：&lt;a href=&#34;http://caniuse.com/#feat=svg-img&#34; target=&#34;_blank&#34;&gt;http://caniuse.com/#feat=svg-img&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本上除了IE 8及其以下，和Android 2.3及其以下都支持。&lt;/p&gt;

&lt;p&gt;兼容方案一：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Modernizr.svg) {  
  $(&amp;quot;.logo img&amp;quot;).attr(&amp;quot;src&amp;quot;, &amp;quot;images/logo.png&amp;quot;);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;兼容方案二：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;image.svg&amp;quot; onerror=&amp;quot;this.onerror=null; this.src=&#39;image.png&#39;&amp;quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;以-background-image-方式使用svg&#34;&gt;以&lt;code&gt;background-image&lt;/code&gt;方式使用SVG&lt;/h2&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;/&amp;quot; class=&amp;quot;logo&amp;quot;&amp;gt;  
  Kiwi Corp  
&amp;lt;/a&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;css:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.logo {  
  display: block;  
  text-indent: -9999px;  
  width: 100px;  
  height: 82px;  
  background: url(kiwi.svg);  
  background-size: 100px 82px;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;浏览器支持-1&#34;&gt;浏览器支持&lt;/h3&gt;

&lt;p&gt;参见:&lt;a href=&#34;http://caniuse.com/#feat=svg-css&#34; target=&#34;_blank&#34;&gt;http://caniuse.com/#feat=svg-css&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本上和使用&lt;code&gt;img&lt;/code&gt;标签一致：除了IE 8及其以下，和Android 2.3及其以下都支持。&lt;/p&gt;

&lt;p&gt;兼容方案一：Modernizr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.main-header {  
  background: url(logo.svg) no-repeat top left;  
  background-size: contain;  
}  

.no-svg .main-header {  
  background-image: url(logo.png);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会比使用&lt;code&gt;img&lt;/code&gt;标签少一次HTTP请求。&lt;/p&gt;

&lt;p&gt;兼容方案二：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body {  
  background: url(fallback.png);  
  background-image: url(image.svg), none;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为浏览器对SVG的支持程度和对多背景的支持程度类似。所以如果浏览器支持多背景图，基本上就支持SVG，第二条css规则就生效，从而覆盖第一条。&lt;/p&gt;

&lt;h2 id=&#34;问题是&#34;&gt;问题是&lt;/h2&gt;

&lt;p&gt;使用上面个两种方式的缺点在于不能用CSS控制SVG的内部结构。用下面的方式就可以：&lt;/p&gt;

&lt;h2 id=&#34;使用-inline-svg&#34;&gt;使用&amp;rdquo;inline&amp;rdquo; SVG&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;  

   &amp;lt;!-- paste in SVG code, image shows up!  --&amp;gt;  

&amp;lt;/body&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就不用发起额外的HTTP请求。和使用Data URI的优点一样，当然缺点也一样。&lt;/p&gt;

&lt;p&gt;还可以利用后端语言进行插入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php echo file_get_contents(&amp;quot;kiwi.svg&amp;quot;); ?&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用PHP时，要使用&lt;code&gt;file_get_contents()&lt;/code&gt; ,而不能用&lt;code&gt;include()&lt;/code&gt;和&lt;code&gt;include_once()&lt;/code&gt;。because SVG sometimes is exported with &amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt; that as the opening line, which will cause the PHP parser to choke on it.&lt;/p&gt;

&lt;h3 id=&#34;优化svg文件&#34;&gt;优化SVG文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://petercollingridge.appspot.com/svg_optimiser&#34; target=&#34;_blank&#34;&gt;http://petercollingridge.appspot.com/svg_optimiser&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/svg/svgo&#34; target=&#34;_blank&#34;&gt;https://github.com/svg/svgo&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用css进行控制&#34;&gt;用CSS进行控制&lt;/h3&gt;

&lt;p&gt;可以像编辑HTML标签那样编辑SVG标签，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg ...&amp;gt;  
  &amp;lt;ellipse class=&amp;quot;ground&amp;quot; .../&amp;gt;  
  &amp;lt;path class=&amp;quot;kiwi&amp;quot; .../&amp;gt;  
&amp;lt;/svg&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SVG 元素有独立的CSS属性集。例如：不是&lt;code&gt;background-color&lt;/code&gt;而是 &lt;code&gt;fill&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.kiwi {  
  fill: #94d31b;  
}  
.kiwi:hover {  
  fill: #ace63c;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svg 可以使用&lt;a href=&#34;http://www.w3.org/TR/SVG/filters.html&#34; target=&#34;_blank&#34;&gt;filter&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg ...&amp;gt;  
  ...  
  &amp;lt;filter id=&amp;quot;pictureFilter&amp;quot; &amp;gt;  
    &amp;lt;feGaussianBlur stdDeviation=&amp;quot;5&amp;quot; /&amp;gt;  
  &amp;lt;/filter&amp;gt;  
&amp;lt;/svg&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;.ground:hover {  
  filter: url(#pictureFilter);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;浏览器支持-2&#34;&gt;浏览器支持&lt;/h3&gt;

&lt;p&gt;参见&lt;a href=&#34;http://caniuse.com/#feat=svg-html5&#34; target=&#34;_blank&#34;&gt;http://caniuse.com/#feat=svg-html5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本上也是：除了IE 8及其以下，和Android 2.3及其以下都支持。&lt;/p&gt;

&lt;p&gt;兼容方案：利用Modernizr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg&amp;gt; ... &amp;lt;/svg&amp;gt;  
&amp;lt;div class=&amp;quot;fallback&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;.fallback {  
  display: none;  
  /* Make sure it&#39;s the same size as the SVG takes up */  
}  
.no-svg .fallback {  
  background-image: url(logo.png);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;以-object-形式使用svg&#34;&gt;以&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;形式使用SVG&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;object type=&amp;quot;image/svg+xml&amp;quot; data=&amp;quot;kiwi.svg&amp;quot; class=&amp;quot;logo&amp;quot;&amp;gt;  
  Kiwi Logo &amp;lt;!-- fallback image in CSS --&amp;gt;  
&amp;lt;/object&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;兼容方案，还是使用Modernizr：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.no-svg .logo {  
  width: 200px;  
  height: 164px;  
  background-image: url(kiwi.png);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要使用CSS，则不能直接在HTML中应用外部样式表，或是内联样式表。需要将&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;写到SVG文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg ...&amp;gt;  
  &amp;lt;style&amp;gt;  
    /* SVG specific fancy CSS styling here */  
  &amp;lt;/style&amp;gt;  
  ...  
&amp;lt;/svg&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要引用外部样式表，则需要在SVG文件中，&lt;svg&gt;标签之上加入下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml-stylesheet type=&amp;quot;text/css&amp;quot; href=&amp;quot;svg.css&amp;quot; ?&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以这种方式引入的样式对于用&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 或是&lt;code&gt;background-image&lt;/code&gt; 方式引入的SVG文件不起作用。&lt;/p&gt;

&lt;h2 id=&#34;以data-uri-形式使用svg&#34;&gt;以Data URI 形式使用SVG&lt;/h2&gt;

&lt;p&gt;在线转换工具：&lt;a href=&#34;http://www.mobilefish.com/services/base64/base64.php&#34; target=&#34;_blank&#34;&gt;http://www.mobilefish.com/services/base64/base64.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以用转换后的结果替换下面的&lt;code&gt;[data]&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;标签：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;data:image/svg+xml;base64,[data]&amp;quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在CSS中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.logo {  
  background: url(&amp;quot;data:image/svg+xml;base64,[data]&amp;quot;);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;标签：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;object type=&amp;quot;image/svg+xml&amp;quot; data=&amp;quot;data:image/svg+xml;base64,[data]&amp;quot;&amp;gt;  
  fallback  
&amp;lt;/object&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在转换之前，在SVG中引入了&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;，那么如果使用&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;方式使用base64结果，同样会起作用。&lt;/p&gt;

&lt;h3 id=&#34;data-uri-的格式&#34;&gt;Data URI 的格式&lt;/h3&gt;

&lt;p&gt;Data URI不一定是base64格式。对于SVG来说，可能&lt;a href=&#34;https://css-tricks.com/probably-dont-base64-svg/&#34; target=&#34;_blank&#34;&gt;最好不要用base64格式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Primarily because the native format of SVG is much more repetitive than base64 ends up, it gzips better.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- base64 --&amp;gt;  
data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL...  

&amp;lt;!-- UTF-8, not encoded --&amp;gt;  
data:image/svg+xml;charset=UTF-8,&amp;lt;svg ...&amp;gt; ... &amp;lt;/svg&amp;gt;  

&amp;lt;!-- UTF-8, optimized encoding for compatibility --&amp;gt;  
data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=&#39;http://...&#39;  

&amp;lt;!-- Fully URL encoded ASCII --&amp;gt;  
data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//...  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://superuser.com/questions/120796/os-x-base64-encode-via-command-line#comment280484_120815&#34; target=&#34;_blank&#34;&gt;通过命令行进行base64编码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;https://css-tricks.com/using-svg/&#34; target=&#34;_blank&#34;&gt;https://css-tricks.com/using-svg/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>十六进制</title>
            <link>//blog.pytool.com/reship/2015-03-02-hexadecimal/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2015-03-02-hexadecimal/</guid>
            <description>&lt;p&gt;##基础知识&lt;br /&gt;
###十六进制 hexadecimal&lt;br /&gt;
十六进制（简写为hex或下标16），一般用数字0到9和字母A到F表示（其中:A~F即10~15）。&lt;br /&gt;
现在的16进制则普遍应用在计算机领域，这是因为将4个位元（Bit）化成单独的16进制数字不太困难。&lt;/p&gt;

&lt;p&gt;1字节可以表示成2个连续的16进制数字。可是，这种混合表示法容易令人混淆，因此需要一些字首、字尾或下标来显示。&lt;/p&gt;

&lt;p&gt;不同电脑系统、编程语言对于16进制数值有不同的表示方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C语言、Shell、Python、Java语言及其他相近的语言使用字首“0x”，例如“0x5A3”。开头的“0”令解析器更易辨认数，而“x”则代表十六进制（就如“O”代表八进制）。在“0x”中的“x”可以大写或小写。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在HTML，十六进制字元可以用“x”，例如&lt;code&gt;&amp;amp;#x5a3;&lt;/code&gt;和&lt;code&gt;&amp;amp;#1443;&lt;/code&gt;效果应该无异。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在网页设计上十六进制是很常用的。HTML和CSS使用十六进制的表示法来表示网页上的特定颜色。使用 # 的符号来表示而非用个别的符号表示十六进制。24-bit 颜色可以用 #RRGGBB 的格式来表示，&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在URL的特殊字符也是用ASCII中的十六进位，每字节都有百份比符号（%）在前，例如： 空格就表示为%20，而中文维基百科的首页地址就是 &lt;a href=&#34;http://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5&#34; target=&#34;_blank&#34;&gt;http://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5&lt;/a&gt; （在一些现代的浏览器，如Firefox中，地址中十六进制编码会被解码成实际字符，所以在这些浏览器中中文维基百科的首页地址显示成 &lt;a href=&#34;http://zh.wikipedia.org/wiki/Wikipedia:首页&#34; target=&#34;_blank&#34;&gt;http://zh.wikipedia.org/wiki/Wikipedia:首页&lt;/a&gt; ）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表示方法表&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;环境&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%hex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;XML,XHTML&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;#hex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HTML,CSS&lt;/td&gt;
&lt;td&gt;&lt;code&gt;#hex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;6位，用于表示颜色&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Unicode&lt;/td&gt;
&lt;td&gt;&lt;code&gt;U+hex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;6位，表示字符编码&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MIME&lt;/td&gt;
&lt;td&gt;&lt;code&gt;=hex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IPv6&lt;/td&gt;
&lt;td&gt;8个hex 用:分割&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
        </item>
        
        <item>
            <title>如何用Modern.IE在本地测试你的网站</title>
            <link>//blog.pytool.com/reship/2014-08-23-use-modern.ie-test-local-site/</link>
            <pubDate>Fri, 01 Jan 2016 00:00:00 UTC</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/reship/2014-08-23-use-modern.ie-test-local-site/</guid>
            <description>&lt;p&gt;市面上有很多用来测试前端代码质量的工具。比如说JSHint和JSLint用来检查我们的JS文件，&lt;a href=&#34;http://validator.w3.org/&#34; target=&#34;_blank&#34;&gt;W3C Markup validator&lt;/a&gt;用来检测我们的HTML代码是否有效，是否符合规范，&lt;a href=&#34;http://jigsaw.w3.org/css-validator/&#34; target=&#34;_blank&#34;&gt;W3C CSS validator&lt;/a&gt;用来检测我们的样式表。其实，还有更多工具可用。&lt;/p&gt;

&lt;p&gt;今天来介绍微软的&lt;a href=&#34;http://modern.ie/&#34; target=&#34;_blank&#34;&gt;Modern.IE&lt;/a&gt;。它可以扫描你的网站，从中找出常见的代码问题并生成一个报告（可以做成pdf）。这份报告包含了每个测试的结果以及一些有关如何解决问题或提高代码质量的建议。用这种方式，你可以保证自己的代码符合当前最佳实践并且性能良好。而你只需提供目标网页URL即可。&lt;/p&gt;

&lt;p&gt;##什么是Modern.IE&lt;/p&gt;

&lt;p&gt;Modern.IE是一项服务，它提供了一系列不同的工具，可以从不同的角度和目标来测试我们的网站。例如：Modern.IE提供了几个免费的windows虚拟机用来在windows，Mac，或者Linux上运行任何版本的IE。&lt;/p&gt;

&lt;p&gt;另一个功能就是由&lt;a href=&#34;http://www.browserstack.com/&#34; target=&#34;_blank&#34;&gt;BrowserStack&lt;/a&gt;提供的免费的自动屏幕快照。这个工具可以在几分钟之内生成指定网站在一系列移动设备和桌面设备上显示效果的快照。这意味着你可以得到你的网站在Android系统上的浏览器，windows 8上的火狐、Opera，甚至那些不容易获取的设备，比如使用Safari的iPhone 4s上显示效果的快照。&lt;/p&gt;

&lt;p&gt;接下来我们将深入探索如何扫描本地网站。&lt;/p&gt;

&lt;p&gt;##如何分析一个本地网站&lt;/p&gt;

&lt;p&gt;###安装扫描工具&lt;/p&gt;

&lt;p&gt;Modern.IE用来扫描网站的工具可以在&lt;a href=&#34;https://github.com/InternetExplorer/modern.IE-static-code-scan/&#34; target=&#34;_blank&#34;&gt;github上获取&lt;/a&gt;。在命令行中执行下面的命令，获取源代码拷贝&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/InternetExplorer/modern.IE-static-code-scan.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接在github上点击下载按钮，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2014/08/1407913254download-source-button.png&#34; alt=&#34;直接在github上点击下载按钮&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下载完成之后，你需要下载安装Node.js(版本0.10或更高版本)。安装Node.js之后，切换到扫描工具的源代码目录，执行下面的命令，安装所需依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一步，启动扫描服务，执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node app.js  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行完上个命令后，你将会看到一条关于服务状态和使用端口的消息（端口默认为1337）。打开浏览器，访问&lt;a href=&#34;http://localhost:[PORT-NUMBER]/&#34; target=&#34;_blank&#34;&gt;http://localhost:[PORT-NUMBER]/&lt;/a&gt; ，如果你没有修改默认设置，那么[PORT-NUMBER]为1337。&lt;/p&gt;

&lt;p&gt;按照上面的步骤操作下来，如果一切正常的话，你将会看到下面的页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2014/08/1407913396offline-scan-tool.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在你就可以开始扫描你的本地网站了&lt;/p&gt;

&lt;p&gt;###创建一个报告&lt;/p&gt;

&lt;p&gt;一切准备妥当之后，你就可以开始扫描本地网站了。在开始之前，要注意一点就是当前版本的扫描工具依赖jQuery，Microsoft选用了jQuery CDN。也就是说你必须联网，即使你测试的是离线网站，否则扫描工具会报错（显示错误“Uncaught ReferenceError: $ is not defined”，因为它无法加载jQuery）.&lt;/p&gt;

&lt;p&gt;输入你要扫描的网址，点击Scan按钮，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2014/08/1407913422scanning-an-offline-page.png&#34; alt=&#34;输入你要扫描的网址，点击Scan按钮&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你正在使用一个需要验证的系统，例如HTTP Basic 和Digest，你可以指定用户名和密码。&lt;/p&gt;

&lt;p&gt;扫描完成之后，工具会生成JSON格式的报告。&lt;/p&gt;

&lt;p&gt;###JSON报告&lt;br /&gt;
扫描完成之后，工具会把扫描结果输出为JSON格式。一个成功的测试输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“imageCompression”: {  
    “testName”: “imageCompression”,  
    “passed”: true  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个失败的测试输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“ie11tiles”: {  
    “testName”: “ie11tiles”,  
    “passed”: false,  
    “data”: {  
        “square70”: false,  
        “square150”: false,  
        “wide310”: false,  
        “square310”: false  
        “notifications”: false  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以选择自己写脚本转换测试报告，也可以在第二步的时候，通过点击Create Report按钮，将JSON格式的报告发送到Modern.IE 。如果你选择第二种方式，Modern.IE会显示本地测试报告，好像你在测试在线网站一样。需要注意的是截止本文发布，离线版本的工具因为一个问题导致不能在Modern.IE 上显示本地测试报告。&lt;/p&gt;

&lt;p&gt;##结语&lt;/p&gt;

&lt;p&gt;为了检测兼容性问题和性能提升，Modern.IE提供了许多用来分析网站的工具，不论是离线还是在线。感谢这个本地版本，它可以在网站上线之前进行测试，使我们可以避免在用户和客户之前出错。&lt;/p&gt;

&lt;p&gt;你试过Modern.IE 了么？&lt;/p&gt;

&lt;p&gt;原文地址： &lt;a href=&#34;http://www.sitepoint.com/test-site-locally-modern-ie/&#34; target=&#34;_blank&#34;&gt;http://www.sitepoint.com/test-site-locally-modern-ie/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
