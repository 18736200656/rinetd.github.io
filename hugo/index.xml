<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Hugos on 时光小栈</title>
        <link>http://blog.pytool.com/hugo/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Thu, 05 Oct 2017 10:58:08 -0400</updated>
        
        <item>
            <title>Hugo Shortcode</title>
            <link>http://blog.pytool.com/hugo/hugo_shortcode/</link>
            <pubDate>Thu, 05 Oct 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_shortcode/</guid>
            <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Markdown 语法十分简洁，如果想要插入更加复杂的内容就需要直接使用 HTML 代码，比如通过 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 来自定义图片尺寸，通过 &lt;code&gt;&amp;lt;iframes&amp;gt;&lt;/code&gt; 来插入视频。显然这样做，虽然扩展了 Markdown 文档的表达能力，但却牺牲了 Markdown 语法的简洁性，而且插入的 HTML 代码不利于后续对文档的维护和更新。&lt;/p&gt;

&lt;p&gt;问题的关键在于，Markdown 的简洁性本身就意味着它难以用来书写复杂的内容，尤其是涉及到展示效果的内容。Hugo 提供了 shortcode 来解决这一问题，既使内容保持了 Markdown 的简洁性，又允许创作者在文档中嵌入一些 Markdown 不支持的形式复杂的内容。&lt;/p&gt;

&lt;p&gt;简单来说，shortcode 是一些可以直接插入内容文档中的助记符，在 Hugo 生成网站时，会将这些助记符替换为相应的 HTML 代码片段（严格来说是模板片段）。这样的好处在于，在创作内容时，只要了解这些助记符的用法而不必关心它们是如何实现和转换的。另一方面来看，更新助记符对应的 HTML 片段时，内容文档不会受到影响。接下来将分别介绍：如何在内容文档中使用 shortcode ，Hugo 内置了哪些 shortcode 以及如何自定义 shortcode ？&lt;/p&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;p&gt;Shortcode 语法有些类似 HTML 标记，一个完整的 shortcode 包含以下几个部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{% shorcodename parameters %}}some content for shortcode template{{% /shortcodename %}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;{{% shorcodename parameters %}}&lt;/code&gt; 表示开标记，相应的 &lt;code&gt;{{% /shortcodename %}}&lt;/code&gt; 表示闭标记，闭标记是可选的，同样在开闭标记之间的内容也是可选的。&lt;/p&gt;

&lt;p&gt;开标记中的参数，最终会被传入 shortcode 模板文件中，影响模板的渲染。参数允许以位置参数或命名参数的形式输入（但不能同时传递这两种参数），参数之间用空格间隔，如果参数本身含有空格则需要为其添加双引号。命名参数的格式为 &lt;code&gt;name=&amp;quot;value&amp;quot;&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;除了使用上面的 &lt;code&gt;%&lt;/code&gt; 外，还可以使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 来作为 shortcode 的定界符，比如 &lt;code&gt;{{&amp;lt; gist spf13 7896402 &amp;gt;}}&lt;/code&gt; 。后者跟前者的唯一区别在于，包含在开闭标记之间的内容将不会被 Markdown 引擎处理。&lt;/p&gt;

&lt;p&gt;另外，本文中的许多 shortcode 只是用于显示，并不想要被 Hugo 处理，此时需要在 &lt;code&gt;%&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 定界符内侧添加 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;内置-shortcode&#34;&gt;内置 Shortcode&lt;/h2&gt;

&lt;p&gt;Hugo 预先定义了一些较为常用的 shortcode ，下面介绍如何使用以及在什么情形下使用它们，更详细的用法参见&lt;a href=&#34;https://gohugo.io/content-management/shortcodes/&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;高亮&#34;&gt;高亮&lt;/h3&gt;

&lt;p&gt;用来高亮文档中的代码片段，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; highlight python &amp;gt;}}  
def pt(txt):  
    print(txt)  
{{&amp;lt; /highlight &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;图片&#34;&gt;图片&lt;/h3&gt;

&lt;p&gt;用来扩展 Markdown 中插入图片的语法，该 shortcode 插入的图片支持自定义 CSS 类、添加链接和 caption 等，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; figure src=&amp;quot;/media/spf13.jpg&amp;quot; title=&amp;quot;Steve Francia&amp;quot; link=&amp;quot;&amp;quot; caption=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot; attr=&amp;quot;&amp;quot; attrlink=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档引用&#34;&gt;文档引用&lt;/h3&gt;

&lt;p&gt;根据文档在本地文件系统中的路径，来插入文档的超链接，甚至可以引用文档标题位置，用法样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Neat]({{&amp;lt; ref &amp;quot;blog/neat.md&amp;quot; &amp;gt;}})  
[Who]({{&amp;lt; relref &amp;quot;about.md#who&amp;quot; &amp;gt;}})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数为被引用文档的路径，Hugo 会自动将其替换为被引用文档的永久链接（permalink），&lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;relref&lt;/code&gt; 的不同之处在于，后者给出相对链接，而前者给出完整链接。以上样例的生成结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;/blog/neat&amp;quot;&amp;gt;Neat&amp;lt;/a&amp;gt;  
&amp;lt;a href=&amp;quot;/about/#who:c28654c202e73453784cfd2c5ab356c0&amp;quot;&amp;gt;Who&amp;lt;/a&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;github-代码片段&#34;&gt;GitHub 代码片段&lt;/h3&gt;

&lt;p&gt;用来在文档中插入 GitHub 上创建的代码片段，假设代码片段链接为：&lt;a href=&#34;https://gist.github.com/username/id&#34; target=&#34;_blank&#34;&gt;https://gist.github.com/username/id&lt;/a&gt; ，则插入语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; gist username id &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;twitter-推文&#34;&gt;Twitter 推文&lt;/h3&gt;

&lt;p&gt;用来在内容中插入一条 tweet ，推文的链接是这样的： &lt;a href=&#34;https://twitter.com/spf13/status/666616452582129664&#34; target=&#34;_blank&#34;&gt;https://twitter.com/spf13/status/666616452582129664&lt;/a&gt; ，插入这条推文的 shortcode 如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; tweet 666616452582129664 &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;youtube-视频&#34;&gt;YouTube 视频&lt;/h3&gt;

&lt;p&gt;用来在内容中插入 YouTube 视频，YouTube 视频资源链接是这样的： &lt;a href=&#34;https://www.youtube.com/watch?v=w7Ft2ymGmfc&#34; target=&#34;_blank&#34;&gt;https://www.youtube.com/watch?v=w7Ft2ymGmfc&lt;/a&gt; ，插入该视频的 shortcode 如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; youtube w7Ft2ymGmfc &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者开启自动播放&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; youtube id=&amp;quot;w7Ft2ymGmfc&amp;quot; autoplay=&amp;quot;true&amp;quot; &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vimeo-视频&#34;&gt;Vimeo 视频&lt;/h3&gt;

&lt;p&gt;同插入 YouTube 视频类似，假设资源链接为：&lt;a href=&#34;https://vimeo.com/channels/staffpicks/146022717&#34; target=&#34;_blank&#34;&gt;https://vimeo.com/channels/staffpicks/146022717&lt;/a&gt; ，则插入语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; vimeo 146022717 &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;speaker-deck-演示文稿&#34;&gt;Speaker Deck 演示文稿&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/&#34; target=&#34;_blank&#34;&gt;Speaker Deck&lt;/a&gt; 是一个允许我们共享演示文稿的地方，我们可以将共享在其上的演示文稿插入到内容文档中，在 Speaker Deck 上点击分享后会生成一段 HTML 代码，假设其中的 &lt;code&gt;data-id=&amp;quot;123456&amp;quot;&lt;/code&gt; ，那么在文档中可以使用如下语法插入该演示文稿&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; speakerdeck 123456 &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;instagram-图片&#34;&gt;Instagram 图片&lt;/h3&gt;

&lt;p&gt;插入 Instagram 上的图片，假设某张图片链接为：&lt;a href=&#34;https://www.instagram.com/p/BMokmydjG-M/&#34; target=&#34;_blank&#34;&gt;https://www.instagram.com/p/BMokmydjG-M/&lt;/a&gt; ，则插入该图片的语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; instagram BMokmydjG-M &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; instagram BMokmydjG-M hidecaption &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义-shortcode&#34;&gt;自定义 Shortcode&lt;/h2&gt;

&lt;h3 id=&#34;模板文件位置&#34;&gt;模板文件位置&lt;/h3&gt;

&lt;p&gt;shortcode 的工作机制就是将助记符关联的 HTML 模板片段渲染后插入到文档中。Hugo 支持自定义 shortcode ，需要做的十分简单，只要在模板目录 &lt;code&gt;layouts/shortcodes/&lt;/code&gt; 中创建模板文件即可，模板文件名即为 shortcode 的名称（除去文件名中的扩展名）。&lt;/p&gt;

&lt;p&gt;同时 Hugo 还支持检索主题资源中的 shortcode，因此 shortcode 的查找顺序如下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;/layouts/shortcodes/&amp;lt;SHORTCODE&amp;gt;.html&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/themes/&amp;lt;THEME&amp;gt;/layouts/shortcodes/&amp;lt;SHORTCODE&amp;gt;.html&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;模板文件内容&#34;&gt;模板文件内容&lt;/h3&gt;

&lt;p&gt;shortcode 的模板文件就是普通的 Hugo 模板文件。只不过在 shortcode 模板文件内，可以通过模板变量来访问传入 shortcode 的参数和开闭标记之间的内容。以及其它常规模板变量都可以在 shortcode 模板中访问。&lt;/p&gt;

&lt;h4 id=&#34;访问参数&#34;&gt;访问参数&lt;/h4&gt;

&lt;p&gt;虽然在使用 shortcode 时只可以传入位置和命名参数中的一种，但是在设计 shortcode 模板时却可以考虑接受这两种参数（当然不可能同时接受），为此可以通过模板变量 &lt;code&gt;.IsNamedParams&lt;/code&gt; 来判断，当前参数传入是位置的，还是命名的。&lt;/p&gt;

&lt;p&gt;在模板文件中，位置参数和命名参数都可以通过模板方法 &lt;code&gt;.Get&lt;/code&gt; 来访问：&lt;code&gt;{{ .Get 0 }}&lt;/code&gt; 和 &lt;code&gt;{{ .Get &amp;quot;name&amp;quot; }}&lt;/code&gt; 。或者使用 &lt;code&gt;with&lt;/code&gt; 语法来访问 &lt;code&gt;{{ with .Get &amp;quot;class&amp;quot;}}class=&amp;quot;{{.}}&amp;quot;{{ end }}&lt;/code&gt; 。此外还可以通过模板变量 &lt;code&gt;.Params&lt;/code&gt; 来访问参数。&lt;/p&gt;

&lt;h4 id=&#34;访问内容&#34;&gt;访问内容&lt;/h4&gt;

&lt;p&gt;使用 shortcode 时，位于开闭标记之间的内容，在模板文件中可以通过模板变量 &lt;code&gt;.Inner&lt;/code&gt; 来访问。&lt;/p&gt;

&lt;h4 id=&#34;访问父模板&#34;&gt;访问父模板&lt;/h4&gt;

&lt;p&gt;此外 shortcode 还支持嵌套，比如在内容文档中像下面这样插入 shortcode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{&amp;lt; parentshortcode &amp;gt;}}  
{{&amp;lt; childshortcode &amp;gt;}}  
{{&amp;lt; /parentshortcode &amp;gt;}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板文件 &lt;code&gt;layouts/shortcodes/childshortcode.html&lt;/code&gt; 中可以通过模板变量 &lt;code&gt;.Parent&lt;/code&gt; 来访问 &lt;code&gt;parendshortcode.html&lt;/code&gt; 的模板环境。&lt;/p&gt;

&lt;p&gt;总之 shortcode 模板文件跟普通的模板文件没有差别，基本就是 HTML 代码跟模板变量的混合体，不过 shortcode 模板除了可以访问常规模板变量外，还可以额外访问几个变量和方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Get 0 }}                    获取位置参数  
{{ .Get &amp;quot;name&amp;quot; }}               获取命名参数  
{{ with .Get &amp;quot;class&amp;quot;}} &amp;lt;p class=&amp;quot;{{.}}&amp;quot;&amp;gt; haha! &amp;lt;/p&amp;gt;{{ end }}  
.Inner                          位于 shortcode 开闭之间的内容  
.Params                         输入的参数列表  
.IsNamedParams                  判断 shortcode 输入的是位置参数还是命名参数  
.Parent                         shortcode 支持继承，该变量表示父 shortcode  
.Page                           所有的页面变量在 shortcode 都可用  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;模板样例&#34;&gt;模板样例&lt;/h3&gt;

&lt;p&gt;年份，模板位置 &lt;code&gt;/layouts/shortcodes/year.html&lt;/code&gt; ，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Page.Now.Year }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;高亮，模板位置 &lt;code&gt;/layouts/shortcodes/highlight.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ .Get 0 | highlight .Inner  }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片，模板位置 &lt;code&gt;/layouts/shortcodes/figure.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;figure {{ with .Get &amp;quot;class&amp;quot; }}class=&amp;quot;{{.}}&amp;quot;{{ end }}&amp;gt;  
    {{ with .Get &amp;quot;link&amp;quot;}}&amp;lt;a href=&amp;quot;{{.}}&amp;quot;&amp;gt;{{ end }}  
        &amp;lt;img src=&amp;quot;{{ .Get &amp;quot;src&amp;quot; }}&amp;quot; {{ if or (.Get &amp;quot;alt&amp;quot;) (.Get &amp;quot;caption&amp;quot;) }}alt=&amp;quot;{{ with .Get &amp;quot;alt&amp;quot;}}{{.}}{{else}}{{ .Get &amp;quot;caption&amp;quot; }}{{ end }}&amp;quot;{{ end }} /&amp;gt;  
    {{ if .Get &amp;quot;link&amp;quot;}}&amp;lt;/a&amp;gt;{{ end }}  
    {{ if or (or (.Get &amp;quot;title&amp;quot;) (.Get &amp;quot;caption&amp;quot;)) (.Get &amp;quot;attr&amp;quot;)}}  
    &amp;lt;figcaption&amp;gt;{{ if isset .Params &amp;quot;title&amp;quot; }}  
        &amp;lt;h4&amp;gt;{{ .Get &amp;quot;title&amp;quot; }}&amp;lt;/h4&amp;gt;{{ end }}  
        {{ if or (.Get &amp;quot;caption&amp;quot;) (.Get &amp;quot;attr&amp;quot;)}}&amp;lt;p&amp;gt;  
        {{ .Get &amp;quot;caption&amp;quot; }}  
        {{ with .Get &amp;quot;attrlink&amp;quot;}}&amp;lt;a href=&amp;quot;{{.}}&amp;quot;&amp;gt; {{ end }}  
            {{ .Get &amp;quot;attr&amp;quot; }}  
        {{ if .Get &amp;quot;attrlink&amp;quot;}}&amp;lt;/a&amp;gt; {{ end }}  
        &amp;lt;/p&amp;gt; {{ end }}  
    &amp;lt;/figcaption&amp;gt;  
    {{ end }}  
&amp;lt;/figure&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;YouTube 视频，模板位置 &lt;code&gt;/layouts/shortcodes/youtube.html&lt;/code&gt;，内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;embed video-player&amp;quot;&amp;gt;  
&amp;lt;iframe class=&amp;quot;youtube-player&amp;quot; type=&amp;quot;text/html&amp;quot; width=&amp;quot;640&amp;quot; height=&amp;quot;385&amp;quot; src=&amp;quot;http://www.youtube.com/embed/{{ index .Params 0 }}&amp;quot; allowfullscreen frameborder=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;  
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 模板template</title>
            <link>http://blog.pytool.com/hugo/hugo_template/</link>
            <pubDate>Thu, 05 Oct 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_template/</guid>
            <description>

&lt;h3 id=&#34;模板变量&#34;&gt;模板变量&lt;/h3&gt;

&lt;p&gt;如果说模板是待填充的网页，则模板变量是用来填充模板的内容。Hugo 内置了许多可以在模板中访问的变量，这些变量可以分为以下几种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网站变量&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过网站变量，我们可以访问网站级别的配置和数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .Site.BaseURL 			配置文件中为网站指定的 basse URL  
  .Site.RSSLink 			网站的 RSS 链接  
  .Site.Taxonomies 		网站所有的分类标签  
  .Site.Pages				网站所有页面（仅含当前语言）  
  .Site.AllPages			网站所有页面（含多语言）  
  .Site.Params			配置文件中通过 params 定义的网站参数  
  .Site.Sections			网站所有 Section（也即网站的顶级目录）  
  .Site.Title				配置文件中为网站指定的 title  
  .Site.Author			配置文件中为网站指定的 author  
  .Site.Copyright			配置文件中为网站指定的 copyright  
  .Site.LastChange		网站最后更新时间，格式跟内容文档头部 date 保持一致  
  .Site.Data				网站自定义数据文件的访问接口  
  .Site.RegularPages		网站中所有常规页面  
  .Site.Files				网站所有源文件  
  .Site.Menus				网站所有菜单  
  .Site.LanguageCode		配置文件中为网站指定的 language code  
  .Site.DisqusShortname	配置文件中为网站指定的 disqus 评论id  
  .Site.GoogleAnalytics   配置文件中为网站指定的 google analytics tracking code  
  .Site.Permalinks		配置文件中为网站指定的 permalink format  
  .Site.BuildDrafts		配置文件中为网站指定的 build drafts  
  .Site.IsMultiLingual	网站是否支持多语言  
  .Site.Language			配置文件中指定的 language  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;页面变量&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过页面变量，我们可以访问内容文档级别的配置和数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .Title					内容文档的标题  
  .Content				内容文档的内容  
  .Date					内容文档的日期  
  .PublishDate			页面发布日期  
  .FuzzyWordCount			内容的近似字数  
  .WordCount				内容的字数  
  .Type					内容文档的内容类型  
  .URL					页面的相对 URL  
  .UniqueID				内容文档路径的md5值  
  .Weidht					内容文档中定义的排序权重  
  .Kind					页面类型  
  .Params					内容文档头部定义的任意元数据都可以通过 .Params 来访问（不同定义如何命名，均以字母小写的名字访问）  
  						补充：网站变量中也有 .Site.Params 来定义网站参数，一般来说页面参数比网站参数更具体，  
  						可以使用模板函数 $.Param &amp;quot;header_image&amp;quot; 来访问网站和页面的同名参数  
  .IsHome					页面是否为首页  
  .IsPage					是否为常规内容页面  
  .Next					下一个页面（根据页面发布日期）  
  .Prev					上一个页面（根据页面发布日期）  
  .NextInSection			当天Section中的下一个页面（根据页面分布日期）  
  .PrevInSection			当天Section中的上一个页面（根据页面分布日期）  
  .TableOfContents		页面目录  
  .Permalink				页面的永久链接  
  .RelPermalink			页面永久链接的相对路径  
  .RawContent				页面的 Markdown 内容，当想要在网站中集成https://github.com/gnab/remark时，就需要提取页面的 Markdown 内容了  
  .ReadingTime			页面大概需要花费的阅读时间  
  .Section				页面所在 Section  
  .Summary				页面摘要  
  .Truncated				摘要是否截断页面  
  .Description			描述  
  .Keywords				关键词  
  .LinkTitle				链接到当前页面时使用的 title  
  .ExpiryDate				页面失效日期  
  .Draft					页面是否为草稿  
  .IsTranslated			页面是否有多语言版本  
  .Translations			页面的多语言页面  
  .Lang					语言  
  .Language				语言对象  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;文件变量&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当页面的生成来源于内容文档时，可以访问内容文档文件相关信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .File.Path				内容文档的相对路径，比如：content/posts/first.en.md  
  .File.Dir				内容文档所在目录  
  .File.LogicalName		内容文档文件名，比如：first.en.md  
  .File.TranslationBaseName 内容文档根文件名，比如：first  
  .File.Ext				内容文档扩展名，比如：md  
  .File.Lang				内容文档的语言  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Hugo 变量&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  .Hugo.Generator			Hugo 版本号的 meta tag，例如：&amp;lt;meta name=&amp;quot;generator&amp;quot; content=&amp;quot;Hugo 0.15&amp;quot; /&amp;gt;  
  .Hugo.Version			Hugo 二进制程序版本号  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模板变量的作用域问题&lt;/p&gt;

&lt;p&gt;单页模板、Section 列表模板以及 Taxonomy 列表模板均可以访问网站变量和页面变量，此外Taxonomy 列表模板可以访问代表其自身的 &lt;code&gt;.Data.Singular&lt;/code&gt; 变量。&lt;/p&gt;

&lt;h3 id=&#34;模板角色&#34;&gt;模板角色&lt;/h3&gt;

&lt;p&gt;模板文件混杂了 HTML 代码和模板标识符，用来设计网页布局的。Hugo 支持 Go 语言的 HTML 模板库来对网站进行布局规划，虽然模板文件本质上没有不同，可 Hugo 结合常用网站布局结构的需要将模板分为了几种角色，下面将依次介绍这些模板角色&lt;/p&gt;

&lt;p&gt;也即页面类型&lt;/p&gt;

&lt;p&gt;page home section taxonomy or taxonomy Term&lt;/p&gt;

&lt;p&gt;rss sitemap robotsTXT 404&lt;/p&gt;

&lt;h4 id=&#34;首页模板&#34;&gt;首页模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用首页模板（homepage template）来渲染网站首页。一般来说网站首页同其它页面具有不一样的风格，因此需要专门为其使用特定的模板进行渲染。Hugo 在生成网站时，通常会依次从下面路径中查找首页模板，将找到的第一个文件作为首页模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- /layouts/index.html  
- /layouts/_default/list.html  
- /layouts/_default/single.html  
- /themes/`THEME`/layouts/index.html  
- /themes/`THEME`/layouts/_default/list.html  
- /themes/`THEME`/layouts/_default/single.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也即默认首页模板是 &lt;code&gt;index.html&lt;/code&gt; ，当该文件不存在时，依次使用 &lt;code&gt;list.html&lt;/code&gt; 和 &lt;code&gt;single.html&lt;/code&gt; 来充当首页模板。另外首页模板中可以通过模板变量 &lt;code&gt;.Data.Pages&lt;/code&gt; 来访问网站中所有内容文档，通常我们会遍历该变量在首页创建一个文档展示列表，不过Hugo 不会对模板的创建有任何限制，如何定义首页模板完全取决于自己。&lt;/p&gt;

&lt;h4 id=&#34;单页模板&#34;&gt;单页模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用单页模板（single template）来渲染内容文档。换句话说，内容文档的内容将嵌入单页模板设计好的网页结构中，以此生成网页。那么当生成静态网站时，Hugo 会使用哪个单页模板来渲染内容文档呢？Hugo 会依次从下面路径列表中查找可用的单页模板，将找到的第一个单页模板文件作为当前内容文档的渲染模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- /layouts/`TYPE`/`LAYOUT`.html  
- /layouts/`SECTION`/`LAYOUT`.html  
- /layouts/`TYPE`/single.html  
- /layouts/`SECTION`/single.html  
- /layouts/_default/single.html  
- /themes/`THEME`/layouts/`TYPE`/`LAYOUT`.html  
- /themes/`THEME`/layouts/`SECTION`/`LAYOUT`.html  
- /themes/`THEME`/layouts/`TYPE`/single.html  
- /themes/`THEME`/layouts/`SECTION`/single.html  
- /themes/`THEME`/layouts/_default/single.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;TYPE&lt;/code&gt; 表示内容文档的类型名称，&lt;code&gt;SECTION&lt;/code&gt; 表示内容文档的 Section ，&lt;code&gt;THEME&lt;/code&gt; 表示主题名称，&lt;code&gt;LAYOUT&lt;/code&gt; 表示内容文档指定的模板名。&lt;code&gt;TYPE&lt;/code&gt; 和 &lt;code&gt;LAYOUT&lt;/code&gt; 可分别通过内容文档头部的 &lt;code&gt;type&lt;/code&gt; （默认跟所在 Section 同名）和 &lt;code&gt;layout&lt;/code&gt; （默认为单页模板）进行设置 ，&lt;code&gt;SECTION&lt;/code&gt; 则由内容文档磁盘路径对应的 Section 决定。&lt;/p&gt;

&lt;p&gt;可以看出 Hugo 默认会先从 &lt;code&gt;TYPE&lt;/code&gt; 和 &lt;code&gt;SECTION&lt;/code&gt; 这些模板目录中查找文档指定的布局 &lt;code&gt;LAYOUT&lt;/code&gt; ，再查找相应的单页模板，然后再从网站源默认的布局目录 &lt;code&gt;_default&lt;/code&gt; 中查找单页模板，最后会查找当前主题的相关布局目录，可见 Hugo 奉行的准则是：先精确查找，再回退默认。&lt;/p&gt;

&lt;p&gt;在单页模板中可以访问网站变量和页面变量以及模板函数，通常我们会将内容文档的内容嵌入到单页模板中，有时也许还想为模板创建一个侧变量用来显示相关信息等，怎样定义单页模板完全取决于自己。&lt;/p&gt;

&lt;p&gt;一般情况下，当我们为网站添加过主题之后，主题都会有单页模板的，如果想要覆盖主题中定义的单页模板，可以在网站源的模板目录下面创建相应的单页模板，或者直接创建单页模板 &lt;code&gt;layouts/_default/single.html&lt;/code&gt; 作为内容文档未找到单页模板时的默认模板。&lt;/p&gt;

&lt;h4 id=&#34;内容视图&#34;&gt;内容视图&lt;/h4&gt;

&lt;p&gt;Hugo 使用内容视图（content views）来以不同于单页模板的方式展示内容文档。比如有时，我们只想要展示文档摘要或者文档列表项而非整个文档，内容视图在此时就特别有用了。&lt;/p&gt;

&lt;p&gt;内容视图也是普通的模板文件，Hugo 查找内容视图时会根据当前文档的内容类型进行查找，也就是说同名的内容视图对不同内容类型渲染效果是不同的。Hugo 会依次从以下路径列表中查找可用的内容视图，将找到的第一个模板文件来作为渲染模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- /layouts/`TYPE`/`VIEW`.html  
- /layouts/_default/`VIEW`.html  
- /themes/`THEME`/layouts/`TYPE`/`VIEW`.html  
- /themes/`THEME`/layouts/_default/`view`.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定我们要为内容类型 &lt;code&gt;post&lt;/code&gt; 和 &lt;code&gt;project&lt;/code&gt; 分别创建内容视图 &lt;code&gt;li.html&lt;/code&gt;  ，则对应的模板文件路径为：&lt;code&gt;/layouts/post/li.html&lt;/code&gt; 和 &lt;code&gt;/layouts/project/li.html&lt;/code&gt; 。如果我们在网站首页使用如下代码罗列所有文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ range .Data.Pages }}  
{{ .Render &amp;quot;li&amp;quot;}}  
{{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;{{ .Render &amp;quot;li&amp;quot; }}&lt;/code&gt; 表示引用当前内容文档对应内容视图 &lt;code&gt;li.html&lt;/code&gt; （&lt;code&gt;post&lt;/code&gt; 和 &lt;code&gt;project&lt;/code&gt; 使用各自的内容视图文件），在内容视图 &lt;code&gt;li.html&lt;/code&gt; 中可以访问任何页面变量，下面是 &lt;code&gt;li.html&lt;/code&gt; 示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;li&amp;gt;  
&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;  
&amp;lt;div class=&amp;quot;meta&amp;quot;&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/div&amp;gt;  
&amp;lt;/li&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;列表模板&#34;&gt;列表模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用列表模板（list template）渲染多个被罗列的内容文档，比如：分类标签页面和 Section 页面通常需要罗列逻辑上从属于该类别的所有文档。值得注意的是，不同于单页文档总是被内容文档填充，列表模板一般却不会被内容文档填充（下文会介绍什么情况下列表模板也会填充内容文档）。&lt;/p&gt;

&lt;p&gt;Hugo 中列表模板常见的应用场景有：Section 列表页、Taxonomy 列表页、Section RSS 以及 Taxonomy RSS等（注：网站首页虽然也是列表页，可因其特殊性，需要使用特定的模板渲染）。这些页面渲染后的 URL 路径分别如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Section 列表页&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/SECTION/&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/post/&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Taxonomy 列表页&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/PLURAL/TERM/&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/tags/python/&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Section RSS&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/SECTION/index.html&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/post/index.html&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Taxonomy RSS&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;baseURL/PLURAL/TERM/index.html&lt;/code&gt; ，例如：&lt;code&gt;http://1.com/tags/python/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此外，Hugo 会依次从路径列表中查找可用的列表模板，将找到的第一个列表模板文件来作为渲染模板。以上介绍的常见列表页面的查找路径如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Section 列表  
  - /layouts/section/`SECTION`.html  
  - /layouts/_default/section.html  
  - /layouts/_default/list.html  
  - /themes/`THEME`/layouts/section/`SECTION`.html  
  - /themes/`THEME`/layouts/_default/section.html  
  - /themes/`THEME`/layouts/_default/list.html  
- Taxonomy 列表  
  - /layouts/taxonomy/`SINGULAR`.html  
  - /layouts/_default/taxonomy.html  
  - /layouts/_default/list.html  
  - /themes/`THEME`/layouts/taxonomy/`SINGULAR`.html  
  - /themes/`THEME`/layouts/_default/taxonomy.html  
  - /themes/`THEME`/layouts/_default/list.html  
- Section RSS  
  - /layouts/section/`SECTION`.rss.xml  
  - /layouts/_default/rss.xml  
  - /themes/`THEME`/layouts/section/`SECTION`.rss.xml  
  - /themes/`THEME`/layouts/_default/rss.xml  
- Taxonomy RSS  
  - /layouts/taxonomy/`SINGULAR`.rss.xml  
  - /layouts/_default/rss.xml  
  - /themes/`THEME`/layouts/taxonomy/`SINGULAR`.rss.xml  
  - /themes/`THEME`/layouts/_default/rss.xml  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面模板的查找路径可以看出，Hugo 首先会查找为特定 &lt;code&gt;SECTION&lt;/code&gt; 和 &lt;code&gt;TAXONOMY&lt;/code&gt; 定义的模板文件，如果查找失败，会再查找 Section 和 Taxonomy 通用的模板文件，如果还是找不到就使用 &lt;code&gt;layouts/_defaults/list.html&lt;/code&gt; 和 &lt;code&gt;layouts/_defaults/rss.xml&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;既然知道了列表模板的用途，也知道了模板文件的查找路径，那么列表模板文件中该写些什么呢？列表文件也是一个普通的模板文件，在模板中可以使用任何 Go 内置模板函数，还可以访问网站模板变量和页面模板变量（用于 Taxonomy 的模板还可以访问代表当前分类的变量 &lt;code&gt;.Data.Singular&lt;/code&gt; ）。根据列表模板的用途一般来说会在模板中为内容文档创建一个展示列表，此外也许希望对这个内容文档分类或者剔除某些文档，利用简洁而强大的 Go 模板方法可以自定义任何复杂的列表页面。下面是一个用于 Section 的列表模板示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}  
{{ partial &amp;quot;subheader.html&amp;quot; . }}  

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;  
  &amp;lt;div&amp;gt;  
   &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;  
        &amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;  
            {{ range .Data.Pages }}  
                {{ .Render &amp;quot;li&amp;quot;}}  
            {{ end }}  
        &amp;lt;/ul&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/section&amp;gt;  

{{ partial &amp;quot;footer.html&amp;quot; . }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分类模板&#34;&gt;分类模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用分类模板（taxonomy terms template）来渲染当前分类下的所有标签。&lt;/p&gt;

&lt;p&gt;要注意同Taxonomy 列表页相区分，Taxonomy 列表页用来罗列属于某个标签下所有的内容文档，优先查找模&lt;code&gt;/layouts/taxonomy/SINGULAR.html&lt;/code&gt; 作为该标签列表页的模板，且将页面渲染于 &lt;code&gt;baseURL/PLURAL/TERM/&lt;/code&gt; 。而分类模板页面是用来罗列当前分类下所有标签的，优先查找 &lt;code&gt;/layouts/taxonomy/SINGULAR.terms.html&lt;/code&gt; 作为页面模板，且渲染于 &lt;code&gt;baseURL/PLURAL/&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;Hugo 会依次从路径列表中查找可用的模板，将找到的第一个模板文件来作为渲染模板&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/layouts/taxonomy/&lt;code&gt;SINGULAR&lt;/code&gt;.terms.html&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/layouts/_default/terms.html&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/themes/&lt;code&gt;THEME&lt;/code&gt;/layouts/taxonomy/&lt;code&gt;SINGULAR&lt;/code&gt;.terms.html&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/themes/&lt;code&gt;THEME&lt;/code&gt;/layouts/_default/terms.html&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果以上模板都不存在，Hugo 就不会渲染分类标签页面。换句话说，分类标签页面的渲染也不一定必须单独使用一个模板文件，我们可以在页面侧边栏之类的地方来渲染分类标签（比如：侧边栏实现一个标签云）。&lt;/p&gt;

&lt;p&gt;分类模板中除了可以访问网站变量和页面变量外，还有一些关于分类标签的变量可供我们使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Data.Singular						分类的单数名称，比如：tag  
.Data.Plural						分类的复数名称，比如：tags  
.Data.Pages							属于当前分类的所有页面  
.Data.Terms							属于当前分类的所有标签  
.Data.Terms.Alphabetical			属于当前分类的所有标签（字母序）  
.Data.Terms.ByCount					属于当前分类的所有标签（根据标签下文档数量排序）  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个示例分类模板，该模板罗列出了当前分类下的所有标签，并给出了标签下所有文档的链接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}  
{{ partial &amp;quot;subheader.html&amp;quot; . }}  

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;  
  &amp;lt;div&amp;gt;  
    &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;  

    {{ $data := .Data }}  
    {{ range $key,$value := .Data.Terms.ByCount }}  
    &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;quot;{{ .Site.LanguagePrefix }}/{{ $data.Plural }}/{{ $value.Name | urlize }}&amp;quot;&amp;gt;{{ $value.Name }}&amp;lt;/a&amp;gt; {{ $value.Count }}&amp;lt;/h2&amp;gt;  
    &amp;lt;ul&amp;gt;  
    {{ range $value.Pages.ByDate }}  
      &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
    {{ end }}  
    &amp;lt;/ul&amp;gt;  
    {{ end }}  
  &amp;lt;/div&amp;gt;  
&amp;lt;/section&amp;gt;  

{{ partial &amp;quot;footer.html&amp;quot; . }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;片段模板&#34;&gt;片段模板&lt;/h4&gt;

&lt;p&gt;Hugo 使用片段模板（partial template）作为其它模板文件的原材料，比如首页模板、单页模板、列表模板等这些模板通常会使用片段模板来创建。这里之所以将片段模板比作原材料，是因为片段模板通常包含了其它模板中的公共部分，反过来说，我们应该将多个模板中的公共内容分离出来创建片段模板文件，然后可以在其它模板中引用该片段文件。使用片段模板的好处在于，不需要重复定义相同的模板内容，而且片段模板十分有利于主题资源的开发，主题中应该将那些想要让用户覆盖的模板内容单独作为一个片段模板，这样主题的使用者只需要定义相同的片段模板就可以对主题片段模板进行替换，片段模板文件是比普通模板文件更加细粒度的模板内容容器。&lt;/p&gt;

&lt;p&gt;如何创建片段模板呢？Hugo 默认将模板目录 &lt;code&gt;/layouts/partials/&lt;/code&gt; 及其子目录中的模板文件看作片段模板，片段模板的内容如同普通模板一样可以访问各种模板变量和模板函数，不过片段模板可以访问到的模板变量取决于引用该模板时传入了怎样的变量进来（后面会有讲，如何引用片段模板以及如何传递变量到片段模板）。在网站中最为常见的片段模板也许就是网页头和网页脚，因为网页头和网页脚在网站大多数页面中都是相同的，将其分离于片段模板中是明智的选择，假设我们创建了 &lt;code&gt;/layouts/partials/header.html&lt;/code&gt; 和 &lt;code&gt;/layouts/partials/footer.html&lt;/code&gt; 片段模板文件，它们的内容分别为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;  
&amp;lt;html class=&amp;quot;no-js&amp;quot; lang=&amp;quot;en-US&amp;quot; prefix=&amp;quot;og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#&amp;quot;&amp;gt;  
&amp;lt;head&amp;gt;  
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;  

    {{ partial &amp;quot;meta.html&amp;quot; . }}  

    &amp;lt;base href=&amp;quot;{{ .Site.BaseURL }}&amp;quot;&amp;gt;  
    &amp;lt;title&amp;gt; {{ .Title }} : spf13.com &amp;lt;/title&amp;gt;  
    &amp;lt;link rel=&amp;quot;canonical&amp;quot; href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;  
    {{ if .RSSLink }}&amp;lt;link href=&amp;quot;{{ .RSSLink }}&amp;quot; rel=&amp;quot;alternate&amp;quot; type=&amp;quot;application/rss+xml&amp;quot; title=&amp;quot;{{ .Title }}&amp;quot; /&amp;gt;{{ end }}  

    {{ partial &amp;quot;head_includes.html&amp;quot; . }}  
&amp;lt;/head&amp;gt;  
&amp;lt;body lang=&amp;quot;en&amp;quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;footer&amp;gt;  
  &amp;lt;div&amp;gt;  
    &amp;lt;p&amp;gt;  
    &amp;amp;copy; 2013-14 Steve Francia.  
    &amp;lt;a href=&amp;quot;http://creativecommons.org/licenses/by/3.0/&amp;quot; title=&amp;quot;Creative Commons Attribution&amp;quot;&amp;gt;Some rights reserved&amp;lt;/a&amp;gt;;  
    please attribute properly and link back. Hosted by &amp;lt;a href=&amp;quot;http://servergrove.com&amp;quot;&amp;gt;ServerGrove&amp;lt;/a&amp;gt;.  
    &amp;lt;/p&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/footer&amp;gt;  
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;  

  var _gaq = _gaq || [];  
  _gaq.push([&#39;_setAccount&#39;, &#39;UA-XYSYXYSY-X&#39;]);  
  _gaq.push([&#39;_trackPageview&#39;]);  

  (function() {  
    var ga = document.createElement(&#39;script&#39;);  
    ga.src = (&#39;https:&#39; == document.location.protocol ? &#39;https://ssl&#39; :  
        &#39;http://www&#39;) + &#39;.google-analytics.com/ga.js&#39;;  
    ga.setAttribute(&#39;async&#39;, &#39;true&#39;);  
    document.documentElement.firstChild.appendChild(ga);  
  })();  

&amp;lt;/script&amp;gt;  
&amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上模板内容除了常规的 HTML 代码外，还出现了像 &lt;code&gt;{{ partial &amp;quot;meta.html&amp;quot; . }}&lt;/code&gt; 这样的模板语句，这条语句在这里的作用是引用片段模板 &lt;code&gt;meta.html&lt;/code&gt; 到当前模板文件中（即 &lt;code&gt;header.html&lt;/code&gt; 片段模板文件），就是说 Hugo 允许我们在片段模板中再次引用片段模板。&lt;/p&gt;

&lt;p&gt;下面让我们研究一下，如何引用一个片段模板文件，引用片段模板的语法为：&lt;code&gt;{{ partial &amp;quot;path/to/file.html&amp;quot; variables }}&lt;/code&gt; ，其中 &lt;code&gt;path/to/file.html&lt;/code&gt; 表示被引用的片段模板文件相对于 &lt;code&gt;/layouts/partials/&lt;/code&gt; 目录的路径，比如想要引用 &lt;code&gt;/layouts/partials/post/sidebar.html&lt;/code&gt; ，则对应的引用路径为 &lt;code&gt;post/sidebar.html&lt;/code&gt; 。其中 &lt;code&gt;variables&lt;/code&gt; 表示要传入片段模板的变量（片段模板除了这些传入的变量，是无法访问其它变量的），通常我们会将代表当前模板内所有变量的 &lt;code&gt;.&lt;/code&gt; 作为 &lt;code&gt;variables&lt;/code&gt; 传入片段模板中。&lt;/p&gt;

&lt;p&gt;有没有想过，很多模板引用相同的片段模板文件，在生成网页时，这些片段模板是不是在每个引用模板中都要重新渲染一次呢？有没有办法减少片段模板的渲染次数，毕竟片段模板生成的网页片段除了根据传入变量不同会有改变外，基本的网页结构是相似的。如果想要让 Hugo 提升片段模板的渲染效率（Hugo 会自动缓存已经渲染好的片段模板供后续使用），可以在引用模板文件时用 &lt;code&gt;partialCached&lt;/code&gt; 来代替 &lt;code&gt;partial&lt;/code&gt; ，并且 Hugo 还支持用户按照类别缓存片段模板，比如： &lt;code&gt;{{ partialCached &amp;quot;footer.html&amp;quot; . .Section }}&lt;/code&gt; 的意思是，为每个 Section 渲染一次 &lt;code&gt;footer.html&lt;/code&gt; 模板。&lt;/p&gt;

&lt;h3 id=&#34;模板调试&#34;&gt;模板调试&lt;/h3&gt;

&lt;p&gt;模板编写中错误在所难免，可以使用模板函数 &lt;code&gt;printf&lt;/code&gt; 调试模板变量，下面是几个常见调试样例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ printf &amp;quot;%#v&amp;quot; . }}  
{{ printf &amp;quot;%#v&amp;quot; $.Site }}  
{{ printf &amp;quot;%#v&amp;quot; .Permalink }}  
{{ range .Data.Pages }}  
    {{/* The context, &amp;quot;.&amp;quot;, is now a Page */}}  
    {{ printf &amp;quot;%#v&amp;quot; . }}  
{{ end }}  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 中的 Markdown 语法</title>
            <link>http://blog.pytool.com/hugo/hugo_markdown/</link>
            <pubDate>Wed, 06 Sep 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_markdown/</guid>
            <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Hugo 中用于书写的标记语言主要是 Markdown。Markdown 作为一门标记语言，其核心&lt;a href=&#34;https://daringfireball.net/projects/markdown/&#34; title=&#34;Markdown Syntax&#34; target=&#34;_blank&#34;&gt;语法&lt;/a&gt;十分精炼易用，有许多优秀的 Markdown 解释器可以将 Markdown 文档转换为 HTML 等便于阅览的文档。Markdown 的巨大优势在于，将内容创作和内容展示剥离开来，给予内容创作者极大的自由。&lt;/p&gt;

&lt;p&gt;不过 Markdown 的核心语法十分精炼，甚至某些功能是不被支持，比如任务列表。为此开发者们，开发出众多解释器来扩展 Markdown 核心语法。Hugo 支持两个 Markdown 扩展语法（解释器）：&lt;a href=&#34;https://github.com/russross/blackfriday&#34; title=&#34;Blackfriday Markdown&#34; target=&#34;_blank&#34;&gt;Blackfriday&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/miekg/mmark&#34; title=&#34;Mmark Markdown&#34; target=&#34;_blank&#34;&gt;Mmark&lt;/a&gt;。可以将 Blackfriday 看成是对基本 Markdown 语法的简单扩展，Mmark 是 Markdown 语法的超集。Hugo 通过文档后缀名或者文档头 Front Matter &lt;code&gt;markup&lt;/code&gt; 来识别这两类 Markdown 文档。Blackfriday Markdown 文档后缀名为 &lt;code&gt;.md&lt;/code&gt; 或者 &lt;code&gt;markup=&amp;quot;markdown&amp;quot;&lt;/code&gt; ，Mmark Markdown 文档后缀名为 &lt;code&gt;.mmark&lt;/code&gt; 或者 &lt;code&gt;markup=&amp;quot;mmark&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;配置-markdown-解释器&#34;&gt;配置 Markdown 解释器&lt;/h2&gt;

&lt;p&gt;Hugo 允许我们配置解释器，来扩展 Markdown 语法，改变解释器的工作过程。由于 Mmark 是 Markdown 语法的超集，语言本身就支持许多特色功能，是无需通过配置来扩展的，因此这里所说的配置是针对 Blackfriday 解释器而言的。更多关于 Mmark 语法参见&lt;a href=&#34;https://miek.nl/2016/March/05/mmark-syntax-document/&#34; title=&#34;Mmark Syntax&#34; target=&#34;_blank&#34;&gt;此处&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;如何配置&#34;&gt;如何配置&lt;/h3&gt;

&lt;p&gt;既可以对解释器进行全局配置，也可以针对一个文档进行配置。全局配置是通过在网站配置文件中添加 &lt;code&gt;blackfriday&lt;/code&gt; 配置项来实现的，而针对文档的配置是通过文档头 Front Matter 中添加 &lt;code&gt;blackfriday&lt;/code&gt; 配置项来实现的，且后者配置的优先级高于前者。&lt;/p&gt;

&lt;p&gt;配置项 &lt;code&gt;blackfriday&lt;/code&gt;  又由许多配置子项组成的，因此 &lt;code&gt;blackfriday&lt;/code&gt; 的配置内容会被写为一个分组，下面分别用 TOML 和 YAML 语法来做样例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[blackfriday]  
  angledQuotes = true  
  fractions = false  
  plainIDAnchors = true  
  extensions = [&amp;quot;hardLineBreak&amp;quot;]  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;blackfriday:  
  angledQuotes: true  
  fractions: false  
  plainIDAnchors: true  
  extensions:  
    - hardLineBreak  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论是全局配置还是针对文档的配置，只要添加以上配置内容就可以改变 Markdown 解释器的行为。&lt;/p&gt;

&lt;h3 id=&#34;常用配置项&#34;&gt;常用配置项&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;taskLists&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt; 。控制是否支持 Github 风格的任务列表语法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smartypants&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt;。控制是否开启标点符号（双引号、分子符号、连字符）的转换。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;angledQuotes&lt;/code&gt;，默认为 &lt;code&gt;false&lt;/code&gt;。控制是否将中文双引号 &lt;code&gt;“hugo”&lt;/code&gt; 转换为 &lt;code&gt;«hugo»&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fractions&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt;。控制是否将分子式 &lt;code&gt;5/7&lt;/code&gt; 转换为 HTML 格式 &lt;code&gt;&amp;lt;sup&amp;gt;5&amp;lt;/sup&amp;gt;&amp;amp;frasl;&amp;lt;sub&amp;gt;7&amp;lt;/sub&amp;gt;&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smartDashes&lt;/code&gt; 和 &lt;code&gt;latexDashes&lt;/code&gt; 共同控制多个连字符如何转换为 &lt;code&gt;–&lt;/code&gt; 和 &lt;code&gt;—&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hrefTargetBlank&lt;/code&gt;，默认为 &lt;code&gt;false&lt;/code&gt;。控制打开外部链接时是否打开新的浏览器窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plainIDAnchors&lt;/code&gt;，默认为 &lt;code&gt;true&lt;/code&gt;。不向标题内容添加文档 ID。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extensions&lt;/code&gt;，是列表项。包含于该列表中的 Blackfriday Markdown 扩展语法标识，将开启对应的扩展语法的支持。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extensionsmask&lt;/code&gt;，是列表项。包含于该列表中的 Blackfriday Markdown 扩展语法标识，将关闭对应的扩展语法的支持。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;扩展语法支持&#34;&gt;扩展语法支持&lt;/h3&gt;

&lt;p&gt;Hugo 的 Blackfriday 解释器扩展了核心的 Markdown 语法，下面将介绍一些常用的扩展语法，更多扩展参见&lt;a href=&#34;https://gohugo.io/getting-started/configuration/#blackfriday-extensions&#34; title=&#34;Blackfriday Markdown Extensions&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;禁止解析单词内的下划线&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;noIntraEmphasis&lt;/code&gt;，默认开启该扩展。由于 &lt;code&gt;_&lt;/code&gt; 字符是 Markdown 语法的组成部分，所以如果代码中出现类似 &lt;code&gt;init_priority_list&lt;/code&gt; 这样的内容，将会被误当成 Markdown 语法来解析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开启对表格语法的支持&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;tables&lt;/code&gt;，默认开启该扩展。表格语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;     Name | Age  
  --------|------  
      Bob | 27  
    Alice | 23  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;代码块&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;fencedCode&lt;/code&gt;，默认开启该扩展。代码块语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;  ​```markdown  
  # h1  
  # h2  
  ​```  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;自动转换 URL&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;autolink&lt;/code&gt;，默认开启该扩展。将内容中那些没有使用 Markdown 语法书写的 URL，转换为 Markdown 格式的 URL。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;删除线&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;strikethrough&lt;/code&gt;，默认开启该扩展。删除线使用两个波浪线的语法 &lt;code&gt;~~删除线~~&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;强制换行&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;hardLineBreak&lt;/code&gt;，默认关闭该扩展。默认的 Markdown 语法中，没有用空行间隔开的多行内容最终会被转换为一行内容来输出。开启该扩展后，内容中只要有换行，输出中就会换行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tab 空格数&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;tabSizeEight&lt;/code&gt;，默认关闭该扩展。开启该扩展后，每个制表符 Tab 将被转换为 8 个空格（默认是 4 个）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脚注&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;footnotes&lt;/code&gt;，默认开启该扩展。支持 Pandoc 风格的脚注语法，样例如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;  文章里有一个脚注[^1]  

  定义在文档尾部的脚注内容如下  
  [^1]: 这里是脚注的内容  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;标题 ID&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;headerIds&lt;/code&gt;，默认开启该扩展。允许通过 &lt;code&gt;{#id}&lt;/code&gt; 来为标题指定 ID。此外还有另外一个扩展标识 &lt;code&gt;autoHeaderIds&lt;/code&gt;，用来控制是否自动为标题创建 ID。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义列表&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展语法标识为：&lt;code&gt;definitionLists&lt;/code&gt;，默认开启该扩展。定义列表的语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;  汽车  
  : 汽车是一种机动车  

  铁  
  : 铁是广泛存在于自然界的一种常见元素，铁的冶炼和制作对现代工业革命中关键性的作用  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它标记语言&#34;&gt;其它标记语言&lt;/h2&gt;

&lt;p&gt;除了 Markdown 语言外，Hugo 还支持 Emacs Org-Mode 语言（文档后缀名为 &lt;code&gt;.org&lt;/code&gt; 或者 &lt;code&gt;markup=&amp;quot;org&amp;quot;&lt;/code&gt;）。此外 Hugo 还可以通过外部程序来支持其它标记语言，比如：&lt;a href=&#34;http://asciidoctor.org/&#34; title=&#34;Asciidoc&#34; target=&#34;_blank&#34;&gt;Asciidoc&lt;/a&gt;, &lt;a href=&#34;http://docutils.sourceforge.net/rst.html&#34; title=&#34;reStructuredText&#34; target=&#34;_blank&#34;&gt;reStructuredText&lt;/a&gt; 等。要使用这些标记语言来书写文档也十分简单，只要将文档的扩展名，命名为该标记语言标准的扩展名即可。Hugo 在生成静态网站时就会自动调用相应标记语言的解释器来渲染它们。当然，前提是已经在电脑上安装好了这些解释器。&lt;/p&gt;

&lt;h2 id=&#34;数学公式显示&#34;&gt;数学公式显示&lt;/h2&gt;

&lt;p&gt;可以借助一款 Javascript 函数库 &lt;a href=&#34;http://www.mathjax.org/&#34; title=&#34;MathJax&#34; target=&#34;_blank&#34;&gt;MathJax&lt;/a&gt; 来显示嵌入在 HTML 文档中 LaTex 风格的数学公式。&lt;/p&gt;

&lt;h3 id=&#34;添加-mathjax-到模板中&#34;&gt;添加 MathJax 到模板中&lt;/h3&gt;

&lt;p&gt;为了可以在所有页面中显示数学公式，建议将使用 MathJax 的代码添加到被所有页面包含的模板文件中，比如 &lt;code&gt;footer.html&lt;/code&gt; 模板文件中。使用 MathJax 的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt;  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了上面这种方式使用 MathJax 外，还有&lt;a href=&#34;http://docs.mathjax.org/en/latest/configuration.html&#34; title=&#34;MathJax Loading&#34; target=&#34;_blank&#34;&gt;其它方式&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;markdown-和-mathjax-的冲突&#34;&gt;Markdown 和 MathJax 的冲突&lt;/h3&gt;

&lt;p&gt;任何 MathJax 可以解析的数学公式&lt;a href=&#34;https://docs.mathjax.org/en/latest/start.html#putting-mathematics-in-a-web-page&#34; title=&#34;MathJax Syntax&#34; target=&#34;_blank&#34;&gt;语法&lt;/a&gt;，都可以直接书写在 Markdown 文档中，在 Markdown 引擎将 Markdown 文档解析为 HTML 后，MathJax 会负责解析 HTML 文档中数学公式语法。&lt;/p&gt;

&lt;p&gt;不过这里有两个问题需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下划线 &lt;code&gt;_&lt;/code&gt; 同时是 Markdown 语法和数学公式语法的组成部分。解析 Markdown 文档时，文档中所有 &lt;code&gt;_&lt;/code&gt; 语法会被处理，甚至在数学公式中使用的 &lt;code&gt;_&lt;/code&gt; 也会被处理。而 Markdown 引擎处理了数学公式中的 &lt;code&gt;_&lt;/code&gt; ，将导致数学公式显示时出错。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;MathJax 要显示 HTML 文档中的数学公式，就需要某种机制来查找到这些数学公式代码。MathJax 是通过数学公式的定界符来查找数学公式的，并且支持自定义定界符。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要解决 Mathdown 和 MathJax 对下划线解析的冲突问题，一种直观的方案是将 Markdown 文档中数学公式中的 &lt;code&gt;_&lt;/code&gt; 转义为 &lt;code&gt;\_&lt;/code&gt; 。Markdown 引擎处理过后，&lt;code&gt;\_&lt;/code&gt; 将会被转换为 &lt;code&gt;_&lt;/code&gt; ，因此数学公式语法是有效的。不过该方案一来要插入许多转义符，二来使得 Markdown 文档中书写的数学公式不直观。&lt;/p&gt;

&lt;p&gt;另外一种解决下划线冲突的方案是，使用 HTML 标签 &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 来将数学代码包含在内，由于 Markdown 引擎不会处理包含在 HTML 标签中的内容，因此 Markdown 引擎也就不会解析数学代码中的下划线了。不过这只适用于块级数学公式（即独立成行的数学公式），并不适用于行内数学公式（即嵌套在行内的数学公式），对于行内数学公式可以使用 Markdown 中的行内代码语法来包裹起来，这样 Markdown 引擎就不会处理里面的内容了，不过由于行内代码的显示样式跟普通文本不一样，所以需要利用 CSS 代码来将其更改为正常的文本样式，具体&lt;a href=&#34;http://doswa.com/2011/07/20/mathjax-in-markdown.html&#34; title=&#34;Markdown and MathJax&#34; target=&#34;_blank&#34;&gt;方法&lt;/a&gt;如下：&lt;/p&gt;

&lt;p&gt;添加 Javascript 代码到所有页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;  
MathJax.Hub.Config({  
  tex2jax: {  
    inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]],  
    displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]],  
    processEscapes: true,  
    processEnvironments: true,  
    skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;],  
    TeX: { equationNumbers: { autoNumber: &amp;quot;AMS&amp;quot; },  
         extensions: [&amp;quot;AMSmath.js&amp;quot;, &amp;quot;AMSsymbols.js&amp;quot;] }  
  }  
});  
&amp;lt;/script&amp;gt;  

&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;  
  MathJax.Hub.Queue(function() {  
    // Fix &amp;lt;code&amp;gt; tags after MathJax finishes running. This is a  
    // hack to overcome a shortcoming of Markdown. Discussion at  
    // https://github.com/mojombo/jekyll/issues/199  
    var all = MathJax.Hub.getAllJax(), i;  
    for(i = 0; i &amp;lt; all.length; i += 1) {  
        all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;  
    }  
});  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 CSS 代码到所有页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;code.has-jax {  
    font: inherit;  
    font-size: 100%;  
    background: inherit;  
    border: inherit;  
    color: #515151; /* 应该设置为跟 body 标签一样的颜色 */  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终在 Markdown 文档中书写块级数学公式的语法为：&lt;code&gt;&amp;lt;div&amp;gt;$$TeX Code$$&amp;lt;/div&amp;gt;&lt;/code&gt;，行内数学公式的语法为：&lt;code&gt;&lt;code&gt;$ TeX Code $&lt;/code&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;code&gt;\( TeX Code \)&lt;/code&gt;&lt;/code&gt;。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 文档处理</title>
            <link>http://blog.pytool.com/hugo/hugo_sort/</link>
            <pubDate>Tue, 15 Aug 2017 10:58:08 -0400</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_sort/</guid>
            <description>&lt;h3 id=&#34;文档排序&#34;&gt;文档排序&lt;/h3&gt;

&lt;p&gt;当在列表页面展示多篇文档时，就涉及到文档先后顺序的问题了。Hugo 中文档默认是以元信息 &lt;code&gt;weight&lt;/code&gt; 来排序，当文档未指定 &lt;code&gt;weight&lt;/code&gt; 时，就以元信息 &lt;code&gt;date&lt;/code&gt; 来排序，如果这两项都没有指定的话，列表页面看到的文档就是无序的。&lt;/p&gt;

&lt;p&gt;不过除了上面 &lt;code&gt;weight&lt;/code&gt; 和 &lt;code&gt;date&lt;/code&gt; 外，Hugo 还支持我们以更多方式来排序列表页面，我们需要在列表模板文件中使用以下一些模板变量来控制文档的排序&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照元信息权重和日期排序（默认排序方式）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages }}  
  &amp;lt;li&amp;gt;  
  &amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;  
  &amp;lt;div class=&amp;quot;meta&amp;quot;&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/div&amp;gt;  
  &amp;lt;/li&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照元信息日期排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByDate }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照发布日期排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByPublishDate }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照失效日期排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByExpiryDate }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照修改日期排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByLastmod }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照文档内容长度排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByLength }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照文档标题排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByTitle }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照链接标题排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByLinkTitle }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照其它元信息排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range (.Date.Pages.ByParam &amp;quot;author.last_name&amp;quot;) }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;反转排序（以上所有排序都可反转）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.ByTitle.Reverse }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，文档还可以按照分类进行排序，而分类标签本身可以按照标签字母序来排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;  
{{ $data := .Data }}  
{{ range $key, $value := .Data.Taxonomy.Alphabetical }}  
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ .Site.LanguagePrefix }}/{{ $data.Plural }}/{{ $value.Name | urlize }}&amp;quot;&amp;gt; {{ $value.Name }} &amp;lt;/a&amp;gt; {{ $value.Count }} &amp;lt;/li&amp;gt;  
{{ end }}  
&amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者按照关联到该分类标签的文档数量排序（即按照分类的热门程度排序）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;  
{{ $data := .Data }}  
{{ range $key, $value := .Data.Taxonomy.ByCount }}  
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ .Site.LanguagePrefix }}/{{ $data.Plural }}/{{ $value.Name | urlize }}&amp;quot;&amp;gt; {{ $value.Name }} &amp;lt;/a&amp;gt; {{ $value.Count }} &amp;lt;/li&amp;gt;  
{{ end }}  
&amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属于某个分类的文档默认按照 &lt;code&gt;weight&lt;/code&gt; 和 &lt;code&gt;date&lt;/code&gt; 来排序，并且支持为文档指定分类排序时的权重，这样可以调整文档在分类中的顺序，这个功能通过文档中指定元数据 &lt;code&gt;taxonomyname_weight&lt;/code&gt; 来实现，其中 &lt;code&gt;taxonomyname&lt;/code&gt; 代表分类名。&lt;/p&gt;

&lt;h3 id=&#34;文档分组&#34;&gt;文档分组&lt;/h3&gt;

&lt;p&gt;当在列表页面展示多篇文档时，Hugo 支持我们根据文档类型、日期或者 Section 来分组显示文档。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照 Section 分组&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupBy &amp;quot;Section&amp;quot; }}  
  &amp;lt;h3&amp;gt;{{ .Key }}&amp;lt;/h3&amp;gt;  
  &amp;lt;ul&amp;gt;  
      {{ range .Pages }}  
      &amp;lt;li&amp;gt;  
      &amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;  
      &amp;lt;div class=&amp;quot;meta&amp;quot;&amp;gt;{{ .Date.Format &amp;quot;Mon, Jan 2, 2006&amp;quot; }}&amp;lt;/div&amp;gt;  
      &amp;lt;/li&amp;gt;  
      {{ end }}  
  &amp;lt;/ul&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照日期分组&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot; }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照发布日期分组&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByPublishDate &amp;quot;2006-01&amp;quot; }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;按照其它元信息分组&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByParam &amp;quot;param_key&amp;quot; }}  
    &amp;lt;!-- ... --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;反转分组排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range (.Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot;).Reverse }}  
    &amp;lt;!-- 利用模板函数Reverse来反转 --&amp;gt;  
  {{ end }}  

  {{ range .Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot; &amp;quot;desc&amp;quot; }}  
    &amp;lt;!-- 或者直接指定排序方向 --&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;组内文档排序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range .Data.Pages.GroupByDate &amp;quot;2006-01&amp;quot; &amp;quot;asc&amp;quot; }}  
  &amp;lt;h3&amp;gt;{{ .Key }}&amp;lt;/h3&amp;gt;  
  &amp;lt;ul&amp;gt;  
      {{ range .Pages.ByTitle }}  
      &amp;lt;!-- 可以按照之前介绍排序文档的各种方法来排序组内文档 --&amp;gt;  
      {{ end }}  
  &amp;lt;/ul&amp;gt;  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档过滤&#34;&gt;文档过滤&lt;/h3&gt;

&lt;p&gt;有时候也许想要排除某些文档在列表页面显示，Hugo 支持我们在列表页面限制文档显示数量以及限制显示的文档种类。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;限制文档显示数量&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range first 10 .Data.Pages }}  
      &amp;lt;!-- 利用模板函数first，只显示排在前面的10篇文档 --&amp;gt;  
      {{ .Render &amp;quot;summary&amp;quot; }}  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;根据条件过滤某些文档&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  {{ range where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;post&amp;quot; }}  
     &amp;lt;!-- 利用模板函数where，只筛选显示Section为post的文档 --&amp;gt;  
     {{ .Content }}  
  {{ end }}  

  {{ range first 5 (where .Data.Pages &amp;quot;Section&amp;quot; &amp;quot;post&amp;quot;) }}  
     &amp;lt;!-- 同时使用where和first --&amp;gt;  
     {{ .Content }}  
  {{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文档摘要&#34;&gt;文档摘要&lt;/h3&gt;

&lt;p&gt;Hugo 默认会截取文档前70个词作为文档摘要，并将摘要内容存放在模板页面变量 &lt;code&gt;.Summary&lt;/code&gt; ，同时提供模板变量 &lt;code&gt;.Truncated&lt;/code&gt; 来记录截取的摘要是否包含了文档的全部内容。同时 Hugo 还支持我们在内容文档中明确指定将哪些内容作为该文档的摘要，具体来说需要在文档中插入一行 &lt;code&gt;&lt;/code&gt; 来标识位于该行之前的内容作为摘要，同理 Hugo 会将摘要存放在模板页面变量 &lt;code&gt;.Summary&lt;/code&gt; ，并用模板变量 &lt;code&gt;.Truncated&lt;/code&gt; 标识摘要是否包含了文档全部内容。&lt;/p&gt;

&lt;p&gt;利用文档的摘要功能可以实现“阅读更多&amp;hellip;”这样的功能，示例如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ range first 10 .Data.Pages }}  
  &amp;lt;div class=&amp;quot;summary&amp;quot;&amp;gt;  
    &amp;lt;h4&amp;gt;&amp;lt;a href=&amp;quot;{{ .RelPermalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/h4&amp;gt;  
    {{ .Summary }}  
  &amp;lt;/div&amp;gt;  
  {{ if .Truncated }}  
  &amp;lt;div class=&amp;quot;read-more-link&amp;quot;&amp;gt;  
    &amp;lt;a href=&amp;quot;{{ .RelPermalink }}&amp;quot;&amp;gt;Read More…&amp;lt;/a&amp;gt;  
  &amp;lt;/div&amp;gt;  
  {{ end }}  
{{ end }}  
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
        <item>
            <title>hugo 模板变量</title>
            <link>http://blog.pytool.com/hugo/hugo_variable/</link>
            <pubDate>Sat, 01 Apr 2017 04:15:26 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_variable/</guid>
            <description>&lt;p&gt;Data 变量&lt;br /&gt;
注：数据以键值对形式保存在模板变量中，键由数据文件所在目录名、文件名以及变量名来决定，比如定义在数据文件 &lt;code&gt;data/author/en/fiction.toml&lt;/code&gt; 中的变量 &lt;code&gt;names&lt;/code&gt; ，最终在模板中通过 &lt;code&gt;.Site.Data.author.en.fiction.names&lt;/code&gt; 来引用。&lt;/p&gt;

&lt;p&gt;变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;变量也是比较枯燥的，大概看看就可以了，需要的时候再来细细的揣摩。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量是用于存储数据的容器，hugo的模板神奇之处就在于这些强大的变量，它们不仅仅是配置文件中的一个属性，或者内容文件头的一个属性，内容本身，而是涵盖了很多方面的。&lt;/p&gt;

&lt;p&gt;出生与CMS世家的hugo作者十分了解我们只做模板需要哪些变量，这些变量在hugo新版本发布的时候还在不停的增加，本中文手册适时更新。&lt;br /&gt;
特殊的点&lt;/p&gt;

&lt;p&gt;{{ . }}&lt;/p&gt;

&lt;p&gt;在hugo模板里面， 点“.” 代表的是上下文，不同的模板里面上下文环境是不同的。它可以用对象的this来理解。&lt;/p&gt;

&lt;p&gt;在全文中的点，和在循环中的点是不一样的，如果要在循环中访问全文中的点（对象），则需要赋值给某个参数。&lt;/p&gt;

&lt;p&gt;例子一：&lt;/p&gt;

&lt;p&gt;{{ $title := .Site.Title }}&lt;br /&gt;
{{ range .Params.tags }}&lt;br /&gt;
  &lt;li&gt;&lt;br /&gt;
    &lt;a href=&#34;{{ $baseurl }}/tags/{{ . | urlize }}&#34;&gt;{{ . }}&lt;/a&gt;&lt;br /&gt;
    - {{ $title }}&lt;br /&gt;
  &lt;/li&gt;&lt;br /&gt;
{{ end }}&lt;/p&gt;

&lt;p&gt;在例子中，站点的标题”Site.Title“在range里面是反问不到的，range里面的点代表Params.tag对象，通过$title把站点标题传递到迭代里面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可以使用”$“在变量前面，在全局的范围访问变量，这是赋值给中间变量的简化方式。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;神奇的点“.”在所有的可用变量前面，千万别忘了哦！  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是页面能够使用的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Title 内容的标题，来自于内容文件的title设置  
.Content 内容本身，来自于文件头  
.Summary 摘要，可以手动设置断点和“更多”链接  
.Truncated 布尔值，判断是否截断  
.Description 内容的描述，来自内容文件头  
.Keywords 内容的meta关键词，用于搜索引擎SEO  
.Date 内容的相关日期  
.PublishDate 内容的发布日期  
.Type 内容的类型  
.Section 内容所属章节  
.Permalink 页面永久链接  
.RelPermalink 页面相对永久链接  
.LinkTitle 设置所链接的目标的标题为链接的标题  
.Taxonomies 复数字段的分类  
.RSSLink 链接到分类的rss  
.TableOfContents 内容列表  
.Prev 上一页（基于日期）  
.Next 下一页  
.PrevInSection 上一节（基于日期）  
.NextInSection 下一节  
.FuzzyWordCount 相似的内容  
.WordCount 字数统计  
.ReadingTime 读取时间  
.Weight 权重  
.RawContent 直接读取md文件内容，排除文件头  
.Draft 布尔值，是否为草稿  
.IsNode 是字段，page都是“否”  
.IsPage 是页面，page页面都是“是”  
.Site 站点（参看下面）  
.Hugo hugo字段（参看下面）  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面参数&lt;/p&gt;

&lt;p&gt;在任何地方都可以访问的页面参数，比如下面的标签和分类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Params.tags  
.Params.categories  

参数为自定义的，所有参数都是小写的。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;节点变量&lt;/p&gt;

&lt;p&gt;节点变量可以被不是详细页的其他页面调用，例如首页、列表页、分类术语页等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Title 内容的标题  
.Date 内容发布日期  
.Permalink 节点永久链接  
.URL 节点的相对路径  
.Ref(ref) 返回永久链接  
.RelRef(ref) 返回永久相对链接  
.RSSLink 分类的rss链接  
.Data 这种类型的数据  
.IsHome 是否是首页，首页永远都是是  
.IsNode 是否是节点，节点永远是“是”  
.IsPage 是否是页面，节点永远是否  
.Site 站点（参看下面）  
.Hugo hugo（参看下面）  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分类术语变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Data.Singular 术语的单数名称  
.Data.Plural 术语的复数名称  
.Data.Pages 分类列表页面  
.Data.Terms 术语自己  
.Data.Terms.Alphabetical 条目按字母排序  
.Data.Terms.ByCount 条目按名气排序  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;站点变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Site.BaseURL 站点的基本路径  
.Site.Taxonomies 整个站点的分类  
.Site.Indexes 站点版本  
.Site.Pages 以日期排序的所有内容数组  
.Site.Params 配置文件中的变量  
.Site.Sections 站点顶级目录  
.Site.Files 所有的站点资源文件  
.Site.Menus 所有的站点菜单  
.Site.Title 一个字符串表示的站点标题  
.Site.Author 配置文件定义的作者地图  
.Site.LanguageCode 一个字符串表示的站点语言  
.Site.DisqusShortname 配置文件定义的短字符串  
.Site.Copyright 字符串定义的版权信息  
.Site.LastChange 最后更新的内容  
.Site.Permalinks 配置文件复写的永久链接  
.Site.BuildDrafts 配置文件中定义的是否建立草稿  
.Site.Data 自定义数据，参看数据文件章节  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.Hugo.Generator 标记mate数据，便于官方跟踪.  
.Hugo.Version hugo 版本  
.Hugo.CommitHash git 二进制散列  
.Hugo.BuildDate 创建日期  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;变量存在上下文关系，很多变量单独输出是没有任何显示的，另外需要注意变量的 首字母大写 。&lt;/p&gt;

&lt;p&gt;函数好比搭积木的方法，变量就是积木。熟悉了hugo模板函数和变量，已经可以尝试使用hugo的规则自己搭建积木了。&lt;/p&gt;

&lt;p&gt;在模板手册到这里的时候，大家是否在思考如下问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;模板文件怎么划分合理？  
CSS放什么地方，怎么样链接进来？  
js和js库放什么地方，怎么链接进来？  
head标签种很多信息怎么而来？  
title到底是谁的title，站点的，还是文章的，还是列表的？  
导航怎么而来，怎么更新，怎么支持中文？  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;讲了那么多枯燥的函数和变量，下一节要来点湿漉漉的润润心灵。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>typora</title>
            <link>http://blog.pytool.com/hugo/typora/</link>
            <pubDate>Sat, 01 Apr 2017 04:15:26 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/typora/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;sequenceDiagram  
 Alice-&amp;gt;&amp;gt;Bob: Hello Bob, how are you?  
    alt is sick  
    Bob-&amp;gt;&amp;gt;Alice: Not so good :(  
    else is well  
    Bob-&amp;gt;&amp;gt;Alice: Feeling fresh like a daisy  
    end  
    opt Extra response  
    Bob-&amp;gt;&amp;gt;Alice: Thanks for asking  
    end  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>个人博客hugo</title>
            <link>http://blog.pytool.com/hugo/hugo/</link>
            <pubDate>Sat, 01 Apr 2017 04:15:26 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://www.zimustudio.com/hugo.html&#34; target=&#34;_blank&#34;&gt;中文帮助&lt;/a&gt;&lt;br /&gt;
主题 hueman &lt;a href=&#34;https://demo-hueman.presscustomizr.com/demo/layouts/boxed/#&#34; target=&#34;_blank&#34;&gt;https://demo-hueman.presscustomizr.com/demo/layouts/boxed/#&lt;/a&gt;&lt;br /&gt;
如果需要更新所有Hugo的依赖库，增加 -u 参数：&lt;br /&gt;
$ go get -u -v github.com/spf13/hugo&lt;/p&gt;

&lt;p&gt;快速生成站点&lt;br /&gt;
hugo new site /path/to/site&lt;/p&gt;

&lt;p&gt;创建一个 about 页面：&lt;br /&gt;
$ hugo new about.md&lt;/p&gt;

&lt;p&gt;hugo new post/first.md&lt;/p&gt;

&lt;h1 id=&#34;创建-themes-目录&#34;&gt;创建 themes 目录&lt;/h1&gt;

&lt;p&gt;$ cd themes&lt;br /&gt;
$ git clone &lt;a href=&#34;https://github.com/spf13/hyde.git&#34; target=&#34;_blank&#34;&gt;https://github.com/spf13/hyde.git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github.com/laozhu/hugo-nuo&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://themes.gohugo.io/&#34; target=&#34;_blank&#34;&gt;主题:&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/Zenithar/hugo-theme-bleak&#34; target=&#34;_blank&#34;&gt;瀑布流风格 Zenithar/hugo-theme-bleak&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/ageekymonk/hugo-tracks-theme&#34; target=&#34;_blank&#34;&gt;卡片风格 ageekymonk/hugo-tracks-theme &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/aerohub/hugrid/&#34; target=&#34;_blank&#34;&gt;Google 图片风格 aerohub/hugrid &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Vimux/mainroad&#34; target=&#34;_blank&#34;&gt;博客 Vimux/Mainroad &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/yoshiharuyamashita/blackburn&#34; target=&#34;_blank&#34;&gt;简洁黑 yoshiharuyamashita/blackburn&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/mmrath/hugo-bootstrap&#34; target=&#34;_blank&#34;&gt;网站风格 mmrath/hugo-bootstrap &lt;/a&gt; &lt;a href=&#34;http://mmrath.com/&#34; target=&#34;_blank&#34;&gt;http://mmrath.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/nodejh/hugo-theme-cactus-plus&#34; target=&#34;_blank&#34;&gt;博客 nodejh/hugo-theme-cactus-plus: &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/dim0627/hugo_theme_robust/&#34; target=&#34;_blank&#34;&gt;博客 dim0627/hugo_theme_robust &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/appernetic/hugo-bootstrap-premium&#34; target=&#34;_blank&#34;&gt;appernetic/hugo-bootstrap-premium &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/digitalcraftsman/hugo-creative-theme&#34; target=&#34;_blank&#34;&gt;官网 digitalcraftsman/hugo-creative-theme &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/saey55/hugo-elate-theme/&#34; target=&#34;_blank&#34;&gt;官网 saey55/hugo-elate-theme&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lord/slate&#34; target=&#34;_blank&#34;&gt;Beautiful static documentation for your API &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/bep/docuapi&#34; target=&#34;_blank&#34;&gt;神器DOCAPI bep/docuapi&lt;/a&gt;&lt;br /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/bep/docuapi/master/images/screenshot.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/syui/hugo-theme-arch&#34; target=&#34;_blank&#34;&gt;WIKI ArchLinux syui/hugo-theme-arch &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://themes.gohugo.io/bootie-docs/&#34; target=&#34;_blank&#34;&gt;文档风格 Bootie Docs&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://themes.gohugo.io/docdock/&#34; target=&#34;_blank&#34;&gt;文档风格 docDock&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/key-amb/hugo-theme-bootie-docs&#34; target=&#34;_blank&#34;&gt;文档风格 key-amb/hugo-theme-bootie-docs:&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/oarrabi/github-project-landing-page&#34; target=&#34;_blank&#34;&gt;文档风格 Swiftline&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/matcornic/hugo-theme-learn&#34; target=&#34;_blank&#34;&gt;文档风格 Grav matcornic/hugo-theme-learn &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/drone/docs.git&#34; target=&#34;_blank&#34;&gt;文档风格 drone &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/aerohub/hugo-orbit-theme&#34; target=&#34;_blank&#34;&gt;个人简历 aerohub/hugo-orbit-theme &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;全文搜索 lunr&lt;br /&gt;
go get github.com/arial7/hugo-golunr&lt;br /&gt;
##名词解释&lt;br /&gt;
Taxonomy 是用来展示内容之间逻辑关系的一种分类方法&lt;/p&gt;

&lt;h3 id=&#34;front-matter&#34;&gt;front-matter&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#必填的  
title：&amp;quot;文章的标题&amp;quot;  
description：内容的描述  
date：时间，一般的这个时间由hugo自己填写  
taxonomies：分类术语的复数形式  

#选填的  

aliases：一个或者多个别名（数组），别名用于生成html路径。  
draft: 草稿。如果设置为“f true”， 内容将不会发布，除非使用“–buildDrafts”参数。  

# 新入门的经常看不到内容，都是这个“draft”的原因，建议直接删除。  

publishdate ：发布日期  
type ：内容的类型  
isCJKLanguage ：汉字编码（其实还包括日文韩语）。如果设置了，才能正确的使用汉字的自动摘要”.Summary “和字数统计” .WordCount”。  
weight ：权重，用于排序的一个数字。默认是从小到大的，可以是负数。  
markup ：标记 (试验性的)。默认是md，也可以是”rst“格式。rst是”reStructuredText“格式。  
slug ：小节。在url尾巴处出现的一个”token“。  
url ：从根目录开始的全部url。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;section&#34;&gt;section&lt;/h3&gt;

&lt;p&gt;章节是目录名字，也就是content下面的 目录&lt;/p&gt;

&lt;h3 id=&#34;type&#34;&gt;type&lt;/h3&gt;

&lt;p&gt;默认的，一个章节就是一种内容类型。那么只需要建立 xxx 目录（章节），就设置了 xxx 内容类型。&lt;br /&gt;
当然，通过文件头指定type属性，就是设置内容类型。我们指定文章内容的“ type = “ xxx ”就设置 xxx 内容类型。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;hugo的基本模板分为三种：详细页，列表页，首页。&lt;/p&gt;

&lt;p&gt;详细页名称为single.html，用于对应单独一篇文章的输出。&lt;/p&gt;

&lt;p&gt;列表页名称为list.html，用于一个栏目、类型、章节、日期等等归集的列表输出。列表页可以分页。&lt;/p&gt;

&lt;p&gt;首页名称为index.html，用于导航列表页和详细页。单页面站点可以只有首页。&lt;/p&gt;

&lt;h3 id=&#34;模板匹配规则&#34;&gt;模板匹配规则&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;若有与文件类型（章节）相同文件名 的内容模板，则匹配和使用。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;若没有，则匹配“ default.md ”。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;若使用 主题 文件，则使用主题的“archetypes”，规则与全局的相同。&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若都没有匹配的，则使用hugo自带的。&lt;/p&gt;

&lt;h3 id=&#34;渲染规则&#34;&gt;渲染规则&lt;/h3&gt;

&lt;p&gt;若hugo无themes文件夹，或themes下面没有主题，则使用根目录下的layouts、archetypes和static文件进行渲染。&lt;br /&gt;
  若有主题文件并设置了主题，则使用主题文件渲染。&lt;br /&gt;
  首页使用index.html渲染。&lt;br /&gt;
  列表页使用_default下的list.html渲染。&lt;br /&gt;
  详细页（对应单个的md文件）使用_default下的single.html渲染。&lt;br /&gt;
  若设置了内容类型，则使用相应的“xxx”类型文件目录下的list和single.html渲染。&lt;br /&gt;
  单页面站点需要index.html,首页index.html模板支持所有列表页和详细页的模板参数、函数。&lt;/p&gt;

&lt;p&gt;列表就是很多个的文章，单个就是单篇，hugo还有模板文件分割（比如头部共同文件）、视图、片段等概念，非常灵活方便，其实hugo的模板就是go模板，无奈谷歌被墙。好东西总是忍不住一枝红杏出墙来！&lt;/p&gt;

&lt;h3 id=&#34;hugo单页模板匹配&#34;&gt;hugo单页模板匹配&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是hugo的单页面模板匹配过程：&lt;/p&gt;

&lt;p&gt;/layouts/类型 或 章节/LAYOUT.html&lt;br /&gt;
  /layouts/类型 或 章节/single.html&lt;br /&gt;
  /layouts/_default/single.html&lt;br /&gt;
  /themes/主题/layouts/类型 或 章节/LAYOUT.html&lt;br /&gt;
  /themes/主题/layouts/类型 或 章节/single.html&lt;br /&gt;
  /themes/主题/layouts/_default/single.html&lt;/p&gt;

&lt;p&gt;以上中文部分都是我们后面新建的主题、类型、章节。我们推荐使用主题，也就是后三个规则。&lt;/p&gt;

&lt;p&gt;为了方便，我们直接修改默认新建主题生成的“/themes/hugao_theme/layouts/_default/ single.html ”单页面主题。&lt;/p&gt;

&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;{{- .Title -}} 移除前后空白字符 [ \t \r \n ]&lt;/p&gt;

&lt;h4 id=&#34;config-yaml-站点级变量访问&#34;&gt;config.yaml 站点级变量访问&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;.Site.Social&lt;/code&gt; #Site变量首字母必须大写&lt;br /&gt;
.Site.Params.Links&lt;br /&gt;
[params.Links] 多级配置变量&lt;br /&gt;
youdao = &amp;ldquo;www.youdao.com&amp;rdquo;&lt;br /&gt;
baidu = &amp;ldquo;www.youdao.com&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;page级变量访问&#34;&gt;page级变量访问&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;.Params.tags&lt;/code&gt;  # front matter变量&lt;br /&gt;
.RelPermalink    the relative permanent link for this page.&lt;br /&gt;
.RelRef&lt;br /&gt;
returns the relative permalink for a given reference (e.g., RelRef &amp;ldquo;sample.md&amp;rdquo;). .RelRef does not handle in-page fragments correctly. See Cross References.&lt;br /&gt;
.Section    当前文档所属的一级目录&lt;br /&gt;
.Title&lt;br /&gt;
.Truncated    “Read more…”&lt;br /&gt;
.Type       the content type of the content (e.g., post).&lt;br /&gt;
.URL&lt;/p&gt;

&lt;h4 id=&#34;全局变量访问-use-to-access-the-global-context&#34;&gt;全局变量访问 Use &lt;code&gt;$.&lt;/code&gt; to Access the Global Context&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;$.Site.Title&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;file-变量-等价-source-file&#34;&gt;.File 变量 等价 &lt;code&gt;.Source.File&lt;/code&gt;&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;访问目录结构&#34;&gt;访问目录结构&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;{{range .Site.Sections }}  
{{  .Type | Title }}                ## .Type关键 获取Section名称  
{{end}}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;如何访问所有的categories&#34;&gt;如何访问所有的categories&lt;/h2&gt;

&lt;p&gt;{{range $k,$v := .Site.Taxonomies.categories}}&lt;br /&gt;
    &lt;option value=&#34;{{$k | humanize | lower}}&#34;&gt;{{$k | humanize | lower}}&lt;/option&gt;&lt;br /&gt;
{{end}}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ with .Site.Taxonomies.categories }}  

	  &amp;lt;h1 class=&amp;quot;headline&amp;quot;&amp;gt;Categories&amp;lt;/h1&amp;gt;  

	  &amp;lt;section class=&amp;quot;categories&amp;quot;&amp;gt;  
	    {{ range $name, $value := . }}  
	    &amp;lt;h2 class=&amp;quot;category&amp;quot;&amp;gt;  
	      &amp;lt;a href=&amp;quot;{{ $baseurl }}categories/{{ $name | urlize }}&amp;quot;&amp;gt;{{ title $name }}&amp;lt;/a&amp;gt;  
	      &amp;lt;small&amp;gt;({{ .Count }})&amp;lt;/small&amp;gt;  
	    &amp;lt;/h2&amp;gt;  
	    {{ end }}  
	  &amp;lt;/section&amp;gt;  

	{{ end }}  

	{{ with .Site.Taxonomies.tags }}  

	  &amp;lt;h1 class=&amp;quot;headline&amp;quot;&amp;gt;Tags&amp;lt;/h1&amp;gt;  
		  &amp;lt;section class=&amp;quot;tags&amp;quot;&amp;gt;  
	    {{ range $name, $value := . }}  
	    &amp;lt;span class=&amp;quot;tag&amp;quot;&amp;gt;  
	      &amp;lt;a href=&amp;quot;{{ $baseurl }}tags/{{ $name | urlize }}&amp;quot;&amp;gt;{{ $name }}&amp;lt;/a&amp;gt;  
	      &amp;lt;small&amp;gt;({{ .Count }})&amp;lt;/small&amp;gt;  
	    &amp;lt;/span&amp;gt;  
	    {{ end }}  
	  &amp;lt;/section&amp;gt;  
	{{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&amp;ndash;uglyURLs  增加&lt;code&gt;.html&lt;/code&gt;后缀&lt;br /&gt;
&lt;code&gt;
└── content  
└── about  
|   └── _index.md  // &amp;lt;- https://example.com/about/index.html  
├── post  
|   ├── firstpost.md   // &amp;lt;- https://example.com/post/firstpost.html  
&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;section path slug url&lt;br /&gt;
                section&lt;br /&gt;
                ⊢&amp;ndash;^&amp;ndash;⊣&lt;br /&gt;
                      path        slug&lt;br /&gt;
                ⊢&amp;mdash;&amp;mdash;^&amp;mdash;&amp;ndash;⊣ ⊢&amp;mdash;-^&amp;mdash;&amp;mdash;⊣&lt;br /&gt;
  baseURL                    url&lt;br /&gt;
⊢&amp;mdash;&amp;mdash;&amp;ndash;^&amp;mdash;&amp;mdash;&amp;ndash;⊣ ⊢&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-^&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;⊣&lt;br /&gt;
              permalink&lt;br /&gt;
⊢&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-^&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;⊣&lt;br /&gt;
&lt;a href=&#34;https://example.com/events/chicago/lollapalooza/&#34; target=&#34;_blank&#34;&gt;https://example.com/events/chicago/lollapalooza/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;post 文章中 增加oldpost 重定向&lt;br /&gt;
+++&lt;br /&gt;
aliases = [&lt;br /&gt;
&amp;rdquo;/posts/my-old-url/&amp;ldquo;,&lt;br /&gt;
&amp;rdquo;/2010/01/01/even-earlier-url.html&amp;rdquo;&lt;br /&gt;
]&lt;br /&gt;
+++&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>个人博客hugo Taxonomy</title>
            <link>http://blog.pytool.com/hugo/hugo_taxonomy/</link>
            <pubDate>Sat, 01 Apr 2017 04:15:26 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_taxonomy/</guid>
            <description>

&lt;p&gt;Taxonomy，即分类，是Hugo中一个很有用的页面管理功能。 本文基于Hyde这个Theme，介绍如何在Hugo中定制、使用Taxonomy。&lt;br /&gt;
Hugo中的Taxonomy概念&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hugo includes support for user-defined groupings of content called taxonomies. Taxonomies are classifications of logical relationships between content.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在官方文档中，简单介绍了Taxonomy的相关概念。 这里有三级概念，见下表。&lt;/p&gt;

&lt;p&gt;| 概念       | 翻译   | 解释                           |&lt;br /&gt;
| &amp;mdash;&amp;mdash;&amp;ndash; | &amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |&lt;br /&gt;
| Taxonomy | 分类   | 用来归类的大类，比如tag。               |&lt;br /&gt;
| term     | 项    | 可以认为是Taxonomy的值，比如hugo。      |&lt;br /&gt;
| Value    | 值    | 被归类为某个term的内容，比如tag为hugo的页面。 |&lt;br /&gt;
| Content  | 内容   | 与Value同义。                    |&lt;/p&gt;

&lt;p&gt;以下是官方给出的例子，关于演员与电影。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Actor                    &amp;lt;- Taxonomy  
    Bruce Willis         &amp;lt;- Term  
        The Sixth Sense  &amp;lt;- Content  
        Unbreakable      &amp;lt;- Content  
        Moonrise Kingdom &amp;lt;- Content  
    Samuel L. Jackson    &amp;lt;- Term  
        Unbreakable      &amp;lt;- Content  
        The Avengers     &amp;lt;- Content  
        xXx              &amp;lt;- Content  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;默认taxonomy&#34;&gt;默认Taxonomy&lt;/h3&gt;

&lt;p&gt;Hugo 支持两个 Taxonomy ：tag和category。 如果是电影类网站，Taxonomy可以有导演、演员、编剧等。 但是对于一个个人博客类网站来说，只需要一个tag就够了。&lt;/p&gt;

&lt;p&gt;除此之外，Hugo默认还有Section的概念。 所有文章都在content目录下，而Section就是文章所在的content子目录。 Section也是URL上的一部分。&lt;/p&gt;

&lt;p&gt;Section与Taxonomy的区别是，一个Single页面只能属于一个Section，而却可以属于多个Taxonomy的不同term。 所以，Taxonomy比Section更灵活。&lt;/p&gt;

&lt;p&gt;官方的示例配置如下，定义了三个Taxonomy的term。&lt;/p&gt;

&lt;p&gt;[taxonomies]&lt;br /&gt;
  tag = &amp;ldquo;tags&amp;rdquo;&lt;br /&gt;
  category = &amp;ldquo;categories&amp;rdquo;&lt;br /&gt;
  series = &amp;ldquo;series&amp;rdquo;&lt;/p&gt;

&lt;p&gt;这里写几个，就是几个Taxonomy。 如果不写[taxonomies]这一个代码块，就是使用默认的tag和category两个。&lt;/p&gt;

&lt;p&gt;其中，等号前面的tag代表真正的term名称，而后面的&amp;rdquo;tags&amp;rdquo;则代表使用时的名称。 通常，前面用名词的单数，后面用名词的复数。 在Taxonomy的列表页面中，以tags为URL的一部分； 在Front Matter中，也使用tags = []来指定当前页面所属的tag。&lt;/p&gt;

&lt;p&gt;+++&lt;br /&gt;
title = &amp;ldquo;Hugo: A fast and flexible static site generator&amp;rdquo;&lt;br /&gt;
tags = [ &amp;ldquo;Development&amp;rdquo;, &amp;ldquo;Go&amp;rdquo;, &amp;ldquo;fast&amp;rdquo;, &amp;ldquo;Blogging&amp;rdquo; ]&lt;br /&gt;
categories = [ &amp;ldquo;Development&amp;rdquo; ]&lt;br /&gt;
series = [ &amp;ldquo;Go Web Dev&amp;rdquo; ]&lt;br /&gt;
+++&lt;/p&gt;

&lt;p&gt;对博客类网站来说，如果每个页面都要写tags、categories、series，想想也是很辛苦。 所以本站还是坚持极简的设计，一个tags足以。&lt;br /&gt;
Taxonomy的展示页面&lt;/p&gt;

&lt;p&gt;Taxonomy有两种展示页面，对应两种模板文件。&lt;/p&gt;

&lt;p&gt;在孤使用之初，由于概念不清，被坑很惨。 做了半天，相关页面却纹丝不动。 因此觉得，定制Taxonomy页面，应该在理清概念的基础上，选定正确的模板文件，再开始定制。&lt;br /&gt;
Taxonomy List Templates&lt;/p&gt;

&lt;p&gt;这是普通的列表页面，URL示例为/tags/hugo/。 由于这是普通的列表页面，所以默认情况下会使用列表模板。&lt;/p&gt;

&lt;p&gt;对于本站，这个页面没有定制的必要，和Section一样，使用默认列表模板即可。 而如果有定制需求，则需要按照以下优先级去修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/layouts/taxonomy/&amp;lt;SINGULAR&amp;gt;.html  
/layouts/_default/taxonomy.html  
/layouts/_default/list.html  
/themes/&amp;lt;THEME&amp;gt;/layouts/taxonomy/&amp;lt;SINGULAR&amp;gt;.html  
/themes/&amp;lt;THEME&amp;gt;/layouts/_default/taxonomy.html  
/themes/&amp;lt;THEME&amp;gt;/layouts/_default/list.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;SINGULAR&gt;是term的单数，即上一节等号左边的名词。 比如/tags/hugo/，第1个模板就是/layouts/taxonomy/tag.html。 第2个模板是对所有的Taxonomy列表页面，而第3个就是所有的列表页面。&lt;br /&gt;
Taxonomy Terms Template&lt;/p&gt;

&lt;p&gt;这是Taxonomy特有的列表页面，URL示例为/tags/。 显然，/tags/hugo/是所有tag为hugo的页面，而/tags/则是需要显示所有tag。 这个页面与普通的列表页面有巨大差异，因为默认是没有任何页面属于这个页面的，所以不使用默认列表模板。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/layouts/taxonomy/&amp;lt;SINGULAR&amp;gt;.terms.html  
/layouts/_default/terms.html  
/themes/&amp;lt;THEME&amp;gt;/layouts/taxonomy/&amp;lt;SINGULAR&amp;gt;.terms.html  
/themes/&amp;lt;THEME&amp;gt;/layouts/_default/terms.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要展示，就需要按照以上优先级去定制。 如果按/tags/来算，第1个模板是/layouts/taxonomy/tag.terms.html。 由于本站仅仅使用了tag作为Taxonomy，所以就直接定制了第2个页面。&lt;br /&gt;
Term模板代码示例&lt;/p&gt;

&lt;p&gt;以下即是本站（2017年10月）的/layouts/_default/terms.html模板的部分内容，以供参考。 页面示例，可以访问/tags/。 （当然，鉴于本站经常更新，页面示例可能会有所修改。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-handlebars&#34;&gt;&amp;lt;h1&amp;gt;分类标签有{{ len .Data.Terms }}个&amp;lt;/h1&amp;gt;  
{{ $data := .Data }}  
{{ range .Data.Terms.ByCount }}  
{{ $termLink := printf &amp;quot;/%s/%s/&amp;quot; $data.Plural .Term | urlize }}  
&amp;lt;h2&amp;gt;  
&amp;lt;a href=&amp;quot;{{ $termLink }}&amp;quot;&amp;gt;{{ .Term }}&amp;lt;/a&amp;gt;  
有{{ .Count }}篇  
&amp;lt;/h2&amp;gt;  
&amp;lt;ul&amp;gt;  

{{ range .Pages | first 5 }}  
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ .Permalink }}&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
{{ end }}  
{{ if gt (len .Pages) 5 }}  
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ $termLink }}&amp;quot;&amp;gt;……&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;  
{{ end }}  

&amp;lt;/ul&amp;gt;  
{{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中用到的函数、变量，需要去相关页面查阅。&lt;br /&gt;
参考&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hugo | Taxonomies  
Hugo | Taxonomy Variables  
Hugo | Taxonomy Templates  
Hugo | Functions Quick Reference  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>静态搜索javascript lunr.js</title>
            <link>http://blog.pytool.com/hugo/search-lunr/</link>
            <pubDate>Sat, 01 Apr 2017 04:15:26 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/search-lunr/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var lunrIndex, pagesIndex;  

// Initialize lunrjs using our generated index file  
function initLunr() {  
    // First retrieve the index file  
    $.getJSON(baseurl + &amp;quot;/json/search.json&amp;quot;)  
        .done(function(index) {  
            pagesIndex = index;  
            // Set up lunrjs by declaring the fields we use  
            // Also provide their boost level for the ranking  
            lunrIndex = new lunr.Index  
            lunrIndex.ref(&amp;quot;uri&amp;quot;);  
            lunrIndex.field(&#39;title&#39;, {  
                boost: 15  
            });  
            lunrIndex.field(&#39;tags&#39;, {  
                boost: 10  
            });  
            lunrIndex.field(&amp;quot;content&amp;quot;, {  
                boost: 5  
            });  

            // Feed lunr with each file and let lunr actually index them  
            pagesIndex.forEach(function(page) {  
                lunrIndex.add(page);  
            });  
            lunrIndex.pipeline.remove(lunrIndex.stemmer)  
        })  
        .fail(function(jqxhr, textStatus, error) {  
            var err = textStatus + &amp;quot;, &amp;quot; + error;  
            console.error(&amp;quot;Error getting Hugo index flie:&amp;quot;, err);  
        });  
}  

/**  
 * Trigger a search in lunr and transform the result  
 *  
 * @param  {String} query  
 * @return {Array}  results  
 */  
function search(query) {  
    // Find the item in our index corresponding to the lunr one to have more info  
    return lunrIndex.search(query).map(function(result) {  
            return pagesIndex.filter(function(page) {  
                return page.uri === result.ref;  
            })[0];  
        });  
}  

// Let&#39;s get started  
initLunr();  
$( document ).ready(function() {  
    var horseyList = horsey($(&amp;quot;#search-by&amp;quot;).get(0), {  
        suggestions: function (value, done) {  
            var query = $(&amp;quot;#search-by&amp;quot;).val();  
            var results = search(query);  
            done(results);  
        },  
        filter: function (q, suggestion) {  
            return true;  
        },  
        set: function (value) {  
            location.href=value.href;  
        },  
        render: function (li, suggestion) {  
            var uri = suggestion.uri.substring(1,suggestion.uri.length);  
            var indexOfIndex = uri.lastIndexOf(&amp;quot;/index&amp;quot;);  
            if (indexOfIndex == -1) {  
                indexOfIndex = uri.length;  
            }  
            var href = uri.substring(uri.indexOf(&amp;quot;/&amp;quot;), indexOfIndex);  
            suggestion.href = baseurl + href;  

            var query = $(&amp;quot;#search-by&amp;quot;).val();  
            var numWords = 2;  
            var text = suggestion.content.match(&amp;quot;(?:\\s?(?:[\\w]+)\\s?){0,&amp;quot;+numWords+&amp;quot;}&amp;quot;+query+&amp;quot;(?:\\s?(?:[\\w]+)\\s?){0,&amp;quot;+numWords+&amp;quot;}&amp;quot;);  
            suggestion.context = text;  
            var image = &#39;&amp;lt;div&amp;gt;&#39; + &#39;» &#39; + suggestion.title + &#39;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size:12px&amp;quot;&amp;gt;&#39; + (suggestion.context || &#39;&#39;) +&#39;&amp;lt;/div&amp;gt;&#39;;  
            li.innerHTML = image;  
        },  
        limit: 10  
    });  
    horseyList.refreshPosition();  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(document).ready(function () {  
    &#39;use strict&#39;;  
    var resultwindow = $(&#39;div.search-result-window&#39;);  
    var resultlist = $(&#39;ul.search-results&#39;);  
    var noresults = $(&#39;.no-results&#39;);  

    // Set up search  
    $.getJSON(&#39;/lunr.json&#39;, function (response) {  
        // Create index  
        var index = lunr(function() {  
            this.ref(&#39;uri&#39;);  
            this.field(&#39;title&#39;, { boost: 10 });  
            this.field(&#39;content&#39;);  
            this.field(&#39;tags&#39;);  
        });  

        $.each(response, function(i, item) {  
            index.add(item);  
        });  

        // Handle search  
        $(&#39;input#search&#39;).on(&#39;keyup&#39;, function () {  
            // Get query  
            var query = $(this).val();  

            if (query) {  
                resultwindow.show();  

                // Search for query  
                var result = index.search(query);  
                console.log(result);  

                // Show results  
                resultlist.empty();  
                if (result.length &amp;gt; 0) {  
                    noresults.hide();  
                    for (var item in result) {  
                        var ref = result[item].ref;  
                        var title = response.find(function(item) { return item.uri == ref; }).title;  
                        var searchitem = &#39;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&#39; + ref + &#39;&amp;quot;&amp;gt;&#39; + title + &#39;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#39;;  
                        resultlist.append(searchitem);  
                    }  
                } else {  
                    noresults.show();  
                }  

            } else {  
                resultwindow.hide();  
            }  
        });  
    });  
});  

function closeSearchWindow() {  
    $(&#39;div.search-result-window&#39;).hide();  
    $(&#39;input#search&#39;).val(&#39;&#39;);  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 集成 MathJax</title>
            <link>http://blog.pytool.com/hugo/hugo_mathjax/</link>
            <pubDate>Thu, 16 Mar 2017 09:46:42 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hugo_mathjax/</guid>
            <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mathjax.org/&#34; target=&#34;_blank&#34;&gt;MathJax&lt;/a&gt; 是一款用于显示 LaTex 等风格数学公式的利器，只需要将其简单几步就可以将其集成到 Hugo 中。&lt;/p&gt;

&lt;h2 id=&#34;引用-mathjax&#34;&gt;引用 MathJax&lt;/h2&gt;

&lt;p&gt;为了展示文章中编写的 LaTeX 数学公式，需要集成 &lt;a href=&#34;https://www.mathjax.org/&#34; target=&#34;_blank&#34;&gt;MathJax&lt;/a&gt;。MathJax 是一个 Javascript 库，通过官方提供的 CDN 集成到自己站点十分简单，只需要将以下代码添加到站点的每一个 HTML 页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; async  
  src=&amp;quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&amp;quot;&amp;gt;  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为 HTML 页面添加以上代码后，页面中所有 &lt;a href=&#34;https://en.wikibooks.org/wiki/LaTeX/Mathematics&#34; target=&#34;_blank&#34;&gt;LaTex&lt;/a&gt; , &lt;a href=&#34;https://www.w3.org/Math/&#34; target=&#34;_blank&#34;&gt;MathML&lt;/a&gt; 以及 &lt;a href=&#34;http://asciimath.org/&#34; target=&#34;_blank&#34;&gt;AsciiMath&lt;/a&gt; 风格的数学公式都会得以显示，当然在页面中查找并显示这三种公式会对性能有所损耗，如果文章中仅仅含有LaTex编写的数学公式，可以将下面代码插入到站点每一个页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; async src=&amp;quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出唯一的不同之处在于脚本源 &lt;code&gt;src&lt;/code&gt; 中的 &lt;code&gt;config&lt;/code&gt; 参数，不同的&lt;code&gt;config&lt;/code&gt;定义了不同数学公式的输入以及输出，更多 MathJax 配置内容&lt;a href=&#34;http://docs.mathjax.org/en/latest/config-files.html#common-configurations&#34; target=&#34;_blank&#34;&gt;参见官网&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;集成-mathjax&#34;&gt;集成 MathJax&lt;/h2&gt;

&lt;p&gt;为了使得引用 MathJax 的代码可以添加到站点每一个页面，可以将其插入到站点每个页面都会包含的模板中，比如页脚模板 &lt;code&gt;partials/default_footer.html&lt;/code&gt; 中，并且可以在站点配置文件中添加配置参数，然后模板中就可以根据配置参数决定是否插入集成 MathJax 的代码。&lt;/p&gt;

&lt;p&gt;比如 &lt;code&gt;config.toml&lt;/code&gt; 配置内容为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Params]  
  mathjax = true  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板 &lt;code&gt;partials/default_footer.html&lt;/code&gt; 中添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if or (eq .Params.mathjax true) (eq .Site.Params.mathjax true) }}  
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; async src=&amp;quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  
{{ end }}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mathjax-跟-markdown-冲突&#34;&gt;MathJax 跟 Markdown 冲突&lt;/h2&gt;

&lt;p&gt;Markdown 将 &lt;code&gt;_&lt;/code&gt; 解析为强调，因此 &lt;code&gt;_..._&lt;/code&gt; 会被 Markdown 引擎转换为 &lt;code&gt;&amp;lt;em&amp;gt;...&amp;lt;/em&amp;gt;&lt;/code&gt;；而 MathJax 将 &lt;code&gt;_&lt;/code&gt; 解析为下标，位于 &lt;code&gt;_&lt;/code&gt; 之后的内容会作为 &lt;code&gt;_&lt;/code&gt; 之前内容的下标。显然在生成静态站点时，Markdown 引擎已经将内容中所有 &lt;code&gt;_&lt;/code&gt; 转换为 &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签，即便是 LaTeX 数学公式中的 &lt;code&gt;_&lt;/code&gt; 也被转换成了 &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;，使得数学公式被破坏了，这样在使用浏览器浏览页面时，MathJax 将无法正确渲染被破坏的数学公式，为了解决这个问题下面有几种解决方案：&lt;/p&gt;

&lt;h3 id=&#34;方案一&#34;&gt;方案一&lt;/h3&gt;

&lt;p&gt;数学公式中使用 &lt;code&gt;_&lt;/code&gt; 的地方都转义为 &lt;code&gt;\_&lt;/code&gt;，这样在 Markdown 引擎转换文档时会将 &lt;code&gt;\_&lt;/code&gt; 转换为 &lt;code&gt;_&lt;/code&gt; ，可以使得 MathJax 能够正确的渲染该公式。该方法的缺点也很明显，将数学公式中的 &lt;code&gt;_&lt;/code&gt; 转义为 &lt;code&gt;\_&lt;/code&gt; 会很繁琐，而且如果用户使用的 Markdown 编辑器支持 LaTeX 公式预览功能，转义为 &lt;code&gt;\_&lt;/code&gt; 可能被预览功能识别为 LaTeX 中对下标符 &lt;code&gt;_&lt;/code&gt; 的转义，将使得下标功能失效，下标符原样输出。&lt;/p&gt;

&lt;h3 id=&#34;方案二&#34;&gt;方案二&lt;/h3&gt;

&lt;p&gt;鉴于嵌套在 HTML 区块标签内的 Markdown 语法不被 Markdown 引擎处理，会原样输出，因此可以考虑将 LaTeX 块级数学公式放在标签 &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 内，数学公式就不会被 Markdown 引擎处理。至于 LaTeX 行内数学公式，如果放在 &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 内则会独立成段打乱内容排版，为此需要考虑使用其它方法避免行内数学公式被 Markdown 引擎处理。Markdown 语法支持行内代码，可以考虑将行内数学公式放在 Markdown 的行内代码语法中，这样就可以避免 Markdown 引擎处理其中的 &lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;`$x_\alpha$`  
以上内容会被Markdown引擎解析为 &amp;lt;code&amp;gt;$x_\alpha$&amp;lt;/code&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过 MathJax 默认不会对 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;等 HTML 标签内的数学公式进行解析。因此需要配置 MathJax 使其可以解析 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 中的数学公式。添加以下代码到站点所有页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;  
MathJax.Hub.Config({  
  tex2jax: {  
    inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]],  
    displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]],  
    processEscapes: true,  
    processEnvironments: true,  
    skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;],  
    TeX: { equationNumbers: { autoNumber: &amp;quot;AMS&amp;quot; },  
         extensions: [&amp;quot;AMSmath.js&amp;quot;, &amp;quot;AMSsymbols.js&amp;quot;] }  
  }  
});  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样所有位于 &lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt; 标签内的数学公式都会被 MathJax 渲染（当然如果正好想要让 &lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt; 标签内数学公式不渲染而原样输出，就办不到了，因为所有公式都将会被渲染），除了配置 MathJax 使得 &lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt; 内的数学公式可以被渲染外，&lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt; 的显示样式同普通文本也是不一样的，因此还需要配置含有数学公式 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 标签的样式，需要将如下代码添加到站点的所有页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;  
  MathJax.Hub.Queue(function() {  
    // Fix &amp;lt;code&amp;gt; tags after MathJax finishes running. This is a  
    // hack to overcome a shortcoming of Markdown. Discussion at  
    // https://github.com/mojombo/jekyll/issues/199  
    var all = MathJax.Hub.getAllJax(), i;  
    for(i = 0; i &amp;lt; all.length; i += 1) {  
        all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;  
    }  
});  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并将如下代码添加到站点的 CSS 文件中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;code.has-jax {font: inherit;  
              font-size: 100%;  
              background: inherit;  
              border: inherit;  
              color: #515151;}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外如果使用了高亮工具 &lt;a href=&#34;http://pygments.org/&#34; target=&#34;_blank&#34;&gt;Pgyments&lt;/a&gt; ，数学公式可能不能够正确显示为黑色，为了修正这个问题需要将以下代码添加到站点每个页面中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;  
  MathJax.Hub.Config({  
    &amp;quot;HTML-CSS&amp;quot;: {  
      styles: {  
        &amp;quot;.MathJax .mo, .MathJax .mi&amp;quot;: {color: &amp;quot;black ! important&amp;quot;}  
      }  
    }  
  });  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方案的缺点也很明显，需要把块级数学公式写在 &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 中，行级数学公式写在 Markdown 的行内代码中，并且配置 MathJax 对 &lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt; 标签内容进行解析可能会使得原本要原样输出的公式被渲染显示。&lt;/p&gt;

&lt;h3 id=&#34;方案三&#34;&gt;方案三&lt;/h3&gt;

&lt;p&gt;以上两种方案都有一个明显的缺点，为了使得 MathJax 能够正确渲染数学公式而要求在撰写 Markdown 文档时添加某些特殊符号，甚至在行内代码语法内嵌套行级数学公式，显然违背了 Markdown 行内代码语法的语义，理想的方式是用户可以像普通文本一样将数学公式添加到 Markdown 文档中，然后由 Markdown 引擎来负责正确解析文档，经过研究（主要参考了两篇文章&lt;a href=&#34;https://github.com/spf13/hugo/issues/1666&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://nosubstance.me/post/a-great-toolset-for-static-blogging/&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;）发现 Hugo 目前搭载了两个 Markdown 引擎&lt;a href=&#34;https://github.com/russross/blackfriday&#34; target=&#34;_blank&#34;&gt;Blackfriday&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/miekg/mmark&#34; target=&#34;_blank&#34;&gt;Mmark&lt;/a&gt;，默认解析 Markdown 文档的是Blackfirday引擎，该引擎简单快速，仅支持基本的 Markdown 语法，而 Mmark 引擎则支持 Markdown &lt;a href=&#34;https://github.com/miekg/mmark/wiki/Syntax&#34; target=&#34;_blank&#34;&gt;语法超集&lt;/a&gt;，参考该语法 &lt;code&gt;Math Blocks&lt;/code&gt; 部分的介绍，发现 Mmark 引擎对数学公式的书写十分友好，要想插入数学公式只需要使用 &lt;code&gt;$$&lt;/code&gt; 来包围数学公式即可，Mmark 会自动根据数学公式的位置判断数学公式是要转换为行级公式还是块级公式，如果数学公式处于段落内就会被转换 LaTeX 行级公式的语法 &lt;code&gt;\(...\)&lt;/code&gt;，反之如果数学公式独立成段就会被转换为 LaTeX 块级公式语法 &lt;code&gt;\[...\]&lt;/code&gt;，而且 Mmark 不会对 &lt;code&gt;$$&lt;/code&gt; 包围的内容做任何解析，看来使用 Mmark 引擎就是最简单的方案了，如何优雅的使用该方案呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置 hugo 在处理文档时使用 Mmark 引擎。要么将文档扩展名从 &lt;code&gt;*.md&lt;/code&gt; 改为 &lt;code&gt;*.mmark&lt;/code&gt;，要么在文档的 Front Matter 中配置 &lt;code&gt;markup&lt;/code&gt; 为 &lt;code&gt;mmark&lt;/code&gt; 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文档中插入数学公式，行级公式直接使用 &lt;code&gt;$$&lt;/code&gt; 包围插入，块级公式需要将公式独立成段落并用 &lt;code&gt;$$&lt;/code&gt; 包围&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MathJax 默认 LaTeX 行级的定界符为 &lt;code&gt;\(...\)&lt;/code&gt;，默认块级定界符为 &lt;code&gt;$$...$$&lt;/code&gt; 和 &lt;code&gt;\[...\]&lt;/code&gt;。而 Mmark 生成的行级和块级公式语法正好可以被 MathJax识别，想要明确声明 MathJax 数学公式的定界符，使用如下代码：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;  
MathJax.Hub.Config({  
  tex2jax: {inlineMath: [[&#39;\\(&#39;,&#39;\\)&#39;]]},  
  displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\\[&#39;,&#39;\\]&#39;]]  
});  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Hexo使用文档</title>
            <link>http://blog.pytool.com/hugo/hexo/</link>
            <pubDate>Tue, 02 Feb 2016 15:03:34 CST</pubDate>
            <author>rinetd</author>
            <guid>http://blog.pytool.com/hugo/hexo/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;http://leanote.com/blog/view/52db8463e01c530ef8000001&#34; target=&#34;_blank&#34;&gt;leanote博客评论设置之Disqus&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://wiki.jikexueyuan.com/project/hexo-document/&#34; target=&#34;_blank&#34;&gt;Hexo document&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://wizardforcel.gitbooks.io/hexo-doc/content/index.html&#34; target=&#34;_blank&#34;&gt;Hexo 中文文档&lt;/a&gt;&lt;br /&gt;
说明:hexo 还是很不错的&lt;/p&gt;

&lt;h2 id=&#34;hexo-按更新时间排序-vi-config-yml&#34;&gt;hexo 按更新时间排序 &lt;code&gt;vi _config.yml&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;index_generator:&lt;br /&gt;
  order_by: -update # order_by: Posts order. (Order by date descending by default)&lt;/p&gt;

&lt;!-- more --&gt;  

&lt;h3 id=&#34;0x01-安装node-js&#34;&gt;0x01 安装node.js&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34;&gt;node.js稳定版&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x02-配置node-js&#34;&gt;0x02 配置node.js&lt;/h3&gt;

&lt;p&gt;通过npm config set   生成 .npmrc&lt;br /&gt;
prefix=D:\Users\nodejs\npm&lt;br /&gt;
cache=D:\Users\nodejs\npm-cache&lt;/p&gt;

&lt;h3 id=&#34;0x03-安装-hexo&#34;&gt;0x03 安装 hexo&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;npm install -g hexo&lt;/code&gt;&lt;br /&gt;
查看安装结果&lt;br /&gt;
&lt;code&gt;npm list -g **hexo**&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ubuntu&#34;&gt;Ubuntu&lt;/h2&gt;

&lt;p&gt;sudo apt-get install nodejs&lt;br /&gt;
sudo ln -s /usr/bin/nodejs /usr/bin/node&lt;br /&gt;
npm install -g cnpm &amp;ndash;registry=&lt;a href=&#34;https://registry.npm.taobao.org&#34; target=&#34;_blank&#34;&gt;https://registry.npm.taobao.org&lt;/a&gt;&lt;br /&gt;
sudo npm install cnpm -g&lt;br /&gt;
sudo cnpm install hexo -g&lt;br /&gt;
sudo cnpm install&lt;/p&gt;

&lt;p&gt;&amp;ldquo;hexo&amp;rdquo;: &amp;ldquo;^3.2.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-toc&amp;rdquo;: &amp;ldquo;^0.0.6&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-server&amp;rdquo;: &amp;ldquo;^0.2.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-github&amp;rdquo;: &amp;ldquo;^1.0.1&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-deployer-git&amp;rdquo;: &amp;ldquo;^0.1.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-generator-archive&amp;rdquo;: &amp;ldquo;^0.1.4&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-generator-category&amp;rdquo;: &amp;ldquo;^0.1.3&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-generator-feed&amp;rdquo;: &amp;ldquo;^1.1.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-generator-index&amp;rdquo;: &amp;ldquo;^0.2.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-generator-sitemap&amp;rdquo;: &amp;ldquo;^1.1.2&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-generator-tag&amp;rdquo;: &amp;ldquo;^0.2.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-renderer-ejs&amp;rdquo;: &amp;ldquo;^0.2.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-renderer-sass&amp;rdquo;: &amp;ldquo;^0.2.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-renderer-jade&amp;rdquo;: &amp;ldquo;^0.3.0&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-renderer-marked&amp;rdquo;: &amp;ldquo;^0.2.10&amp;rdquo;,&lt;br /&gt;
   &amp;ldquo;hexo-renderer-stylus&amp;rdquo;: &amp;ldquo;^0.3.1&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;hexo&lt;/p&gt;

&lt;p&gt;npm install hexo -g #安装&lt;br /&gt;
npm update hexo -g #升级&lt;br /&gt;
hexo init #初始化&lt;br /&gt;
简写&lt;/p&gt;

&lt;p&gt;hexo n &amp;ldquo;我的博客&amp;rdquo; == hexo new &amp;ldquo;我的博客&amp;rdquo; #新建文章&lt;br /&gt;
hexo p == hexo publish&lt;br /&gt;
hexo g == hexo generate#生成&lt;br /&gt;
hexo s == hexo server #启动服务预览&lt;br /&gt;
hexo d == hexo deploy#部署&lt;/p&gt;

&lt;p&gt;服务器&lt;/p&gt;

&lt;p&gt;hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。&lt;br /&gt;
hexo server -s #静态模式&lt;br /&gt;
hexo server -p 5000 #更改端口&lt;br /&gt;
hexo server -i 192.168.1.1 #自定义 IP&lt;/p&gt;

&lt;p&gt;hexo clean #清除缓存 网页正常情况下可以忽略此条命令&lt;br /&gt;
hexo g #生成静态网页&lt;br /&gt;
hexo d #开始部署&lt;br /&gt;
python -m SimpleHTTPServer&lt;br /&gt;
监视文件变动&lt;/p&gt;

&lt;p&gt;hexo generate #使用 Hexo 生成静态文件快速而且简单&lt;br /&gt;
hexo generate &amp;ndash;watch #监视文件变动&lt;/p&gt;

&lt;p&gt;完成后部署&lt;/p&gt;

&lt;p&gt;两个命令的作用是相同的&lt;br /&gt;
hexo generate &amp;ndash;deploy&lt;br /&gt;
hexo deploy &amp;ndash;generate&lt;br /&gt;
hexo deploy -g&lt;br /&gt;
hexo server -g&lt;/p&gt;

&lt;p&gt;草稿&lt;/p&gt;

&lt;p&gt;hexo publish [layout] &lt;title&gt;&lt;/p&gt;

&lt;p&gt;模版&lt;/p&gt;

&lt;p&gt;hexo new &amp;ldquo;postName&amp;rdquo; #新建文章&lt;br /&gt;
hexo new page &amp;ldquo;pageName&amp;rdquo; #新建页面&lt;br /&gt;
hexo generate #生成静态页面至public目录&lt;br /&gt;
hexo server #开启预览访问端口（默认端口4000，&amp;rsquo;ctrl + c&amp;rsquo;关闭server）&lt;br /&gt;
hexo deploy #将.deploy目录部署到GitHub&lt;/p&gt;

&lt;p&gt;hexo new [layout] &lt;title&gt;&lt;br /&gt;
hexo new photo &amp;ldquo;My Gallery&amp;rdquo;&lt;br /&gt;
hexo new &amp;ldquo;Hello World&amp;rdquo; &amp;ndash;lang tw&lt;/p&gt;

&lt;p&gt;模版（Scaffold）&lt;/p&gt;

&lt;p&gt;hexo new photo &amp;ldquo;My Gallery&amp;rdquo;&lt;/p&gt;

&lt;p&gt;设置文章摘要&lt;/p&gt;

&lt;p&gt;以上是文章摘要  以下是余下全文&lt;br /&gt;
写作&lt;/p&gt;

&lt;p&gt;hexo new page &lt;title&gt;&lt;br /&gt;
hexo new post &lt;title&gt;&lt;/p&gt;

&lt;p&gt;变量  描述&lt;br /&gt;
:title  标题&lt;br /&gt;
:year   建立的年份（4 位数）&lt;br /&gt;
:month  建立的月份（2 位数）&lt;br /&gt;
:i_month    建立的月份（去掉开头的零）&lt;br /&gt;
:day    建立的日期（2 位数）&lt;br /&gt;
:i_day  建立的日期（去掉开头的零）&lt;br /&gt;
推送到服务器上&lt;/p&gt;

&lt;p&gt;hexo n #写文章&lt;br /&gt;
hexo g #生成&lt;br /&gt;
hexo d #部署 #可与hexo g合并为 hexo d -g&lt;/p&gt;

&lt;p&gt;报错&lt;/p&gt;

&lt;p&gt;1.找不到git部署&lt;/p&gt;

&lt;p&gt;ERROR Deployer not found: git&lt;br /&gt;
解决方法&lt;/p&gt;

&lt;p&gt;npm install hexo-deployer-git &amp;ndash;save&lt;/p&gt;

&lt;p&gt;3.部署类型设置git&lt;/p&gt;

&lt;p&gt;hexo 3.0 部署类型不再是github，_config.yml 中修改&lt;/p&gt;

&lt;h1 id=&#34;deployment&#34;&gt;Deployment&lt;/h1&gt;

&lt;h2 id=&#34;docs-http-hexo-io-docs-deployment-html&#34;&gt;Docs: &lt;a href=&#34;http://hexo.io/docs/deployment.html&#34; target=&#34;_blank&#34;&gt;http://hexo.io/docs/deployment.html&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;deploy:&lt;br /&gt;
  type: git&lt;br /&gt;
  repository: git@&lt;strong&gt;&lt;em&gt;.github.com:&lt;/em&gt;&lt;/strong&gt;/***.github.io.git&lt;br /&gt;
  branch: master&lt;br /&gt;
4. xcodebuild&lt;/p&gt;

&lt;p&gt;xcode-select: error: tool &amp;lsquo;xcodebuild&amp;rsquo; requires Xcode, but active developer directory &amp;lsquo;/Library/Developer/CommandLineTools&amp;rsquo; is a command line tools instance&lt;/p&gt;

&lt;p&gt;npm install bcrypt&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;RSS不显示&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装RSS插件&lt;/p&gt;

&lt;p&gt;npm install hexo-generator-feed &amp;ndash;save&lt;/p&gt;

&lt;p&gt;开启RSS功能&lt;/p&gt;

&lt;p&gt;编辑hexo/_config.yml，添加如下代码：&lt;/p&gt;

&lt;p&gt;rss: /atom.xml #rss地址  默认即可&lt;/p&gt;

&lt;h3 id=&#34;0x04-创建项目&#34;&gt;0x04 创建项目&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;hexo init rinetd&lt;/code&gt;&lt;br /&gt;
 &lt;code&gt;hexo new rinetd&lt;/code&gt;&lt;br /&gt;
 &lt;code&gt;hexo g&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x05-主题安装&#34;&gt;0x05 主题安装&lt;/h3&gt;

&lt;p&gt;maupassant&lt;br /&gt;
&lt;code&gt;git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;npm install hexo-renderer-sass --save&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;npm install hexo-renderer-jade --save&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x06-配置多说&#34;&gt;0x06 配置多说&lt;/h2&gt;

&lt;p&gt;申请多说开发者帐号&lt;a href=&#34;http://duoshuo.com/create-site&#34; target=&#34;_blank&#34;&gt;注册&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&#34;http://api.duoshuo.com/sites/listTopThreads.json?short_name=jyprince&#34; target=&#34;_blank&#34;&gt;测试帐号&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x07-配置disqus&#34;&gt;0x07 配置disqus&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://disqus.com/admin/signup/?utm_source=New-Site&#34; target=&#34;_blank&#34;&gt;申请Disqus帐号&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://segmentfault.com/a/1190000002632530&#34; target=&#34;_blank&#34;&gt;http://segmentfault.com/a/1190000002632530&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
