<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Edits on 时光小栈</title>
        <link>//blog.pytool.com/edit/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Tue, 12 Jan 2016 15:30:01 CST</updated>
        
        <item>
            <title>Emacs GTD</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-org-mode/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-org-mode/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/holbrook/archive/2012/04/17/2454619.html&#34; target=&#34;_blank&#34;&gt;Emacs学习笔记(11):用Org-mode实现GTD - 心内求法 - 博客园&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.lishen.me/archives/295&#34; target=&#34;_blank&#34;&gt;结合Doit.im谈谈GTD中的几个清单 | 李参的个人成长空间&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.doitim.com/post/3-gtd03.html&#34; target=&#34;_blank&#34;&gt;用Doit.im实施GTD的五个阶段（三）组织整理 | The Doit.im Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://pic002.cnblogs.com/images/2012/376709/2012032012034418.gif&#34; alt=&#34;BPMN&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;capture&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;refile&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;org-modules&lt;br /&gt;
&lt;a href=&#34;http://orgmode.org/worg/org-contrib/&#34; target=&#34;_blank&#34;&gt;Org-mode 插件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(add-to-list &amp;lsquo;org-modules &amp;lsquo;org-timer)&lt;/p&gt;

&lt;p&gt;C-c C-w refile 更改分类 （比如可以再gtd中实现移动到完成）&lt;/p&gt;

&lt;p&gt;状态关键词使用 #+SEQ_TODO:&lt;br /&gt;
类型关键词使用 #+TYP_TODO&lt;/p&gt;

&lt;p&gt;创建表格&lt;br /&gt;
|name|age|sex|&lt;br /&gt;
|-&lt;/p&gt;

&lt;h2 id=&#34;常用快捷键&#34;&gt;常用快捷键&lt;/h2&gt;

&lt;p&gt;g j 同级移动&lt;br /&gt;
 g k 同级移动&lt;br /&gt;
 g h 上级移动&lt;br /&gt;
 g l 下级移动&lt;/p&gt;

&lt;p&gt;5.remember 收集工具&lt;/p&gt;

&lt;p&gt;Inbox,在 GTD 的定义里面是收集材料的工具。最好的 Inbox 工具是纸和笔。而 Remember 在 Org mode 里面算是较好的 Inbox 工具。它比每次打开 org 文件来写好非常非常多。&lt;/p&gt;

&lt;p&gt;配置和基本使用remember.el在emacs23以上版本是自带的，emacs22及以下版本如果发现没有自带，请自行放狗搜。&lt;br /&gt;
 (setq org-default-notes-file &amp;ldquo;~/.notes&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;在.emacs中作如上设置，表示你希望将remember产生的note存放在~/.notes中，要我说这可一点也不重要，重要的是下面这一行：&lt;br /&gt;
 (define-key global-map [f12] &amp;lsquo;org-remember)&lt;/p&gt;

&lt;h1 id=&#34;stuck-project-被卡住的项目&#34;&gt;stuck project 被卡住的项目&lt;/h1&gt;

&lt;p&gt;A stuck project is a project that has no defined next actions, so it will never show up in the TODO lists Org mode produces. During the review, you need to identify such projects and define next actions for them.&lt;/p&gt;

&lt;p&gt;journal.org 个人备忘录 今天干了什么事情&lt;br /&gt;
notes.org 笔记 资料整理&lt;br /&gt;
gtd.org&lt;br /&gt;
收集箱 Inbox Remember org-capture [C-c c| SPC a o c]&lt;br /&gt;
  日历Calendar 重复固定（生日 纪念日）&lt;br /&gt;
  灵感inspiration: 我所说的是哪种突然出现，又害怕遗忘的一件事情。这件事情的来源可以是一个电话，可以是领导走过来交办的一件事情，当然也可以是头脑中突然闪现的一个念头&lt;/p&gt;

&lt;p&gt;!优先级 高、中、低&lt;br /&gt;
  !!! 重要度&lt;br /&gt;
  !!  紧急度&lt;br /&gt;
@情境contexts  情景是用来减少切换成本的 @Call @home @office @way&lt;/p&gt;

&lt;p&gt;&amp;amp;标签 TAGS&lt;br /&gt;
工作working 生活 学习Learning&lt;/p&gt;

&lt;p&gt;$目标 targets&lt;/p&gt;

&lt;p&gt;#项目projects&lt;br /&gt;
 多步骤的任务为项目&lt;/p&gt;

&lt;p&gt;项目-核查清单(核验单)&lt;br /&gt;
 项目-备忘录 Tickler File 记录对将来有帮助的项目[43个目录  12月 31日]&lt;/p&gt;

&lt;p&gt;^开始时间&lt;br /&gt;
  日程表中安排的内容是必须在某天或某点执行的，如果这些任务刚好属于当天，就会出现在“今日待办”中&lt;br /&gt;
  “今日待办”中空闲的那段时间去处理“下一步行动nextActions”中的任务&lt;br /&gt;
  1. 若是确定具体时间的任务，记录到自己的“今日待办”, “明日待办” , “日程agendas” 中；&lt;br /&gt;
  2. “将来/也许“ Someday/MAYBE” 若是需要着手但没有确定具体时间的，则可将此任务放在“择日待办Someday”&lt;br /&gt;
    将来/也许”的一层含义就是也许Maybe，可能做，也可能不做，还不确定。所以不用考虑太多，写下来就是了&lt;br /&gt;
  3. 等待waiting for 委托别人 [Follow 跟踪,追踪]&lt;/p&gt;

&lt;p&gt;%过滤&lt;br /&gt;
  参考资料&lt;/p&gt;

&lt;p&gt;~归档archiving&lt;br /&gt;
内部归档&lt;br /&gt;
内部归档是在本文件内部给特定子树打上 ACHIVED 标签或者移动到名为 ACHIVED 的子树中去并打上标签。这个被认为是 ACIVED 的子树，会被移动了本级子树的最末端。&lt;br /&gt;
C-c C-x a 将某一个节点打上ARCHIVE标签&lt;br /&gt;
C-c C-x A 将当前节点归入一个名为Archive的子树中&lt;br /&gt;
并且这个子树是位于当前级别子树的最下方&lt;/p&gt;

&lt;p&gt;外部归档&lt;br /&gt;
外部归档是指把子树移动到另一个org文件中去。文件名可以自定义。默认情况下，归档的子树会被移动到名为“当年文件名_archived”的文件中去。&lt;br /&gt;
C-c C-x C-s 把当前的节点移到archived文件中去。&lt;/p&gt;

&lt;p&gt;5.检查（Review） 回顾&lt;br /&gt;
周期任务 [仪式（Ritual）]&amp;ndash; 是指每天都在重复的任务，比如早上出门前要记得关窗灌煤气，晚上睡觉前要做腹部运动等等，我通常也将每天的晚间回顾Evening Review放在这里面。&lt;/p&gt;

&lt;h3 id=&#34;review&#34;&gt;Review&lt;/h3&gt;

&lt;p&gt;org-Agenda [C-c a|]&lt;/p&gt;

&lt;p&gt;看板中的列展示了某项工作处于工作流中的什么状态. 一般可以分成三个状态todo, doing, done workflow. 当然你也可以自定义自己的工作流状态.&lt;/p&gt;

&lt;p&gt;我使用看板系统有一阵子了,我现在将工作流分成5个阶段: planning, in progress, blocked, review, done&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;planning - 待组织的工作.  
in progress - 正在作的工作. 我尽可能的减少同时进行的工作以便能够快速的完成手头上的事情.  
blocked - 已经开始作的工作,但由于某些原因目前无法完成.  
review - 已经完成的工作. 但需要检查是否还有后续任务或需要总结.  
done - 任务已经彻底结束了,可以放松一下了.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小贴士：&lt;br /&gt;
  “今日待办” &amp;gt; “下一步行动” &amp;gt; “明日待办” &amp;gt; “日程agendas”&lt;br /&gt;
  如果你的“日程”箱子内容及时更新、非常可靠，而且你的“下一步行动”箱子也及时更新，&lt;br /&gt;
  那么你每天只要看这两样就行（在Doit.im中，因为“日程”中的任务到开始当天就会自动到“今日待办”，&lt;br /&gt;
  因此你每天只要看“今日待办”和“下一步行动”就行了——若“今日待办”的内容足够你做一天，就连“下一步行动”也不用看了。）&lt;/p&gt;

&lt;p&gt;5、小贴士&lt;/p&gt;

&lt;p&gt;“下一步行动NEXT”必须是不用额外思考步骤就执行的：&lt;br /&gt;
    正确：“美团查下周末有什么新电影，买票”&lt;br /&gt;
    错误：“周末去看电影”&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;capture&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;clarify&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;organize&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;reflect&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;engage&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;场景&#34;&gt;场景&lt;/h1&gt;

&lt;p&gt;生活”“公司”“学习&amp;rdquo;&lt;/p&gt;

&lt;p&gt;GTD中“下一步行动” VS “择日待办”的区别&lt;/p&gt;

&lt;p&gt;从意义上讲：&lt;/p&gt;

&lt;p&gt;“下一步行动/Next Actions”在英文版“Getting Things Done”中也叫“ASAP actions”，就是虽然没有具体时间规定，但要尽快去完成的任务；&lt;/p&gt;

&lt;p&gt;而“择日待办”就是那些你想到了可能以后要做，但不是那么重要（或者至少现在看来不是那么重要的），英文是Someday，就是说，“有朝一日”我要去做这个事情，所以GTD的作者曾说，你可以想想等你有钱了，你想干什么，然后把这个放到“择日待办”／“Someday”的箱子中。&lt;/p&gt;

&lt;p&gt;从处理整理的程度上讲：&lt;/p&gt;

&lt;p&gt;“下一步行动”都是已经经过处理、分析整理后，成为了具体可执行的那些任务；&lt;/p&gt;

&lt;p&gt;而“择日待办”的就不一定，很有可能你从收集箱你处理这个任务的时候，一看，哦，我“有朝一日”要这么做，但我现在还不去做它，那就不作分析细化了，直接扔到“择日待办”。然后，你每个礼拜都会去回顾查看一下这些任务（回顾过程我们在“回顾篇”文章中已经讲了），突然有一天，你决定要准备做这个事情了，那你再把它当成是刚从收集箱拿出来的一样，进行分析处理－组织整理（可能还因为它是多步骤任务都成了一个项目）。&lt;/p&gt;

&lt;h1 id=&#34;org-mode-gtd-常见问题&#34;&gt;Org Mode GTD 常见问题&lt;/h1&gt;

&lt;p&gt;Q：如何设置重复项目（例如习惯和重复的任务）？&lt;/p&gt;

&lt;p&gt;可以在时间戳内加如 +1d 、++1d/.+1d来使其可以每日循环，两者的差别是:+1d标记的事件如果有一天忘记做了，在agenda中依然会出现，而++1d/.+1d只会从你最后一次完成开始，之前没有做的都不再提示了。&lt;br /&gt;
更多内容可以在下面的链接里面找到。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://orgmode.org/manual/Repeated-tasks.html12&#34; target=&#34;_blank&#34;&gt;http://orgmode.org/manual/Repeated-tasks.html12&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Q：如何设置 Inbox？&lt;/p&gt;

&lt;p&gt;在使用单一文件的情况下，可以用下面的层级来设置 Inbox。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inbox&lt;br /&gt;
** TODO Task Number 01&lt;br /&gt;
** TODO Task Number 02&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Q：如何建立项目？&lt;/p&gt;

&lt;p&gt;单一文件可以用一个一级标题来做项目，再在其下做更多的代办事项即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Projects&lt;br /&gt;
** Project Name 01&lt;br /&gt;
*** TODO Task Number 01&lt;br /&gt;
*** TODO Task Number 02&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Q：如何在当前事项下设置子事项（Sub-tasks）？&lt;/p&gt;

&lt;p&gt;根据上面的方法，我们可以用下面的方法为已存在的事项添加子事项。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Projects&lt;br /&gt;
** Project Name 01&lt;br /&gt;
*** TODO Task Number 01&lt;br /&gt;
**** TODO Sub-task Number 01&lt;br /&gt;
**** TODO Sub-task Number 02&lt;br /&gt;
*** TODO Task Number 02&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Q：如何归档（Archive）已完成的事项？&lt;/p&gt;

&lt;p&gt;org-archive-subtree 可以用于归档意见完场的事项。快捷键是 C-c $。完成事项归档有钱拿，这样来记忆。&lt;/p&gt;

&lt;p&gt;Q：如何做每日、每周、每月的回顾？&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Q：如何快速改变事项的分组？&lt;/p&gt;

&lt;p&gt;C-c C-w 可以通过 org-refile 来快速改变当前内容所属层级。&lt;/p&gt;

&lt;p&gt;Q：如何添加场景（Context）？&lt;/p&gt;

&lt;p&gt;场景可以使用标签（Tag）来代替，C-c C-c 用于设置标题栏的标签。&lt;/p&gt;

&lt;p&gt;更多关于标签的内容可以再后面找到 &lt;a href=&#34;http://orgmode.org/manual/Tags.html。5&#34; target=&#34;_blank&#34;&gt;http://orgmode.org/manual/Tags.html。5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Q：如何进行事项的搜索？&lt;/p&gt;

&lt;p&gt;C-c a s 接着输入事项关键字即可完成搜索。&lt;/p&gt;

&lt;p&gt;Q：如何在 Agenda 视图中标记事项已完成？&lt;/p&gt;

&lt;p&gt;在 Agenda 视图中使用 t 来对选中的事项进行完成状态的改变。或者使用 C-u t 来直接输入事项的状态。&lt;/p&gt;

&lt;p&gt;Q：如何快速打开 GTD 文件查看待办事项？&lt;/p&gt;

&lt;p&gt;使用下面的快捷键可以快速打开 GTD 全部待办事项。&lt;/p&gt;

&lt;p&gt;(defun XYLayer/open-org-file()&lt;br /&gt;
    &amp;ldquo;Open ~/org/GTD.org file&amp;rdquo;&lt;br /&gt;
    (interactive)&lt;br /&gt;
    (find-file &amp;ldquo;~/org/GTD.org&amp;rdquo;))&lt;/p&gt;

&lt;p&gt;(global-set-key (kbd &amp;ldquo;&lt;f12&gt;&amp;rdquo;) &amp;lsquo;XYLayer/open-org-file)&lt;/p&gt;

&lt;p&gt;Q：如何改变事项的优先级？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S-&amp;lt;up&amp;gt; , org-priority-up  
S-&amp;lt;down&amp;gt;, org-priority-down  
C-c ,, org-priority  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;gtd&#34;&gt;GTD&lt;/h1&gt;

&lt;p&gt;一、模板的清单系统&lt;/p&gt;

&lt;p&gt;清单系统其实来自于 GTD (搞定)一书中的“组织”环节。通过对 ToDo List 的梳理，把所有事情妥当整理在相应清单下。这些清单彼此可以快速转化，又有非常强烈的互斥性，对“三多”人群有非常大的帮助。这里简单介绍下我的三个清单列表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;下一步行动清单  
等待清单  
未来/也许清单  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.下一步行动清单=动词+事件+关键人+截止日期&lt;br /&gt;
决定下一步行动只要 10 秒。&lt;/p&gt;

&lt;p&gt;当面对一个比较大的项目时，不断拆分下一步行动可以更好的明确行动方式，不至于被一个巨大任务压倒。当然，我们不见得每个步骤都会写下来，但是在梳理的时候，必定会标记简单的 1、2、3 步骤，帮助我们把大项目切割成可执行的一小块，然后一步步执行下来。这样可以很快减少你的压力和焦虑，让你专注在下一步行动的执行中。&lt;/p&gt;

&lt;p&gt;比如“开网店”这个任务，如果就这样放在清单中，不仅难以下手造成拖延，而且每次打开清单都会看到，反而形成了压力。那么，拆解后，将下一步行动变成：“了解（动词）开网店（事件）的流程并且明天（截止日期）向其他店主（关键人）咨询”，你就可以迅速的去行动了。&lt;/p&gt;

&lt;p&gt;当你在滴答清单里把“下一步行动”一个个勾掉的时候，那种由内而发提升起来的自我价值感，就噗噗噗地在你小心脏里快速地跳跃，真是好有自豪感，有木有！&lt;/p&gt;

&lt;p&gt;2.等待清单=关键人+事件+截止日期+更早日期提醒&lt;br /&gt;
“等待清单”的出现，就是把我们身上的猴子（比如项目/任务），快速处理后转移到其他人身上。放在“等待清单”的事情，不需要关心过程，只关心结果是不是想要的。&lt;/p&gt;

&lt;p&gt;当然，在大家的工作中，如果碰到一些有严重拖延症的同事，我建议设定一个“更早日期提醒”，这样可以帮助你了解目前任务的进度，并做到及时跟进。这样的做法，也帮助你及时跟相关领导报告任务卡顿在哪里，是否需要领导出面施压或是延长任务时间，而不是到最后 deadline 的时候，你没有时间整合处理，反而把猴子背在自己身上，产生巨大的压力和焦虑。&lt;/p&gt;

&lt;p&gt;比如“和笑笑去欧洲自由行”这个任务，当你把自己负责的行程确定好之后，就可以将任务转入“等待清单”，转化为“笑笑（关键人）预定好机票（事件），最迟11月25日要定好（截止日期）但是尽量10月25日前就预定（更早截止日期）”，这样处理之后，你就可以在 10 月 25 日询问笑笑机票的预订情况，确保不会买不到合适的机票导致旅游泡汤。&lt;/p&gt;

&lt;p&gt;在滴答清单中把一件事情处理完后，直接转入“等待清单”，能够更好地节约自己的时间成本。而且，当你看到自己的“下一步行动清单”已经清空，你就可以挥舞着小鞭子去督促其他人按时完成任务，那种感觉真是不要不要的！&lt;/p&gt;

&lt;p&gt;3.未来/也许清单=项目中产生+灵感创意+生活中触动&lt;br /&gt;
我经常发现非常火的一些App（比如“饿了吗”）推出后，就会听到一些人说，“其实这个想法我也想到过，就是被他抢先啊，真是太后悔了有木有，否则现在已经到 D 轮融资，来自阿里巴巴的 12.5 亿美元，那就发达了。”&lt;/p&gt;

&lt;p&gt;其实我相信，这样的故事并不陌生，两者的区别在于，有些人在有创意的时候，放入了清单系统中，然后天时地利人和的时候，把事情给办了。但是另外一些人就是嘴巴上说两句，然后…就没有然后了。所以即使上帝给到他再多的灵感，他不能进行收集，并进行持续性孵化，也终将一事无成。&lt;/p&gt;

&lt;p&gt;我们日常生活中经常会有很多想法冒出来，把这些都放入清单，不时看看这些清单，是不是有哪些事情可以实现？&lt;br /&gt;
二、个性化定制的清单系统&lt;/p&gt;

&lt;p&gt;进行自己的个性化定制，添加属于自己特有的清单列表，让你能够事半功倍地处理 ToDo List，从而走上时间管理的快车道。这里就是我跟大家分享我的三个个性化清单列表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;每天最重要的三件事  
套路/常规  
微习惯  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.每天最重要的三件事=重要性+紧急性+影响力&lt;br /&gt;
首先，时间管理不是帮助我们做更多的事情，而是让我们有足够多的空间去思考，去判断，去选择最重要的事情，然后把 80% 的时间、精力、金钱、能量对焦在最重要的三件事情上。&lt;/p&gt;

&lt;p&gt;什么是最重要的三件事呢？简单排序的话，就是重要性，紧急性和影响力。复杂一点，就是我们经常说 10000 小时的累积，如果你想要真正成为行业内的大咖，你就要经过10年的积累。&lt;/p&gt;

&lt;p&gt;比如我想要做培训师，就应该训练如下的能力：&lt;/p&gt;

&lt;p&gt;①快速学习能力，应对专业知识的快速迭代更新。&lt;br /&gt;
②敏锐的观察力，有利于收集素材，挖掘培训需求，反馈学员议题。&lt;br /&gt;
③一致性沟通能力，培训需求调查，学员互动反馈。&lt;br /&gt;
④项目管理能力，每次培训都是一个小的项目，需要多方协作，共同呈现。&lt;br /&gt;
……&lt;/p&gt;

&lt;p&gt;其实，我很喜欢滴答清单的一个原因是，我们可以单独建立一个清单，发到微信群中互动敦促。同时每周回顾的时候，当我打开「显示已完成」，可以直观的看到短期任务的重心是否围绕着中长期目标，从而不断淘汰无用和不重要的任务。&lt;/p&gt;

&lt;p&gt;2.套路/常规清单=固定时间+重复出现+模板制定&lt;br /&gt;
每次我跟学员确定一对一教练信息的时候，对方就会很惊讶，为什么我可以这么快确定具体信息，里面包含时间、地点、交通、地图，其实这个就是我教练的“老地方”，这样的模板这就是我们说的套路/常规。&lt;/p&gt;

&lt;p&gt;在固定的时间（比如每天，每周，每月，每季度或是每年）重复出现，而且内容大同小异，那么就说明这些任务有固定模板可寻，只要调整部分细节就可以。&lt;/p&gt;

&lt;p&gt;我的清单系统中，有 100+ 个套路/常规，也就是说，将近 500+ 事情的处理，可以交托在系统里，不用思考，只要按部就班执行即可。同时，可以通过这个迷你套路/常规系统的建立，为以后建立整体的时间管理，知识管理等系统打下扎实的基础。&lt;/p&gt;

&lt;p&gt;如果你想要节省更多的时间，同时避免在自己“情绪大姨夫”来临的时候犯常识性错误，就赶紧在滴答清单中设定自己的日常性的套路吧，比如购物套路，阅读套路，睡觉套路等等。&lt;/p&gt;

&lt;p&gt;3.微习惯清单=每天做5分钟+重复设置&lt;br /&gt;
当我们仔细查看的时候，会发现我们的一天是由一个个习惯堆积起来的，很多微习惯可能已经融入我们的骨血，不需要提醒，身体自带记忆，会自动化处理很多事情。&lt;/p&gt;

&lt;p&gt;有好的，当然也有坏的，比如拖延症，这就需要我们用一些好习惯去进行替代，而不是抹杀，面对这种情况，可以建立“微习惯清单”。同时滴答清单有「重复」设置，也就是你每天都可以看到完成情况。&lt;/p&gt;

&lt;p&gt;通过系统的建立，可以帮助大家更好地做好收集，真正做到“清空大脑，放入思考”。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Emacs org agenda</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-org-agenda/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-org-agenda/</guid>
            <description>&lt;p&gt;org-download-image-dir &amp;ldquo;~/Dropbox/org/statics&amp;rdquo;&lt;br /&gt;
org-download-image-html-width 600&lt;br /&gt;
dropbox-org-directory-path &amp;ldquo;~/Dropbox/org/notes&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;(setq org-directory &amp;ldquo;~/Dropbox/org&amp;rdquo;)&lt;br /&gt;
org-default-notes-file &amp;ldquo;~/Dropbox/org/Temp.org&amp;rdquo;&lt;/p&gt;

&lt;p&gt;(setq org-directory &amp;ldquo;~/Dropbox/org&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;org-agenda-files (find-lisp-find-files &amp;ldquo;~/Dropbox/org/&amp;rdquo; &amp;ldquo;.org$&amp;ldquo;)&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Emacs org capture的启用设定</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-org-capture/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-org-capture/</guid>
            <description>&lt;pre&gt;&lt;code&gt;(setq org-capture-templates  
      &#39;(  

        (&amp;quot;t&amp;quot; &amp;quot;Todo&amp;quot; entry (file+headline &amp;quot;gtd.org&amp;quot; &amp;quot;待办事项&amp;quot;)  
         &amp;quot;* TODO %?\n  %i\n&amp;quot;  
         :empty-lines 1)  

        (&amp;quot;x&amp;quot; &amp;quot;NEXT&amp;quot; entry (file+headline &amp;quot;gtd.org&amp;quot; &amp;quot;下一步行动&amp;quot;)  
         &amp;quot;* NEXT [#B] %?\n  %i\n&amp;quot;  
         :empty-lines 1)  
        (&amp;quot;m&amp;quot; &amp;quot;MAYBE&amp;quot; entry (file+headline &amp;quot;gtd.org&amp;quot; &amp;quot;将来/也许&amp;quot;) &amp;quot;* MAYBE [#C]  %?\n  %i\n&amp;quot; )  

        (&amp;quot;w&amp;quot; &amp;quot;WAITING&amp;quot; entry (file+headline &amp;quot;gtd.org&amp;quot; &amp;quot;等待waiting&amp;quot;)  
         &amp;quot;* WAITING [#A] %? %^G  %i\n %U&amp;quot;)  

        (&amp;quot;l&amp;quot; &amp;quot;待确定讨论 CheckList&amp;quot; checkitem  (file+headline &amp;quot;gtd.org&amp;quot; &amp;quot;待确定&amp;quot;) &amp;quot; [ ] %?\n\n&amp;quot; :prepend t :kill-buffer t)  

        ;; For capturing details of bills  
        (&amp;quot;z&amp;quot; &amp;quot;账单表格 Bill&amp;quot;      table-line (file+headline &amp;quot;gtd.org&amp;quot; &amp;quot;12月账单&amp;quot; ) &amp;quot;| %U | %^{people} | %^{物品} | %^{数量} | %^{价格}| &amp;quot; :prepend t :kill-buffer t)  
        (&amp;quot;k&amp;quot; &amp;quot;考勤清单 List&amp;quot;      item       (file+headline &amp;quot;gtd.org&amp;quot; &amp;quot;考勤&amp;quot;) &amp;quot; %? &amp;quot;)  
        (&amp;quot;j&amp;quot; &amp;quot;一句话备忘录   Journal&amp;quot;   entry      (file+datetree &amp;quot;journal.org&amp;quot;) &amp;quot;*  %?&amp;quot;)  
        (&amp;quot;s&amp;quot; &amp;quot;Code Snippet&amp;quot;      entry      (file &amp;quot;snippets.org&amp;quot;) &amp;quot;* %?\t%^g\n#+BEGIN_SRC %^{language}\n\n#+END_SRC&amp;quot;)  

        (&amp;quot;n&amp;quot; &amp;quot;笔记&amp;quot; entry (file+headline &amp;quot;notes.org&amp;quot; &amp;quot;Quick notes&amp;quot;)  
         &amp;quot;* %?\n %i\n %x\n %u\n&amp;quot;  
         :clock-in t)  

        ;; To capture ideas for my blog  
        (&amp;quot;b&amp;quot;                                  ; key  
         &amp;quot;Blog&amp;quot;                               ; name  
         entry                                ; type  
         (file+headline &amp;quot;notes.org&amp;quot; &amp;quot;Blog&amp;quot;)   ; target  
         &amp;quot;* %^{Title} :blog:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?&amp;quot; ; template  
         :prepend t                 ; properties  
         :empty-lines 1             ; properties  
         :created t                 ; properties  
         :kill-buffer t)            ; properties  

        (&amp;quot;l&amp;quot; &amp;quot;links&amp;quot; entry (file+headline &amp;quot;~/org-notes/notes.org&amp;quot; &amp;quot;Quick notes&amp;quot;)  
         &amp;quot;* TODO [#C] %?\n  %i\n %a \n %U&amp;quot;  
         :empty-lines 1)))  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(setq org-capture-templates&lt;br /&gt;
(quote&lt;br /&gt;
(&lt;br /&gt;
(&amp;ldquo;l&amp;rdquo; &amp;ldquo;Later&amp;rdquo; checkitem (file+headline &amp;ldquo;scratch.org&amp;rdquo; &amp;ldquo;later&amp;rdquo;) &amp;ldquo; [ ] %?\n\n&amp;rdquo; :prepend t :kill-buffer t)&lt;br /&gt;
 )))&lt;/p&gt;

&lt;p&gt;;; 账单&lt;br /&gt;
(&amp;ldquo;a&amp;rdquo; &amp;ldquo;Account&amp;rdquo; table-line  (file+headline &amp;ldquo;account.org&amp;rdquo; &amp;ldquo;Web accounts&amp;rdquo;) &amp;ldquo;| %? | | %a | %U |&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;Instead of using %(org-set-tags) in the template, use %^g&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-https://sriramkswamy.github.io/dotemacs/&#34;&gt;(setq org-capture-templates &#39;(  
        ;; For code snippets  
        (&amp;quot;a&amp;quot;               ; key  
         &amp;quot;Algo/Code&amp;quot;       ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/notes.org&amp;quot; &amp;quot;Code&amp;quot;)  ; target  
         &amp;quot;* %^{TITLE} %(org-set-tags)  :code:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\#+BEGIN_SRC %^{language}\n%?\n\#END_SRC&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; For taking notes on random things  
        (&amp;quot;n&amp;quot;               ; key  
         &amp;quot;Note&amp;quot;            ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/notes.org&amp;quot; &amp;quot;Notes&amp;quot;)  ; target  
         &amp;quot;* %? %(org-set-tags)  :note:\n:PROPERTIES:\n:Created: %U\n:Linked: %A\n:END:\n%i&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; Ledger is a CLI accounting system  
        (&amp;quot;l&amp;quot;               ; key  
         &amp;quot;Ledger&amp;quot;          ; name  
         entry             ; type  
         (file+datetree &amp;quot;~/Dropbox/org/ledger.org&amp;quot; &amp;quot;Ledger&amp;quot;)  ; target  
         &amp;quot;* %^{expense} %(org-set-tags)  :accounts:\n:PROPERTIES:\n:Created: %U\n:END:\n%i  
#+NAME: %\\1-%t  
\#+BEGIN_SRC ledger :noweb yes  
%^{Date of expense (yyyy/mm/dd)} %^{&#39;*&#39; if cleared, else blank} %\\1  
    %^{Account name}                                $%^{Amount}  
    %?  
\#+END_SRC  
&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; For notes or something regarding more work  
        (&amp;quot;w&amp;quot;               ; key  
         &amp;quot;Work&amp;quot;            ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/phd.org&amp;quot; &amp;quot;Work&amp;quot;)  ; target  
         &amp;quot;* TODO %^{Todo} %(org-set-tags)  :work:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; For capturing some things that are worth reading  
        (&amp;quot;r&amp;quot;               ; key  
         &amp;quot;Reading&amp;quot;         ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/fun.org&amp;quot; &amp;quot;Reading&amp;quot;)  ; target  
         &amp;quot;* %^{Title} %(org-set-tags)\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; For capturing minutes of the meeting  
        (&amp;quot;m&amp;quot;               ; key  
         &amp;quot;Meeting&amp;quot;         ; name  
         entry             ; type  
         (file+datetree &amp;quot;~/Dropbox/org/phd.org&amp;quot; &amp;quot;Meeting&amp;quot;)  ; target  
         &amp;quot;* %^{Title} %(org-set-tags)  :meeting:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n** Agenda:\n%?\n\n** Minutes of the meeting:\n&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; To practice for my driving test  
        (&amp;quot;d&amp;quot;               ; key  
         &amp;quot;Drill driving&amp;quot;   ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/drill.org&amp;quot; &amp;quot;Driving&amp;quot;)  ; target  
         &amp;quot;* Question  :drill:driving:\n%^{Question}\n** Answer\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; For taking notes of math/stats stuff that I keep forgetting  
        (&amp;quot;s&amp;quot;              ; key  
         &amp;quot;Drill math&amp;quot;     ; name  
         entry            ; type  
         (file+headline &amp;quot;~/Dropbox/org/drill.org&amp;quot; &amp;quot;Stats/Math&amp;quot;)  ; target  
         &amp;quot;* Question  :drill:stats:math:\n%^{Question}\n** Answer\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; For capturing some physics concepts that I need to remember  
        (&amp;quot;p&amp;quot;              ; key  
         &amp;quot;Drill physics&amp;quot;  ; name  
         entry            ; type  
         (file+headline &amp;quot;~/Dropbox/org/drill.org&amp;quot; &amp;quot;Physics&amp;quot;)  ; target  
         &amp;quot;* Question  :drill:physics:\n%^{Question}\n** Answer\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; For capturing details of a job application/details  
        (&amp;quot;j&amp;quot;                      ; key  
         &amp;quot;Jobs&amp;quot;                   ; name  
         table-line               ; type  
         (file+headline &amp;quot;~/Dropbox/org/notes.org&amp;quot; &amp;quot;Jobs&amp;quot;)  ; target  
         &amp;quot;| %u | %^{Company} | [[%^{job link}][%^{position}]] | %^{referrals?} | %^{Experience?} | %^t | %^{Status} | %^{Follow up} | %^{Result} |&amp;quot;  ; template  
         :prepend t               ; properties  
         ;; :table-line-pos &amp;quot;II-3&amp;quot;   ; properties  
         :empty-lines 1           ; properties  
         :created t               ; properties  
         :kill-buffer t)          ; properties  

        ;; To capture movies that I plan to see  
        (&amp;quot;f&amp;quot;              ; key  
         &amp;quot;films&amp;quot;          ; name  
         entry            ; type  
         (file+headline &amp;quot;~/Dropbox/org/fun.org&amp;quot; &amp;quot;Movies&amp;quot;)  ; target  
         &amp;quot;* %^{Movie} %(org-set-tags)  :film:\n:PROPERTIES:\n:Created: %U\n:END:\n%i  
Netflix?: %^{netflix? Yes/No}\nGenre: %^{genre}\nDescription:\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; To capture ideas for my blog  
        (&amp;quot;b&amp;quot;               ; key  
         &amp;quot;Blog&amp;quot;            ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/blog.org&amp;quot; &amp;quot;Blog&amp;quot;)  ; target  
         &amp;quot;* %^{Title} %(org-set-tags)  :blog:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; To capture tons of errands  
        (&amp;quot;e&amp;quot;               ; key  
         &amp;quot;Errands&amp;quot;         ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/errands.org&amp;quot; &amp;quot;Errands&amp;quot;)  ; target  
         &amp;quot;* TODO %^{Todo} %(org-set-tags)  :errands:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t)   ; properties  

        ;; To capture things regarding my course  
        (&amp;quot;c&amp;quot;               ; key  
         &amp;quot;Courses&amp;quot;         ; name  
         entry             ; type  
         (file+headline &amp;quot;~/Dropbox/org/phd.org&amp;quot; &amp;quot;Courses&amp;quot;)  ; target  
         &amp;quot;* %^{Course} %(org-set-tags)  :courses:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?&amp;quot;  ; template  
         :prepend t        ; properties  
         :empty-lines 1    ; properties  
         :created t        ; properties  
         :kill-buffer t))) ; properties  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;;; %[file]     插入文件&lt;br /&gt;
;; %(sexp)     插入 sexp 的返回值，sexp 必须返回字符串&lt;br /&gt;
;; %&amp;lt;&amp;hellip;&amp;gt;      插入时间戳信息&lt;br /&gt;
;; %t          插入日期&lt;br /&gt;
;; %T          插入日期与时间&lt;br /&gt;
;; %u, %U      同上，但时间戳用 [] 括起来&lt;br /&gt;
;; %i          调用 capture 命令时有选中的内容则插入选中的内容&lt;br /&gt;
;; %a          注记，通常是 org-store-link 创建的链接&lt;br /&gt;
;; %A          类似 %a，但提示输入链接的描述&lt;br /&gt;
;; %l          类似 %a，但仅插入文本链接&lt;br /&gt;
;; %c          当前 kill-ring 中的内容&lt;br /&gt;
;; %x          粘贴板的内容&lt;br /&gt;
;; %k          当前计时任务标题&lt;br /&gt;
;; %K          当前计时任务链接&lt;br /&gt;
;; %n          用户名，变量 user-full-name&lt;br /&gt;
;; %f          capture 命令调用时当前 buffer 对应文件名&lt;br /&gt;
;; %F          类似 %f，但显示全路径&lt;br /&gt;
;; %:keyword   Specific information for certain link types, see below.&lt;br /&gt;
;; %^g         提示输入 tag，target file 中的列表作为可选项&lt;br /&gt;
;; %^G         类似 %^g，但是有 agenda 中所有注册的文件中的 tag 作为可选项&lt;br /&gt;
;; %^t         类似 %t,但提示手动输入日期，类似还有 %^T， %^u， %^U                 You may define a prompt like %^{Birthday}t.&lt;br /&gt;
;; %^C         提示插入哪个 kill-ring 的内容&lt;br /&gt;
;; %^L         类似 %^C，但插入为链接&lt;br /&gt;
;; %^{prop}p   Prompt the user for a value for property prop.&lt;br /&gt;
;; %^{prompt}  prompt the user for a string and replace this sequence with it.&lt;br /&gt;
;;             You may specify a default value and a completion table with&lt;br /&gt;
;;             %^{prompt|default|completion2|completion3&amp;hellip;}.&lt;br /&gt;
;;             The arrow keys access a prompt-specific history.&lt;br /&gt;
;; %\n         Insert the text entered at the nth %^{prompt}, where n is&lt;br /&gt;
;;             a number, starting from 1.&lt;br /&gt;
;; %?          After completing the template, position cursor here.&lt;/p&gt;

&lt;p&gt;;; properties&lt;br /&gt;
      ;; :prepend 通常情况下,新捕获的内容会附加在target location的后面,而该属性会添加在target location的前面&lt;br /&gt;
      ;; :immediate-finish 该属性表示不需要显示capture buffer给用户输入更多的信息.直接返回就好. 若所有的信息都能够通过模板变量自动获得的情况下可以使用&lt;br /&gt;
      ;; :empty-lines 插入新捕获的内容时,前后空出多少个空行.&lt;br /&gt;
      ;; :clock-in 为新捕获的item开始计时&lt;br /&gt;
      ;; :clock-keep 若设置了clock-in,则在capture动作完成后,依然保持计时器的继续运行&lt;br /&gt;
      ;; :clock-resume&lt;br /&gt;
      ;; 若capture操作中断了对之前任务的计时,则在完成capture操作之后继续对之前任务进行计时.&lt;br /&gt;
      ;; 需要注意的是,:clock-keep的优先级高于:clock-resume,若两者都设置为t,则当前计时器会启动,而前一个计时器不会继续运行.&lt;br /&gt;
      ;; :unnarrowed 不要narrow target buffer,显示target buffer的所有内容. 默认情况下会narrow target buffer,让它只显示捕获新事物的那节点内容&lt;br /&gt;
      ;; :table-line-pos 设置capture的内容插入到table的位置. 它的格式类似于”II-3”,表示它是表格中第二部分(以——-分隔)的第三行&lt;br /&gt;
      ;; :kill-buffer 若target file是未打开的状态,则在capture完成之后,自动kill掉新打开的buffer&lt;/p&gt;

&lt;p&gt;Emacs的配置&lt;br /&gt;
org capture的启用设定&lt;/p&gt;

&lt;p&gt;在emacs的启动配置文件中，使用如下代码完成org capture的启用。&lt;/p&gt;

&lt;p&gt;(setq org-default-notes-file (concat org-directory &amp;ldquo;~/notes.org&amp;rdquo;))&lt;br /&gt;
(define-key global-map &amp;ldquo;\C-cc&amp;rdquo; &amp;lsquo;org-capture)&lt;/p&gt;

&lt;p&gt;代码解释如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(setq org-default-notes-file (concat org-directory &amp;quot;~/notes.org&amp;quot;))  
设定默认的片段存放文件名为Home目录中的“notes.org”文件。在Windows中“~/notes.org”也可以写做“d:/home/notes.org”  

(define-key global-map &amp;quot;\C-cc&amp;quot; &#39;org-capture)  
使用组合键“Ctrl-c c”激活org capture功能。当然，如果使用“Alt-x”组合键后输入 org-capture &amp;lt;enter&amp;gt; 也可以达到同样的目的。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置模板&lt;/p&gt;

&lt;p&gt;利用我们上面介绍的内容，我们可以开始定义我们要用到的模板信息：&lt;/p&gt;

&lt;p&gt;(setq org-capture-templates&lt;br /&gt;
   &amp;lsquo;((&amp;ldquo;l&amp;rdquo; &amp;ldquo;灵感&amp;rdquo; entry (file+headline &amp;ldquo;~/写作创意.org&amp;rdquo; &amp;ldquo;创意&amp;rdquo;)&lt;br /&gt;
          &amp;ldquo;* %?\n  %i\n  %a&amp;rdquo;)&lt;br /&gt;
     (&amp;ldquo;j&amp;rdquo; &amp;ldquo;Journal&amp;rdquo; entry (file+datetree &amp;ldquo;~/journal.org&amp;rdquo;)&lt;br /&gt;
          &amp;ldquo;* %?\n输入于： %U\n  %i\n  %a&amp;rdquo;)))&lt;br /&gt;
          Capture的模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      在Capture的基本使用流程之中，我们提到了一个名词“模板”。什么是模板？  

      我们来试着定义一下，所谓的模板是：  

          一个记录事件的加速系统，通过简单的几个按键就可以定位到一个具体的记录类别  
          一个快速记录事件的框架，类似网站的表单，通些必要的字段即可完成事件记录。  
          一个归档位置的快速定义，不同类别的记录可以按设定记录在不同的文件里，方便查询。  

      一个有效的模板由以下几个部分组成：  

          快捷键 - keys  
          用于在列表中快速选择模板。支持单个字符。嗯，多个字符的快捷键有待进一步研究。  
          描述 - description  
          简单的描述模板的用途。这部分设定会出现在选择模板的过程中  

          类型 - type  
          模板的种类。目前支持的取值为：  
              entry  
              Org Mode的标题节点。使用中须指定Org文件的名称  
              item  
              一个简单列表中的项目。同样，这个类型的模板最终需要存储在org文件中。  
              checkitem  
              一个带有checkbox的项目。与item类型的模板相比，多了一个checkbox。  
              table-line  
              在指定位置表格添加一行新的记录。  
              plain  
              一段文字。如何输入的，就如何记录下来。  

          注：org文件：扩展名为org的文本文件。遵循org mode定义的各类文本文件编写规则。目前Emacs对org mode的支持最好（org mode就是在emacs中用elisp编写开发的）。  

          目标 - target  
          用于定义收集得到的文字片段在文件的存储方式。一般来说，目标文件为一个org文件。收集得到的相关内容也会记录到相应的标题之下。最常用的target是：  

              指定文件名和文件中唯一的标题  

              (file+headline &amp;quot;path/to/file&amp;quot; &amp;quot;node headline&amp;quot;)  

              指定文件名和完整的标题路径（如果需要存放片段的标题不唯一）  

              (file+olp &amp;quot;path/to/file&amp;quot; &amp;quot;Level 1 heading&amp;quot; &amp;quot;Level 2&amp;quot; ...)  

              指定日期方式的标题路径，在今天的日期下添加片段  

              (file+datetree &amp;quot;path/to/file&amp;quot;)  

              4.3 预定义tag  

              上面提到，除了可以输入标签外，还可以从预定义的标签中进行选择。预定义的方式有两种：  

                  在当前文件头部定义  

                  这种方式预定义的标签只能在当前文件中使用。使用#+TAGS元数据进行标记，如：  

                      #+TAGS: { 桌面(d) 服务器(s) }  编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)  

                  每项之间必须用空格分隔，可以在括号中定义一个快捷键；花括号里的为标签组，只能选择一个  

                  对标签定义进行修改后，要在标签定义的位置按 C-c C-c 刷新才能生效。  
                  在配置文件中定义 上面的标签定义只能在当前文件生效，如果要在所有的.org 文件中生效，需要在 Emacs 配置文件 .emacs 中进行定义：  
                  (setq org-tag-alist &#39;(  

                                      (:startgroup . nil)  
                                           (&amp;quot;桌面&amp;quot; . ?d) (&amp;quot;服务器&amp;quot; . ?s)  
                                      (:endgroup . nil)  
                                      (&amp;quot;编辑器&amp;quot; . ?e)  
                                      (&amp;quot;浏览器&amp;quot; . ?f)  
                                      (&amp;quot;多媒体&amp;quot; . ?m)  
                                      ))  

              默认情况下，org会动态维护一个Tag列表，即当前输入的标签若不在列表中，则自动加入列表以供下次补齐使用。  

              为了使这几种情况（默认列表、文件预设tags，全局预设tags）同时生效，需要在文件中增加一个空的TAGS定义：  

                  #+TAGS:  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Emacs笔记</title>
            <link>//blog.pytool.com/edit/2015-11-09-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91emacs-notes/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-11-09-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91emacs-notes/</guid>
            <description>

&lt;h1 id=&#34;1-关于emacs&#34;&gt;1. 关于Emacs #&lt;/h1&gt;

&lt;p&gt;EMacs 是一个 Lisp 解释器，是 Elisp Macros 的缩写。用 /高德纳/ 的话讲，用&lt;br /&gt;
EMacs 按键就像弹琴。没错，使用Emacs，你经常需要按 Esc + Meta + Alt +&lt;br /&gt;
Control + Shift，所以叫 &lt;em&gt;Emacs&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;一些约定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-x 表示同时按住Ctrl和x，M-x 表示先按Esc再按x，或者按住Alt的时候按x。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x v l表示同时按住Ctrl和x后，松开Ctrl再依次按v和l。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-f表示按住Ctrl同是分别按x和f。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;键序列是大小写敏感的。如果你的键序列输入一半，你又改变了注意，可以按&lt;br /&gt;
C-g 或者 Esc Esc Esc，取消键入的命令。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;good-reference&#34;&gt;Good reference ##&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.emacswiki.org&#34; target=&#34;_blank&#34;&gt;EmacsWiki&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zybuluo.com/mdeditor&#34; target=&#34;_blank&#34;&gt;CmdMarkdown&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sachachua.com/blog/&#34; target=&#34;_blank&#34;&gt;sacha chua, an awsome girl&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;2-启动emacs时的选项&#34;&gt;2. 启动Emacs时的选项 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;-nw 在终端下启动emacs，不使用gui。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-q 不读取 =.emacs= 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-Q 不仅不读取 =.emacs= ，也略过 site-lisp 。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;3-用户界面&#34;&gt;3. 用户界面 #&lt;/h1&gt;

&lt;p&gt;如果你在终端使用Emacs, 用 (M-&lt;code&gt;) 或者 (ESC,&lt;/code&gt;) 可以方便的使用菜单.&lt;br /&gt;
在图形界面下同样可以试试啊.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;状态栏上的标记：（把鼠标放在状态栏上在 MiniBuffer 上会出现说明）&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash; 表明缓冲区的内容和磁盘上的一致。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;** 表明文件被修改了，还没保存。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;%% 表明文件是只读的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;%* 表明文件是写保护的，但是已经被修改了。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;M-x menu-bar-mode能显示和隐藏菜单。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x tool-bar-mode能显示和隐藏工具栏。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x hl-line-mode 打开高亮当前行模式。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x set-background-color      设置背景色。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x set-foreground-color      设置前景色。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x set-cursor-color          设置光标颜色。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gtk版emacs设置widget外观&#34;&gt;gtk版Emacs设置Widget外观 ##&lt;/h2&gt;

&lt;p&gt;当我们使用 xlib 版的Emacs时，可以通过 XResource 定义 Emacs 的菜单&lt;br /&gt;
栏、工具条、滚动条的外观。&lt;/p&gt;

&lt;p&gt;现在，在Linux上我们大多使用 gtk版的Emacs，是否还有办法定义 Emacs&lt;br /&gt;
的菜单栏、工具条等的外观？&lt;/p&gt;

&lt;p&gt;一种方法是，通过 ~/.gtkrc 定义全局的 Gtk Widget 的外观。Emacs的外&lt;br /&gt;
观自然也会改变。&lt;/p&gt;

&lt;p&gt;另一种方法是单独定制 emacs 的 Gtk Widget的外观。&lt;br /&gt;
&lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/emacs/GTK-resources.html&#34; target=&#34;_blank&#34;&gt;http://www.gnu.org/software/emacs/manual/html_node/emacs/GTK-resources.html&lt;/a&gt;&lt;br /&gt;
讲述了 emacs 的资源名，以及如何定制。&lt;/p&gt;

&lt;p&gt;下面我们改变 Emacs 菜单栏的字体。&lt;br /&gt;
在 ~/.emacs.d/ 下新建 &lt;code&gt;gtkrc&lt;/code&gt; 文件。&lt;br /&gt;
内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;style &amp;quot;emacs-menu&amp;quot;  
{  
  font_name = &amp;quot;monospace 10&amp;quot;  
  bg[NORMAL] = &amp;quot;gray70&amp;quot;  
  bg[ACTIVE] = &amp;quot;gray75&amp;quot;  
  fg[NORMAL] = {0.0, 0.2, 0.05}  
}  

widget &amp;quot;*menubar*&amp;quot; style &amp;quot;emacs-menu&amp;quot;  
widget &amp;quot;*emacs-menuitem*&amp;quot; style &amp;quot;emacs-menu&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在重启 Emacs 看看，菜单栏是不是变样了？&lt;/p&gt;

&lt;h1 id=&#34;4-与文件有关的操作&#34;&gt;4. 与文件有关的操作 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;C-x C-f    查找文件并且在新缓冲区中打开。&lt;br /&gt;
当打开文件时，提示的路径可能不是你想要的，你可以输入 =//= ，&lt;br /&gt;
则提示的路径变为 =/= 。你也可以输入 =/~/= ，&lt;br /&gt;
则提示的路径变为 =~/= 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-r 以只读方式打开文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-v    读入另一个文件，覆盖当前缓冲区的内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x i      把文件插入到光标的当前位置&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-s    保存文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-w    把缓冲区内容写入一个文件（另存为）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-c    退出Emacs&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;5-光标移动&#34;&gt;5. 光标移动 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;C-f     光标前移一个字符（右）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-b     光标后移一个字符（左）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-p     光标前移一行（上）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-n     光标后移一行（下）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-f (C-Right)    前移一个单词，也可以用C-&lt;right&gt;或M-&lt;right&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-b (C-Left)    后移一个单词，也可以用C-&lt;left&gt;或M-&lt;left&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-r     循环移动到窗口中间,窗口顶端,窗口底端&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-a     移动到行首&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-e     移动到行尾&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-m     移动到第一个非空格字符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-e     前移一个句子&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-a     后移一个句子&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-}     前移一个段落&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-{     后移一个段落&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-v: scroll-up, 屏幕上卷一屏, 如果加参数N, 向上滚动N行. 如果N是&lt;br /&gt;
负数, 则相当于 C-u -N M-v.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-v: scroll-down, 屏幕下卷一屏.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x &amp;gt;: scroll-left. This command is disabled by default.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x &amp;lt;: scroll-right. 加参数N可以指定滚动N列。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x ]    前移一页（页由Ctrl+L分割，C-q C-l 可以插入一个分页符）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x [    后移一页&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-&amp;lt; (C-Home) 移动光标到文档开头，其实可以加参数2-9，将光标移到距开头&lt;br /&gt;
0.2-0.9处，如M-5 M-&amp;lt; 将光标定位到文档50%处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-&amp;gt; (C-End)    后移到文件尾&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-l: recenter-top-bottom. 重新绘制屏幕，当前行放在画面中心, 继续&lt;br /&gt;
调用该函数, 会把当前行放在窗口顶端, 然后是底端, 再然后又是中间.&lt;br /&gt;
在Emacs 23之前的版本中, C-l 只是绑定到 recenter. 是否重新绘制屏&lt;br /&gt;
幕受变量 recenter-redisplay的影响, 如果该变量值是 nil, 则始终不&lt;br /&gt;
重绘屏幕. 默认值是 &lt;code&gt;tty&lt;/code&gt;, 表示只有在终端中才重绘屏幕.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-u n C-l: 将当前行滚动到距屏幕顶端第n行的位置，所以C-u 0 C-l，&lt;br /&gt;
将当前行移动到屏幕顶部。当然C-0 C-l或M-0 C-l也能实现同样的功能。&lt;br /&gt;
C-u C-l把当前行滚动到屏幕中间, 如果参数是负数, 则把当前行滚动到&lt;br /&gt;
距屏幕底部第n行的位置.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-l: reposition-window, 主要针对lisp文件, 尽量让定义或注释完全&lt;br /&gt;
可见. 例如, 如果函数定义不完全可见, 尽可能使整个函数可见. 如果函&lt;br /&gt;
数完全可见, 则将之滚动到屏幕顶端.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-o open-line, 插入空行, 如果光标在行首, 则在当前行上方插入空行;&lt;br /&gt;
如果光标在行尾, 则在当前行下方插入空行；如果光标在行中央, 则分割&lt;br /&gt;
当前行.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-o 把多个空行合并成一个空行, 如果只有一个空行, 则删除这个空行.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x flush-lines RET ^$ 删除选中区域的所有空行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x goto-line 到文件第N行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x goto-char 到文件第N个字节。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;6-删除剪切与复制&#34;&gt;6. 删除剪切与复制 #&lt;/h1&gt;

&lt;p&gt;和vim相同，所有删除都是剪切操作。&lt;/p&gt;

&lt;p&gt;在 EMACS 中所谓的 kill-ring 是指一个存放从文件缓冲区中删除和&lt;br /&gt;
复制的文本的地方。文本在缓冲区中是消失了， 但却储存在kill-ring。&lt;br /&gt;
EMACS 可以有许多的缓冲区，但却只有一个 kill-ring。&lt;br /&gt;
EMACS 所设计共享的 killing-ring 的用意是让被遗弃的文件可以找回， 而且各&lt;br /&gt;
缓冲区彼此也可借由killing-ring 来建立一个互通的管道。&lt;br /&gt;
因此，想将甲缓冲区中的某些文本给乙缓冲区，只要将那些文本放&lt;br /&gt;
入 kill-ring 中，乙缓冲区就可以至此共享的 kill-ring 中将文本取出。&lt;/p&gt;

&lt;p&gt;要查看kill-ring中的内容， 键入 =Ctrl-h v= 后，echo area 处会出现提示：输入&lt;br /&gt;
&amp;ldquo;kill-ring&amp;rdquo;， Emacs 会另开一个 视窗来显示 kill-ring的值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-d或Del     删除光标位置上的字符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;BACKSPACE    删除光标位置上的字&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-d          删除光标后面的单词&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-DEL        删除光标前面的单词&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-k          从光标位置删除到行尾&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-S-BACKSPACE  不管光标位置在哪, 删除当前整行的内容 (kill-whole-line)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-k          删除到句子结尾&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x &lt;DEL&gt;    删除光标前面的句子&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-k   删除point后面的sexp, kill-sexp.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-w     删除选中的文件块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-w   append-next-kill, 下一次kill的内容会追加到kill-ring中最新的entry.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-w     复制选中的文件块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-y 在当前位置粘贴剪贴板的内容, point在后，mark在开始处。C-u&lt;br /&gt;
C-y会使得point在前，mark在结束处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-y M-y   即如果在粘贴命令后根一个M-y，则切换到剪贴板中前一个内容，&lt;br /&gt;
可以有多个M-y。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;按下M-x后在辅助输入区中输入&amp;rdquo;kill-paragraph&amp;rdquo;删除光标后面的段落，&lt;br /&gt;
按下&amp;rdquo;backward-kill-paragraph&amp;rdquo;删除光标前面的段落&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-z CHAR 剪切到当前行指定的字符CHAR, 包括CHAR在内。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;7-标记&#34;&gt;7. 标记 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;C-@  标记文本块的开始（或结束）位置，&lt;br /&gt;
如果你的不是用C-SPC激活输入法，用C-SPC也可以开始标记。&lt;br /&gt;
或者M-x set-mark-command。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-@       从光标所在位置开始，标记到一个单词的末尾。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-@     在point后的表达式(如被括号包围的文本)的结尾设置标记.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-h     标记段落, 将 point 移到段首, 在段末设定标记.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-h 标记函数(mark-defun), 将 point 移到函数开头, 在函数末尾设&lt;br /&gt;
定标记.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-x 交换当前插入点和上一个marker的位置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-p    标记页面, point 在页开始的地方, 在页结束的地方设定标记.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x h    标记整个缓冲区&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-h 标记一段, 重复按M-h会继续标记后面的段落. 可以加前缀参数, 如&lt;br /&gt;
C-u M-h, 会标记从当前段开始的后续四段. C-u -2 M-h 会标记从&lt;br /&gt;
point 向上的两段.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果用鼠标标记一个区域(鼠标左键拖动, 鼠标右键单击), 会自动将选定&lt;br /&gt;
的区域复制到kill-ring中.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-=, M-x count-words-region 会显示选中的区域中有多少行，多少词，多少个字符。&lt;br /&gt;
（注意，一个汉字也只算一个字符哦）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;可以应用于-region-的操作&#34;&gt;可以应用于 region 的操作: ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-%: query-replace.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x &lt;TAB&gt; 或 C-M-\ 缩进.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x eval-region.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r s 将选定的内容copy到register中 (copy-to-register). 你可以&lt;br /&gt;
用 M-x append-to-register 向register中添加内容. C-x r i 将指定&lt;br /&gt;
register的内容插入到当前位置.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-$: ispell-region&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x delete-selection-mode. 开启这个模式后, 如果有选定的文本, 在&lt;br /&gt;
你输入文本时会自动删除选定的文本.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mark-ring&#34;&gt;mark ring ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;mark的位置存储在mark ring中, 默认可以存储16个mark的位置. 你可以&lt;br /&gt;
通过设置 =mark-ring-max= 来改变这个值. 每个buffer都有自己的&lt;br /&gt;
mark ring.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用mark在文档中跳转的方法, C-SPC C-SPC在当前位置做一个标记, 然&lt;br /&gt;
后通过 C-u C-SPC可以回到做标记的地方. 如果&lt;br /&gt;
&lt;code&gt;set-mark-command-repeat-pop&lt;/code&gt; 的值不是 nil, 则C-u C-SPC后就可&lt;br /&gt;
以继续按C-SPC回到以前的标记位置.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Emacs也有一个全局的 mark-ring, 每当你激活一个标记, 在存入当前&lt;br /&gt;
buffer的mark-ring的同时, 也存入global-mark-ring. &lt;em&gt;C-x C-SPC&lt;/em&gt; 可&lt;br /&gt;
以跳回到global-mark-ring中上一个mark所在的buffer和位置.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;收集分散的文本&#34;&gt;收集分散的文本 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-x append-to-buffer 将选定的文本追加到指定buffer的光标处，光标&lt;br /&gt;
放在追加文本的末尾.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x prepend-to-buffer 也是将选定的文本追加到指定的buffer处，光标&lt;br /&gt;
放在追加文本的开始处.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x copy-to-buffer 用选定的文本替换 指定buffer 中原有的文本.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x insert-buffer 将指定的 buffer 插入到光标处，光标放置于插入的&lt;br /&gt;
内容之前，并在插入内容的末尾放置标记. 比如你用 append-to-buffer&lt;br /&gt;
累积了一些文本到 buffer1 中，可以再用 insert-buffer buffer1 将累&lt;br /&gt;
积的文本取回来.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M-x append-to-file&lt;/em&gt; 将选定的文本追加到指定文件的末尾.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;8-寄存器-registers&#34;&gt;8. 寄存器 Registers #&lt;/h1&gt;

&lt;p&gt;寄存器可以存储 mark或point的位置, 文本, 矩形区域内的文本, 窗口配置, 文件名等.&lt;/p&gt;

&lt;p&gt;寄存器的名字可以是一个字母(区分大小写), 也可以是一个数字或者其它字符.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;M-x view-register R: 查看寄存器中R存放的内容.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r &lt;SPC&gt; R: point-to-register, 把point在哪个buffer什么位置的&lt;br /&gt;
信息记录下来.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r j R: jump-to-register, 跳转到寄存器R记录的位置. 如果缓冲区&lt;br /&gt;
已经关闭, Emacs会问你是否重新加载.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r s R: 复制region内的内容到R中. C-u C-x r s R, 在将region复&lt;br /&gt;
制到R中后从buffer中删除.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r i R: 将R中的内容插入到当前位置. Point在插入的文本前, mark&lt;br /&gt;
在插入的文本后. 以C-u引导则相反.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x append-to-register &lt;RET&gt; R: 向R中追加文本. 以C-u引导也会从&lt;br /&gt;
buffer中删除选定的内容.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x prepend-to-register &lt;RET&gt; R: 向R中已有的内容之前添加内容.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x r r R: 把rectangle选定的内容存入寄存器R中. 同样用C-x r i R取回内容.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x r w R: window-configuration-to-register, 将窗口配置存入R. 包&lt;br /&gt;
括窗口布局, 以及各窗口关联的缓冲区. C-x r j R可以恢复存储在R中的窗口配置.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x r f R: frame-configuration-to-register, 将各帧的窗口布局, 缓&lt;br /&gt;
冲区等配置存入R, 同样用C-x r j R来恢复. C-u C-x r j R在恢复&lt;br /&gt;
frame configuration时, 会删除 frame configuration 不包含的帧.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-u NUMBER C-x r n R: 将数字NUMBER存入R. 如果没有参数,&lt;br /&gt;
会把0存入R. 同样用C-x r i R来插入.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-u NUMBER C-x r + R: 给R中存储的数字增加NUMBER, 如果没有参数, 增加1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(set-register ?R &amp;lsquo;(file . &amp;ldquo;PATH&amp;rdquo;))会把文件名存入R, C-x r j R会打开该文件.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;9-查找与替换&#34;&gt;9. 查找与替换 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;C-s RET searchstring RET  向前开始非递增查找操作，&lt;br /&gt;
继续按C-s就会查找下一个。如果你上次搜索了beer，只需要按C-s C-s，&lt;br /&gt;
就会再搜索beer。如果你已经标记了要搜索的文本，只需要按C-s M-y。&lt;br /&gt;
可以用C-s M-p或C-s M-n翻看查找历史。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ESC C-s 递增地用正则表达式向前查找&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ESC C-r 递增地用正则表达式向后查找&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-r RET searchstring RET  和C-s对称，只不过是向后查找。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-s C-w    开始递增查找，把光标位置的单词做查找字符串&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-s C-y    开始递增查找，把光标位置到行尾之间的文本做查找字符串&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;多次按C-s进入增量搜索后，按Backspace可定位到上一个匹配处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x search-forward   非递增的向前查找&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x search-backward   非递增的向后查找&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x re-search-forward    非递增地用正则表达式向前查找&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x re-search-backward   非递增地用正则表达式向后查找&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-s return C-w  向前开始单词查找（不受换行符、空格、标点符号影响）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-r return C-w  向后开始单词查找（不受换行符、空格、标点符号影响）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x replace-string RET 旧字串 RET 新字串 RET（不征询意见）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x replace-regexp 不征询意见地替换一个正则表达式&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-% (M-x query-replace) 交互式替换。空格或y，替换并找到下一个；Del或n，&lt;br /&gt;
不替换，找到下一个；&amp;rdquo;.&amp;ldquo;，替换并退出；&amp;rdquo;!&amp;ldquo;，替换剩下的全部，不要再问；&lt;br /&gt;
&amp;rdquo;^&amp;ldquo;，回到上一个；回车或q，退出查询替换。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x query-replace-regexp 交互式替换正则表达式。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;10-缓冲区-窗口和帧&#34;&gt;10. 缓冲区、窗口和帧 #&lt;/h1&gt;

&lt;h2 id=&#34;缓冲区&#34;&gt;缓冲区 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-x b    如果输入一个新的文件名则新建一个文件并且编辑,否则打开该文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-left    上一个缓冲区&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x C-right    下一个缓冲区&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x C-b   可以得到一个buffer列表，下面是列表的一些快捷键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;空格或n，下一个buffer&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;p，上一个buffer&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;1，全屏打开当前buffer&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d或k，做删除的标记&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;x，执行标记的命令，比如有几个buffer标记了删除，x则删除这几个buffer。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x s    保存全部缓冲区&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x k    删除缓冲区&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x kill-some-buffers 对每个缓冲区询问是否关闭&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x rename-buffer 重命名当前缓冲区&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x C-q    Toggle当前缓冲区的只读属性&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;窗口&#34;&gt;窗口 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-x 0    删除当前所在的窗口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 4 0  将缓冲区和窗口一起删除&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 4 f  在别的窗口打开文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 4 b  切换其它窗口中的缓冲区&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 1    当前缓冲区满屏显示（常用的按键）, 或者按Esc Esc Esc关&lt;br /&gt;
闭其它窗口.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 2    创建上下排列的窗口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 3    创建左右排列的窗口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x o    在窗口之间移动&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x ^    将窗口增高一行，也可以用M-x enlarge-window&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-u n C-x ^   将窗口增高n行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M&amp;ndash; C-x ^  将窗口垂直收缩一行，也可以用M-x shrink-window&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x }   将当前窗口增宽一列，也可以用M-x enlarge-window-horizontally&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x {   将当前窗口水平减一列，也可用M-x shrink-window-horizontally&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ESC C-v或C-M-v 滚动其它窗口的内容。你也可以用M-PgDn和M-PgUp滚动&lt;br /&gt;
其它窗口内容。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;帧-frame&#34;&gt;帧 (frame) ##&lt;/h2&gt;

&lt;p&gt;一个frame就是一个Emacs窗口，这个窗口是被窗口管理器管理的窗口，&lt;br /&gt;
有自己的菜单栏，工具栏的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-x 5 0       删除当前的frame&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 5 1       删除其它的frame&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 5 b       在其它的frame中打开缓冲区&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 5 f       在其它的frame中打开文件&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;minibuffer&#34;&gt;MiniBuffer ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;按 RET 会退出MiniBuffer, &lt;em&gt;要想输入换行符, 可以输入 C-o 或 C-q C-j&lt;/em&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;默认情况下, 在 MiniBuffer 中输入 &lt;TAB&gt;, &lt;SPACE&gt;, &amp;lt;?&amp;gt; 都会补全,&lt;br /&gt;
要想输入这些字符, 可以用C-q.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当你在MiniBuffer中输入命令或参数时, 可能要在另一个窗口中弹出候选&lt;br /&gt;
项,当候选项多时, 你可以用 C-M-v 来滚动补全的内容, 或者用&lt;br /&gt;
M-&lt;PageUp&gt; 和 M-&lt;PageDown&gt;来上下滚动帮助内容.&lt;br /&gt;
似乎连续地按Tab键也可以让帮助内容向下滚动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在 MiniBuffer 输入过的东西会记录在 Minibuffer history list中,&lt;br /&gt;
=M-p= 和 &lt;UP&gt; 是上一个项目, =M-n= 和&lt;Down&gt; 是下一个项目, =M-r&lt;br /&gt;
REGEXP &lt;RET&gt;= 向前搜索符合正则表达式的项目, =M-s REGEXP &lt;RET&gt;=&lt;br /&gt;
向后搜索符合正则表达式的项目.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;minibuffer history list分为几个: 文件名, 缓冲区名, 命令参数,&lt;br /&gt;
Emacs命令, 编译命令&amp;hellip;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;C-x &lt;ESC&gt; &lt;ESC&gt;&lt;/em&gt; 重新执行最近的一个命令.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x list-command-history 会显示minibuffer的命令历史, 最近使用的排在最先.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当在minibuffer中输入密码时, C-u: delete all; &lt;RET&gt; 或 &lt;ESC&gt;: submit.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;11-编辑&#34;&gt;11. 编辑 #&lt;/h1&gt;

&lt;h2 id=&#34;一些方便的按键&#34;&gt;一些方便的按键 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-m    移动光标到当前行的第一个非空字符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ESC ^    将这一行与上一行合并&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-SPC    删除连续的空格，只保留一个&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-\     删除连续的空格, =C-u M-\= 只删除 point 前面的空白字符.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-(      输入 =()=&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Esc, Tab (M-Tab)     用字典补全输入。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;插入/覆盖模式切换：M-x overwrite-mode是用来转换 insert mode&lt;br /&gt;
与 overwrite mode ，按Insert键可以实现同样的功能。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-i 相当于TAB，M-i 输入制表符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-m 相当于RET；C-o在光标后重开一行，但光标保持不动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-j 换行并根据当前模式缩进。M-j 重开一行并保持缩进，如果当前行是注&lt;br /&gt;
释，下一行也是注释。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-o 在光标后插入一个空白行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-o 删除多个连续的空行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;list-matching-lines: 列出符合给定模式的行(对整个文件).&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;delete-matching-lines: 删除符合模式的行. (如果有region, 作用于&lt;br /&gt;
region, 否则作用于光标到文件末尾)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;delete-non-matching-lines: 与 delete-matching-lines 类似.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;输入特殊符号&#34;&gt;输入特殊符号 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-q: (1) C-q后按特殊按键 如按TAB输入制表符；按回车(或C-m)输入回&lt;br /&gt;
车符, 等等. (2) C-q后可以跟ascII码, 如 =C-q 7 7 b= 会输入 =?b=.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-q C-m 会输入 ^M, C-q C-j 会输入换行符。&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x 8 可以插入一些特殊符号。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-x 8 &amp;ldquo;a ä&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 &amp;ldquo;A Ä&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 ~D Ð&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 /e æ&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 /E Æ&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 ,c ç&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 ,C Ç&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 /o ø&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 &amp;ldquo;o ö&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 &amp;ldquo;s ß&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x 8 ~t þ&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在多个位置间跳转&#34;&gt;在多个位置间跳转 ##&lt;/h2&gt;

&lt;p&gt;以前的marker存在mark ring中，所以可以用C-@ 或C-SPC在多个位置做标&lt;br /&gt;
记，然后用C-u C-@ 或C-u C-SPC在当前缓冲区内跳转。用C-x C-@ 或C-x&lt;br /&gt;
C-SPC在全局的标记位置内跳转。&lt;/p&gt;

&lt;h2 id=&#34;矩形区域操作&#34;&gt;矩形区域操作 ##&lt;/h2&gt;

&lt;p&gt;在矩形的左上角进行标记，然后将光标移动到矩形的右下角，&lt;br /&gt;
就可以进行矩形操作了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-x r d: delete-rectangle, 删除矩形区域的文字&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r k: kill-rectangle, 删除矩形区域，并把它放入kill-ring&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r y: yank-rectangle, 粘贴最后剪切的矩形区域&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r o: open-rectangle, 将选定的rectangle用空格填充, 将已有的文本右移.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r c: clear-rectangle, 将矩形区域内的文本用空格替换.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r t STRING: 将矩形区域的每行用给定的字符串替换.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x string-insert-rectangle &lt;RET&gt; STRING: 用字符串填充矩形区域,&lt;br /&gt;
原有文本右移.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r r R: 将矩形区域的内容存储在寄存器R中. 可以再用C-x r i R取回.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进行矩形区域操作时打开CUA (common user access) mode会方便许多.&lt;br /&gt;
在CUA模式下, C-x 剪切, C-c复制, C-v粘贴, 如果选中了Region, 你输&lt;br /&gt;
入内容会删除Region. 如果你不想原来的Emacs键绑定产生干扰. 你可以&lt;br /&gt;
(setq cua-enable-cua-keys nil). 或者你可以按住shift来调用C-x, 如&lt;br /&gt;
果你想C-x C-f, 你要输入 S-C-x C-f, 或者你可以多按一次C-x, 如C-x&lt;br /&gt;
C-x C-f. 要启用CUA模式, M-x cua-mode &lt;RET&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;文本位置交换&#34;&gt;文本位置交换 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-t     交换光标所在字符与前一个字符的位置&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-t     交换光标前后两个单词的位置&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-t    交换两个文本行的位置&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;按下M-x后在辅助输入区中输入&amp;rdquo;transpose-sentences&amp;rdquo;交换两个句子的位置，&lt;br /&gt;
按下&amp;rdquo;transpose-paragraph&amp;rdquo;交换两个段落的位置&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;改变字母大小写&#34;&gt;改变字母大小写 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-c     单词首字母改为大写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-u     单词的字母全部改为大写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-l     单词的字母全部改为小写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-l（downcase-region）使标记的区域变成小写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-u（upcase-region）使标记的区域变成大写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x upcase-initials-region, 选定区域首字母大写.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;撤销与重做&#34;&gt;撤销与重做 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;撤销操作 (undo）：C-x u或C-_或C-/。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;重做。GNU Emacs本身没有Redo，不过可以借助undo undoes来实现。&lt;br /&gt;
在做了一系列undo后，只要让光标离开原来的位置，再执行undo的动作，&lt;br /&gt;
就会Redo。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;撤销上次保存后的所有操作：M-x revert-buffer RET。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;简单排版&#34;&gt;简单排版 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果想启用自动断行，M-x auto-fill-mode。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-s  让一行居中 (M-x center-line)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-S  让一段居中 (M-x center-paragraph)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x center-region    让一个区域居中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-q (M-x fill-paragraph)  让一段自动断行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x fill-region           让选中的区域自动断行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;统计字数：C-x h选中整个缓冲区。M-|会让你输入shell命令，&lt;br /&gt;
输入wc -w 统计单词数，输入 wc -m 可以统计字符数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;统计中文字数：M-x count-words，会告诉你行数和字符数。不管使用什&lt;br /&gt;
么编码，每个汉字算是一个字符，所以字符数减去行数，就大致是汉字的&lt;br /&gt;
字数。比实际的汉字数要多，因为文中可能包含空格和英文字符。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;宏&#34;&gt;宏 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-x ( 开始宏，也可以按 F3 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x ) 结束宏，也可以按 F4 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x e 执行宏。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重复操作&#34;&gt;重复操作 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-num 可以重复执行一条命令，比如C-9 *可以连续插入9个星号。&lt;br /&gt;
M-num可以达到相同的目的. 即使数值参数超过9, 这种方式也可以工作.&lt;br /&gt;
如按住Meta时按下5, 放开meta再按6, 再输入其它命令, 则会重复56次.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;也可以用C-u num来辅助，如用C-u 20 *插入20个星号。&lt;br /&gt;
如撤销10次操作：C-u 10 C-x u。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果C-u后面不加数值参数，则默认的数值参数是4。C-u C-u C-n 会向下移动16行.&lt;br /&gt;
但是要输入重复的数字，就需要用C-u来间隔重复的次数和要重复的数字，&lt;br /&gt;
例如：要输入20个5，C-u 20 C-u 5。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;有一个例外是，C-u 3 C-v不是翻3页，而是整个屏幕上移三行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x z重复上一次操作, 如果想重复一次以上, 就继续按z.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;abbrev&#34;&gt;abbrev ##&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;=C-x a g= add-global-abbrev, 输入一个单词后，按C-x a g, 然后输入这个单词的缩写，再回车。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;=C-x a -= or =C-x a i g=, inverse-add-global-abbrev, 输入一个缩写，按这个序列，再输入完整的单词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;=C-x a += or =C-x a C-a=, add-mode-abbrev, 为当前模式加入缩写。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;=C-x a i l= inverse-add-mode-abbrev, 反向（先写缩写，再写完整的）为当前模式加入缩写。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;C-x a &amp;lsquo;&amp;rdquo; or &amp;ldquo;C-x a e&amp;rdquo; 扩展缩写。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;=C-x a n=, expand-jump-to-next-slot; =C-x a p=, expand-jump-to-previous-slot.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;12-书签&#34;&gt;12. 书签 #&lt;/h1&gt;

&lt;p&gt;书签可以看成一种特殊的寄存器, 和寄存器的区别在于寄存器的名字是单个&lt;br /&gt;
字符, 而书签名可以是多个字符.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-x r m BOOKMARK &lt;RET&gt; 在光标当前位置设置一个书签, 如果直接回车,&lt;br /&gt;
会使用缓冲区的名字做书签名.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x r b BOOKMARK &lt;RET&gt;  跳到指定的书签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x bookmark-rename   重命名书签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x bookmark-delete   删除书签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x bookmark-insert-location: 插入BOOKMARK指向的文件名.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x bookmark-insert &lt;RET&gt; BOOKMARK &lt;RET&gt;: 插入BOOKMARK指向文件的内容.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x bookmark-save 用该命令, 可以随时保存书签列表, Emacs在退出时&lt;br /&gt;
也会自动保存默认的书签列表, 存储在 &lt;code&gt;~/.emacs.bmk&lt;/code&gt;. 如果你想每&lt;br /&gt;
次新建书签都保存书签列表, &lt;code&gt;(setq bookmark-save-flag 1)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x bookmark-write    保存书签列表到特定的文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x bookmark-load     从特定的文件读取书签列表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x r l   打开书签列表，下面是书签列表的一些快捷键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;f: 显示光标所在的书签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;t: 是否显示和书签关联的文件路径&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;q: 退出书签列表&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;m: 标记在其它的窗口显示&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;v: 显示被标记的书签，如果没有标记的书签，就显示光标所在的书签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d: 做删除的标记&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;x: 删除被标记删除的书签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;u: 移除标记&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;13-使用在线帮助&#34;&gt;13. 使用在线帮助 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;C-h t   运行Emacs教程。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-h C-f 查看Emacs FAQ.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-h [C-n, n] 查看最近版本的新特性.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-h C-p 查看已知的问题.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-h p 可以查看Emacs中包含了哪些包.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h C-c, describe-copying, 查看GPL许可证。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h c   describe-key-briefly, 查看某个键序列对应的命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h k   比C-h c更详细。查看某个键序列对应的命令及做了什么。&lt;br /&gt;
像是C-h c和C-h f的结合。还可以查看某个菜单项对应的命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h K 显示按键序列对应的手册. 注意: C-h c, C-h k 和 C-h K的参数&lt;br /&gt;
可以是按键序列, 也可以是菜单项或鼠标动作.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h f 描述一个函数（或命令）做了什么。如果你使用Emacs23或更新的版本，你可&lt;br /&gt;
以用*进行模糊查找。比如 ~C-h f *buffer TAB~, 就会得到所有以buffer结尾的函数列&lt;br /&gt;
表。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h F   打开对应命令的手册. command = interactive function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h b   describe-bindings, 显示所有活跃的键绑定.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h w   查看对应某个命令的键绑定是什么。对应的是 where-is 命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h d   查看匹配给定模式的关于变量和命令的文档.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h v   查看某个变量的含义和它的值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h e   显示 *Messages* buffer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h m   描述当前的模式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h l 查看我最后敲的100个字符是什么。等同于 M-x view-lossage,最&lt;br /&gt;
后键入的100个键盘输入称为 Lossage。有什么实际用途呢？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h C-h 如果你记不住前面那么多的C-h没有关系，记住C-h C-h就可以&lt;br /&gt;
了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h a apropos-command, 查看哪些命令包含了某个子字符串。参数可以&lt;br /&gt;
是单个关键字, 关键字列表 和 正则表达式.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-u C-h a, show apropos commands or functions.&lt;br /&gt;
When looking for command by apropos-command, you can call it with 【Ctrl+u】 first.&lt;br /&gt;
It&amp;rsquo;ll then also list functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x apropos 查看哪些命令或变量包含了某个子串。默认不显示与命令对&lt;br /&gt;
应的按键, C-u M-x apropos会显示对应的按键(如果有绑定按键的话).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x apropos-variable 列出用户可以定制的变量, 如果用C-u 做前缀,&lt;br /&gt;
列出所有匹配的变量.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x apropos-value 列出附和条件的变量值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x apropos-documentation 搜索文档字符串匹配模式的命令和变量.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x elisp-index-search 在elisp手册中寻找函数的文档&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x emacs-index-search 在emacs手册中寻找函数的文档&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h r   在Info中显示Emacs Manual.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你在编辑程序，你可以按C-h S (info-lookup-symbol)在对应的手册&lt;br /&gt;
中找到光标下符号的入口，前提是你有Info版的手册。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h i 或者M-x info查看帮助info。&lt;br /&gt;
运行 C-h i 指令，会先进入 info 树状结构的根部 (/usr/share/info)。&lt;br /&gt;
任何情况下， 可键入 =d= 回到此根部.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;空格键和退格键，分别向下和向上滚动当前节点，并自动地跳到下一个和上一个节点。&lt;br /&gt;
当向下滚动遇到菜单时，会跳转到菜单引用的第一个节点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;h 介绍如何使用 info.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;m MenuName 直接移动到指定的Menu上, 如m Emacs &lt;RET&gt;会跳转到Emacs的Info.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;n 将结点移至下一个与此结点相连的结点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;p 将结点移至上一个与此结点相连的结点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;u 将结点移至上一层的结点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;t 移动到当前节点的top节点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;gt; 移动到当前文档指向的最后一个节点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;l 移动到之前访问的最后一个节点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;i &lt;keyword&gt; &lt;RET&gt;, 调用info-index命令，搜索索引中包含给定关键字的节点。&lt;br /&gt;
会在当前Info节点中搜索keyword, 按 &amp;lsquo;,&amp;rsquo; 到下一个匹配处.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;s &lt;keyword&gt; &lt;RET&gt; 搜索手册, 可以输入正则表达式.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;q 隐藏 Info 的缓冲区，可以按 C-x b 返回 Info.&lt;br /&gt;
若想真正关闭 Info，就像关闭一个普通缓冲区一样，C-x k &lt;RET&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Tab 将光标移动到下一个交叉引用处，M-Tab则移动到上一个交叉引用处。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-h在后面输入，也很有用，比如：要看以C-c为前缀的有哪些键绑定，可&lt;br /&gt;
以按C-c C-h。常用的命令都以C-x为前缀，而和模式有关的按键一般以&lt;br /&gt;
C-c为前缀。再如：要看以C-x r为前缀的有哪些命令，可以按C-x r C-h。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x = what-cursor-position 显示光标所在字符信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x describe-char, 描述光标下的字符。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x describe-font 描述光标下的字体信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-=, count-lines-region, 统计被选中的行数和字符数, 汉字算一个字符.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x what-line, 显示光标所在的当前行数.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x what-page, 显示光标在多少页多少行.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C-x l, count-lines-page, 统计当前页多少行.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;C-h&lt;/code&gt; 相当于 &lt;code&gt;&amp;lt;F1&amp;gt;&lt;/code&gt;, 可以跟在前缀按键后查看前缀按键都有哪些命令,&lt;br /&gt;
有时C-h和前缀按键一起绑定到特定的命令, 但&lt;code&gt;&amp;lt;F1&amp;gt;&lt;/code&gt;总是有效的. 如 C-x v&lt;br /&gt;
&lt;code&gt;&amp;lt;F1&amp;gt;&lt;/code&gt; 可以查看所有以 C-x v为前缀的键绑定对应的命令.&lt;/p&gt;

&lt;h1 id=&#34;14-一些模式的帮助&#34;&gt;14. 一些模式的帮助 #&lt;/h1&gt;

&lt;p&gt;C-h m 列出目前的mode的特殊说明。&lt;/p&gt;

&lt;h2 id=&#34;text-mode&#34;&gt;TEXT MODE ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-Tab 单词的拼写补全&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-S   段落居中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-s   本行居中&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;html-mode&#34;&gt;HTML MODE ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-c C-v  在浏览器中查看正在编辑的网页。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-s (M-x html-autoview-mode) 在保存文档时自动打开浏览器显示&lt;br /&gt;
文档。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c 1   插入1级标题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c 2   插入2级标题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c 3   插入3级标题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c 4   插入4级标题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c 5   插入5级标题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c 6   插入6级标题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-j  插入回车的标记。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c RET  插入新的段落。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c -   插入分割线。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c h   插入链接标记。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c n   插入锚点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c i   插入图片标记。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c o   插入排序列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c u   插入无序列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c l   插入列表项。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-f     向前跳过同一级tag。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-b     向后跳过同一级tag。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-t     会提示你输入标签，如果你输入html，就会生成html文档的模板。&lt;br /&gt;
如果你输入别的标签，Emacs都会智能的补全。这是个非常有用的绑定。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c /       闭合未闭合的标签，这个功能也很棒。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c Tab     隐藏和显示标签。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;将光标移动到标签上，按C-c ?可以查看标签的简单含义。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-n     用于输入特殊字符，指被html标签占用的字符，如：&lt;br /&gt;
C-c C-n SPC会输入 &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; ，C-c C-n &amp;lt; 会输入 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c DEL     删除光标所在的标签，包括与之配对的标签。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;outline模式&#34;&gt;Outline模式 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-c C-n  移动到下一个可见的标题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-p  移动到上一个可见的标题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-f  移动到下一个同级标题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-b  移动到上一个同级标题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-u  移动到上一级&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-t  收起正文&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-d  收起子标题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x hide-entry   收起指定标题的正文&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-a  显示所有&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tex模式&#34;&gt;Tex模式 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-x plain-tex-mode 进入plain-Tex模式&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x latex-mode     进入latex模式&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x validate-tex-buffer   检查缓冲区内容是否符合Tex语法。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-f            保存并编译当前文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-v            预览编译结果(dvi文件)。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c TAB            bibtex&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-j                插入两个硬回车，即Tex中的分段，并检查段落的语法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c {              插入{}，并将光标置于其中间。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c }              如果光标在{}之间，将光标定位到}。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-e            对于latex中的\begin{x}，自动补全\end{x}。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-o            插入\begin{。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-RET              插入\item。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rst模式&#34;&gt;rst模式 ##&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;reStructuredText&lt;/em&gt; 是我常用的文档格式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-c C-t            显示文档目录。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-t C-u            更新文档目录。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-n            下一节。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-p            上一节。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c RET            标记当前节。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c 1              编译当前rst为html文档。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-b            把当前域转换为无序列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-e            把当前域转换为有序列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-v            把无序列表转换为有序列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-d            把当前域转换为line block。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-l            把当前域左移。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-r            把当前域右移。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;narrow模式&#34;&gt;narrow模式 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-x n n narrow模式：让你聚焦于选中的区域，隐藏其他的文本。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x n w 从narrow模式恢复。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;follow模式&#34;&gt;Follow模式 ##&lt;/h2&gt;

&lt;p&gt;两个窗口显示同一个缓冲区时，可以设置follow mode (M-x follow-mode)，&lt;br /&gt;
滚动一个窗口时，另一个窗口会跟着滚动。&lt;/p&gt;

&lt;p&gt;两个窗口显示的内容是连续的，如果你的光标移出了一个窗口的范围，&lt;br /&gt;
它会出现在另一个窗口里。不清楚这个模式有什么作用。&lt;/p&gt;

&lt;h1 id=&#34;15-编程&#34;&gt;15. 编程 #&lt;/h1&gt;

&lt;h2 id=&#34;一些编程模式下通用按键&#34;&gt;一些编程模式下通用按键 ##&lt;/h2&gt;

&lt;h3 id=&#34;快速移动&#34;&gt;快速移动 ###&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;C-M-a (M-x beginning-of-defun) 到当前或上一个函数定义的开始处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-e (M-x end-of-defun) 到当前或下一个函数定义的开始处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-h (M-x mark-defun) 选中当前或下一个函数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-u (M-x backward-list) 到当前程序块的开始&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-n (M-x forward-list) 到下一个程序块的开始，或是当前程序块的结束。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-f 向前匹配括号；C-M-b 向后匹配括号。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;缩进&#34;&gt;缩进 ###&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ESC C-\ 选中区域的每行都缩进。 (M-x indent-region)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-\: indent-region&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-q: 缩进当前函数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-c . &amp;lt;RET&amp;gt; STYLE &amp;lt;RET&amp;gt;&#39; Select a predefined style STYLE (&lt;/code&gt;c-set-style&amp;rsquo;).&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注释&#34;&gt;注释 ###&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;=ESC ;= 或 =M-;=    在当前行右边注释。如果选中区域，则注释/反注释选中的区域。&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x uncomment-region  取消选中区域的注释&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;M-x hs-minor-mode     打开折叠模式，然后可以使用hs-show-block,&lt;br /&gt;
hide-hide-block, hs-show-all, hs-hide-all等命令&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cc-mode&#34;&gt;CC-Mode ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-c C-a或M-x c-toggle-auto RET，打开或关闭C模式的自动状态（输入&lt;br /&gt;
分号自动换行并缩进）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x ff-find-other-file 打开和源文件对应的头文件，或者相反。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对条件编译指令的快捷键(c-mode &amp;amp;&amp;amp; c++-mode):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-c C-u: c-up-conditional, 回到 ~#if~ 的开始处&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-n: c-forward-conditional, 移动光标到当前或下一个 条件编译 的结束处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-p: c-backward-conditional, 移动光标到当前或上一个 条件编译 的开始处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x hide-ifdef-mode, 然后你可以按 C-c @ C-d 隐藏 ifdef block，按 C-c @&lt;br /&gt;
C-s 显示隐藏的 ifdef block. 你还可以用 C-c @ d 指定要 ifdef block 是关于哪&lt;br /&gt;
个宏的，然后你可以用 C-c @ h 和 C-c @ s 来隐藏和显示关于这个宏的 ifdef&lt;br /&gt;
block. 你可以按 C-c @ u 取消已指定的宏。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编译&#34;&gt;编译 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-x compile：编译。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x `：到下一个出错的地方。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用gdb&#34;&gt;使用GDB ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-x gdb：启动GDB&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-h m: 描述GDB模式&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-n：下一行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-s：下一行，遇到函数则进入&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-f：执行完当前函数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-c：继续执行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x SPC：设置断点。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;etags&#34;&gt;Etags ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;建立tag表。M-x cd RET切换默认目录到程序目录，&lt;br /&gt;
用M-!etags *.[ch]建立tag表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-.   find tags&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-*   返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果要查看一个函数的定义，将光标在函数名上，&lt;br /&gt;
M-. RET就搞定了。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果emacs找错了，你可以用C-u M-. 找下一个。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;global&#34;&gt;global ##&lt;/h2&gt;

&lt;p&gt;用emacs + global阅读代码方便得很。&lt;br /&gt;
global相当于ctags + cscope。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在工程目录运行 =gtags= 生成TAG文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在emacs中 =M-x gtags-mode=&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;然后 =M-x gtags-visit-rootdir=&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;就可以使用 =M-.= 定位tag，使用 =M-*= 返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;而且可以通过 =M-x gtags-find-rtag= 定位tag被访问的位置&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python模式&#34;&gt;Python模式 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-TAB   符号补全&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-c 运行当前缓冲区中的python代码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-z 切换到Python解释器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-k 标记光标所在的代码块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-u 找到代码块的开始&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-f 如果你安装了pythonDoc，可以程序中某个符号的帮助文档。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-a   移动到一个函数或类定义的开始，你可以按ESC C-a来得到这个按键&lt;br /&gt;
序列。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-M-e   移动到一个函数或类定义的结束。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Python代码的 &lt;em&gt;折叠显示&lt;/em&gt; 。C-u 4 C-x $ ，只显示缩进级别小于4的&lt;br /&gt;
行；C-u 8 C-x $ ，只显示缩进级别小于8的行； C-x $ ，显示所有行。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;grep&#34;&gt;Grep ##&lt;/h2&gt;

&lt;p&gt;如果不想记住复杂的grep参数，可以使用 =M-x rgrep= (递归子目录), =M-x lgrep= (只搜索当前目录)&lt;/p&gt;

&lt;h1 id=&#34;16-会话管理&#34;&gt;16. 会话管理 #&lt;/h1&gt;

&lt;p&gt;Emacs 23已经集成了desktop包，在退出emacs时，我们可以使用 &lt;code&gt;M-x desktop-save&lt;/code&gt; 在选定的目录下生成 &lt;code&gt;.emacs.desktop&lt;/code&gt; ，保存一些会话信息。&lt;/p&gt;

&lt;p&gt;在保存有 &lt;code&gt;.emacs.desktop&lt;/code&gt; 的目录下，启动emacs，然后 &lt;code&gt;M-x desktop-read&lt;/code&gt; 恢复会话。&lt;/p&gt;

&lt;p&gt;你可以在多个目录下保存 &lt;code&gt;.emacs.desktop&lt;/code&gt; ，然后用 &lt;code&gt;M-x desktop-change-dir&lt;/code&gt; 加载新的会话。现在不确定在加载新的会话前会不会保存当前会话。&lt;/p&gt;

&lt;p&gt;可以用 &lt;code&gt;M-x desktop-clear&lt;/code&gt; 清空当前会话。&lt;/p&gt;

&lt;h1 id=&#34;17-编码&#34;&gt;17. 编码 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Emacs22和Emacs21一样，通过mule能支持gb2312和utf-8编码，  但不支持gbk和gb18030。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Emacs23进行一番大改动，内置unicode，支持gb2312, gbk, gb18030。也就是说能完美的支持中文。而且可以使用xft字体了！&lt;br /&gt;
对中文用户来讲，Emacs23将是比较完美的一个版本。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;转换文件编码，比如想把gb2312编码的文件转换为utf-8编码，C-x C-m f，会让你选择编码系统，我们选utf-8-unix，回车。则转换完成，别忘了保存。注意：C-m = RET&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果想转换编码后，将文件另存。C-x C-m c，会让你选择编码系统，&lt;br /&gt;
然后让你输入命令序列，输入C-x C-w，输入另存的文件名，回车。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-m k，改变键盘输入的编码系统。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-m l，设定当前的语言环境。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-m p, 设定进程输入输出的编码系统。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-m r，设定打开文件的编码系统，当你打开文件乱码的时候可以试试这&lt;br /&gt;
个。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-m t，设定终端显示的编码系统。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-m x，设定X选中文本的编码系统。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;18-faces&#34;&gt;18. Faces #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;M-x set-face-foreground&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x set-face-background&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x list-faces-display, 显示当前frame的所有face. C-u M-x&lt;br /&gt;
list-faces-display, 会提示你输入一个正则表达式，只会列出匹配这个&lt;br /&gt;
表达式的face.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x highlight-phrase (C-x w p): 用指定的颜色高亮给定的字符串.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;19-emacs的其它用途&#34;&gt;19. Emacs的其它用途 #&lt;/h1&gt;

&lt;h2 id=&#34;在emacs中使用shell&#34;&gt;在Emacs中使用shell ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M-! 可以执行外部命令。 C-u M-! 会将shell命令的输出结果插入到当前缓冲区中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x shell  启动shell。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-u M-x shell 可以打开新的shell。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在Emacs中使用shell的好处是你可以全屏编辑，一个最酷的例子是：&lt;br /&gt;
如果你想把以前执行过的长命令修改一下再执行，&lt;br /&gt;
你可以C-r向后递增查找到这个长命令，然后编辑修改，&lt;br /&gt;
然后，最神奇的地方，你在这条命令上按回车，这条修改过的命令就执行了。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果你想在emacs中启动多个shell可能会疑惑，&lt;br /&gt;
因为你使用两次M-x shell也只有一个shell。&lt;br /&gt;
你需要将第一个shell所在的缓冲区重命名才能启动新的shell。&lt;br /&gt;
还记得吗？重命名用M-x rename-buffer。看来这个命令还是有些用的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;这并不是一个功能完整的shell，如果你想在emacs中用功能完整的shell，用&lt;br /&gt;
M-x term 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你可以将shell中的输出或者命令提示符向普通文本一样地删除。&lt;br /&gt;
也可以用C-c C-o清理刚才的输出。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-c C-u 相当于C-u。M-p 上一条命令; M-n 下一条命令。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用dired做文件管理器&#34;&gt;用Dired做文件管理器 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-x d     打开 Dired ，进入某个目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;i         在当前缓冲区打开子目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;$         折叠光标所在目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;^         进入上一级目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;a         在当前缓冲区进入新的目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;e         在当前窗口打开文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;o         在另一个窗口打开文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;j         跳到当前目录中指定的文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;         跳到上一个子目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;gt;         跳到下一个子目录&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;功能很多，还是看 &lt;em&gt;菜单&lt;/em&gt; 和 &lt;em&gt;帮助&lt;/em&gt; 吧。&lt;/p&gt;

&lt;h2 id=&#34;打开系统文件&#34;&gt;打开系统文件 ##&lt;/h2&gt;

&lt;p&gt;要在普通用户的emacs会话中打开系统文件, 需要 TRAMP 的辅助.&lt;br /&gt;
TRAMP = Transparent Remote Access Multiple Protocols,&lt;br /&gt;
即支持多种协议的远程访问.&lt;/p&gt;

&lt;p&gt;打开远程文件的方法为: &lt;code&gt;C-x C-f /protocol:user@machine:file&lt;/code&gt;,&lt;br /&gt;
protocol 可以是ftp, ssh等. 要打开本地的系统文件, 比如&lt;br /&gt;
&lt;code&gt;/etc/php/php.ini/&lt;/code&gt;, 当前用户名 &lt;code&gt;john&lt;/code&gt;, 主机名 &lt;code&gt;ArchLinux&lt;/code&gt;, 有两种&lt;br /&gt;
方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C-x C-f /su::/etc/php/php.ini&lt;/code&gt;, 相当于&lt;br /&gt;
&lt;code&gt;/su:root@ArchLinux:/etc/php/php.ini&lt;/code&gt;, 要输入 root的密码.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-x C-f /sudo::/etc/php/php.ini&lt;/code&gt;, 相当于&lt;br /&gt;
&lt;code&gt;/sudo:root@ArchLinux:/etc/php/php.ini&lt;/code&gt;, 要输入john的密码.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其它&#34;&gt;其它 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在emacs中查看手册，M-x man。如果要查看带颜色的手册，M-x woman。&lt;br /&gt;
man依赖于Unix/Linux系统的man，而woman是完全用elisp实现的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x list-colors-display 可以查看emacs使用的顏色。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M-x calc 打開emacs自帶的計算器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x l: 可以显示缓冲区共有多少行，光标前有多少行，光标后有多少行。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;20-vim-功能的模拟&#34;&gt;20. Vim_ 功能的模拟 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;gf：ffap (find file at point)或ffap-other-window。可以做一个键绑定：&lt;br /&gt;
&lt;code&gt;(global-set-key (kbd &amp;quot;C-c g f&amp;quot;) &#39;ffap-other-window)&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>spacemacs 加载顺序</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-spacemacs-%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-spacemacs-%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/xh_acmagic/article/details/52054569&#34; target=&#34;_blank&#34;&gt;Spacemacs configuration layers - 小幻的博客 - 博客频道 - CSDN.NET&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/xh_acmagic/article/details/52081549&#34; target=&#34;_blank&#34;&gt;Spacemas的Dotfile配置 - 小幻的博客 - 博客频道 - CSDN.NET&lt;/a&gt;&lt;br /&gt;
特性： 自动加载Auto-loading&lt;br /&gt;
&lt;a href=&#34;https://linuxtoy.org/archives/emacs-autoload.html&#34; target=&#34;_blank&#34;&gt;emacs autoload 集装箱 · LinuxTOY&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun add-to-load-path (dir) (add-to-list &#39;load-path dir))  
(add-to-list &#39;exec-path &amp;quot;~/.local/bin/&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;spacemacs-约定&#34;&gt;Spacemacs 约定&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Code guidelines&lt;br /&gt;
** Spacemacs core and layer&lt;br /&gt;
函数命名&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;=spacemacs/xxx= 命令函数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;=spacemacs//xxx= 私有函数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;=spacemacs|xxx= 宏&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变量命名规范&lt;br /&gt;
  - =spacemacs-xxx= 普通变量&lt;br /&gt;
  - =spacemacs&amp;ndash;xxx= 私有变量&lt;/p&gt;

&lt;p&gt;layer 命名规范&lt;br /&gt;
(defun  layer/init-package ()&lt;br /&gt;
  )&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zhexuany/.spacemacs.d&#34; target=&#34;_blank&#34;&gt;zhexuany/.spacemacs.d&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/eggcaker/spacemacs-layers&#34; target=&#34;_blank&#34;&gt;eggcaker/spacemacs-layers&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/chrisbarrett/spacemacs-layers&#34; target=&#34;_blank&#34;&gt;chrisbarrett/spacemacs-layers&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;emacs配置加载顺序&#34;&gt;emacs配置加载顺序&lt;/h2&gt;

&lt;p&gt;[&lt;code&gt;~/.emacs|.emacs.el&lt;/code&gt; -&amp;gt;  &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;] -&amp;gt; [&lt;code&gt;.spacemacs&lt;/code&gt; -&amp;gt; &lt;code&gt;.spacemacs.d/init.el&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;..spacemacs.d/init.el 文件加载顺序定义在&lt;code&gt;~/.emacs.d/init.el -&amp;gt; .emacs.d/core/core-spacemacs.el&lt;/code&gt;中通过 &lt;code&gt;dotspacemacs|call-func&lt;/code&gt; 宏实现调用。&lt;br /&gt;
在这个文件中有四个顶级函数： dotspacemacs/init，dotspacemacs/user-init, dotspacemacs/layers, 和 dotspacemacs/user-config。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dotspacemacs/init  函数是在启动过程中，在其他东西运行前运行，并且包含  Spacemacs  设置。 除非你需要更改默认 Spacemacs 设置，否则你不用动这个函数。  
Dotspacemacs/user-init 函数也是在其他程序运行前运行，并包含用户特定配置。  
dotspacemacs/emacs-custom-settings  
Dotspacemacs/layers 函数仅用于启用和禁用层和包 自定义层在此处加载  
Dotspacemacs/user-config 最后加载，函数是你用到最多的函数。 在这里，你可以定义任何用户配置  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;spacemacs-顶级函数之三-dotspacemacs-layers&#34;&gt;spacemacs 顶级函数之三 &lt;code&gt;Dotspacemacs/layers&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun dotspacemacs/layers ()  

 (setq-default dotspacemacs-configuration-layers  
   &#39;(  
      ;; :packages            ;; 针对当前layer需要启用的package 默认全部启用  
      ;; :variables           ;; 配置当前layer 变量设置  
      ;; :disabled-for        ;; 指定layer中禁用  
      ;; :enabled-for         ;; 在指定layer中启用  

      (chinese :packages  
         :variables  
         ;;pangu-spacingchinese-enable-fcitx t  
         pangu-spacing-real-insert-separtor t ;;将空格加入 linux 到你的档案  
         ;;linux 或者有 fcitx-remote 才启用 fcitx 支持  
         chinese-enable-fcitx &#39;(or (spacemacs/system-is-linux) (executable-find &amp;quot;fcitx-remote&amp;quot;))  
         chinese-enable-youdao-dict t)  

      (auto-completion :enabled-for java python)  
      (auto-completion :disabled-for org git)  

     )))  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;spacemacs-layer创建自定义层layer&#34;&gt;Spacemacs layer创建自定义层layer&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;configuration-layer/create-layer&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;spacemacs-layer加载顺序&#34;&gt;Spacemacs layer加载顺序&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;layers.el   declare additional layers&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;packages.el the packages list and configuration&lt;br /&gt;
    &lt;layer&gt;/pre-init-&lt;package&gt;&lt;br /&gt;
    &lt;layer&gt;/init-&lt;package&gt;&lt;br /&gt;
     &lt;code&gt;use-package&lt;/code&gt; 一般在此处调用&lt;br /&gt;
    &lt;layer&gt;/post-init-&lt;package&gt;&lt;br /&gt;
    除非至少一个层为其定义了一个init函数，否则不会安装该包。 也就是说，在某种意义上，init函数是强制性设置，而pre-init和post-init函数做可选的设置。 这可以用于管理跨层依赖性，我们将在后面讨论。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;funcs.el    all functions used in the layer should be declared here&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;config.el   layer specific configuration&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;keybindings.el  general key bindings&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;spacemacs-layer加载过程&#34;&gt;Spacemacs layer加载过程&lt;/h2&gt;

&lt;p&gt;Spacemacs加载过程可以概括如下：&lt;/p&gt;

&lt;p&gt;Spacemacs经过所有启用层，并评估他们的文件。通过引入的变化config.el因此被应用，然后funcs.el和 packages.el被加载，但没有从发生packages.el，因为这些文件只定义函数和变量。&lt;br /&gt;
Spacemacs检查该包应下载并安装。要安装一个程序包必须&lt;br /&gt;
I layer配置package &lt;strong&gt;以下4个条件必须都满足才可以&lt;/strong&gt;&lt;br /&gt;
1. 在layer中声明，并且启用&lt;br /&gt;
2. 不能被其他层排除掉 =&lt;layer&gt;-excluded-packages=&lt;br /&gt;
3. 不能被自己排除掉 =&lt;layer&gt;-excluded-packages=.&lt;br /&gt;
4. 必须有至少一个&lt;layer&gt;/init-&lt;package&gt;为它定义的功能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;included by a layer that the user has enabled,&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;not be excluded by any other layer that the user has enabled,&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;not be excluded by the user herself, and&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;there must be at least one &lt;layer&gt;/init-&lt;package&gt; function defined for it.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;II: 另外，如果一个包是最终用户的一部分 &lt;code&gt;dotspacemacs-additional-packages&lt;/code&gt;，它也将被安装。&lt;/p&gt;

&lt;p&gt;加载所有的包，并按字母顺序排列 package.el内置的Emacs库负责隐含的依赖。不包含上述规则的包及其依赖将被删除。（是否移除依赖包是可选的，缺省值t）。&lt;br /&gt;
的pre-init，init并且post-init为每个安装的包功能依次执行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意： 如果一个layer拥有一个包，仅仅只定义pre-init或post-init 函数 但是没有定义init函数，那么这个包并不会安装。&lt;br /&gt;
所以 如果一个layer已经init了一个包，自定义的layer可以只定义 pre-init或post-init 去配置一个自定义的选项。&lt;br /&gt;
 每一个包应该只在一个layer中初始化，在其他层配置&lt;br /&gt;
注意：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-layers-el&#34;&gt;1. layers.el&lt;/h3&gt;

&lt;p&gt;移除layer&lt;br /&gt;
&lt;code&gt;(configuration-layer/remove-layer &#39;chinese)&lt;/code&gt;&lt;br /&gt;
添加 其他layer&lt;br /&gt;
(configuration-layer/declare-layers &amp;lsquo;(&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                  ))  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-packages-el&#34;&gt;2. packages.el&lt;/h3&gt;

&lt;p&gt;Packages.el 文件包含你可以在 &lt;layer-name&gt;-packages 变量中安装的包的列表。所有 MELPA 仓库中的包都可以添加到这个列表中。还可以使用 :excluded t 特性将包包含在列表中。每个包都需要一个函数来初始化。这个函数必须以这种模式命名：&lt;layer-name&gt;/init-&lt;package-name&gt;。这个函数包含了包的配置。同时还有一个 pre/post-init 函数来在包加载之前或之后运行代码。它看起来想这个样子：&lt;/p&gt;

&lt;p&gt;(defconst layer-name-packages &amp;lsquo;(example-package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                        ;; :location built-in  

                        ;; :toggle 条件控制 当变量chinese-enable-fcitx为`t`时加载fcitx包  
                        (fcitx :toggle chinese-enable-fcitx)  

                        ;; :excluded 为真(t)来卸载example-package-2  
                        (example-package-2 :excluded t)))  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;;; List of packages to exclude.&lt;br /&gt;
(setq appleshan-core-excluded-packages &amp;lsquo;())&lt;/p&gt;

&lt;p&gt;(defun layer-name/post-init-package ()&lt;br /&gt;
  ;;在这里添加&lt;strong&gt;另一个层&lt;/strong&gt;的包的配置&lt;br /&gt;
  )&lt;br /&gt;
(defun layer-name/init-example-package ()&lt;br /&gt;
  ;;在这里配置example-package&lt;br /&gt;
  )&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：只有一个层可以具有一个对于包的 init 函数。如果你想覆盖另一个层对一个包的配置，请使用 use-package hooks 中的 &lt;layer-name&gt;/pre-init 函数。&lt;/p&gt;

&lt;p&gt;如果 MELPA 中没有你想要的包，你必须是由一个本地包或一个包源。关于此的更多信息可以从层的剖析处获得。&lt;/p&gt;

&lt;p&gt;确保你添加了你的层到你的 .spacemacs 文件中，并重启 spacemacs 以激活。&lt;/p&gt;

&lt;h3 id=&#34;3-funcs-el&#34;&gt;3. funcs.el&lt;/h3&gt;

&lt;h3 id=&#34;4-config-el&#34;&gt;4. config.el&lt;/h3&gt;

&lt;p&gt;声明一些可被外部配置的变量&lt;/p&gt;

&lt;h3 id=&#34;5-keybindings-el&#34;&gt;5. keybindings.el&lt;/h3&gt;

&lt;p&gt;为了将配置分组或当配置与你的 .spacemacs 文件之间不匹配时，你可以创建一个配置层。Spacemacs 提供了一个内建命令用于生成层的样板文件：SPC :configuration-layer/create-layer。这条命令将会生成一个如下的文件夹：&lt;/p&gt;

&lt;h2 id=&#34;依赖检查&#34;&gt;依赖检查&lt;/h2&gt;

&lt;p&gt;Spacemacs提供了一些可以用来检查是否包括其他层或包的其他有用的功能。&lt;/p&gt;

&lt;h3 id=&#34;启用一个层&#34;&gt;启用一个层&lt;/h3&gt;

&lt;p&gt;对于需要启用另一个层，使用功能的层 configuration-layer/declare-layer及configuration-layer/declare-layers以确保即使用户没有使他们明确表示的层被启用。调用这些功能必须去的config.el文件。&lt;/p&gt;

&lt;h3 id=&#34;检查是否启用了一个层&#34;&gt;检查是否启用了一个层&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;configuration-layer/layer-usedp&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;启用package&#34;&gt;启用package&lt;/h3&gt;

&lt;p&gt;即使在layer中激活了一个package，但是依然有可能会在其他层中excluded掉&lt;br /&gt;
1. =&lt;layer&gt;-excluded-packages=.&lt;br /&gt;
2. =dotspacemacs-excluded-packages=&lt;/p&gt;

&lt;h3 id=&#34;检查包是否或将被安装&#34;&gt;检查包是否或将被安装&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;configuration-layer/package-usedp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(when (configuration-layer/layer-usedp &amp;lsquo;chinese) # 当chinese层被启用时才执行以下配置&lt;/p&gt;

&lt;p&gt;这些是在某些情况下是有用的，但通常可以只通过使用获得所需的结果post-init的功能。&lt;/p&gt;

&lt;h2 id=&#34;关系整合&#34;&gt;关系整合&lt;/h2&gt;

&lt;p&gt;use-package 与 layer&lt;br /&gt;
use-package 与 require&lt;br /&gt;
use-package 与 autoload&lt;br /&gt;
layer 与 package&lt;br /&gt;
require 与 load&lt;/p&gt;

&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;

&lt;p&gt;注意，是&lt;strong&gt;加载&lt;/strong&gt;，而不是&lt;strong&gt;激活&lt;/strong&gt;。回忆下你是怎么使用Chrome的插件系统：安装插件，插件的图标出现在浏览器地址栏的右侧，点击插件的图标来使用插件（激活其功能），有的插件甚至默认激活。这个过程中，所有加载和初始化配置的工作都由软件自动完成，你唯一需要做的就是选择用不用（激活）而已。&lt;/p&gt;

&lt;p&gt;然而，&lt;code&gt;elpa&lt;/code&gt;要求你自己完成加载和配置的步骤。一般来说，常见的载入命令有，&lt;code&gt;require&lt;/code&gt;，&lt;code&gt;load&lt;/code&gt;，&lt;code&gt;autoload&lt;/code&gt;等。而所谓的配置就是初始化一些参数。&lt;/p&gt;

&lt;p&gt;emacs一般称“插件”为&amp;rdquo;package&amp;rdquo;或者&amp;rdquo;library&amp;rdquo;。本质上，它们都提供一堆定义好的函数，来实现一些操作，进而实现某个功能。这里多说几句。在emacs中，连移动光标这种最底层的操作都有对应的函数。比如，你在emacs中可以键入&lt;code&gt;C-f&lt;/code&gt;来将光标向右移动一个字符，同时也可键入&lt;code&gt;M-x forward-char&lt;/code&gt;来实现。任何复杂的功能，比如给文档生成一个目录，都可以被分解为一个个操作，或者说调用一个个函数，而这些函数顺序执行下来功能就得到了实现。&lt;/p&gt;

&lt;p&gt;当emacs想要加载某个插件时，归根到底需要&lt;strong&gt;定位并运行&lt;/strong&gt;一个（也许是一些）脚本文件，那个脚本里定义了实现插件功能所需的变量和函数。emacs将它们转变为可供自己使用的对象（elisp object），放到运行环境中等待调用。而脚本自身还可以在内部进一步加载其他脚本。下面，来了解加载脚本的几个语句，&lt;code&gt;load&lt;/code&gt;，&lt;code&gt;require&lt;/code&gt;，&lt;code&gt;load-file&lt;/code&gt;，&lt;code&gt;autoload&lt;/code&gt;。&lt;br /&gt;
参考&lt;a href=&#34;http://ergoemacs.org/emacs/elisp_library_system.html&#34; target=&#34;_blank&#34;&gt;Emacs Lisp&amp;rsquo;s Library System: What&amp;rsquo;s require, load, load-file, autoload, feature?&lt;/a&gt;&lt;br /&gt;
延伸阅读 &lt;a href=&#34;http://www.emacswiki.org/emacs/RequiredFeature&#34; target=&#34;_blank&#34;&gt;Required Feature&lt;/a&gt;&lt;br /&gt;
参考&lt;a href=&#34;http://ergoemacs.org/emacs_manual/elisp/Autoload.html&#34; target=&#34;_blank&#34;&gt;Autoload&lt;/a&gt;&lt;br /&gt;
延伸阅读&lt;br /&gt;
* &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/elisp/Named-Features.html&#34; target=&#34;_blank&#34;&gt;Features&lt;/a&gt; TD&lt;br /&gt;
* &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/elisp/How-Programs-Do-Loading.html&#34; target=&#34;_blank&#34;&gt;How Programs Do Loading&lt;/a&gt; TD&lt;br /&gt;
* &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Libraries.html&#34; target=&#34;_blank&#34;&gt;Libraries of Lisp Code for Emacs&lt;/a&gt; TD&lt;br /&gt;
* &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html&#34; target=&#34;_blank&#34;&gt;Byte Compilation&lt;/a&gt; TD&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Feature可以理解为“特色功能”，比如，你在苹果的App Store里查看应用程序简介时，一般都会看到一个以Features开头的段落。单数形式，feature，一般对应一个插件的名字，因为一般插件的名字直接表明它实现的功能。复数形式，features，是一个用来存储feature的列表，这个列表可以告诉emacs哪些插件经被加载了。一般情况下，一个插件的启动脚本的结尾会调用&lt;code&gt;(provide &#39;&amp;lt;symbol name&amp;gt;)&lt;/code&gt;，将&lt;code&gt;&#39;&amp;lt;symbol name&amp;gt;&lt;/code&gt;加入到features中去。&lt;code&gt;&#39;&amp;lt;symbol name&amp;gt;&lt;/code&gt;一般就是插件的名字&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load&lt;/code&gt;一个位于硬盘上的文件，意味着执行这个文件里的所有elisp语句，然后将执行结果放进emacs的运行环境&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(require &#39;&amp;lt;symbol name&amp;gt;)&lt;/code&gt;会先查看features里面是否存在&lt;code&gt;&amp;lt;symbol name&amp;gt;&lt;/code&gt;。如果存在，语句执行完毕。如果不存在，基于它来猜一个文件名，或者由&lt;code&gt;require&lt;/code&gt;的第二个参数直接指定文件名，然后&lt;code&gt;load&lt;/code&gt;文件。注意，&lt;code&gt;load&lt;/code&gt;完成后，&lt;code&gt;require&lt;/code&gt;函数会再一次查看features列表中是否存在&lt;code&gt;&#39;&amp;lt;symbol name&amp;gt;&lt;/code&gt;，如果发现还是不存在，视参数&lt;code&gt;&amp;lt;soft-flag&amp;gt;&lt;/code&gt;来决定是否报错&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;require&lt;/code&gt; 只不过是一种加载load-file的方法，它的意义在于避免重复加载。比如，某个插件的启动脚本中需要用到另一个插件提供的某个函数。那么它就会&lt;code&gt;require&lt;/code&gt;这个插件，保证插件已被载入，然后再执行后续语句。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;load-file&lt;/code&gt;需要指定文件路径，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;load&lt;/code&gt;对load-file进行封装,不需要指定路径。会自动搜索&lt;code&gt;load-path&lt;/code&gt;，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;require&lt;/code&gt; 只不过是一种加载load-file的方法，它确保文件以正确的顺序加载，并避免重复加载。在某种程度上解决了去哪里找到需要加载的文件的问题，但是过长的加载列表依然导致emacs加载起来很慢。所以采用autoload才是王道&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;autoload&lt;/code&gt;在函数执行时再&lt;code&gt;load&lt;/code&gt;指定文件 （该函数关联到指定el,当该函数被调用时再去加载运行指定文件）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实，连整个emacs的启动都可以概括为一句话：加载一系列脚本。只不过这些脚本有的是内置的（built in），有的是你安装的插件包含的，有的是你自己写的。&lt;/p&gt;

&lt;p&gt;autoload原理:&lt;br /&gt;
1. 首先当函数加载时，将函数定义为null,当调用时立即将函数替换为函数本身，并加载执行。所以也会带来微小的延时。&lt;br /&gt;
2. autoload 主要用于 xxx-mode major模式中.&lt;br /&gt;
+ &lt;code&gt;autoload&lt;/code&gt;告诉emacs某个地方有一个定义好的函数，并且告诉emacs，先别加载，只要记住在调用这个函数时去哪里寻找它的定义即可&lt;br /&gt;
+ 这样做的一个好处是，避免在启动emacs时因为执行过多代码而效率低下，比如启动慢，卡系统等。想象一下，如果你安装了大量的有关python开发的插件，而某次打开emacs只是希望写点日记，你肯定不希望这些插件在启动时就被加载，让你白白等上几秒，也不希望这些插件在你做文本编辑时抢占系统资源（内存，CPU时间等）。所以，一个合理的配置应该是，当你打开某个python脚本，或者手动进入python的编辑模式时，才加载那些插件&lt;br /&gt;
+ 一个简单概括：“只注册函数名而不定义函数本身”&lt;/p&gt;

&lt;p&gt;前面介绍了几种加载机制。加载的目的在于定义变量和函数以供使用。任何插件，只有先被加载才能被使用。而且通常，你都希望先加载一个插件，再来配置它。考虑如下情景。&lt;/p&gt;

&lt;p&gt;你的插件中定义了一个变量a，默认值是1，插件内定义的许多函数都在内部使用了a。你希望在自己使用这些函数时，用到的a的值是2。有两种实现途径。一种是直接到插件的脚本文件中修改a的值为2。这叫做&amp;rdquo;hard coding&amp;rdquo;，有很多坏处。比如，每次更新插件，都要重新修改。另一种方法是，等这个插件已经被加载后，修改相应的elisp object。那自然，你得先让这个对象存在于emacs中，然后才能修改。所以要先加载，让需要配置的变量得到定义，再去修改变量的值。&lt;/p&gt;

&lt;p&gt;下面，让我们来看看这些脚本文件究竟长什么样子。打开emacs内置插件的文件夹，&lt;code&gt;emacs安装路径\share\emacs\24.4.91\lisp&lt;/code&gt;，你会看到一些子文件夹，一些后缀名为&lt;code&gt;gz&lt;/code&gt;的压缩文件，以及一些后缀名为&lt;code&gt;elc&lt;/code&gt;的文件。压缩文件中存放的其实是同名的&lt;code&gt;.el&lt;/code&gt;文件，也就是前面一直在提的脚本。&lt;code&gt;.elc&lt;/code&gt;是这个脚本编译好的版本，可以加快载入速度，不适合人类阅读。所以，如果你想查看一个插件的源代码，请查看&lt;code&gt;.el&lt;/code&gt;文件。&lt;code&gt;.el&lt;/code&gt;被放在压缩包是为了避免源代码被修改，进而造成各种问题。另外，加载插件时，总是会优先加载编译好的版本，其默认的文件扩展名即&lt;code&gt;.elc&lt;/code&gt;；如果不存在，才会加载&lt;code&gt;.el&lt;/code&gt;或者其他格式的文件。&lt;/p&gt;

&lt;h2 id=&#34;autoload&#34;&gt;autoload&lt;/h2&gt;

&lt;p&gt;autoload 在 emacs 中也是一种类型，和符号、数字、字符串、函数是同等级别的对象，实际上，它就是个函数。它和函数的区别类似于函数原型和函数的区别——没有实际的定义，只有简单说明， 调用的时候才加载相关定义。&lt;br /&gt;
有两种定义方式：&lt;br /&gt;
1. (autoload &amp;lsquo;some-function &amp;ldquo;some-file&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;autoload 对象需要用 autoload 函数生成，类似下面这种：(autoload &amp;lsquo;fn &amp;ldquo;file&amp;rdquo; &amp;ldquo;docstring&amp;rdquo; interactive type)&lt;br /&gt;
参数包含：&lt;br /&gt;
      fn （没有名称你敢怎么调用）&lt;br /&gt;
      file （具体定义实际存储的位置）&lt;br /&gt;
      docstring （使用说明）&lt;br /&gt;
      interactive （如果非 nil 表示可以通过交互方式调用）&lt;br /&gt;
      type （类型：函数、宏、键图）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Magic comments&lt;/strong&gt; &lt;code&gt;;;;###autoload&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;把你所有的非emacs自带函数集中起来，放到一个文件夹里；&lt;br /&gt;
然后拆分成许多文件（每个文件里的函数建议不要超过5个），然后函数前面加上 &lt;strong&gt;Magic comments&lt;/strong&gt; &lt;code&gt;;;;###autoload&lt;/code&gt; ，在你的配置文件里写：&lt;br /&gt;
;假设你的这个文件夹路径为 /x/y/z&lt;br /&gt;
&lt;code&gt;(lazily &amp;quot;/x/y/z&amp;quot;)&lt;/code&gt;&lt;br /&gt;
通俗的说，效果就是，给这些文件里面的函数生成一个路径表，这些函数文件都不用读取了，只读取这个路径表，用到这些函数的时候再根据这个路径表读取所在文件，对于加快 emacs 的启动速度有一定帮助&lt;/p&gt;

&lt;p&gt;##3.5 Use-package&lt;br /&gt;
默认 不加参数相当于 require&lt;/p&gt;

&lt;p&gt;它把各种配置整合到属性里面去&lt;br /&gt;
:commands (isearch-moccur isearch-all) == autoload&lt;br /&gt;
  当包的作者已经不更新时，你可以通过:commands创建自己的autoload引用。推迟到使用他们时在去加载&lt;br /&gt;
:init  == pre-init&lt;br /&gt;
   不管什么情况下,init代码块都会执行,即使use-package调用包不存在，也会执行。并且调用时立即执行。&lt;br /&gt;
:defer t == lazyload&lt;br /&gt;
  使用package本身提供的autoload命令延迟package的加载。实现lazyload 本质上，这就是一个空操作。&lt;br /&gt;
:config == post-init&lt;br /&gt;
  当启用defer后 :init依然会立即执行，但是:config块会延迟到package加载完成之后执行。 因此defer和config盘配合起来使用相当于&lt;code&gt;with-eval-after-load&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用-spacemacs-use-package-add-hook-注入-use-package-hooks&#34;&gt;使用&lt;code&gt;spacemacs|use-package-add-hook&lt;/code&gt; 注入&lt;code&gt;Use-package&lt;/code&gt; hooks&lt;/h3&gt;

&lt;p&gt;(spacemacs|use-package-add-hook helm&lt;br /&gt;
  :pre-init 注入use-package :init&lt;br /&gt;
  ;; Code&lt;br /&gt;
  :post-init&lt;br /&gt;
  ;; Code&lt;br /&gt;
  :pre-config&lt;br /&gt;
  ;; Code&lt;br /&gt;
  :post-config&lt;br /&gt;
  ;; Code&lt;br /&gt;
  )&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;use-package&lt;/code&gt;被调用时立即执行:init块代码，因此任何想要将代码注入此块的函数必须在调用use-package之前运行。&lt;br /&gt;
此外，由于对use-package的调用通常发生在&lt;code&gt;init-&amp;lt;package&amp;gt;&lt;/code&gt;函数中，&lt;br /&gt;
而对&lt;code&gt;spacemacs|use-package-add-hook&lt;/code&gt;的调用通常发生在&lt;code&gt;pre-init-&amp;lt;package&amp;gt;&lt;/code&gt;函数中，而不在&lt;code&gt;post-init-&amp;lt;package&amp;gt;&lt;/code&gt; 中。&lt;br /&gt;
所以嘛，&lt;code&gt;spacemacs|use-package-add-hook&lt;/code&gt;当然最好在&lt;code&gt;pre-init-&amp;lt;package&amp;gt;&lt;/code&gt;中。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>spacemacs 如何自定义engine搜索</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-spacemacs-%E5%90%AF%E7%94%A8%E5%AD%97%E5%85%B8/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-spacemacs-%E5%90%AF%E7%94%A8%E5%AD%97%E5%85%B8/</guid>
            <description>&lt;pre&gt;&lt;code&gt;(defconst jerry-packages  
  &#39;(  
    chinese-pyim-greatdict  
    ))  

(defun jerry/init-chinese-pyim-greatdict ()  
  (use-package chinese-pyim-greatdict)  
  )  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;;;; init-chinese.el --- 中文输入法  
;;; Commentary:  
;;; Code:  

;; chinese-fonts-setup -- 中文字体问题  
(use-package chinese-fonts-setup  
  ;; :disabled t  
  :if (window-system)  
  :demand t  
  :config  
  (chinese-fonts-setup-enable)  
  (setq cfs-use-face-font-rescale t)  
  )  

;; chineas-pyim -- 中文输入  
(use-package chinese-pyim  
  :disabled t  
  ;; :demand t  
  :config  
  ;; 使用basedict拼音词库  
  (use-package chinese-pyim-basedict  
	:demand t  
	:config  
	(chinese-pyim-basedict-enable)  

	;; 开始真正配置  
	(setq default-input-method &amp;quot;chinese-pyim&amp;quot;)  
	;; 全拼  
	(setq pyim-default-scheme &#39;quanpin)  

	;; 设置 pyim 探针设置，这是 pyim 高级功能设置，可以实现 *无痛* 中英文切换 :-)  
	;; 我自己使用的中英文动态切换规则是：  
	;; 1. 光标只有在注释里面时，才可以输入中文。  
	;; 2. 光标前是汉字字符时，才能输入中文。  
	;; 3. 使用 M-j 快捷键，强制将光标前的拼音字符串转换为中文。  
	(setq-default pyim-english-input-switch-functions  
				  &#39;(pyim-probe-dynamic-english  
					pyim-probe-isearch-mode  
					pyim-probe-program-mode  
					pyim-probe-org-structure-template))  

	(setq-default pyim-punctuation-half-width-functions  
				  &#39;(pyim-probe-punctuation-line-beginning  
					pyim-probe-punctuation-after-punctuation))  

	;; 开启拼音搜索功能  
	(setq pyim-isearch-enable-pinyin-search t)  

	;; 使用 pupup-el 来绘制选词框  
	(setq pyim-page-tooltip &#39;popup)  

	;; 选词框显示5个候选词  
	(setq pyim-page-length 5)  

	;; 让 Emacs 启动时自动加载 pyim 词库  
	(add-hook &#39;emacs-startup-hook  
			  #&#39;(lambda () (pyim-restart-1 t)))  
	:bind  
	((&amp;quot;M-j&amp;quot; . pyim-convert-code-at-point) ;与 pyim-probe-dynamic-english 配合  
	 (&amp;quot;C-;&amp;quot; . pyim-delete-word-from-personal-buffer))  
	)  
  )  

(provide &#39;init-chinese)  
;;; init-chinese.el ends here  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;;; Auto generated by chinese-fonts-setup  
;; &amp;lt;https://github.com/tumashu/chinese-fonts-setup&amp;gt;  
(set-face-attribute  
 &#39;default nil  
 :font (font-spec :name &amp;quot;-ADBO-Source Code Pro-normal-normal-normal-*-*-*-*-*-m-0-iso10646-1&amp;quot;  
                  :weight &#39;normal  
                  :slant &#39;normal  
                  :size 11.5))  
(dolist (charset &#39;(kana han symbol cjk-misc bopomofo))  
  (set-fontset-font  
   (frame-parameter nil &#39;font)  
   charset  
   (font-spec :name &amp;quot;-WQYF-文泉驿等宽微米黑-normal-normal-normal-*-*-*-*-*-*-0-iso10646-1&amp;quot;  
              :weight &#39;normal  
              :slant &#39;normal  
              :size 13.5)))  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>spacemacs 如何自定义engine搜索</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-spacemacs-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89engine%E6%90%9C%E7%B4%A2/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-spacemacs-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89engine%E6%90%9C%E7%B4%A2/</guid>
            <description>

&lt;p&gt;spacemacs 如何自定义engine搜索&lt;/p&gt;

&lt;h2 id=&#34;方式1-spacemacs&#34;&gt;方式1 .spacemacs&lt;/h2&gt;

&lt;p&gt;(defun dotspacemacs/user-config ()&lt;/p&gt;

&lt;p&gt;;; 1. 定义搜索引擎&lt;br /&gt;
  (defengine spotify &amp;ldquo;&lt;a href=&#34;https://play.spotify.com/search/%s&amp;quot;&#34; target=&#34;_blank&#34;&gt;https://play.spotify.com/search/%s&amp;quot;&lt;/a&gt;)&lt;br /&gt;
  ;; 2. 添加搜索引擎&lt;br /&gt;
  (add-to-list &amp;lsquo;search-engine-alist&lt;br /&gt;
          &amp;lsquo;(spotify&lt;br /&gt;
          :name &amp;ldquo;Spotify&amp;rdquo;&lt;br /&gt;
          :url &amp;ldquo;&lt;a href=&#34;https://play.spotify.com/search/%s&amp;quot;))&#34; target=&#34;_blank&#34;&gt;https://play.spotify.com/search/%s&amp;quot;))&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;)&lt;/p&gt;

&lt;h2 id=&#34;方式2-自定义layer中配置&#34;&gt;方式2 自定义layer中配置&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/appleshan/my-spacemacs-config&#34; target=&#34;_blank&#34;&gt;appleshan/my-spacemacs-config: My personal Spacemacs config&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(defun appleshan-programming/post-init-engine-mode ()&lt;br /&gt;
  (add-to-list &amp;lsquo;search-engine-alist&lt;br /&gt;
    ;; elisp code search&lt;br /&gt;
    &amp;lsquo;(Elisp&lt;br /&gt;
         :name &amp;ldquo;Elisp code search&amp;rdquo;&lt;br /&gt;
         :url &amp;ldquo;&lt;a href=&#34;http://www.google.com.au/search?q=%s+filetype:el&amp;quot;)&#34; target=&#34;_blank&#34;&gt;http://www.google.com.au/search?q=%s+filetype:el&amp;quot;)&lt;/a&gt;&lt;br /&gt;
    ;; javascript search on mozilla.org&lt;br /&gt;
    &amp;lsquo;(Elisp&lt;br /&gt;
         :name &amp;ldquo;Javascript search on mozilla.org&amp;rdquo;&lt;br /&gt;
         :url &amp;ldquo;&lt;a href=&#34;http://www.google.com.au/search?q=%s+site:developer.mozilla.org&amp;quot;)&#34; target=&#34;_blank&#34;&gt;http://www.google.com.au/search?q=%s+site:developer.mozilla.org&amp;quot;)&lt;/a&gt;&lt;br /&gt;
    ))&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>vim abbreviation</title>
            <link>//blog.pytool.com/edit/vim-%E7%BC%A9%E5%86%99abbreviation/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/vim-%E7%BC%A9%E5%86%99abbreviation/</guid>
            <description>&lt;p&gt;Vim有一句哲学是这样说的：“if you write a thing once,it it okay,However,if you&amp;rsquo;re writing it twice or more times,then you should find a better way to do it&amp;rdquo;。这句话估计也是引用软件开发里面的DRP（Don&amp;rsquo;t Repeat Yourself）原则。如果你老是需要重复的写一些相同的东西，此时你就应该使用&lt;strong&gt;abbreviation（缩写）&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;:abbreviate 作用于所有模式   （ab）&lt;br /&gt;
 :iabbrev    仅作用于插入模式 （iab）&lt;br /&gt;
 :cabbrev    仅作用于命令行模式（cab）&lt;/p&gt;

&lt;p&gt;abbreviation可以用在很多有意思的地方，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;纠正错误的拼写::iabbr teh the  
程序中你能想到的模版语句：:iabbr forx for(x=0;x&amp;lt;100;x++){&amp;lt;cr&amp;gt;&amp;lt;cr&amp;gt;}  
简化命令的输入：cabbr cse colorscheme evening  

如果你是Java程序员，如下命令毫不逊色于Eclipse  
写程序追求的高内聚，低耦合，同样，毫无疑问，Vim也遵循同样的原则，如果我们有上十条百条这样的缩写命令，如果都挤在vimrc配置文件中，这样过显得很难管理，因此我们可以把专门用于缩写的命令放置在单独的文件中，然后在vimrc文件中引用就ok，:source $VIM/abbreviation.vim  

你有没有想过一个问题，如果把forx设置成了缩写格式，那么有时候我本意是输入&#39;forx&#39;呢？  

    方法一：就是把它的映射取消掉una forx，这样有个缺点是下次我又需要这个缩写了，这时又不得不重新捡回来。  

    方法二：写一个函数，在每次输入&#39;forx&#39;的时候询问是作为普通字符串还是作为缩写呢？函数如下：  

    function! s:forxAsk(abbr,expansion)  
      let answer = confirm(&amp;quot;使用缩写&#39;&amp;quot; . a:abbr .&amp;quot;&#39;?&amp;quot;,  
                             &amp;quot;&amp;amp;Yes\n&amp;amp;No&amp;quot;,1)  
      return answer ==1 ? a:expansion : a:abbr  
    endfunction  

    iabbrev &amp;lt;expr&amp;gt; forx &amp;lt;SID&amp;gt;forxAsk(&#39;forx&#39;,&#39;for(x=0;x&amp;lt;100;x++)&#39;)  

    函数中abbr是缩写，expansion就是全写，这样一来，每次输入forx时，就会弹出一对话框询问你是使用缩写还写不使用。当然这种方式显得比较笨拙，另外一个目的也是告诉大家如果写函数。  

    方法三：使出杀手锏，输入forx完成后，按Ctrl-v（windows系统按Ctrl-q）就能避免尴尬了。  
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>vim marks</title>
            <link>//blog.pytool.com/edit/vim-marks/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/vim-marks/</guid>
            <description>

&lt;p&gt;在追踪代码时，经常跳转到很多新文件中，想回到原点时就比较麻烦了，这时候就需要 “书签” 了。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;bookmarks&#34;&gt;Bookmarks&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;用 &lt;code&gt;:help marks&lt;/code&gt; 来查看关于书签的说明：&lt;/p&gt;

&lt;p&gt;书签可以分为 3 类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;lowercase marks&lt;/p&gt;

&lt;p&gt;书签名只能为 &amp;lsquo;a - &amp;lsquo;z，只在所在文件内有效，不能在文件之间跳转，不同书签名不能包含有相同字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;uppercase  marks&lt;/p&gt;

&lt;p&gt;书签名只能为 &amp;lsquo;A - &amp;lsquo;Z，也叫文件书签，可以在文件之间跳转，不同书签名不能包含有相同字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;numbered marks&lt;/p&gt;

&lt;p&gt;书签名只能为 &amp;lsquo;0 - &amp;lsquo;9，用 &lt;code&gt;.viminfor&lt;/code&gt; 文件来设置&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用字母 a-zA-Z 建立的书签能被保存下来，再次打开时仍然存在，而用数字 0-9 建立的书签在关闭文件后就被删除了，不能恢复，所以 一般使用 a-zA-Z 更多一点吧。&lt;/p&gt;

&lt;p&gt;知道这些最基本的东西就可以顺利使用书签了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;help 文档中说 numbered marks 不能手动设置，实际上是可以的，不知道是不是我理解错了，不过这个应该不影响平常的使用。&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;常用的几个 Vim 内置的书签命令如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设置书签 &lt;code&gt;m{a-zA-Z}&lt;/code&gt;，如 ma&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除书签 &lt;code&gt;delm {marks}&lt;/code&gt;，如 delm a&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;跳转书签&lt;/p&gt;

&lt;p&gt;跳转有两种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用 backtick 键（数字 1 键左边），跳转到设置书签时光标所在的行和列，如 `a&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用单引号 &lt;code&gt;&#39;&lt;/code&gt;，跳转到书签所在行的第一个非空字符处（不包含列信息），如 &amp;lsquo;a&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;`` 回到到上次修改的位置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列出所有书签 &lt;code&gt;:marks&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;vim-signature&#34;&gt;Vim-signature&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;使用 Vim 书签时，最大的不方便之处是：书签是不可见的，也就是说我们输入命令之后，是无法看到书签是否建立成功了，外观上是看不出书签行和普通行的区别的。还好有个很不错的插件 &lt;a href=&#34;https://github.com/kshenoy/vim-signature&#34; target=&#34;_blank&#34;&gt;vim-signature&lt;/a&gt; 可以帮助我们实现可视化的书签。&lt;/p&gt;

&lt;p&gt;在 github 项目上有这个插件的简单介绍，另外在 Vim 中也可以看 help 文档查阅详细帮助，这里只记录我用到简单配置。&lt;/p&gt;

&lt;h3 id=&#34;install&#34;&gt;Install&lt;/h3&gt;

&lt;p&gt;使用这个插件需要 vim 支持 sign 特性，使用命令 &lt;code&gt;:echo has(&#39;signs&#39;)&lt;/code&gt; 来查看 vim 是否支持这个特性，如果结果是 1，则支持，如果结果是 0，需要重新编译 vim。&lt;/p&gt;

&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bundle &#39;vim-signature&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;:help signature&lt;/code&gt; 可以查看帮助文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mx           Toggle mark &#39;x&#39; and display it in the leftmost column  
dmx          Remove mark &#39;x&#39; where x is a-zA-Z  

m,           Place the next available mark  
m.           If no mark on line, place the next available mark. Otherwise, remove (first)     existing mark.  
m-           Delete all marks from the current line  
m&amp;lt;Space&amp;gt;     Delete all marks from the current buffer  
]`           Jump to next mark  
[`           Jump to prev mark  
]&#39;           Jump to start of next line containing a mark  
[&#39;           Jump to start of prev line containing a mark  
`]           Jump by alphabetical order to next mark  
`[           Jump by alphabetical order to prev mark  
&#39;]           Jump by alphabetical order to start of next line having a mark  
&#39;[           Jump by alphabetical order to start of prev line having a mark  
m/           Open location list and display marks from current buffer  

m[0-9]       Toggle the corresponding marker !@#$%^&amp;amp;*()  
m&amp;lt;S-[0-9]&amp;gt;   Remove all markers of the same type  
]-           Jump to next line having a marker of the same type  
[-           Jump to prev line having a marker of the same type  
]=           Jump to next line having a marker of any type  
[=           Jump to prev line having a marker of any type  
m?           Open location list and display markers from current buffer  
m&amp;lt;BS&amp;gt;        Remove all markers  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而且 help 中列出了具体配置，我们可以对其修改，自定义快捷键。总结一下我常用的操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设置书签 &lt;code&gt;mx&lt;/code&gt;，比如 ma&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除书签&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接在目标行重新输入 &lt;code&gt;mx&lt;/code&gt;，旧书签就会被删除，并且设定到光标所在行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将光标移动到旧书签行，重新输入 &lt;code&gt;mx&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除所有 lowercase + uppercase marks，&lt;code&gt;m&amp;lt;Space&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除所有 numbered marks，&lt;code&gt;m&amp;lt;BS&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;跳转书签&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;]`，跳转到前一个书签&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[`，跳转到后一个书签&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;]-，跳转到之前同一类型的 numbered marks 书签行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[-，跳转到之后同一类型的 numbered marks 书签行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;ref&#34;&gt;Ref&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kshenoy/vim-signature&#34; target=&#34;_blank&#34;&gt;vim-signature&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tuicool.com/articles/f6feae&#34; target=&#34;_blank&#34;&gt;像 IDE 一样使用 Vim&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>vim 最佳实践</title>
            <link>//blog.pytool.com/edit/vim-best-tips/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/vim-best-tips/</guid>
            <description>

&lt;h2 id=&#34;vimtips-txt-for-vim-version-8-0&#34;&gt;vimtips.txt*    For Vim version 8.0.&lt;/h2&gt;

&lt;p&gt;&amp;rdquo; new items marked [N] , corrected items marked [C]&lt;br /&gt;
&amp;rdquo; &lt;em&gt;best-searching&lt;/em&gt;&lt;br /&gt;
/joe/e                      : cursor set to End of match&lt;br /&gt;
3/joe/e+1                   : find 3rd joe cursor set to End of match plus 1 [C]&lt;br /&gt;
/joe/s-2                    : cursor set to Start of match minus 2&lt;br /&gt;
/joe/+3                     : find joe move cursor 3 lines down&lt;br /&gt;
/^joe.*fred.*bill/          : find joe AND fred AND Bill (Joe at start of line)&lt;br /&gt;
/&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:A-J&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:A-J&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;/                    : search for lines beginning with one or more A-J&lt;br /&gt;
/begin_.*end               : search over possible multiple lines&lt;br /&gt;
/fred_s*joe/               : any whitespace including newline [C]&lt;br /&gt;
/fred|joe                  : Search for FRED OR JOE&lt;br /&gt;
/.*fred&amp;amp;.&lt;em&gt;joe              : Search for FRED AND JOE in any ORDER!&lt;br /&gt;
/&amp;lt;fred&amp;gt;/                  : search for fred but not alfred or frederick [C]&lt;br /&gt;
/&amp;lt;\d\d\d\d&amp;gt;               : Search for exactly 4 digit numbers&lt;br /&gt;
/\D\d\d\d\d\D               : Search for exactly 4 digit numbers&lt;br /&gt;
/&amp;lt;\d{4}&amp;gt;                 : same thing&lt;br /&gt;
/([^0-9]|^)%.&lt;/em&gt;%          : Search for absence of a digit or beginning of line&lt;br /&gt;
&amp;rdquo; finding empty lines&lt;br /&gt;
/^\n{3}                    : find 3 empty lines&lt;br /&gt;
/^str.&lt;em&gt;\nstr                : find 2 successive lines starting with str&lt;br /&gt;
/(^str.&lt;/em&gt;\n){2}           : find 2 successive lines starting with str&lt;br /&gt;
&amp;rdquo; using rexexp memory in a search find fred.*joe.*joe.*fred &lt;em&gt;C&lt;/em&gt;&lt;br /&gt;
/(fred).&lt;em&gt;(joe).&lt;/em&gt;\2.&lt;em&gt;\1&lt;br /&gt;
&amp;rdquo; Repeating the Regexp (rather than what the Regexp finds)&lt;br /&gt;
/^([^,]&lt;/em&gt;,){8}&lt;br /&gt;
&amp;rdquo; visual searching&lt;br /&gt;
:vmap // y/&lt;C-R&gt;&amp;ldquo;&lt;CR&gt;       : search for visually highlighted text&lt;br /&gt;
:vmap &lt;silent&gt; //    y/&lt;C-R&gt;=escape(@&amp;ldquo;, &amp;lsquo;\/.&lt;em&gt;$^~[]&amp;lsquo;)&lt;CR&gt;&lt;CR&gt; : with spec chars&lt;br /&gt;
&amp;rdquo; \zs and \ze regex delimiters :h /\zs&lt;br /&gt;
/&amp;lt;\zs[^&amp;gt;]&lt;/em&gt;\ze&amp;gt;              : search for tag contents, ignoring chevrons&lt;br /&gt;
&amp;rdquo; zero-width :h /\@=&lt;br /&gt;
/&amp;lt;\@&amp;lt;=[^&amp;gt;]&lt;em&gt;&amp;gt;\@=             : search for tag contents, ignoring chevrons&lt;br /&gt;
/&amp;lt;\@&amp;lt;=_[^&amp;gt;]&lt;/em&gt;&amp;gt;\@=           : search for tags across possible multiple lines&lt;br /&gt;
&amp;rdquo; searching over multiple lines _ means including newline&lt;br /&gt;
/&lt;!--\_p\{-}--&gt;                   : search for multiple line comments&lt;br /&gt;
/fred_s*joe/                     : any whitespace including newline &lt;em&gt;C&lt;/em&gt;&lt;br /&gt;
/bugs(_.)*bunny                : bugs followed by bunny anywhere in file&lt;br /&gt;
:h _                             : help&lt;br /&gt;
&amp;rdquo; search for declaration of subroutine/function under cursor&lt;br /&gt;
:nmap gx yiw/^(sub&amp;lt;bar&amp;gt;function)\s+&lt;C-R&gt;&amp;ldquo;&lt;CR&gt;&lt;br /&gt;
&amp;rdquo; multiple file search&lt;br /&gt;
:bufdo /searchstr/                : use :rewind to recommence search&lt;br /&gt;
&amp;rdquo; multiple file search better but cheating&lt;br /&gt;
:bufdo %s/searchstr/&amp;amp;/gic   : say n and then a to stop&lt;br /&gt;
&amp;rdquo; How to search for a URL without backslashing&lt;br /&gt;
?&lt;a href=&#34;http://www.vim.org/&#34; target=&#34;_blank&#34;&gt;http://www.vim.org/&lt;/a&gt;        : (first) search BACKWARDS!!! clever huh!&lt;br /&gt;
&amp;rdquo; Specify what you are NOT searching for (vowels)&lt;br /&gt;
/\c\v([^aeiou]&amp;amp;\a){4}       : search for 4 consecutive consonants&lt;br /&gt;
/\%&amp;gt;20l\%&lt;30lgoat           : Search for goat between lines 20 and 30 [N]  
/^.\{-}home.\{-}\zshome/e   : match only the 2nd occurence in a line of &#34;home&#34; [N]  
:%s/home.\{-}\zshome/alone  : Substitute only the 2nd occurrence of home in any line [U]  
&#34; find str but not on lines containing tongue  
^\(.*tongue.*\)\@!.*nose.*$  
\v^((tongue)@!.)*nose((tongue)@!.)*$  
.*nose.*\&amp;^\%(\%(tongue\)\@!.\)*$  
:v/tongue/s/nose/&amp;/gic  
&#39;a,&#39;bs/extrascost//gc       : trick: restrict search to between markers (answer n) [N]  
/integ&lt;C-L&gt;                 : Control-L to complete search term [N]&lt;br /&gt;
&amp;rdquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;br /&gt;
&amp;rdquo; &lt;em&gt;best-substitution&lt;/em&gt;&lt;br /&gt;
:%s/fred/joe/igc            : general substitute command&lt;br /&gt;
:%s//joe/igc                : Substitute what you last searched for [N]&lt;br /&gt;
:%s/~/sue/igc               : Substitute your last replacement string [N]&lt;br /&gt;
:%s/\r//g                   : Delete DOS returns ^M&lt;br /&gt;
&amp;rdquo; Is your Text File jumbled onto one line? use following&lt;br /&gt;
:%s/\r/\r/g                 : Turn DOS returns ^M into real returns&lt;br /&gt;
:%s=  &lt;em&gt;$==                  : delete end of line blanks&lt;br /&gt;
:%s= +$==                  : Same thing&lt;br /&gt;
:%s#\s&lt;/em&gt;\r\?$##              : Clean both trailing spaces AND DOS returns&lt;br /&gt;
:%s#\s&lt;em&gt;\r&lt;/em&gt;$##               : same thing&lt;br /&gt;
&amp;rdquo; deleting empty lines&lt;br /&gt;
:%s/^\n{3}//               : delete blocks of 3 empty lines&lt;br /&gt;
:%s/^\n+/\r/               : compressing empty lines&lt;br /&gt;
:%s#&amp;lt;[^&amp;gt;]+&amp;gt;##g             : delete html tags, leave text (non-greedy)&lt;br /&gt;
:%s#&amp;lt;_.{-1,}&amp;gt;##g          : delete html tags possibly multi-line (non-greedy)&lt;br /&gt;
:%s#.&lt;em&gt;(\d+hours).&lt;/em&gt;#\1#   : Delete all but memorised string (\1) [N]&lt;br /&gt;
&amp;rdquo; parse xml/soap&lt;br /&gt;
%s#&amp;gt;&amp;lt;([^/])#&amp;gt;\r&amp;lt;\1#g      : split jumbled up XML file into one tag per line [N]&lt;br /&gt;
%s/&amp;lt;/\r&amp;amp;/g                  : simple split of html/xml/soap  [N]&lt;br /&gt;
:%s#&amp;lt;[^/]#\r&amp;amp;#gic           : simple split of html/xml/soap  but not closing tag [N]&lt;br /&gt;
:%s#&amp;lt;[^/]#\r&amp;amp;#gi            : parse on open xml tag [N]&lt;br /&gt;
:%s#[\d+]#\r&amp;amp;#g          : parse on numbered array elements [1] [N]&lt;br /&gt;
ggVGgJ                      : rejoin XML without extra spaces (gJ) [N]&lt;br /&gt;
%s=\n#\d=\r&amp;amp;=g             : parse PHP error stack [N]&lt;br /&gt;
:%s#^[^\t]+\t##            : Delete up to and including first tab [N]&lt;br /&gt;
&amp;rdquo; VIM Power Substitute&lt;br /&gt;
:&amp;lsquo;a,&amp;lsquo;bg/fred/s/dick/joe/igc : VERY USEFUL&lt;br /&gt;
&amp;rdquo; duplicating columns&lt;br /&gt;
:%s= [^ ]+$=&amp;amp;&amp;amp;=            : duplicate end column&lt;br /&gt;
:%s= \f+$=&amp;amp;&amp;amp;=              : Dupicate filename&lt;br /&gt;
:%s= \S+$=&amp;amp;&amp;amp;               : usually the same&lt;br /&gt;
&amp;rdquo; memory&lt;br /&gt;
:%s#example#&amp;amp; = &amp;amp;#gic        : duplicate entire matched string [N]&lt;br /&gt;
:%s#.&lt;em&gt;(tbl_\w+).&lt;/em&gt;#\1#    : extract list of all strings tbl&lt;em&gt;* from text  [NC]&lt;br /&gt;
:s/(.&lt;em&gt;):(.&lt;/em&gt;)/\2 : \1/   : reverse fields separated by :&lt;br /&gt;
:%s/^(.&lt;em&gt;)\n\1$/\1/        : delete duplicate lines&lt;br /&gt;
:%s/^(.&lt;/em&gt;)(\n\1)+$/\1/  : delete multiple duplicate lines [N]&lt;br /&gt;
&amp;rdquo; non-greedy matching {-}&lt;br /&gt;
:%s/^.{-}pdf/new.pdf/      : delete to 1st occurence of pdf only (non-greedy)&lt;br /&gt;
%s#^.{-}([0-9]{3,4}serial)#\1#gic : delete up to 123serial or 1234serial [N]&lt;br /&gt;
&amp;rdquo; use of optional atom \?&lt;br /&gt;
:%s#&amp;lt;[zy]\?tbl&lt;/em&gt;[a-z_]+&amp;gt;#\L&amp;amp;#gc : lowercase with optional leading characters&lt;br /&gt;
&amp;rdquo; over possibly many lines&lt;br /&gt;
:%s/&lt;!--\_.\{-}--&gt;//        : delete possibly multi-line comments&lt;br /&gt;
:help /{-}                 : help non-greedy&lt;br /&gt;
&amp;rdquo; substitute using a register&lt;br /&gt;
:s/fred/&lt;c-r&gt;a/g            : sub &amp;ldquo;fred&amp;rdquo; with contents of register &amp;ldquo;a&amp;rdquo;&lt;br /&gt;
:s/fred/&lt;c-r&gt;asome_text&lt;c-r&gt;s/g&lt;br /&gt;
:s/fred/\=@a/g              : better alternative as register not displayed (not &lt;em&gt;) [C]&lt;br /&gt;
:s/fred/\=@&lt;/em&gt;/g              : replace string with contents of paste register [N]&lt;br /&gt;
&amp;rdquo; multiple commands on one line&lt;br /&gt;
:%s/\f+.gif&amp;gt;/\r&amp;amp;\r/g | v/.gif$/d | %s/gif/jpg/&lt;br /&gt;
:%s/a/but/gie|:update|:next : then use @: to repeat&lt;br /&gt;
&amp;rdquo; ORing&lt;br /&gt;
:%s/goat|cow/sheep/gc      : ORing (must break pipe)&lt;br /&gt;
:&amp;lsquo;a,&amp;lsquo;bs#[|]##g           : remove [] from lines between markers a and b [N]&lt;br /&gt;
:%s/\v(.&lt;em&gt;\n){5}/&amp;amp;\r         : insert a blank line every 5 lines [N]&lt;br /&gt;
&amp;rdquo; Calling a VIM function&lt;br /&gt;
:s/&lt;strong&gt;date&lt;/strong&gt;/\=strftime(&amp;ldquo;%c&amp;rdquo;)/ : insert datestring&lt;br /&gt;
:inoremap \zd &lt;C-R&gt;=strftime(&amp;ldquo;%d%b%y&amp;rdquo;)&lt;CR&gt;    : insert date eg 31Jan11 [N]&lt;br /&gt;
&amp;rdquo; Working with Columns sub any str1 in col3&lt;br /&gt;
:%s:((\w+\s+){2})str1:\1str2:&lt;br /&gt;
&amp;rdquo; Swapping first &amp;amp; last column (4 columns)&lt;br /&gt;
:%s:(\w+)(.&lt;/em&gt;\s+)(\w+)$:\3\2\1:&lt;br /&gt;
&amp;rdquo; format a mysql query&lt;br /&gt;
:%s#&amp;lt;from&amp;gt;|&amp;lt;where&amp;gt;|&amp;lt;left join&amp;gt;|&amp;lt;\inner join&amp;gt;#\r&amp;amp;#g&lt;br /&gt;
&amp;rdquo; filter all form elements into paste register&lt;br /&gt;
:redir @&lt;em&gt;|sil exec &amp;lsquo;g#&amp;lt;(input|select|textarea|/\=form)&amp;gt;#p&amp;rsquo;|redir END&lt;br /&gt;
:nmap ,z :redir @&lt;/em&gt;&lt;Bar&gt;sil exec &amp;lsquo;g@&amp;lt;(input&amp;lt;Bar&amp;gt;select&amp;lt;Bar&amp;gt;textarea&amp;lt;Bar&amp;gt;/\=form)&amp;gt;@p&amp;rsquo;&lt;Bar&gt;redir END&lt;CR&gt;&lt;br /&gt;
&amp;rdquo; substitute string in column 30 [N]&lt;br /&gt;
:%s/^(.{30})xx/\1yy/&lt;br /&gt;
&amp;rdquo; decrement numbers by 3&lt;br /&gt;
:%s/\d+/\=(submatch(0)-3)/&lt;br /&gt;
&amp;rdquo; increment numbers by 6 on certain lines only&lt;br /&gt;
:g/loc|function/s/\d/\=submatch(0)+6/&lt;br /&gt;
&amp;rdquo; better&lt;br /&gt;
:%s#txtdev\zs\d#\=submatch(0)+1#g&lt;br /&gt;
:h /\zs&lt;br /&gt;
&amp;rdquo; increment only numbers gg\d\d  by 6 (another way)&lt;br /&gt;
:%s/(gg)\@&amp;lt;=\d+/\=submatch(0)+6/&lt;br /&gt;
:h zero-width&lt;br /&gt;
&amp;rdquo; rename a string with an incrementing number&lt;br /&gt;
:let i=10 | &amp;lsquo;a,&amp;lsquo;bg/Abc/s/yy/\=i/ |let i=i+1 # convert yy to 10,11,12 etc&lt;br /&gt;
&amp;rdquo; as above but more precise&lt;br /&gt;
:let i=10 | &amp;lsquo;a,&amp;lsquo;bg/Abc/s/xx\zsyy\ze/\=i/ |let i=i+1 # convert xxyy to xx11,xx12,xx13&lt;br /&gt;
&amp;rdquo; find replacement text, put in memory, then use \zs to simplify substitute&lt;br /&gt;
:%s/&amp;rdquo;([^.]+).&lt;em&gt;\zsxx/\1/&lt;br /&gt;
&amp;rdquo; Pull word under cursor into LHS of a substitute&lt;br /&gt;
:nmap &lt;leader&gt;z :%s#&amp;lt;&lt;c-r&gt;=expand(&amp;rdquo;&lt;cword&gt;&amp;rdquo;)&lt;cr&gt;&amp;gt;#&lt;br /&gt;
&amp;rdquo; Pull Visually Highlighted text into LHS of a substitute&lt;br /&gt;
:vmap &lt;leader&gt;z :&lt;C-U&gt;%s/&amp;lt;&lt;c-r&gt;&lt;/em&gt;&amp;gt;/&lt;br /&gt;
&amp;rdquo; substitute singular or plural&lt;/p&gt;

&lt;h2 id=&#34;a-bs-bucket-s-bowl-1-gic-n&#34;&gt;:&amp;lsquo;a,&amp;lsquo;bs/bucket(s)*/bowl\1/gic   [N]&lt;/h2&gt;

&lt;p&gt;&amp;rdquo; all following performing similar task, substitute within substitution&lt;br /&gt;
&amp;rdquo; Multiple single character substitution in a portion of line only&lt;br /&gt;
:%s,(all/.&lt;em&gt;)\@&amp;lt;=/,_,g     : replace all / with _ AFTER &amp;ldquo;all/&amp;rdquo;&lt;br /&gt;
&amp;rdquo; Same thing&lt;br /&gt;
:s#all/\zs.&lt;/em&gt;#\=substitute(submatch(0), &amp;lsquo;/&amp;rsquo;, &amp;lsquo;&lt;em&gt;&amp;rsquo;, &amp;lsquo;g&amp;rsquo;)#&lt;br /&gt;
&amp;rdquo; Substitute by splitting line, then re-joining&lt;br /&gt;
:s#all/#&amp;amp;^M#|s#/#&lt;/em&gt;#g|-j!&lt;br /&gt;
&amp;rdquo; Substitute inside substitute&lt;/p&gt;

&lt;h2 id=&#34;s-cp-submatch-0-all-substitute-submatch-0-g&#34;&gt;:%s/.*/\=&amp;lsquo;cp &amp;lsquo;.submatch(0).&amp;rsquo; all/&amp;lsquo;.substitute(submatch(0),&amp;rsquo;/&amp;lsquo;,&amp;rsquo;_&amp;lsquo;,&amp;lsquo;g&amp;rsquo;)/&lt;/h2&gt;

&lt;p&gt;&amp;rdquo; &lt;em&gt;best-global&lt;/em&gt; command&lt;br /&gt;
:g/gladiolli/#              : display with line numbers (YOU WANT THIS!)&lt;br /&gt;
:g/fred.*joe.&lt;em&gt;dick/         : display all lines fred,joe &amp;amp; dick&lt;br /&gt;
:g/&amp;lt;fred&amp;gt;/                : display all lines fred but not freddy&lt;br /&gt;
:g/^\s&lt;/em&gt;$/d                  : delete all blank lines&lt;br /&gt;
:g!/^dd/d                   : delete lines not containing string&lt;br /&gt;
:v/^dd/d                    : delete lines not containing string&lt;br /&gt;
:g/joe/,/fred/d             : not line based (very powerfull)&lt;br /&gt;
:g/fred/,/joe/j             : Join Lines [N]&lt;br /&gt;
:g/&amp;mdash;&amp;mdash;-/.-10,.d          : Delete string &amp;amp; 10 previous lines&lt;br /&gt;
:g/{/ ,/}/- s/\n+/\r/g     : Delete empty lines but only between {&amp;hellip;}&lt;br /&gt;
:v/\S/d                     : Delete empty lines (and blank lines ie whitespace)&lt;br /&gt;
:v/./,/./-j                 : compress empty lines&lt;br /&gt;
:g/^$/,/./-j                : compress empty lines&lt;br /&gt;
:g/&lt;input\|&lt;form/p          : ORing  
:g/^/put_                   : double space file (pu = put)  
:g/^/m0                     : Reverse file (m = move)  
:g/^/m$                     : No effect! [N]  
:&#39;a,&#39;bg/^/m&#39;b               : Reverse a section a to b  
:g/^/t.                     : duplicate every line  
:g/fred/t$                  : copy (transfer) lines matching fred to EOF  
:g/stage/t&#39;a                : copy (transfer) lines matching stage to marker a (cannot use .) [C]  
:g/^Chapter/t.|s/./-/g      : Automatically underline selecting headings [N]  
:g/\(^I[^^I]*\)\{80}/d      : delete all lines containing at least 80 tabs  
&#34; perform a substitute on every other line  
:g/^/ if line(&#39;.&#39;)%2|s/^/zz /  
&#34; match all lines containing &#34;somestr&#34; between markers a &amp; b  
&#34; copy after line containing &#34;otherstr&#34;  
:&#39;a,&#39;bg/somestr/co/otherstr/ : co(py) or mo(ve)  
&#34; as above but also do a substitution  
:&#39;a,&#39;bg/str1/s/str1/&amp;&amp;&amp;/|mo/str2/  
:%norm jdd                  : delete every other line  
&#34; incrementing numbers (type &lt;c-a&gt; as 5 characters)&lt;br /&gt;
:.,$g/^\d/exe &amp;ldquo;norm! &amp;lt;c-a&amp;gt;&amp;rdquo;: increment numbers&lt;br /&gt;
:&amp;lsquo;a,&amp;lsquo;bg/\d+/norm! ^A       : increment numbers&lt;br /&gt;
&amp;rdquo; storing glob results (note must use APPEND) you need to empty reg a first with qaq.&lt;br /&gt;
&amp;ldquo;save results to a register/paste buffer&lt;br /&gt;
:g/fred/y A                 : append all lines fred to register a&lt;br /&gt;
:g/fred/y A | :let @&lt;em&gt;=@a    : put into paste buffer&lt;br /&gt;
:g//y A | :let @&lt;/em&gt;=@a    : put last glob into paste buffer [N]&lt;br /&gt;
:let @a=&amp;ldquo;|g/Barratt/y A |:let @&lt;em&gt;=@a&lt;br /&gt;
&amp;rdquo; filter lines to a file (file must already exist)&lt;br /&gt;
:&amp;lsquo;a,&amp;lsquo;bg/^Error/ . w &amp;gt;&amp;gt; errors.txt&lt;br /&gt;
&amp;rdquo; duplicate every line in a file wrap a print &amp;ldquo; around each duplicate&lt;br /&gt;
:g/./yank|put|-1s/&amp;lsquo;/&amp;ldquo;/g|s/.&lt;/em&gt;/Print &amp;lsquo;&amp;amp;&amp;lsquo;/&lt;br /&gt;
&amp;rdquo; replace string with contents of a file, -d deletes the &amp;ldquo;mark&amp;rdquo;&lt;br /&gt;
:g/^MARK$/r tmp.txt | -d&lt;br /&gt;
&amp;rdquo; display prettily&lt;br /&gt;
:g/&lt;pattern&gt;/z#.5           : display with context&lt;br /&gt;
:g/&lt;pattern&gt;/z#.5|echo &amp;ldquo;==========&amp;rdquo;  : display beautifully&lt;br /&gt;
&amp;rdquo; Combining g// with normal mode commands&lt;br /&gt;
:g/|/norm 2f|r*                      : replace 2nd | with a star&lt;br /&gt;
&amp;ldquo;send output of previous global command to a new window&lt;br /&gt;
:nmap &lt;F3&gt;  :redir @a&lt;CR&gt;:g//&lt;CR&gt;:redir END&lt;CR&gt;:new&lt;CR&gt;:put! a&lt;CR&gt;&lt;CR&gt;&lt;br /&gt;
&amp;rdquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;br /&gt;
&amp;rdquo; &lt;em&gt;Best-Global-combined-with-substitute&lt;/em&gt; (&lt;em&gt;power-editing&lt;/em&gt;)&lt;br /&gt;
:&amp;lsquo;a,&amp;lsquo;bg/fred/s/joe/susan/gic :  can use memory to extend matching&lt;br /&gt;
:/fred/,/joe/s/fred/joe/gic :  non-line based (ultra)&lt;/p&gt;

&lt;h2 id=&#34;biz-any-g-article-s-wheel-bucket-gic-non-line-based-n&#34;&gt;:/biz/,/any/g/article/s/wheel/bucket/gic:  non-line based [N]&lt;/h2&gt;

&lt;p&gt;&amp;rdquo; Find fred before beginning search f&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:A-J&#34;&gt;A-J &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:A-J&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        
        <item>
            <title>vim 最佳实践</title>
            <link>//blog.pytool.com/edit/vim-best-tips0/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/vim-best-tips0/</guid>
            <description>&lt;p&gt;简单的那些「set xxx」之类的命令就不提了，先从 map 开始吧。&lt;br /&gt;
map 命令的用途是把一组键映射为其他的命令。&lt;br /&gt;
例如我想在按「;」键的时候，自动变成「:」键进入命令行模式，就可以这样设置：&lt;/p&gt;

&lt;p&gt;map ; :&lt;/p&gt;

&lt;p&gt;Vim 的搜索模式太古怪，我比较习惯 Python 的风格，所以可以把「/」替换成「/\v」，变成 very magic 模式：&lt;/p&gt;

&lt;p&gt;map / /\v&lt;/p&gt;

&lt;p&gt;还有设置了 hlsearch 后，搜索结果就一直高亮了，切换它又比较麻烦。还好我习惯没事多按几次 Esc 键，所以可以在按 Esc 键时清空搜索寄存器，这样就不会再高亮搜索结果了：&lt;/p&gt;

&lt;p&gt;map &lt;Esc&gt; &lt;Esc&gt;:let @/=&amp;ldquo;&amp;rdquo;&lt;CR&gt;&lt;/p&gt;

&lt;p&gt;这样设置后，虽然效果达到了，可是引入了一个副作用：方向键的行为变得很诡异了。搜了下原因，好像是方向键也会触发 Esc 键，而且好像没法解决。于是只好换个快捷键了：&lt;/p&gt;

&lt;p&gt;let mapleader=&amp;ldquo;,&amp;rdquo;&lt;br /&gt;
map &lt;Leader&gt;/ :let @/=&amp;ldquo;&amp;rdquo;&lt;CR&gt;&lt;/p&gt;

&lt;p&gt;mapleader 是自定义命令的起始键，一般都定义成逗号。因为「/」离「,」比较近，而且表示搜索的意思，所以我就把快捷键设为「,/」了。如果为了方便的话，「,,」或「,&lt;Space&gt;」会更快。&lt;/p&gt;

&lt;p&gt;你会发现这个设置在普通模式和可视模式下都可用，但是插入模式下并不会生效。&lt;br /&gt;
如果要针对某个模式的话，需要加上这个模式的前缀，常用的有 nmap、vmap、imap 和 cmap 等，分别适用于普通、可视、插入和命令行模式。&lt;br /&gt;
例如我在插入模式的时候，想回到上一个单词，一般需要按下 Esc 进入普通模式，再按 b 到上一个单词，然后按 i 进入插入模式。于是可以把这些操作绑定到 Ctrl + b 快捷键上：&lt;/p&gt;

&lt;p&gt;imap &lt;C-b&gt; &lt;Esc&gt;bi&lt;/p&gt;

&lt;p&gt;然而你在使用时会遇到问题，按 Esc 键从插入模式返回普通模式时，会让光标左移一位，再按 b 有可能就定位错误了。这种情况下，就可以用 Ctrl + o 来临时切换到普通模式，在执行完 b 命令后，会自动回到插入模式：&lt;/p&gt;

&lt;p&gt;imap &lt;C-b&gt; &lt;C-o&gt;b&lt;/p&gt;

&lt;p&gt;如果想让 Esc 键不让光标左移，可以这样设置：&lt;/p&gt;

&lt;p&gt;imap &lt;Esc&gt; &lt;C-o&gt;:stopinsert&lt;CR&gt;&lt;/p&gt;

&lt;p&gt;另外，回退一个单词用这个快捷键也是有效的：&lt;/p&gt;

&lt;p&gt;imap &lt;C-b&gt; &lt;S-Left&gt;&lt;/p&gt;

&lt;p&gt;不过我直接按 Shift + ← 并没反应，原因是大部分终端模拟器并不能区分 Shift 和不可见字符的组合。另外，CMD 键也是不可用的。如果非要使用这二者的话，只能用 MacVim。&lt;br /&gt;
由于 MBP 上没有 Home 键，因此这样回到行首也是可行的：&lt;/p&gt;

&lt;p&gt;imap &lt;C-a&gt; &lt;Home&gt;&lt;/p&gt;

&lt;p&gt;接着又出现了一个问题，假设我把 Home 键设置成回到页首：&lt;/p&gt;

&lt;p&gt;imap &lt;Home&gt; &lt;C-o&gt;gg&lt;/p&gt;

&lt;p&gt;然后我按 Ctrl + a 时，也会回到页首，而不是行首了，这种不可控的事是程序员不愿意遇到的。&lt;br /&gt;
所以要加上 nore 这个前缀，以确保替换成的命令是不会因其他设置而改动的：&lt;/p&gt;

&lt;p&gt;inoremap &lt;C-a&gt; &lt;Home&gt;&lt;/p&gt;

&lt;p&gt;如果要问什么时候该加 nore，答案是如果你没把握，那就加上。&lt;/p&gt;

&lt;p&gt;目前为止，一切看上去都很正常，但是好像又有什么不对：为什么我在普通模式替换的是普通按键，而在插入模式替换的却是快捷键？&lt;br /&gt;
前半个问题很好回答：因为没这个必要，在普通模式下，我只需要像普通的命令一样连续按键就行了，为什么要用快捷键这种需要同时按住多个按键的方式？&lt;br /&gt;
后半个问题则主要是识别问题：插入模式下，按下按键需要立刻输出到屏幕上，如果要判断是否是一个命令，就得等待一段时间，确认不是命令后才能输出，导致输入体验不佳。&lt;br /&gt;
以下面的例子为例，假设我想按 2 下引号，就在当前单词的前后各插入一个引号：&lt;/p&gt;

&lt;p&gt;inoremap &amp;ldquo;&amp;rdquo; &lt;C-o&gt;viwv&lt;C-o&gt;b&amp;rdquo;&lt;C-o&gt;e&lt;C-o&gt;a&amp;rdquo;&lt;/p&gt;

&lt;p&gt;只要快速按 2 下引号，大部分时候确实是能用的；但如果我只是想输入一个引号，就会看到等一秒后光标位置才会右移（虽然并不妨碍我继续输入后面的字符）。&lt;br /&gt;
不过，如果只有一个按键，不需要等待匹配下一个，那就不会影响输入体验了。例如自动补全括号和引号：&lt;/p&gt;

&lt;p&gt;inoremap ( ()&lt;Left&gt;&lt;br /&gt;
inoremap [ []&lt;Left&gt;&lt;br /&gt;
inoremap { {}&lt;Left&gt;&lt;br /&gt;
inoremap &amp;ldquo; &amp;ldquo;&amp;rdquo;&lt;Left&gt;&lt;br /&gt;
inoremap &amp;lsquo; &amp;ldquo;&lt;Left&gt;&lt;/p&gt;

&lt;p&gt;而在命令行模式下，一般都要敲入回车才真正执行一条命令，但 cmap 会让匹配的命令立刻执行，不需要敲入回车，这也显得比较诡异。&lt;br /&gt;
所以大部分情况下，插入模式和命令行模式都只定义一些快捷键的 map。&lt;/p&gt;

&lt;p&gt;另外，map 还能加一些特殊参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;buffer&amp;gt; 表示只对当前文件有效。  
&amp;lt;nowait&amp;gt; 表示不等待范围更大的组合匹配。例如同时定义这两组：  

nnoremap &amp;lt;Leader&amp;gt;wd dw  
nnoremap &amp;lt;buffer&amp;gt; &amp;lt;nowait&amp;gt; &amp;lt;Leader&amp;gt;w w  

如果没有加「&amp;lt;nowait&amp;gt;」，按下「,w」后，要等一段时间确认之后你接下来要按的不是「d」，才会执行。加了之后就不会等待，而是直接执行了，缺点就是「,wd」会失效。  
&amp;lt;silent&amp;gt; 表示不在命令行显示输入的命令。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他不是很常用，就不说了。&lt;/p&gt;

&lt;p&gt;说完 map 后，再回到之前未解决的一个问题：命令行模式下，如何自定义命令？&lt;br /&gt;
这就该轮到 command 出场了。&lt;br /&gt;
以保存文件为例，有时候打开了一些系统文件，编辑完后却发现不能保存，要输入一段很长的代码才能用 sudo 来保存。&lt;br /&gt;
现在就用 :W 命令（必须以大写字母开头）来简化这个操作：&lt;/p&gt;

&lt;p&gt;command W :w !sudo tee %&lt;/p&gt;

&lt;p&gt;无论怎样，它至少是能用的，但是保存时会出现一个确认界面，有点难看，于是这样去掉：&lt;/p&gt;

&lt;p&gt;command W :silent w !sudo tee %&lt;/p&gt;

&lt;p&gt;可如果设置了检查文件是否改动，保存完后还会提示你文件被修改了。于是可以用 execute 命令来执行，执行完后再用 :e! 来编辑：&lt;/p&gt;

&lt;p&gt;command W :execute &amp;lsquo;silent w !sudo tee %&amp;rsquo; | :e!&lt;/p&gt;

&lt;p&gt;还有个不爽之处是命令行仍然会闪动一下，输出一片内容然后很快消失掉，可以将输出重定向到 /dev/null 来解决：&lt;/p&gt;

&lt;p&gt;command W :execute &amp;lsquo;silent w !sudo tee % &amp;gt; /dev/null&amp;rsquo; | :e!&lt;/p&gt;

&lt;p&gt;再把 :WQ 给加上：&lt;/p&gt;

&lt;p&gt;command WQ :execute &amp;lsquo;silent w !sudo tee % &amp;gt; /dev/null&amp;rsquo; | :q!&lt;/p&gt;

&lt;p&gt;或者偷下懒，在 :W 命令后再执行 :q：&lt;/p&gt;

&lt;p&gt;command WQ :execute &amp;lsquo;W&amp;rsquo; | :q&lt;/p&gt;

&lt;p&gt;最后，如果设置了自动重新载入 .vimrc 文件，重复加载时会报命令已经定义过的错误。把 command 改成 command! 即可解决。&lt;/p&gt;

&lt;p&gt;接着再来说说自动执行的问题。&lt;br /&gt;
大部分的编程语言里都用制表符来缩进，而 Python 通常使用 4 个空格。这种情况下，就可以用 autocmd 来解决：&lt;/p&gt;

&lt;p&gt;autocmd FileType python set expandtab&lt;/p&gt;

&lt;p&gt;当检测到文件类型为 python 时，就会设置 expandtab，把 Tab 展成空格了。&lt;br /&gt;
不过再打开其他文件时，仍然是用空格来缩进，于是需要把 set 改成 setlocal，让它只针对当前 buffer 和 window 有效。&lt;br /&gt;
另外，和 command 一样，重新加载 .vimrc 文件时，这个事件会再次被绑定，于是会重复执行两次。解决办法是把它加入一个组：&lt;/p&gt;

&lt;p&gt;augroup python_indent&lt;br /&gt;
    autocmd!&lt;br /&gt;
    autocmd FileType python setlocal expandtab&lt;br /&gt;
augroup END&lt;/p&gt;

&lt;p&gt;其中，autocmd! 会先清空这个组，而后面的 autocmd 会重新绑定事件。&lt;/p&gt;

&lt;p&gt;另一种做法是直接使用 autocmd! 来绑定事件，和 command! 一样，它也会替换之前绑定的事件。&lt;br /&gt;
例如这样的设置：&lt;/p&gt;

&lt;p&gt;autocmd! BufNewFile *.py call append(0, &amp;ldquo;test&amp;rdquo;)&lt;br /&gt;
autocmd! BufNewFile &lt;em&gt;.py call append(0, &amp;ldquo;# -&lt;/em&gt;- coding: utf-8 -*-&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;只有后一句会生效。&lt;/p&gt;

&lt;p&gt;顺带一提，自动重新加载 .vimrc 文件也可以用 autocmd 来实现的：&lt;/p&gt;

&lt;p&gt;augroup reload_vim_config&lt;br /&gt;
    autocmd!&lt;br /&gt;
    autocmd BufWritePost $MYVIMRC source $MYVIMRC&lt;br /&gt;
augroup END&lt;/p&gt;

&lt;p&gt;再来一个比较复杂点的，保存某些类型的文件时，自动去掉行尾的空格：&lt;/p&gt;

&lt;p&gt;augroup strip_traling_spaces&lt;br /&gt;
    autocmd!&lt;br /&gt;
    autocmd BufWritePre &lt;em&gt;.py,&lt;/em&gt;.js,*.css %s/\s+$//e&lt;br /&gt;
augroup END&lt;/p&gt;

&lt;p&gt;如果想让读取时也去掉空格，可以把第三行改成&lt;/p&gt;

&lt;p&gt;autocmd BufRead,BufWritePre &lt;em&gt;.css,&lt;/em&gt;.js,*.py %s/\s+$//e&lt;/p&gt;

&lt;p&gt;也就是说，这后面跟的多个事件是「或」的关系。&lt;br /&gt;
如果需要「与」的关系，可以用多个 autocmd：&lt;/p&gt;

&lt;p&gt;autocmd FileType css,javascript,python autocmd BufWritePre &lt;buffer&gt; %s/\s+$//e&lt;/p&gt;

&lt;p&gt;还能加上 if 来判断：&lt;/p&gt;

&lt;p&gt;autocmd BufWritePre * if index([&amp;lsquo;css&amp;rsquo;, &amp;lsquo;javascript&amp;rsquo;, &amp;lsquo;python&amp;rsquo;], &amp;amp;filetype) &amp;gt;= 0 | %s/\s+$//e&lt;/p&gt;

&lt;p&gt;其中，&amp;amp;filetype 或 &amp;amp;ft 是当前文件的类型，index 函数可以用来检查是否在列表中。&lt;/p&gt;

&lt;p&gt;虽然列出了那么多种方法，但其实都没能解决一个问题：删除空格后，光标位置变了。&lt;br /&gt;
在编写 Vimscript 时，不带来副作用也是很重要的一点。而为了解决这个问题，就不得不保存原位置，修改完后再恢复了：&lt;/p&gt;

&lt;p&gt;function! &lt;SID&gt;StripTrailingSpaces()&lt;br /&gt;
    let l = line(&amp;ldquo;.&amp;rdquo;)&lt;br /&gt;
    let c = col(&amp;ldquo;.&amp;rdquo;)&lt;br /&gt;
    %s/\s+$//e&lt;br /&gt;
    call cursor(l, c)&lt;br /&gt;
endfunction&lt;br /&gt;
augroup strip_traling_spaces&lt;br /&gt;
    autocmd!&lt;br /&gt;
    autocmd FileType css,javascript,python autocmd BufWritePre &lt;buffer&gt; call &lt;SID&gt;StripTrailingSpaces()&lt;br /&gt;
augroup END&lt;/p&gt;

&lt;p&gt;其中，function 后的叹号和 command! 的作用一样，重复定义时覆盖之前的定义。&lt;SID&gt; 会被替换成一个唯一的值，避免命名冲突。&lt;br /&gt;
另外，如果函数名没有加范围前缀（例如 s: 表示本地函数，g: 表示全局函数），则必须大写。&lt;/p&gt;

&lt;p&gt;然后再聊聊复制粘贴的问题。&lt;br /&gt;
用 Vim 的人应该都有过把代码粘贴到 Vim 里后，缩进变得乱七八糟的经历。&lt;br /&gt;
原因就是直接用 CMD + v 粘贴时，会模拟成用户的输入，而在设置了自动缩进的情况下，缩进就变乱了。&lt;br /&gt;
解决起来其实很简单，一种办法是 :set paste 后再粘贴，贴完后再 :set nopaste；另一种办法是直接用 p 来粘贴，但这要求 Vim 能访问系统剪贴板；此外，OS X 上还能调用 pbpaste 这个外部命令来粘贴。&lt;br /&gt;
第一种办法因为我没法在 MBP 上绑定 CMD + v 快捷键，所以就不管了。&lt;br /&gt;
第二种办法需要 Vim 在编译时带上了 +clipboard。可以用 vim &amp;ndash;version | grep clipboard 来查看，包含 +clipboard 则表示没问题，-clipboard 则表示不支持。OS X 自带的 Vim 是不支持的，用 brew 安装，或者 MacVim 是带了的。确认支持后，这样设置即可：&lt;/p&gt;

&lt;p&gt;set clipboard+=unnamed&lt;br /&gt;
inoremap &lt;C-p&gt; &lt;C-o&gt;p&lt;/p&gt;

&lt;p&gt;要注意的是，剪贴板与 Vim 共用后，Vim 中所有的复制操作都会修改剪贴板内容。而且 Vim 的删除命令也有复制的副作用，所以很可能一不小心就把剪贴板弄乱了。如果要将一个单词替换成剪贴板的内容，ce&lt;C-p&gt; 是不行的，得用 vep。&lt;br /&gt;
第三种办法则这样实现：&lt;/p&gt;

&lt;p&gt;if has(&amp;ldquo;mac&amp;rdquo;)&lt;br /&gt;
    inoremap &lt;C-p&gt; &lt;C-o&gt;:r !pbpaste&lt;CR&gt;&lt;br /&gt;
endif&lt;/p&gt;

&lt;p&gt;has(&amp;ldquo;mac&amp;rdquo;) 可以判断是不是 OS X，:r !pbpaste 则是读取 pbpaste 这个外部命令的输出，并插入到光标位置。&lt;br /&gt;
这个办法不跨平台，而且要调用外部命令，所以相对而言还是第二种比较好。但&lt;/p&gt;

&lt;p&gt;还有一点美中不足的是，如果贴进来的代码和现有代码使用的缩进方式不一致（比如一个用空格，一个用 Tab），仍然会有问题。&lt;br /&gt;
好在 Vim 提供了 retab 这个命令，只要在粘贴后，再执行下它就行了：&lt;/p&gt;

&lt;p&gt;inoremap &lt;C-p&gt; &lt;C-o&gt;p&lt;C-o&gt;:retab&lt;CR&gt;&lt;br /&gt;
nnoremap &lt;silent&gt; p p:retab&lt;CR&gt;&lt;/p&gt;

&lt;p&gt;然而故事的结尾，我还是用回了 PyCharm。&lt;br /&gt;
原因是 Vim 下最强大的代码补全插件 YouCompleteMe，也无法满足我的需求：from xxx import yyy 中，yyy 部分是无法补全的。&lt;br /&gt;
回到 PyCharm 后，我的感觉是配置 Vim 的过程像是自己在实现编辑器的各个功能，而 PyCharm 则是大部分都配好了，稍微改改就行了，很多时候比 Vim 更好用（例如随便一个编辑器都几乎不用为粘贴头疼）。当然，后者的缺点就是很多地方无法定制（虽然 Vim 也不是完全可定制的），例如我想在保存文件时删除末尾的空格，但是不处理 markdown 文件；还有复制粘贴时，按照当前文件的类型，自动重新格式化 Tab 和 Space。&lt;br /&gt;
为了尽量追上 Vim 的速度，还不得不再记一些快捷键（例如 Shift + CMD + o 和 CMD + e 可以快速打开文件），禁用没用的插件，隐藏编辑区和 Tab 区以外的区域等。&lt;br /&gt;
此外还发现 PyCharm 的 Vim 插件可以读取 ~/.ideavimrc 配置文件，不过基本只能定义 map，其中最需要加上的是设置是：&lt;/p&gt;

&lt;p&gt;vnoremap &amp;lt; &lt;gv  
vnoremap &gt; &amp;gt;gv&lt;/p&gt;

&lt;p&gt;即选择一个区域后，可以连续调整缩进；否则需要精确计算缩进次数，用 n&amp;gt; 和 n&amp;lt; 来替代。&lt;/p&gt;

&lt;p&gt;nnoremap &lt;silent&gt; &lt;C-l&gt; :nohl&lt;CR&gt;&lt;C-l&gt; 我就是用的nohl,再次搜索是自动高亮的，不用手动恢复&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>vim 脚本简述</title>
            <link>//blog.pytool.com/edit/vim-%E8%84%9A%E6%9C%AC%E7%AE%80%E8%BF%B0/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/vim-%E8%84%9A%E6%9C%AC%E7%AE%80%E8%BF%B0/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://www.kancloud.cn/kancloud/learn-vimscript-the-hard-way/49321&#34; target=&#34;_blank&#34;&gt;笨方法学Vimscript&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/jeffreyst_zb/article/details/8733100&#34; target=&#34;_blank&#34;&gt;vim 脚本简述&lt;/a&gt;&lt;br /&gt;
1.1 函数调用的两种方式&lt;/p&gt;

&lt;p&gt;有两种调用VimScript函数的方式。&lt;/p&gt;

&lt;p&gt;（1）不关心返回值&lt;br /&gt;
    call search(&amp;ldquo;Date: &amp;ldquo;, &amp;ldquo;W&amp;rdquo;)&lt;br /&gt;
使用关键字call 来显式调用函数。&lt;br /&gt;
（2）关心返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let line = getline(&amp;quot;.&amp;quot;)  
    let repl = substitute(line, &#39;\a&#39;, &amp;quot;*&amp;quot;, &amp;quot;g&amp;quot;)  
    call setline(&amp;quot;.&amp;quot;, repl)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例子，getline(&amp;ldquo;.&amp;rdquo;)返回当前光标所在的行文本，substitue()则返回替换后的文本， 这种情况下自动调用函数，无需使用call。&lt;/p&gt;

&lt;p&gt;其实函数调用的call与变量赋值的let类似，看起来好像真的是多余的，C和PHP都没有这种用法，也能工作的很好啊，搞不懂VimScript的开发者是如何想的。&lt;/p&gt;

&lt;p&gt;2.1 基本变量命名空间&lt;br /&gt;
在VimScript中默认的作用域是全局作用域，也就是说你在一个脚本文件中定义了一个变量，在其他脚本中也可以读取和修改这个变量。在任何编程语言中，全局变量的滥用都会造成混乱，所以VimScript提供了更多的非全局作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s:name 脚本文件作用域，此时s:name这个变量只在当前脚本文件中有效，其他的脚本文件中如果也定义了同名的s:name也没关系，因为这两者彼此独立。这一点与C中的static关键字类似。  
b:name 缓冲区作用域，b:name只在指定的缓冲区中有效  
w:name 窗口作用域，w:name只在指定的窗口中有效  
g:name 全局作用域，函数外定义的变量的默认值  
v:name vim预定义的变量，注意预定义变量不同于vim的选项(option)变量。  
l:name 函数内部的局部变量，函数内部定义的变量的默认值  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这些作用域只针对变量名，而不能作用于函数名。&lt;/p&gt;

&lt;p&gt;表 1. Vimscript 变量范围&lt;br /&gt;
前缀  含义&lt;br /&gt;
g: varname  变量为全局变量&lt;br /&gt;
s: varname  变量的范围为当前的脚本文件&lt;br /&gt;
w: varname  变量的范围为当前的编辑器窗口&lt;br /&gt;
t: varname  变量的范围为当前的编辑器选项卡&lt;br /&gt;
b: varname  变量的范围为当前的编辑器缓冲区&lt;br /&gt;
l: varname  变量的范围为当前的函数&lt;br /&gt;
a: varname  变量是当前函数的一个参数&lt;br /&gt;
v: varname  变量是 Vim 的预定义变量&lt;/p&gt;

&lt;p&gt;还有一些伪变量（pseudovariables），脚本可以使用它们访问 Vim 提供的其他类型的值容器。表 2 对此进行了总结。&lt;/p&gt;

&lt;p&gt;表 2. Vimscript 伪变量&lt;br /&gt;
前缀  含义&lt;br /&gt;
&amp;amp; varname   一个 Vim 选项（如果指定的话，则为本地选项，否则为全局选项）&lt;br /&gt;
&amp;amp;l: varname     本地 Vim 选项&lt;br /&gt;
&amp;amp;g: varname     全局 Vim 选项&lt;br /&gt;
@ varname   一个 Vim 注册器&lt;br /&gt;
$ varname   一个环境变量&lt;/p&gt;

&lt;p&gt;“option” 伪变量非常有用。例如，可以设置两个键映射（key-map）来增加或减小当前的表空间，如下所示：&lt;/p&gt;

&lt;p&gt;nmap &lt;silent&gt; ]] :let &amp;amp;tabstop += 1&lt;CR&gt;&lt;/p&gt;

&lt;p&gt;nmap &lt;silent&gt; [[ :let &amp;amp;tabstop -= &amp;amp;tabstop &amp;gt; 1 ? 1 : 0&lt;CR&gt;&lt;/p&gt;

&lt;p&gt;option  如果变量名以&amp;amp;开头，那么这个变量是一个vim内部变量。vim提供了很多可以配置的选项，也被称为vim内部变量。&lt;br /&gt;
        同一个名称的内部变量往往有很多副本，一个是全局的，还有buffer和window局部的，而且提供了不同的读写命令set和setlocal。&lt;br /&gt;
        内部变量共使用了三种数据类型：boolean，Number, String。其实VimScript并不支持boolean，而是用Number模仿而已。&lt;/p&gt;

&lt;p&gt;改变一个option有两种方法：一是使用set命令，如 set number， set tabstop=4； 二是给变量直接赋值，如 let &amp;amp;number=1, let &amp;amp;tabstop=4。两种方法达到的效果是一样的。不过需要注意的是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    set命令可以使用简写形式的option名字，如set nu，而直接赋值必须使用完整的内部变量名称；  
    直接赋值时要在变量名之前添加&amp;amp;，否则会新建一个同名变量，而不是使用vim的内部变量。如 let number=1不会修改vim的number内部变量。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;register 如果变量名以@开头，那么这本变量是暂存区变量，注意register在这里的含义与CPU中的寄存器没有直接关系。&lt;/p&gt;

&lt;p&gt;register其实就是一块内存，用来存放各种临时性的东西，比如拷贝的文本，文件的名称，最近删除的文本等等。共有9种类型的register。分别是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;（1）无名register &amp;quot;&amp;quot; ， 在vim中register使用引号开头  
（2）以数字为名的register，&amp;quot;0到&amp;quot;9，共10个  
（3）小删除register, “-（连接符）  
（4）以字母为名的register, ”a到&amp;quot;z，共26个  
（5）只读register，共有4个，分别是 &amp;quot;, ，“。，”%，&amp;quot;#  
（6）表达式register，&amp;quot;=  
（7）选择与删除register，共3个，分别是 &amp;quot;*，&amp;quot;+以及&amp;quot;~  
（8）黑洞register, “_（下划线），注意与&amp;quot;-区别  
（9）上次查找模式register, ”/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些register中，有一些是vim自身使用的，有些则是共用户使用的。&lt;br /&gt;
在VimScript中，使用@+暂存区名的语法来读取和设置暂存区。如下：&lt;br /&gt;
[plain] view plain copy&lt;/p&gt;

&lt;p&gt;echo @&amp;rdquo;&lt;br /&gt;
let @/ = &amp;ldquo;hello&amp;rdquo;  &amp;ldquo; 写入register&lt;br /&gt;
echo type(@/)&lt;br /&gt;
echo type(@_)&lt;/p&gt;

&lt;p&gt;通过实验得知，所有的register类型变量的数据类型都是String。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>vim使用笔记</title>
            <link>//blog.pytool.com/edit/2015-11-09-editor-vim-notes/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-11-09-editor-vim-notes/</guid>
            <description>

&lt;h1 id=&#34;1-关于vim&#34;&gt;1. 关于Vim #&lt;/h1&gt;

&lt;p&gt;vim是我最喜欢的编辑器，也是linux下第二强大的编辑器。&lt;br /&gt;
虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。&lt;br /&gt;
如果是初学vi，运行一下vimtutor是个聪明的决定。&lt;br /&gt;
（如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）&lt;/p&gt;

&lt;p&gt;Vim的几种模式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正常模式：可以使用快捷键命令，或按:输入命令行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可视模式：正常模式下按v可以进入可视模式，&lt;br /&gt;
在可视模式下，移动光标可以选择文本。按V进入可视行模式，&lt;br /&gt;
总是整行整行的选中。ctrl+v进入可视块模式。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;替换模式：正常模式下，按R进入。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-启动vim&#34;&gt;2. 启动Vim #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;vim -c cmd file: 在打开文件前，先执行指定的命令；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim -r file: 恢复上次异常退出的文件；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim -R file: 以只读的方式打开文件，但可以强制保存；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim -M file: 以只读的方式打开文件，不可以强制保存；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim -y num file: 将编辑窗口的大小设为num行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim + file: 从文件的末尾开始；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim +num file: 从第num行开始；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim +/string file: 打开file，并将光标停留在第一个找到的string上。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim &amp;ndash;remote file: 用已有的vim进程打开指定的文件。&lt;br /&gt;
如果你不想启用多个vim会话，这个很有用。但要注意，&lt;br /&gt;
如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了，&lt;br /&gt;
你可以用gvim &amp;ndash;remote file在已有的gvim中打开文件。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;3-文档操作&#34;&gt;3. 文档操作 #&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;:e file &amp;ndash;关闭当前编辑的文件，并开启新的文件。&lt;br /&gt;
如果对当前文件的修改未保存，vi会警告。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:e! file &amp;ndash;放弃对当前文件的修改，编辑新的文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:e+file &amp;ndash; 开始新的文件，并从文件尾开始编辑。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:e+n file &amp;ndash; 开始新的文件，并从第n行开始编辑。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:enew &amp;ndash;编译一个未命名的新文档。(CTRL-W n)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:e &amp;ndash; 重新加载当前文档。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:e! &amp;ndash; 重新加载当前文档，并丢弃已做的改动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:e#或ctrl+^ &amp;ndash; 回到刚才编辑的文件，很实用。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:f或ctrl+g &amp;ndash; 显示文档名，是否修改，和光标位置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:f filename &amp;ndash; 改变编辑的文件名，这时再保存相当于另存为。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gf &amp;ndash; 打开以光标所在字符串为文件名的文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:w &amp;ndash; 保存修改。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:n1,n2w filename &amp;ndash; 选择性保存从某n1行到另n2行的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:wq &amp;ndash; 保存并退出。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ZZ &amp;ndash; 保存并退出。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:x &amp;ndash; 保存并退出。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:saveas newfilename &amp;ndash; 另存为&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;:browse e &amp;ndash; 会打开一个文件浏览器让你选择要编辑的文件。&lt;br /&gt;
如果是终端中，则会打开netrw的文件浏览窗口；&lt;br /&gt;
如果是gvim，则会打开一个图形界面的浏览窗口。&lt;br /&gt;
实际上:browse后可以跟任何编辑文档的命令，如sp等。&lt;br /&gt;
用browse打开的起始目录可以由browsedir来设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:set browsedir=last &amp;ndash; 用上次访问过的目录（默认）；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set browsedir=buffer &amp;ndash; 用当前文件所在目录；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set browsedir=current &amp;ndash; 用当前工作目录；&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;:Sex &amp;ndash; 水平分割一个窗口，浏览文件系统；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;:Vex &amp;ndash; 垂直分割一个窗口，浏览文件系统；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;4-光标的移动&#34;&gt;4. 光标的移动 #&lt;/h1&gt;

&lt;h2 id=&#34;4-1-基本移动&#34;&gt;4.1 基本移动 ##&lt;/h2&gt;

&lt;p&gt;以下移动都是在normal模式下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;h或退格: 左移一个字符；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;l或空格: 右移一个字符；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;j: 下移一行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;k: 上移一行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gj: 移动到一段内的下一行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gk: 移动到一段内的上一行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;+或Enter: 把光标移至下一行第一个非空白字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-: 把光标移至上一行第一个非空白字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;w: 前移一个单词，光标停在下一个单词开头；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;W: 移动下一个单词开头，但忽略一些标点；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;e: 前移一个单词，光标停在下一个单词末尾；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;b: 后移一个单词，光标停在上一个单词开头；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;B: 移动到上一个单词开头，忽略一些标点；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ge: 后移一个单词，光标停在上一个单词末尾；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gE: 同 &lt;code&gt;ge&lt;/code&gt; ，不过‘单词’包含单词相邻的标点。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(: 前移1句。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;): 后移1句。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;{: 前移1段。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;}: 后移1段。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;fc: 把光标移到同一行的下一个c字符处&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Fc: 把光标移到同一行的上一个c字符处&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;tc: 把光标移到同一行的下一个c字符前&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Tc: 把光标移到同一行的上一个c字符后&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;;: 配合f &amp;amp; t使用，重复一次&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;,: 配合f &amp;amp; t使用，反向重复一次&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h，&lt;br /&gt;
则光标向左移动3个字符。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0: 移动到行首。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g0: 移到光标所在屏幕行行首。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;^: 移动到本行第一个非空白字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g^: 同 &lt;code&gt;^&lt;/code&gt; ，但是移动到当前屏幕行第一个非空字符处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;$: 移动到行尾。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g$: 移动光标所在屏幕行行尾。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;n|: 把光标移到递n列上。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;nG: 到文件第n行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:n&lt;cr&gt; 移动到第n行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:$&lt;cr&gt; 移动到最后一行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;H: 把光标移到屏幕最顶端一行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;M: 把光标移到屏幕中间一行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;L: 把光标移到屏幕最底端一行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gg: 到文件头部。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;G: 到文件尾部。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-翻屏&#34;&gt;4.2 翻屏 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ctrl+f: 下翻一屏。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+b: 上翻一屏。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+d: 下翻半屏。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+u: 上翻半屏。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+e: 向下滚动一行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+y: 向上滚动一行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;n%: 到文件n%的位置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zz: 将当前行移动到屏幕中央。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zt: 将当前行移动到屏幕顶端。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zb: 将当前行移动到屏幕底端。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-标记&#34;&gt;4.3 标记 ##&lt;/h2&gt;

&lt;p&gt;使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。&lt;br /&gt;
Ctrl+o和Ctrl+i 很像浏览器上的 &lt;em&gt;后退&lt;/em&gt; 和 &lt;em&gt;前进&lt;/em&gt; 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim，&lt;br /&gt;
重新启动，标记仍然有效。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;`{a-z}: 移动到标记位置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;lsquo;{a-z}: 移动到标记行的行首。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;``: 移动到上次编辑的位置。&amp;rdquo;也可以，不过``精确到列，而&amp;rdquo;精确到行&lt;br /&gt;
。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;`&amp;ldquo;: 移动到上次离开的地方。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;`.: 移动到最后改动的地方。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:marks 显示所有标记。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:delmarks a b &amp;ndash; 删除标记a和b。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:delmarks a-c &amp;ndash; 删除标记a、b和c。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:delmarks a c-f &amp;ndash; 删除标记a、c、d、e、f。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:delmarks! &amp;ndash; 删除当前缓冲区的所有标记。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:help mark-motions 查看更多关于mark的知识。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;5-插入文本&#34;&gt;5. 插入文本 #&lt;/h1&gt;

&lt;h2 id=&#34;5-1-基本插入&#34;&gt;5.1 基本插入 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=，&lt;br /&gt;
按esc进入命令模式，就会出现8个=。&lt;br /&gt;
这在插入分割线时非常有用，如30i+&lt;esc&gt;就插入了36个+组成的分割线。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;I: 在当前行第一个非空字符前插入；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gI: 在当前行第一列插入；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;a: 在光标后插入；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;A: 在当前行最后插入；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;o: 在下面新建一行插入；&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O: 在上面新建一行插入；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;:r filename\ 在当前位置插入另一个文件的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;:[n]r filename\ 在第n行插入另一个文件的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;:r !date\  在光标处插入当前日期与时间。\&lt;br /&gt;
同理，:r !command可以将其它shell命令的输出插入当前文档。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-2-改写插入&#34;&gt;5.2 改写插入 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;c[n]w: 改写光标后1(n)个词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;c[n]l: 改写光标后n个字母。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;c[n]h: 改写光标前n个字母。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[n]cc: 修改当前[n]行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[n]S: 删除指定数目的行，并以所输入文本代替之。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。&lt;/p&gt;

&lt;h1 id=&#34;6-剪切复制和寄存器&#34;&gt;6. 剪切复制和寄存器 #&lt;/h1&gt;

&lt;h2 id=&#34;6-1-剪切和复制-粘贴&#34;&gt;6.1 剪切和复制、粘贴 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[n]x: 剪切光标右边n个字符，相当于d[n]l。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[n]X: 剪切光标左边n个字符，相当于d[n]h。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;y: 复制在可视模式下选中的文本。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;yy or Y: 复制整行文本。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;y[n]w: 复制一(n)个词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;y[n]l: 复制光标右边1(n)个字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;y[n]h: 复制光标左边1(n)个字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;y$: 从光标当前位置复制到行尾。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;y0: 从光标当前位置复制到行首。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:m,ny&lt;cr&gt; 复制m行到n行的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;y1G或ygg: 复制光标以上的所有行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;yG: 复制光标以下的所有行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d: 删除（剪切）在可视模式下选中的文本。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d$ or D: 删除（剪切）当前位置到行尾的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d[n]w: 删除（剪切）1(n)个单词&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d[n]l: 删除（剪切）光标右边1(n)个字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d[n]h: 删除（剪切）光标左边1(n)个字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d0: 删除（剪切）当前位置到行首的内容&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[n] dd: 删除（剪切）1(n)行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:m,nd&lt;cr&gt; 剪切m行到n行的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d1G或dgg: 剪切光标以上的所有行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dG: 剪切光标以下的所有行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;d/f&lt;cr&gt;：这是一个比较高级的组合命令，它将删除当前位置&lt;br /&gt;
到下一个f之间的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;p: 在光标之后粘贴。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;P: 在光标之前粘贴。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-2-文本对象&#34;&gt;6.2 文本对象 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;aw：一个词&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;as：一句。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ap：一段。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ab：一块（包含在圆括号中的）。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;y, d, c, v都可以跟文本对象。&lt;/p&gt;

&lt;h2 id=&#34;6-3-寄存器&#34;&gt;6.3 寄存器 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;a-z：都可以用作寄存器名。\&amp;ldquo;ayy把当前行的内容放入a寄存器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。&lt;br /&gt;
如\&amp;ldquo;Ayy把当前行的内容追加到a寄存器中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:reg 显示所有寄存器的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\&amp;rdquo;\&amp;ldquo;：不加寄存器索引时，默认使用的寄存器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\&amp;rdquo;*：当前选择缓冲区，&amp;rdquo;*yy把当前行的内容放入当前选择缓冲区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\&amp;ldquo;+：系统剪贴板。\&amp;ldquo;+yy把当前行的内容放入系统剪贴板。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;7-查找与替换&#34;&gt;7. 查找与替换 #&lt;/h1&gt;

&lt;h2 id=&#34;7-1-查找&#34;&gt;7.1 查找 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;/something: 在后面的文本中查找something。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;?something: 在前面的文本中查找something。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/pattern/+number: 将光标停在包含pattern的行后面第number行上。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/pattern/-number: 将光标停在包含pattern的行前面第number行上。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;n: 向后查找下一个。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;N: 向前查找下一个。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;可以用grep或vimgrep查找一个模式都在哪些地方出现过，&lt;br /&gt;
其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。&lt;br /&gt;
用法为： :vim[grep]/pattern/[g] [j] files&lt;br /&gt;
g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。&lt;br /&gt;
j的含义是grep结束后，结果停在第j项，默认是停在第一项。&lt;br /&gt;
vimgrep前面可以加数字限定搜索结果的上限，如&lt;br /&gt;
:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。&lt;/p&gt;

&lt;p&gt;其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。&lt;br /&gt;
比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：&lt;br /&gt;
:vim/^\d{1,}./ %&lt;br /&gt;
然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，&lt;br /&gt;
就更像个目录了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;7-2-替换&#34;&gt;7.2 替换 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:s/old/new - 用new替换当前行第一个old。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:s/old/new/g - 用new替换当前行所有的old。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:%s/old/new/g - 用new替换文件中所有的old。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;所有替换命令末尾加上c，每个替换都将需要用户确认。&lt;br /&gt;
如：%s/old/new/gc，加上i则忽略大小写(ignore)。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，&lt;br /&gt;
语法为 :[range]g/pattern/command&lt;br /&gt;
例如 :%g/^ xyz/normal dd。&lt;br /&gt;
表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于range的规定为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果不指定range，则表示当前行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;m,n: 从m行到n行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;0: 最开始一行（可能是这样）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;$: 最后一行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;.: 当前行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;%: 所有行&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-3-正则表达式&#34;&gt;7.3 正则表达式 ##&lt;/h2&gt;

&lt;p&gt;高级的查找替换就要用到正则表达式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\d: 表示十进制数（我猜的）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\s: 表示空格&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\S: 非空字符&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\a: 英文字母&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\|: 表示 或&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;\.: 表示.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;{m,n}: 表示m到n个字符。这要和 \s与\a等连用，如 \a\{m,n} 表示m&lt;br /&gt;
到n个英文字母。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;{m,}: 表示m到无限多个字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;**: 当前目录下的所有子目录。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;:help pattern得到更多帮助。&lt;/p&gt;

&lt;h1 id=&#34;8-排版&#34;&gt;8. 排版 #&lt;/h1&gt;

&lt;h2 id=&#34;8-1-基本排版&#34;&gt;8.1 基本排版 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lt;&amp;lt; 向左缩进一个shiftwidth&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;gt;&amp;gt; 向右缩进一个shiftwidth&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:ce(nter) 本行文字居中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:le(ft) 本行文字靠左&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:ri(ght) 本行文字靠右&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gq 对选中的文字重排，即对过长的文字进行断行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gqq 重排当前行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gqnq 重排n行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gqap 重排当前段&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gqnap 重排n段&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gqnj 重排当前行和下面n行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gqQ 重排当前段对文章末尾&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;J 拼接当前行和下一行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gJ 同 &lt;code&gt;J&lt;/code&gt; ，不过合并后不留空格。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-2-拼写检查&#34;&gt;8.2 拼写检查 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:set spell－开启拼写检查功能&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set nospell－关闭拼写检查功能&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;]s－移到下一个拼写错误的单词&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[s－作用与上一命令类似，但它是从相反方向进行搜索&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;z=－显示一个有关拼写错误单词的列表，可从中选择&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zg－告诉拼写检查器该单词是拼写正确的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-3-统计字数&#34;&gt;8.3 统计字数 ##&lt;/h2&gt;

&lt;p&gt;g \^g可以统计文档字符数，行数。&lt;br /&gt;
将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。&lt;br /&gt;
以上对 Mac 或 Unix 的文件格式适用。&lt;br /&gt;
如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为：&lt;br /&gt;
字符数 - 行数 * 2。&lt;/p&gt;

&lt;h1 id=&#34;9-编辑多个文件&#34;&gt;9. 编辑多个文件 #&lt;/h1&gt;

&lt;h2 id=&#34;9-1-一次编辑多个文件&#34;&gt;9.1 一次编辑多个文件 ##&lt;/h2&gt;

&lt;p&gt;我们可以一次打开多个文件，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi a.txt b.txt c.txt  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用:next(:n)编辑下一个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:2n 编辑下2个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用:previous或:N编辑上一个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用:wnext，保存当前文件，并编辑下一个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用:wprevious，保存当前文件，并编辑上一个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用:args 显示文件列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:n filenames或:args filenames 指定新的文件列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vi -o filenames 在水平分割的多个窗口中编辑多个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vi -O filenames 在垂直分割的多个窗口中编辑多个文件。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-2-多标签编辑&#34;&gt;9.2 多标签编辑 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;vim -p files: 打开多个文件，每个文件占用一个标签页。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tabe, tabnew &amp;ndash; 如果加文件名，就在新的标签中打开这个文件，&lt;br /&gt;
否则打开一个空缓冲区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;^w gf &amp;ndash; 在新的标签页里打开光标下路径指定的文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tabn &amp;ndash; 切换到下一个标签。Control + PageDown，也可以。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tabp &amp;ndash; 切换到上一个标签。Control + PageUp，也可以。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[n] gt &amp;ndash; 切换到下一个标签。如果前面加了 &lt;code&gt;n&lt;/code&gt; ，&lt;br /&gt;
就切换到第n个标签。第一个标签的序号就是1。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tab split &amp;ndash; 将当前缓冲区的内容在新页签中打开。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tabc[lose] &amp;ndash; 关闭当前的标签页。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tabo[nly] &amp;ndash; 关闭其它的标签页。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tabs &amp;ndash; 列出所有的标签页和它们包含的窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tabm[ove] [N] &amp;ndash; 移动标签页，移动到第N个标签页之后。&lt;br /&gt;
如 &lt;code&gt;tabm 0&lt;/code&gt; 当前标签页，就会变成第一个标签页。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-3-缓冲区&#34;&gt;9.3 缓冲区 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:buffers或:ls或:files 显示缓冲区列表。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+^：在最近两个缓冲区间切换。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:bn &amp;ndash; 下一个缓冲区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:bp &amp;ndash; 上一个缓冲区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:bl &amp;ndash; 最后一个缓冲区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:b[n]或:[n]b &amp;ndash; 切换到第n个缓冲区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:nbw(ipeout) &amp;ndash; 彻底删除第n个缓冲区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:nbd(elete) &amp;ndash; 删除第n个缓冲区，并未真正删除，还在unlisted列表中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:ba[ll] &amp;ndash; 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-4-分屏编辑&#34;&gt;9.4 分屏编辑 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;vim -o file1 file2:水平分割窗口，同时打开file1和file2&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;vim -O file1 file2:垂直分割窗口，同时打开file1和file2&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-5-水平分割&#34;&gt;9.5 水平分割 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:split(:sp) &amp;ndash; 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S)&lt;br /&gt;
注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:split filename &amp;ndash; 水平分割窗口，并在新窗口中显示另一个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:nsplit(:nsp) &amp;ndash; 水平分割出一个n行高的窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:[N]new &amp;ndash; 水平分割出一个N行高的窗口，并编辑一个新文件。&lt;br /&gt;
(CTRL-W n或 CTRL-W CTRL-N)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w f &amp;ndash;水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件&lt;br /&gt;
。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-w C-^ &amp;ndash; 水平分割一个窗口，打开刚才编辑的文件。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-6-垂直分割&#34;&gt;9.6 垂直分割 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:vsplit(:vsp) &amp;ndash; 把当前窗口分割成水平分布的两个窗口。&lt;br /&gt;
(CTRL-W v或CTRL CTRL-V)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:[N]vne[w] &amp;ndash; 垂直分割出一个新窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:vertical 水平分割的命令： 相应的垂直分割。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-7-关闭子窗口&#34;&gt;9.7 关闭子窗口 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:qall &amp;ndash; 关闭所有窗口，退出vim。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:wall &amp;ndash; 保存所有修改过的窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:only &amp;ndash; 只保留当前窗口，关闭其它窗口。(CTRL-W o)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:close &amp;ndash; 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-8-调整窗口大小&#34;&gt;9.8 调整窗口大小 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ctrl+w + &amp;ndash;当前窗口增高一行。也可以用n增高n行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w - &amp;ndash;当前窗口减小一行。也可以用n减小n行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w _ &amp;ndash;当前窗口扩展到尽可能的大。也可以用n设定行数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:resize n &amp;ndash; 当前窗口n行高。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w = &amp;ndash; 所有窗口同样高度。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;n ctrl+w _ &amp;ndash; 当前窗口的高度设定为n行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w &amp;lt; &amp;ndash;当前窗口减少一列。也可以用n减少n列。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w &amp;gt; &amp;ndash;当前窗口增宽一列。也可以用n增宽n列。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w | &amp;ndash;当前窗口尽可能的宽。也可以用n设定列数。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-9-切换和移动窗口&#34;&gt;9.9 切换和移动窗口 ##&lt;/h2&gt;

&lt;p&gt;如果支持鼠标，切换和调整子窗口的大小就简单了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w p: 切换到前一个窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w t(b):切换到最上（下）面的窗口。&lt;BR&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w r：旋转窗口的位置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl+w T: 将当前的窗口移动到新的标签页上。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;10-快速编辑&#34;&gt;10. 快速编辑 #&lt;/h1&gt;

&lt;h2 id=&#34;10-1-改变大小写&#34;&gt;10.1 改变大小写 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;~: 反转光标所在字符的大小写。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可视模式下的U或u：把选中的文本变为大写或小写。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部&lt;br /&gt;
转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小&lt;br /&gt;
写。再如gu5j，把当前行和下面四行全部变成小写。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;10-2-替换-normal模式&#34;&gt;10.2 替换（normal模式） ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;r: 替换光标处的字符，同样支持汉字。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;R: 进入替换模式，按esc回到正常模式。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;10-3-撤消与重做-normal模式&#34;&gt;10.3 撤消与重做（normal模式） ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[n] u: 取消一(n)个改动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:undo 5 &amp;ndash; 撤销5个改变。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:undolist &amp;ndash; 你的撤销历史。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ctrl + r: 重做最后的改动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;U: 取消当前行中所有的改动。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:earlier 4m &amp;ndash; 回到4分钟前&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:later 55s &amp;ndash; 前进55秒&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;10-4-宏&#34;&gt;10.4 宏 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;. &amp;ndash;重复上一个编辑动作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;qa：开始录制宏a（键盘操作记录）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;q：停止录制&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;@a：播放宏a&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;11-编辑特殊文件&#34;&gt;11. 编辑特殊文件 #&lt;/h1&gt;

&lt;h2 id=&#34;11-1-文件加解密&#34;&gt;11.1 文件加解密 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;vim -x file: 开始编辑一个加密的文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:X &amp;ndash; 为当前文件设置密码。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set key= &amp;ndash; 去除文件的密码。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;11-2-文件的编码&#34;&gt;11.2 文件的编码 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set fenc或:set fileencoding，查看当前文件的编码。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在vimrc中添加set&lt;br /&gt;
fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。&lt;br /&gt;
注意：编码之间不要留空格。&lt;br /&gt;
cp936对应于gbk编码。&lt;br /&gt;
ucs-bom对应于windows下的文件格式。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;11-3-文件格式&#34;&gt;11.3 文件格式 ##&lt;/h2&gt;

&lt;p&gt;大致有三种文件格式：unix, dos, mac.&lt;br /&gt;
三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有&lt;br /&gt;
换行符，mac 下只有回车符。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:e ++ff=dos filename, 让vim用dos格式打开这个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:w ++ff=mac filename, 以mac格式存储这个文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set ff，显示当前文件的格式。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;12-编程辅助&#34;&gt;12. 编程辅助 #&lt;/h1&gt;

&lt;h2 id=&#34;12-1-一些按键&#34;&gt;12.1 一些按键 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;gd: 跳转到局部变量的定义处；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g;: 上一个修改过的地方；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g,: 下一个修改过的地方；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[[: 跳转到上一个函数块开始，需要有单独一行的{。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;]]: 跳转到下一个函数块开始，需要有单独一行的{。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[]: 跳转到上一个函数块结束，需要有单独一行的}。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;][: 跳转到下一个函数块结束，需要有单独一行的}。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[{: 跳转到当前块开始处；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;]}: 跳转到当前块结束处；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[/: 跳转到当前注释块开始处；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;]/: 跳转到当前注释块结束处；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else，&lt;br /&gt;
#endif之间跳跃。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的括号匹配对编程很实用的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ci&amp;rsquo;, di&amp;rsquo;, yi&amp;rsquo;：修改、剪切或复制&amp;rsquo;之间的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ca&amp;rsquo;, da&amp;rsquo;, ya&amp;rsquo;：修改、剪切或复制&amp;rsquo;之间的内容，包含&amp;rsquo;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ci&amp;rdquo;, di&amp;rdquo;, yi&amp;rdquo;：修改、剪切或复制&amp;rdquo;之间的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ca&amp;rdquo;, da&amp;rdquo;, ya&amp;rdquo;：修改、剪切或复制&amp;rdquo;之间的内容，包含&amp;rdquo;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ci(, di(, yi(：修改、剪切或复制()之间的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ci[, di[, yi[：修改、剪切或复制[]之间的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ci{, di{, yi{：修改、剪切或复制{}之间的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ci&amp;lt;, di&amp;lt;, yi&amp;lt;：修改、剪切或复制&amp;lt;&amp;gt;之间的内容。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ca&amp;lt;, da&amp;lt;, ya&amp;lt;：修改、剪切或复制&amp;lt;&amp;gt;之间的内容，包含&amp;lt;&amp;gt;。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-2-ctags&#34;&gt;12.2 ctags ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set tags=path/tags &amp;ndash; 告诉ctags使用哪个tag文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tag xyz &amp;ndash; 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:stag xyz &amp;ndash; 用分割的窗口显示xyz的定义，或者C-w ]，&lt;br /&gt;
如果用C-w n ]，就会打开一个n行高的窗口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:ptag xyz &amp;ndash; 在预览窗口中打开xyz的定义，热键是C-w }。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:pclose &amp;ndash; 关闭预览窗口。热键是C-w z。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:pedit abc.h &amp;ndash; 在预览窗口中编辑abc.h&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:psearch abc &amp;ndash; 搜索当前文件和当前文件include的文件，显示包含abc的行。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。&lt;br /&gt;
这种情况会先跳转到第一个匹配处。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:[n]tnext &amp;ndash; 下一[n]个匹配。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:[n]tprev &amp;ndash; 上一[n]个匹配。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tfirst &amp;ndash; 第一个匹配&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tlast &amp;ndash; 最后一个匹配&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tselect tagname &amp;ndash; 打开选择列表&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;tab键补齐&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:tag xyz&lt;tab&gt; &amp;ndash; 补齐以xyz开头的tag名，继续按tab键，会显示其他的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:tag /xyz&lt;tab&gt; &amp;ndash; 会用名字中含有xyz的tag名补全。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-3-cscope&#34;&gt;12.3 cscope ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;cscope -Rbq: 生成cscope.out文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cs add /path/to/cscope.out /your/work/dir&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cs find c func &amp;ndash; 查找func在哪些地方被调用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cw &amp;ndash; 打开quickfix窗口查看结果&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-4-gtags&#34;&gt;12.4 gtags ##&lt;/h2&gt;

&lt;p&gt;Gtags综合了ctags和cscope的功能。&lt;br /&gt;
使用Gtags之前，你需要安装GNU Gtags。&lt;br /&gt;
然后在工程目录运行 &lt;code&gt;gtags&lt;/code&gt; 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:Gtags funcname  定位到 funcname 的定义处。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:Gtags -r funcname 查询 funcname被引用的地方。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:Gtags -s symbol  定位 symbol 出现的地方。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:Gtags -g string  Goto string 出现的地方。&lt;br /&gt;
:Gtags -gi string 忽略大小写。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:Gtags -f filename    显示 filename 中的函数列表。&lt;br /&gt;
你可以用 :Gtags -f % 显示当前文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:Gtags -P pattern 显示路径中包含特定模式的文件。&lt;br /&gt;
如 :Gtags -P .h$ 显示所有头文件，&lt;br /&gt;
:Gtags -P /vm/ 显示vm目录下的文件。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-5-编译&#34;&gt;12.5 编译 ##&lt;/h2&gt;

&lt;p&gt;vim提供了:make来编译程序，默认调用的是make，&lt;br /&gt;
如果你当前目录下有makefile，简单地:make即可。&lt;/p&gt;

&lt;p&gt;如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。&lt;br /&gt;
如果你只有一个abc.java文件，你可以这样设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set makeprg=javac\ abc.java  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。&lt;br /&gt;
不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。&lt;br /&gt;
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。&lt;br /&gt;
请参考 :help errorformat。&lt;/p&gt;

&lt;h2 id=&#34;12-6-快速修改窗口&#34;&gt;12.6 快速修改窗口 ##&lt;/h2&gt;

&lt;p&gt;其实是quickfix插件提供的功能，&lt;br /&gt;
对编译调试程序非常有用 :)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:copen &amp;ndash; 打开快速修改窗口。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cclose &amp;ndash; 关闭快速修改窗口。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;快速修改窗口在make程序时非常有用，当make之后：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:cl &amp;ndash; 在快速修改窗口中列出错误。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cn &amp;ndash; 定位到下一个错误。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cp &amp;ndash; 定位到上一个错误。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cr &amp;ndash; 定位到第一个错误。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-7-自动补全&#34;&gt;12.7 自动补全 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C-x C-s &amp;ndash; 拼写建议。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-v &amp;ndash; 补全vim选项和命令。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-l &amp;ndash; 整行补全。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-f &amp;ndash; 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按&lt;br /&gt;
C-n和C-p。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-p 和C-x C-n &amp;ndash; 用文档中出现过的单词补全当前的词。&lt;br /&gt;
直接按C-p和C-n也可以。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-o &amp;ndash; 编程时可以补全关键字和函数名啊。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-i &amp;ndash; 根据头文件内关键字补全。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-d &amp;ndash; 补全宏定义。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-x C-n &amp;ndash; 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当弹出补全菜单后：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-p 向前切换成员；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-n 向后切换成员；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-e 退出下拉菜单，并退回到原来录入的文字；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-y 退出下拉菜单，并接受当前选项。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-8-多行缩进缩出&#34;&gt;12.8 多行缩进缩出 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;正常模式下，按两下&amp;gt;;光标所在行会缩进。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果先按了n，再按两下&amp;gt;;，光标以下的n行会缩进。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对应的，按两下&amp;lt;;，光标所在行会缩出。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果在编辑代码文件，可以用=进行调整。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;或者n =，调整n行代码的缩排。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-9-折叠&#34;&gt;12.9 折叠 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;zf &amp;ndash; 创建折叠的命令，可以在一个可视区域上使用该命令；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zd &amp;ndash; 删除当前行的折叠；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zD &amp;ndash; 删除当前行的折叠；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zfap &amp;ndash; 折叠光标所在的段；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zo &amp;ndash; 打开折叠的文本；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zc &amp;ndash; 收起折叠；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;za &amp;ndash; 打开/关闭当前折叠；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zr &amp;ndash; 打开嵌套的折行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zm &amp;ndash; 收起嵌套的折行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zR (zO) &amp;ndash; 打开所有折行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zM (zC) &amp;ndash; 收起所有折行；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zj &amp;ndash; 跳到下一个折叠处；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zk &amp;ndash; 跳到上一个折叠处；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;zi &amp;ndash; enable/disable fold;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;13-命令行&#34;&gt;13. 命令行 #&lt;/h1&gt;

&lt;p&gt;normal模式下按:进入命令行模式&lt;/p&gt;

&lt;h2 id=&#34;13-1-命令行模式下的快捷键&#34;&gt;13.1 命令行模式下的快捷键： ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一&lt;br /&gt;
条或者下一条匹配的命令。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;左右方向键：左/右移一个字符。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-w： 向前删除一个单词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-h： 向前删除一个字符，等同于Backspace。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-u： 从当前位置移动到命令行开头。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-b： 移动到命令行开头。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C-e： 移动到命令行末尾。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Shift-Left： 左移一个单词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Shift-Right： 右移一个单词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;@： 重复上一次的冒号命令。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;q： 正常模式下，q然后按&amp;rsquo;:&amp;lsquo;，打开命令行历史缓冲区，&lt;br /&gt;
可以像编辑文件一样编辑命令。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;q/和q? 可以打开查找历史记录。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;13-2-执行外部命令&#34;&gt;13.2 执行外部命令 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:! cmd 执行外部命令。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:!! 执行上一次的外部命令。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:sh 调用shell，用exit返回vim。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:r !cmd 将命令的返回结果插入文件当前位置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;14-其它&#34;&gt;14. 其它 #&lt;/h1&gt;

&lt;h2 id=&#34;14-1-工作目录&#34;&gt;14.1 工作目录 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:pwd 显示vim的工作目录。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:cd path 改变vim的工作目录。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;14-2-一些快捷键-收集中&#34;&gt;14.2 一些快捷键（收集中） ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;K: 打开光标所在词的manpage。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;*: 向下搜索光标所在词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g*: 同上，但部分符合即可。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;#: 向上搜索光标所在词。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g#: 同上，但部分符合即可。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;g C-g: 统计全文或统计部分的字数。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;14-3-在线帮助&#34;&gt;14.3 在线帮助 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;:h(elp)或F1 打开总的帮助。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:help user-manual 打开用户手册。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;命令帮助的格式为：第一行指明怎么使用那个命令；&lt;br /&gt;
然后是缩进的一段解释这个命令的作用，然后是进一步的信息。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:helptags somepath 为somepath中的文档生成索引。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Ctrl+] 跳转到tag主题，Ctrl+t 跳回。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;:ver 显示版本信息。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;14-4-一些小功能&#34;&gt;14.4 一些小功能 ##&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在&lt;br /&gt;
光标处得到计算结果。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>文本编辑 Atom</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-atom-/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-atom-/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/a8cd0fdb931a&#34; target=&#34;_blank&#34;&gt;Atom&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://atom-china.org/&#34; target=&#34;_blank&#34;&gt;Atom 中文社区&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://wizardforcel.gitbooks.io/atom-flight-manual-zh-cn/content/index.html&#34; target=&#34;_blank&#34;&gt;Atom飞行手册翻译&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/atom/atom&#34; target=&#34;_blank&#34;&gt;atom source&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;快捷键&#34;&gt;快捷键&lt;/h2&gt;

&lt;p&gt;i                       # tree-view:toggle-vcs-ignored-files&lt;br /&gt;
Ctrl + L              # Select Line     选定一行&lt;br /&gt;
Shift + Home          # Select First Character of Line  选定光标至行首&lt;br /&gt;
Ctrl + Shift + Home   # Select to Top   选定光标处至文档首行&lt;br /&gt;
Ctrl + Shift + K      # Delete Line     删除一行&lt;br /&gt;
ctrl + tab&lt;br /&gt;
&lt;strong&gt;添加环境变量&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;echo PATH=/usr/share/atom-beta/resources/app/apm/bin:\$PATH &amp;gt;&amp;gt; ~/.bashrc&lt;/code&gt;&lt;br /&gt;
2. &lt;strong&gt;代理设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apm -v  
  apm  1.9.2  
  npm  2.13.3  
  node 0.10.40  
  python 2.7.11+  
  git 2.7.4  

apm install --check  
apm config set strict-ssl false  
apm config set proxy http://localhost:8087  
apm config set https-proxy http://localhost:8087  
apm config delete http-proxy  

apm config set registry http://registry.npm.taobao.org  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;手动安装插件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/.atom/packages  
git clone https://github.com/emmetio/emmet-atom  
cd emmet-atom  
npm install  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fontFamily: &amp;ldquo;DejaVu Sans Mono,文泉驿正黑&amp;rdquo;&lt;br /&gt;
&amp;lsquo;DejaVu Sans Mono&amp;rsquo;, &amp;lsquo;Source Han Sans CN&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;

&lt;p&gt;增加颜色显示 color&lt;br /&gt;
apm install pigments&lt;/p&gt;

&lt;!-- terminal  
apm install term3  
open-terminal-here  
apm install atom-terminal-panel  
apm install terminal-plus  
--&gt;  

&lt;p&gt;apm install platformio-ide-terminal&lt;br /&gt;
apm install go-hyperclick #安装xx-hyperclick，实现按住commond + 单击跳转到函数定义处或引入文件。&lt;/p&gt;

&lt;p&gt;apm install git-plus&lt;br /&gt;
apm install go-plus&lt;/p&gt;

&lt;p&gt;apm install markdown-scroll-sync&lt;br /&gt;
apm install markdown-preview-plus&lt;/p&gt;

&lt;p&gt;markdown-preview&lt;br /&gt;
-  &lt;code&gt;ctrl-shift-m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;apm install editorconfig&lt;br /&gt;
- &lt;code&gt;EditorConfig: Generate Config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;apm install git-plus&lt;br /&gt;
- &lt;code&gt;Ctrl-Shift-H&lt;/code&gt;&lt;br /&gt;
&lt;img src=&#34;https://i.github-camo.com/78e2bafa5f9b3afdf47d7e02e3f949fea4801fc0/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f616b6f6e77692f6769742d706c75732f6d61737465722f636f6d6d69742e676966&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;apm install atomic-emacs&lt;br /&gt;
[](&lt;a href=&#34;https://atom.io/packages/atomic-emacs&#34; target=&#34;_blank&#34;&gt;https://atom.io/packages/atomic-emacs&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;apm-install-jumpy&#34;&gt;apm install jumpy&lt;/h2&gt;

&lt;p&gt;apm install indent-guide-improved&lt;br /&gt;
&lt;img src=&#34;https://i.github-camo.com/83f38ef15d0f90120fec4fc21fab18fc3ac0effc/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f68617261692f696e64656e742d67756964652d696d70726f7665642f6d61737465722f646f632f64656d6f2e676966&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;apm install multi-cursor-plus&lt;/p&gt;

&lt;p&gt;apm install markdown-writer&lt;br /&gt;
&lt;!-- apm install synced-sidebar --&gt;&lt;br /&gt;
apm install rest-client&lt;br /&gt;
&lt;!-- 为文件设置图标 --&gt;&lt;br /&gt;
apm install seti-ui&lt;br /&gt;
apm install livestyle-atom&lt;br /&gt;
LiveStyle是css实时编辑工具&lt;br /&gt;
apm install regex-railroad-diagram&lt;br /&gt;
&lt;img src=&#34;https://pic3.zhimg.com/ac5335553d8cb1cebc5132921678fdb6_b.jpg&#34; alt=&#34;正则表达式图形化&#34; /&gt;&lt;/p&gt;

&lt;p&gt;apm install todo-show&lt;br /&gt;
&lt;code&gt;CTRL + SHIFT + T&lt;/code&gt;&lt;br /&gt;
apm install imdone-atom imdone-atom-github&lt;br /&gt;
&lt;img src=&#34;https://i.github-camo.com/6a64a215c395ff2aba140cc1c978b847510fc014/68747470733a2f2f636c6f75642e67697468756275736572636f6e74656e742e636f6d2f6173736574732f3233333530352f31313133333631332f35663931646630382d383935632d313165352d396361612d6361613662646539333330302e676966&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;apm install git-time-machine&lt;br /&gt;
&lt;img src=&#34;https://i.github-camo.com/62085307dccead1c2f5efdf4d7a40f9cdb777b93/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6c6974746c656265652f6769742d74696d652d6d616368696e652f6d61737465722f7265736f75726365732f74696d656d616368696e652e676966&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;apm install atom-ctags&lt;br /&gt;
apm install atom-fuzzy-grep&lt;br /&gt;
&lt;code&gt;ctrl-alt-g&lt;/code&gt;&lt;br /&gt;
&lt;img src=&#34;https://i.github-camo.com/7819d532ad92f98c1391e464c70d0248f7111b5b/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f67656b73696c6c612f61746f6d2d66757a7a792d677265702f6d61737465722f64656d6f2e676966&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;apm install symbols-tree-view&lt;br /&gt;
&lt;img src=&#34;https://i.github-camo.com/625e6d10dbc90e14696852bf0d4db63b4e1810b2/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f786e64636e2f73796d626f6c732d747265652d766965772f6d61737465722f73637265656e636173742e6769663f7261773d74727565&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;language-ini&lt;/p&gt;

&lt;h2 id=&#34;调试&#34;&gt;调试&lt;/h2&gt;

&lt;p&gt;atom &amp;ndash;safe -d -f .&lt;br /&gt;
Crash dumps on Windows can be found in:&lt;br /&gt;
C:\Users&lt;Username&gt;\AppData\Local\Temp\Atom Crashes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;*&amp;quot;:  
  #这个用户ID用于提交异常的,官方描述:Reports uncaught Atom exception to bugsnag.com  
  &amp;quot;exception-reporting&amp;quot;:  
    userId: &amp;quot;dce1a874-569c-0d60-1714-66461c6d20f9&amp;quot;  
  core:  
    #主题设置,主题和语法主题同时配置需要用中括号包含;若是单一主题则不需要,只需要双引号即可.  
    themes: [  
      &amp;quot;graphite-ui&amp;quot;  
      &amp;quot;seti-monokai&amp;quot;  
    ]  

    #这里跟Sublime Text的配置&amp;quot;ignored_packages&amp;quot;: [&amp;quot;package_name&amp;quot;]一样的效果,禁用某某插件  
    disabledPackages: [  
      &amp;quot;spell-check&amp;quot;  
    ]  
  editor:  
    invisibles:  
      {}  

    #表示是否按照上面设置过的「推荐行宽（默认 80 个字符）」来折行，否则默认按照屏幕宽度来折行  
    softWrapAtPreferredLineLength: true  

    #是否开启折行  
    softWrap: false  

    #字体及字体大小  
    fontFamily: &amp;quot;monoca&amp;quot;  
    fontSize: 16  

    #显示缩进辅助线  
    showIndentGuide: true  

  #这一块基本都是所有插件的配置 ,具体都可以参考插件作者的介绍再做调整  
  #显示所有错误  
  linter:  
    statusBar: &amp;quot;Show all errors&amp;quot;  

  #这个还有多个参数,可以配置是否高亮显示颜色等,此处是启用滚动动画  
  minimap:  
    scrollAnimation: true  

  #忽略显示一些文件  
  &amp;quot;tree-view&amp;quot;:  
    hideVcsIgnoredFiles: true  

  #待进一步自定义  
  &amp;quot;autocomplete-plus&amp;quot;:  
    {}  
  #待进一步自定义  
  &amp;quot;linter-csslint&amp;quot;:  
    {}  

  #vim-mode这个插件默认启用的方式是插入,而不是命令模式  
  &amp;quot;vim-mode&amp;quot;:  
    startInInsertMode: true  

  #这个是更改文件类型颜色(插件),这里启用了  
  &amp;quot;filetype-color&amp;quot;:  
    enabled: &amp;quot;true&amp;quot;  

  #启用atom的自动进入引导界面..蛮实用的  
  welcome:  
    showOnStartup: true;  

  #UI主题的自定义,,空则不生效  
  &amp;quot;isotope-ui&amp;quot;:  
    {}  

  #插件生效,更多样化的文件图标  
  &amp;quot;file-icons&amp;quot;:  
    onChanges: true  
    forceShow: true  

  #这个是排版插件带的,,这里的用户ID的作用不清楚  
  &amp;quot;atom-beautify&amp;quot;:  
    _analyticsUserId: &amp;quot;cde3641c-d5ee-4ccb-9d45-37f85f7e98e9&amp;quot;  

  #在文件更改时候生效(进行查询错误)  
  csslint:  
    validateOnChange: true  

  #这个是内置的核心插件,自动保存功能,挺实用的  
  autosave:  
    enabled: true  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;终端程序默认不走系统 socks 代理，所以你这个全局设置估计没有起效&lt;/p&gt;

&lt;p&gt;apm config set strict-ssl false&lt;br /&gt;
apm config set proxy &lt;a href=&#34;http://localhost:8087&#34; target=&#34;_blank&#34;&gt;http://localhost:8087&lt;/a&gt;&lt;br /&gt;
apm config set http-proxy &lt;a href=&#34;http://localhost:8087&#34; target=&#34;_blank&#34;&gt;http://localhost:8087&lt;/a&gt;&lt;br /&gt;
apm config set https-proxy &lt;a href=&#34;http://localhost:8087&#34; target=&#34;_blank&#34;&gt;http://localhost:8087&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解决方案：&lt;br /&gt;
1、给 apm 绑代理(&lt;a href=&#34;https://github.com/atom/apm#behind-a-firewall)，可以直接使用&#34; target=&#34;_blank&#34;&gt;https://github.com/atom/apm#behind-a-firewall)，可以直接使用&lt;/a&gt; socks 代理(&lt;a href=&#34;https://github.com/atom/apm/issues/173&#34; target=&#34;_blank&#34;&gt;https://github.com/atom/apm/issues/173&lt;/a&gt;)&lt;br /&gt;
2、使用 proxychains-ng(&lt;a href=&#34;https://github.com/rofl0r/proxychains-ng&#34; target=&#34;_blank&#34;&gt;https://github.com/rofl0r/proxychains-ng&lt;/a&gt;) 绑 socks 代理，然后 用 apm 命令安装 atom 插件&lt;br /&gt;
3、或者试试国内 npm 源(&lt;a href=&#34;https://atom-china.org/t/cnpm/750&#34; target=&#34;_blank&#34;&gt;https://atom-china.org/t/cnpm/750&lt;/a&gt;)&lt;br /&gt;
4、使用 VPN&lt;/p&gt;

&lt;p&gt;使用 cnpm 安装插件的依赖可以显著提高安装速度&lt;br /&gt;
编辑 ~/.atom/.apmrc，添加 registry = &lt;a href=&#34;https://registry.npm.taobao.org&#34; target=&#34;_blank&#34;&gt;https://registry.npm.taobao.org&lt;/a&gt; 即可&lt;/p&gt;

&lt;p&gt;cat ~/.atom/.apmrc&lt;br /&gt;
strict-ssl = false&lt;br /&gt;
http_proxy = socks5://127.0.0.1:1997&lt;br /&gt;
https_proxy = socks5://127.0.0.1:1997&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages&#34; target=&#34;_blank&#34;&gt;https://atom.io/packages&lt;/a&gt;&lt;br /&gt;
cd ~/.atom/packages&lt;br /&gt;
git clone &lt;a href=&#34;https://github.com/emmetio/emmet-atom&#34; target=&#34;_blank&#34;&gt;https://github.com/emmetio/emmet-atom&lt;/a&gt;&lt;br /&gt;
cd emmet-atom&lt;br /&gt;
npm install&lt;/p&gt;

&lt;p&gt;必备插件&lt;br /&gt;
1.git-plus&lt;/p&gt;

&lt;p&gt;用apm管理Atom的包&lt;br /&gt;
apm help install // 查看具体的命令的帮助&lt;br /&gt;
apm search color // 搜索跟 color 相关的包&lt;br /&gt;
apm home color-picker // 会用默认的浏览器打开包的首页 &amp;hellip; 确定以后&lt;br /&gt;
apm install color-picker // 安装 color-picker&lt;br /&gt;
apm list// 查看一下已经安装的包的列表&lt;br /&gt;
 Mac 用户可以使用快捷键 ctrl + alt + cmd + L ， Windows 用户可以使用 alt-ctrl-r (注: 使用 apm 安装了新的包以后，可能需要重新加载一下 Atom 编辑器 )&lt;br /&gt;
apm uninstall color-picker // 不需要的包可以直接把它删除掉&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>文本编辑 Emacs</title>
            <link>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-emacs-%E6%8F%92%E4%BB%B6/</link>
            <pubDate>Tue, 12 Jan 2016 15:30:01 CST</pubDate>
            <author>rinetd</author>
            <guid>//blog.pytool.com/edit/2015-01-12-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-emacs-%E6%8F%92%E4%BB%B6/</guid>
            <description>&lt;p&gt;treemacs 替换neotree 侧边栏&lt;br /&gt;
linum-mode显示侧边栏的行号。&lt;/p&gt;

&lt;p&gt;f - 处理文件相关的库&lt;br /&gt;
s - 处理字符串相关的库&lt;br /&gt;
ag - 据说比ack更快的文本搜索工具 the_silver_searcher&lt;br /&gt;
的emacs插件&lt;br /&gt;
ht - 处理哈希相关的库&lt;br /&gt;
anzu - 显示当前匹配文本，预览替换效果和总匹配数的插件&lt;br /&gt;
dash - 常用函数集合&lt;br /&gt;
helm - 方便查找各种文件内容,buffer切换,emacs命令执行等&lt;br /&gt;
jedi - python代码补全，快速需要函数/模块定义的插件&lt;br /&gt;
smex - M-x 的命令行补全的功能&lt;br /&gt;
direx - 展示目录树&lt;br /&gt;
magit - git插件&lt;br /&gt;
slime - commonlisp交互模式&lt;br /&gt;
ac-js2 - js2-mode支持js函数定义查找&lt;br /&gt;
rinari - 依赖,需要安装&lt;br /&gt;
diff-hl - 在行首用颜色表示git状态-只支持图形界面的emacs&lt;br /&gt;
dired-k - 用带不同颜色的高亮显示文件/目录,大小等信息&lt;br /&gt;
bind-key - 本项目绑定快捷键的用法都根据这个包,没有用global-set-key&lt;br /&gt;
css-mode - css-mode&lt;br /&gt;
js2-mode - js-mode的升级版&lt;br /&gt;
web-mode - 前端开发必备, html缩进,支持根据tag/元素/属性/block/dom跳转,语法高亮,支持mako,jinja2等模板&lt;br /&gt;
git-blame - git-blame,单独版&lt;br /&gt;
key-chord - 可以快速按键达到快捷键的作用&lt;br /&gt;
nyan-mode - 一直可爱的小猫&lt;br /&gt;
plim-mode - 我写的编辑plim的major-mode&lt;br /&gt;
powerline - 提供一个漂亮的状态栏&lt;br /&gt;
sass-mode - 编辑sass&lt;br /&gt;
scss-mode - 编辑scss&lt;br /&gt;
sublimity - 在图形界面的emacs能缩小预览代码-sublime-text有类似的插件&lt;br /&gt;
undo-tree - 让undo可视化&lt;br /&gt;
yaml-mode - 编辑yaml&lt;br /&gt;
yasnippet - 一个神奇的模板系统,定义缩写并通过tab键自动帮你展开(一些自动的”填空题”机制)&lt;br /&gt;
drag-stuff - 可以将代码块整体拖动&lt;br /&gt;
helm-swoop - 项目内关键词查找,并能自动跳到对应文件和对应行&lt;br /&gt;
ibuffer-vc - 支持版本空的ibuffer模式&lt;br /&gt;
projectile - 管理项目，可快速访问项目里任何文件，支持全项目关键词搜索&lt;br /&gt;
coffee-mode - 编辑coffee&lt;br /&gt;
python-mode - 编辑python&lt;br /&gt;
smartparens - 自动括号匹配,可以按块删除,tag跳转&lt;br /&gt;
use-package - 本项目引用包的方式&lt;br /&gt;
crontab-mode - 高亮编辑crontab&lt;br /&gt;
golden-ratio - 黄金分割展示当前window&lt;br /&gt;
helm-ipython - helm的ipython插件&lt;br /&gt;
rainbow-mode - 在代码中通过背景色标示颜色值&lt;br /&gt;
ace-jump-mode - 快速让光标位置到你想去的地方&lt;br /&gt;
expand-region - 按层次块区域选择&lt;br /&gt;
helm-css-scss - helm的css/scss插件&lt;br /&gt;
markdown-mode - 编辑markdown&lt;br /&gt;
switch-window - 可视化切换窗口&lt;br /&gt;
visual-regexp - 可视化正则匹配&lt;br /&gt;
gitconfig-mode - 单独的gitconfig-mode&lt;br /&gt;
gitignore-mode - 单独的gitignore-mode&lt;br /&gt;
helm-descbinds - 让默认的 C-h b&lt;br /&gt;
高亮并且按组分开&lt;br /&gt;
imenu-anywhere - 类似于etag, 可直接跳到对应的标签&lt;br /&gt;
multiple-cursors - 一次编辑多处/行文字&lt;br /&gt;
discover-my-major - 告诉你当前mode的一些说明/快捷键设置&lt;br /&gt;
virtualenvwrapper - virtualenvwrapper&lt;br /&gt;
gitattributes-mode - 独立的gitattributes-mode&lt;br /&gt;
rainbow-delimiters - 对内嵌的括号等pair符号加不同颜色&lt;br /&gt;
idle-highlight-mode - 在设置的一段设置时间未操作电脑会自动高亮当前关键词,并且全文高亮相同关键词&lt;br /&gt;
exec-path-from-shell - 可以使用$PATH环境变量&lt;br /&gt;
find-file-in-repository - 根据git属性在项目里查找文件&lt;br /&gt;
emmet-mode - 类似于zencoding，但是能编辑css,使用很少的代码就能构造一个复杂的div/css&lt;br /&gt;
browse-kill-ring - 查看最近操作的删除文本,以及恢复后的效果&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
